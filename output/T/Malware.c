/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

// signed __int64 __usercall sub_140001000@<rax>(__int128 *a1@<xmm1>, __m256i *a2@<ymm0>, __m256i *a3@<ymm1>);
void *sub_140001040();
// signed __int64 __usercall sub_140001050@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __m128i *a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>);
// __int64 __usercall sub_1400012B0@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// signed __int64 __usercall sub_1400014F0@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// __m128i *__usercall sub_1400015A0@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// signed __int64 __usercall sub_140001710@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r15>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>);
signed int *__fastcall sub_140001950(__int64 a1, __int64 a2);
_BYTE *__fastcall sub_1400019A0(__int64 a1, __int64 a2);
char *__fastcall sub_140001A30(__int64 a1, signed int *a2);
// __int64 __usercall sub_140001A40@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// signed __int64 __usercall sub_140001C50@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
void __fastcall sub_140001E20(LPVOID *a1);
// __int64 __usercall sub_140001E50@<rax>(__int128 *a1@<xmm1>, __m256i *a2@<ymm0>, __m256i *a3@<ymm1>);
// __int64 __usercall sub_140001E90@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>, ...);
// BOOL __usercall sub_140001EF0@<eax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// INT_PTR __usercall DialogFunc@<rax>(HWND a1@<rcx>, int a2@<edx>, unsigned __int16 a3@<r8w>, LONG_PTR a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>);
BOOL __fastcall sub_140002390(__int64 a1, unsigned __int16 a2, __int16 a3);
// __int64 __usercall sub_1400025A0@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>);
// __int64 __usercall sub_140002710@<rax>(LPCSTR lpMultiByteStr@<rcx>, LPCSTR a2@<rdx>, LPCSTR a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>);
// __int64 __usercall sub_1400027D0@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>, ...);
// int __usercall sub_140002830@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>, ...);
// int __usercall sub_140002980@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>, __int64 a6@<r8>, __int64 a7@<r9>, ...);
// int __usercall sub_140002AD0@<eax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>, ...);
// int __usercall sub_140002BE0@<eax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>, ...);
// signed __int64 __usercall sub_140002CF0@<rax>(__int64 *a1@<rcx>, __int64 a2@<r15>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// __int64 __usercall sub_140003140@<rax>(__int64 a1@<rdx>, const CHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>, ...);
// _BYTE *__usercall sub_1400031E0@<rax>(int a1@<r9d>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_1400033F0@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// __int64 __usercall sub_140003450@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r15>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>);
__int64 __fastcall sub_1400035A0(_QWORD); // weak
__int64 __fastcall nullsub_1(_QWORD); // weak
// signed __int64 __usercall sub_1400035C0@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// signed __int64 __usercall sub_140003910@<rax>(__int64 *a1@<rdx>, int a2@<ecx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
signed __int64 __fastcall sub_140003D20(__int64 a1, char *a2);
signed __int64 __fastcall sub_140003D70(__int64 a1, __m128i *a2);
// signed __int64 __usercall sub_140003DD0@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// signed __int64 __usercall sub_140003E50@<rax>(CHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// _BOOL8 __usercall sub_140003EF0@<rax>(const CHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// __int64 __usercall sub_140003F60@<rax>(const CHAR *a1@<rdx>, const CHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// _BYTE *__usercall sub_140003FE0@<rax>(__int64 a1@<rcx>, char *a2@<r8>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// signed __int64 __usercall sub_1400040A0@<rax>(const CHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// __int64 __usercall sub_140004100@<rax>(const CHAR *a1@<rdx>, const CHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// __int64 __usercall sub_1400041E0@<rax>(_QWORD *a1@<rdx>, const CHAR *a2@<rcx>, __m256i *a3@<ymm0>);
signed __int64 __fastcall sub_140004250(_DWORD *a1);
// signed __int64 __usercall sub_140004360@<rax>(const CHAR *a1@<r8>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
__int64 sub_140004420();
void __fastcall sub_140004490(void *a1);
__int64 __fastcall sub_1400044C0(__int64 a1);
// signed __int64 __usercall sub_140004560@<rax>(__int64 a1@<rdx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// signed __int64 __usercall sub_1400046D0@<rax>(__int64 a1@<rdx>, _DWORD *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// signed __int64 __usercall sub_140004830@<rax>(__int64 a1@<rdx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// signed __int64 __usercall sub_1400048C0@<rax>(__int64 a1@<rdx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
signed __int64 __fastcall sub_140004930(_DWORD *a1, __int64 a2);
void __fastcall sub_140004D00(__int64 a1);
// __int64 __usercall sub_140004DA0@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_1400051A0@<rax>(HMODULE hModule@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
void __fastcall sub_1400058A0(__int64 a1);
// signed __int64 __usercall sub_1400058E0@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// signed __int64 __usercall sub_140005A50@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// __int64 __usercall sub_140005B80@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// __int64 __usercall sub_140005CE0@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
__int64 __fastcall sub_140005EE0(_QWORD *a1);
signed __int64 __fastcall sub_140005F20(_QWORD *a1);
__int64 __fastcall sub_140005FA0(__int64 a1);
__int64 sub_140006340();
__int64 sub_140006350();
// __int64 __usercall sub_140006360@<rax>(__int64 a1@<r9>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// __int64 __usercall sub_140006440@<rax>(int a1@<r8d>, __int64 a2@<r9>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// signed __int64 __usercall sub_140006530@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// __int64 __usercall sub_1400065B0@<rax>(__m128i *a1@<rdx>, __int64 a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
__int64 __fastcall sub_140006800(__int64 a1);
__int64 __fastcall sub_140006930(__int64 a1, int a2, __int64 a3, __int64 a4);
// signed __int64 __usercall sub_140006A50@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// signed __int64 __usercall sub_140006BF0@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
void __fastcall sub_140006D20(_QWORD **a1);
// __int64 __usercall sub_140006DA0@<rax>(__int128 *a1@<xmm1>, __m256i *a2@<ymm0>, __m256i *a3@<ymm1>);
__int64 __fastcall sub_140006DE0(__int64 a1, __int64 a2);
// __int64 __usercall sub_140006EB0@<rax>(HMODULE hModule@<rcx>, HMODULE a2@<rdx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
signed __int64 __fastcall HandlerRoutine(DWORD CtrlType);
// const __m128i *__usercall sub_1400073E0@<rax>(const CHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// signed __int64 __usercall sub_140007560@<rax>(const CHAR *a1@<rcx>, __int64 a2@<r8>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// signed __int64 __usercall sub_140007780@<rax>(__int128 *a1@<xmm1>, __m256i *a2@<ymm0>, __m256i *a3@<ymm1>);
// signed __int64 __usercall sub_140007910@<rax>(const CHAR *a1@<rdx>, CHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// _BYTE *__usercall sub_140007B20@<rax>(const CHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// __int64 __usercall sub_140007BD0@<rax>(__int64 a1@<rdx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// signed __int64 __usercall sub_140007D00@<rax>(const CHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// __int64 __usercall sub_140007F90@<rax>(LPCSTR lpMultiByteStr@<rcx>, LPCSTR a2@<rdx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// __int64 __usercall sub_140008000@<rax>(LPCSTR lpMultiByteStr@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// signed __int64 __usercall sub_140008040@<rax>(const CHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
_BOOL8 __fastcall sub_140008200(HMODULE a1);
// HMODULE __usercall sub_140008220@<rax>(LPCSTR lpMultiByteStr@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// signed __int64 __usercall sub_140008270@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, unsigned __int64 a3@<r8>, __m256i *a4@<ymm0>);
// signed __int64 __usercall sub_1400083A0@<rax>(__int64 a1@<rdx>, const WCHAR *a2@<rcx>, __int128 *a3@<r8>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// const char *__usercall sub_140008520@<rax>(DWORD a1@<ecx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// __int64 __usercall sub_140008610@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>, ...);
// __int64 __usercall sub_140008670@<rax>(__int64 a1@<rdx>, int a2@<ecx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
_BOOL8 __fastcall sub_140008810(WCHAR *a1);
__int64 __fastcall sub_140008890(const WCHAR *a1);
// signed __int64 __usercall sub_140008910@<rax>(const WCHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// WCHAR *__usercall sub_140008AA0@<rax>(LPWSTR lpWideCharStr@<rcx>, LPCSTR lpMultiByteStr@<rdx>, int cchWideChar@<r8d>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>);
// CHAR *__usercall sub_140008BB0@<rax>(LPSTR lpMultiByteStr@<rcx>, LPCWSTR lpWideCharStr@<rdx>, int cbMultiByte@<r8d>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>);
signed __int64 __fastcall sub_140008CA0(unsigned int a1, unsigned __int8 *a2, unsigned __int64 a3);
__int64 __fastcall sub_140008F90(int a1, char *a2, unsigned int a3);
__int64 __fastcall sub_140008FA0(int a1, char *a2, unsigned __int64 a3);
__int64 __fastcall sub_140009450(unsigned __int8 **a1, int a2);
signed __int64 __fastcall sub_140009950(__int64 a1, int a2);
signed __int64 __fastcall sub_14000B1E0(_QWORD *a1);
signed __int64 __fastcall sub_14000B260(_QWORD *a1, int a2, _BYTE *a3, int a4);
signed __int64 __fastcall sub_14000B500(_QWORD *a1, _BYTE *a2, int a3);
signed __int64 __fastcall sub_14000B510(__int64 a1, __int64 a2, unsigned int a3);
signed __int64 __fastcall sub_14000B620(__int64 a1, unsigned __int16 *a2, __int64 a3, _DWORD **a4, unsigned int *a5, _WORD *a6);
__int64 __fastcall sub_14000BBC0(__int64 a1, int a2, int a3);
void __fastcall sub_14000BBD0(__int64 a1, void *a2);
// BOOL __stdcall ConvertSidToStringSidW(PSID Sid, LPWSTR *StringSid);
// BOOL __stdcall ConvertStringSecurityDescriptorToSecurityDescriptorW(LPCWSTR StringSecurityDescriptor, DWORD StringSDRevision, PSECURITY_DESCRIPTOR *SecurityDescriptor, PULONG SecurityDescriptorSize);
// void __cdecl _security_check_cookie(uintptr_t StackCookie);
// __int64 __fastcall _raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
__int64 __fastcall sub_14000BD30(DWORD64 a1);
// __int64 __fastcall _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_14000BE18(unsigned int a1);
// __int64 __fastcall capture_current_context(PCONTEXT ContextRecord); idb
// __int64 __fastcall capture_previous_context(PCONTEXT ContextRecord); idb
// __int64 __usercall sub_14000BFA0@<rax>(__m256i *a1@<ymm0>);
__int64 sub_14000C060();
// signed __int64 __usercall sub_14000C070@<rax>(__m256i *a1@<ymm0>);
// signed __int64 __usercall sub_14000C08C@<rax>(UINT a1@<ebx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
char sub_14000C220();
char __fastcall sub_14000C25C(int a1);
// char __usercall sub_14000C2A8@<al>(unsigned int a1@<ecx>, __m256i *a2@<ymm0>);
char __fastcall sub_14000C334(__int64 a1);
_BOOL8 __fastcall sub_14000C3CC(char a1);
// char __usercall sub_14000C3F0@<al>(char a1@<dl>, char a2@<cl>, __m256i *a3@<ymm0>);
// __int64 __usercall sub_14000C41C@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_14000C458@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
__int64 sub_14000C470();
signed __int64 sub_14000C51C();
signed __int64 sub_14000C524();
void sub_14000C52C();
char sub_14000C540();
void *sub_14000C544();
_QWORD *sub_14000C54C();
_BOOL8 sub_14000C568();
void *sub_14000C574();
void *sub_14000C57C();
void sub_14000C584();
// void __usercall sub_14000C58C(unsigned int a1@<ecx>, __m256i *a2@<ymm0>);
// WORD __usercall sub_14000C6D8@<ax>(__m256i *a1@<ymm0>);
__int64 sub_14000C714(void); // weak
bool sub_14000C71C();
LPTOP_LEVEL_EXCEPTION_FILTER sub_14000C770();
// __int64 __usercall sub_14000C780@<rax>(_QWORD *a1@<rcx>, __m256i *a2@<ymm0>);
__int64 __fastcall sub_14000C7DC(__int64 a1);
__int64 __fastcall sub_14000C820(__int64 a1);
__int64 sub_14000C85C();
_BOOL8 sub_14000CA08();
void __fastcall sub_14000CA30(void *a1, const void *a2, unsigned __int64 a3);
__int64 __fastcall sub_14000CA50(__m128i *_RCX, const __m128i *_RDX, unsigned __int64 _R8);
__int64 __fastcall sub_14000D0E0(void *a1, char a2, unsigned __int64 a3, __int64 a4);
// __int64 __usercall sub_14000D100@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, unsigned __int64 a3@<r8>, __m256i *__struct_ptr _YMM0@<ymm0>);
_BYTE *__fastcall sub_14000D488(__int64 a1, unsigned __int8 a2);
__m128i *__fastcall sub_14000D508(__m128i *a1, int a2);
const __m128i *__fastcall sub_14000D644(const __m128i *a1, unsigned __int16 a2);
__int64 __fastcall sub_14000D6D0(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_14000D798(PEXCEPTION_RECORD ExceptionRecord, PVOID TargetFrame, __int64 a3, __int64 a4);
char sub_14000D990();
char __fastcall sub_14000D9B8(char a1);
__int64 __fastcall sub_14000D9D4(__int64 a1, __int64 a2);
void __fastcall sub_14000DA00(__int64 a1);
__int64 __fastcall sub_14000DA70(_QWORD, _QWORD); // weak
// signed __int64 __usercall sub_14000DA74@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
__int64 __fastcall sub_14000DAA4(__int64 a1, signed int *a2);
// __int64 __usercall sub_14000DAC8@<rax>(_DWORD **a1@<rcx>, __m256i *a2@<ymm0>);
// char *__usercall sub_14000DB30@<rax>(__m256i *a1@<ymm0>);
// char *__usercall sub_14000DB44@<rax>(__m256i *a1@<ymm0>);
void sub_14000DB80();
__int64 nullsub_2(void); // weak
__int64 (__fastcall *__fastcall sub_14000DBB4(__int64 a1))();
void __fastcall sub_14000DBF0(void *a1);
// LPVOID __usercall sub_14000DC10@<rax>(__m256i *a1@<ymm0>);
LPVOID sub_14000DC2C();
char sub_14000DCEC();
char sub_14000DD34();
char sub_14000DD58();
char sub_14000DDA0();
FARPROC __fastcall sub_14000DDD8(unsigned int a1, const CHAR *a2, unsigned int *a3, unsigned int *a4);
int sub_14000DF28();
int __fastcall sub_14000DF70(DWORD a1);
LPVOID __fastcall sub_14000DFB8(DWORD a1);
int __fastcall sub_14000E000(DWORD dwTlsIndex, LPVOID lpTlsValue);
int __fastcall sub_14000E054(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
// __int64 __usercall sub_14000E0B8@<rax>(unsigned int *a1@<rcx>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_14000E10C@<rax>(int a1@<edx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// bool __usercall sub_14000E170@<al>(__int64 a1@<rdx>, unsigned __int64 *a2@<rcx>, __m256i *a3@<ymm0>);
// __int64 __usercall sub_14000E19C@<rax>(unsigned __int64 *a1@<rdx>, _QWORD *a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
// _QWORD *__usercall sub_14000E200@<rax>(unsigned __int64 *a1@<rdx>, _QWORD *a2@<rcx>, __int64 a3@<r8>, _QWORD *a4@<r9>, __m256i *a5@<ymm0>);
// __m128i *__usercall sub_14000E2CC@<rax>(__int64 a1@<rdx>, __m128i *a2@<rcx>, int a3@<r8d>, unsigned __int64 *a4@<r9>, __m256i *a5@<ymm0>, __int64 a6);
void __fastcall sub_14000E40C(void **a1, ULONG_PTR a2, ULONG_PTR a3, ULONG_PTR a4, ULONG_PTR a5, ULONG_PTR a6, int a7, int a8, __int64 a9, __int64 a10, unsigned __int8 a11);
// _QWORD *__usercall sub_14000E510@<rax>(__int64 a1@<rdx>, _QWORD *a2@<rcx>, __m256i *a3@<ymm0>);
// _QWORD *__usercall sub_14000E54C@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_14000E5A0@<rax>(__m256i *a1@<ymm0>);
// __int64 __usercall sub_14000E5B4@<rax>(__m256i *a1@<ymm0>);
// _QWORD *__usercall sub_14000E5C8@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// _QWORD *__usercall sub_14000E5E0@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_14000E5F8@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
// signed __int64 __usercall sub_14000E680@<rax>(unsigned __int64 *a1@<rdx>, _QWORD *a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
// __int64 __usercall sub_14000E6A8@<rax>(unsigned __int64 *a1@<rdx>, _QWORD *a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
__int64 __fastcall sub_14000E6D4(__int64 *a1, __int64 a2, int a3);
// __int64 __usercall sub_14000E6E0@<rax>(unsigned __int64 *a1@<rdx>, _QWORD *a2@<rcx>, __int64 a3@<r8>, int a4@<r9d>, __m256i *a5@<ymm0>);
// signed __int64 __usercall sub_14000E71C@<rax>(unsigned __int64 *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// signed __int64 __usercall sub_14000E724@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, unsigned __int64 a3@<r8>, __m256i *a4@<ymm0>);
// __int64 __usercall sub_14000E78C@<rax>(__m128i *a1@<rdx>, __int64 a2@<rcx>, _DWORD *a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
// __int64 __usercall sub_14000E98C@<rax>(__m128i *a1@<rdx>, __int64 a2@<rcx>, _DWORD *a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
// void __usercall sub_14000EA4C(void **a1@<rdx>, ULONG_PTR a2@<rcx>, ULONG_PTR a3@<r8>, unsigned __int64 *a4@<r9>, __m256i *a5@<ymm0>, int a6, int a7, int a8, int a9, int a10, int a11, char a12, unsigned __int8 a13);
// _QWORD *__usercall sub_14000EB20@<rax>(void **a1@<rdx>, ULONG_PTR a2@<rcx>, ULONG_PTR a3@<r8>, unsigned __int64 *a4@<r9>, __m256i *a5@<ymm0>, _DWORD *a6, __int64 a7, int a8, __int64 a9);
// void __usercall sub_14000EFF8(unsigned int *a1@<rcx>, unsigned __int64 *a2@<r9>, __m256i *a3@<ymm0>);
// signed __int64 __usercall sub_14000F214@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, _BYTE *a3@<r8>, __m256i *a4@<ymm0>);
// __int64 __usercall sub_14000F354@<rax>(__int64 *a1@<rdx>, ULONG_PTR a2@<rcx>, __int64 a3@<r8>, unsigned __int64 *a4@<r9>, __m256i *a5@<ymm0>, __int64 a6, int a7, __int64 a8, char a9);
__int64 __fastcall sub_14000F58C(__int64, _DWORD, _DWORD, __int64, char); // weak
// _QWORD *__usercall sub_14000F594@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
_QWORD *__fastcall sub_14000F5D0(_QWORD *a1);
// __int64 __usercall sub_14000F5F0@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
void __fastcall sub_14000F624(_QWORD *a1);
_QWORD *__fastcall sub_14000F640(_QWORD *a1, char a2);
// __int64 __usercall sub_14000F690@<rax>(_QWORD *a1@<rcx>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_14000F87C@<rax>(__int64 a1@<rdx>, __int64 *a2@<rcx>, signed int *a3@<r8>, __m256i *a4@<ymm0>);
// __int64 __usercall sub_14000F904@<rax>(unsigned __int64 *a1@<rdx>, __int64 *a2@<rcx>, __int64 a3@<r8>, int a4@<r9d>, __m256i *a5@<ymm0>);
// __int64 __usercall sub_14000FA90@<rax>(unsigned __int64 *a1@<rdx>, _QWORD *a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
// char __usercall sub_14000FB28@<al>(_DWORD *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// char __usercall sub_14000FC18@<al>(_DWORD *a1@<rcx>, __m256i *a2@<ymm0>);
__int64 __fastcall sub_14000FCA0(__int64 a1, __int64 (__fastcall *a2)(__int64, __int64), __int64 a3);
__int64 __fastcall sub_14000FCAC(__int64 a1, __int64 (__fastcall *a2)(__int64, __int64, _QWORD), __int64 a3, unsigned int a4);
const char *__fastcall sub_14000FCC0(__int64 a1);
void __fastcall sub_14000FCF0(__int64 a1, __int64 *a2);
__int64 __fastcall sub_14000FD40(__int64 a1, __int64 *a2);
void __fastcall sub_14000FD70(__int64 a1, __int64 *a2);
void __fastcall sub_14000FDA0(__int64 a1, __int64 a2, __int64 a3);
// void __usercall sub_14000FDE8(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
void __fastcall sub_14000FE78(__int64 a1);
void __fastcall sub_14000FEA0(_QWORD *a1, _BYTE *a2);
char sub_14000FF40();
int *sub_14000FF68();
LPVOID *sub_14000FF70();
// signed __int64 __usercall sub_14000FF78@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// signed __int64 __usercall sub_14000FFF4@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// signed __int64 __usercall sub_14001009C@<rax>(signed __int64 *a1@<rcx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_140010104@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_14001019C@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_140010234@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_140010260@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// unsigned __int64 __usercall sub_14001028C@<rax>(unsigned __int64 a1@<rdx>, __int64 a2@<rcx>, unsigned __int64 a3@<r8>, unsigned __int64 a4@<r9>, __m256i *a5@<ymm0>, __int64 a6);
// unsigned __int64 __usercall sub_1400104EC@<rax>(unsigned __int64 a1@<rdx>, __int64 a2@<rcx>, unsigned __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
// unsigned __int64 __usercall sub_14001050C@<rax>(unsigned __int64 a1@<rdx>, __int64 a2@<rcx>, unsigned __int64 a3@<r8>, unsigned __int64 a4@<r9>, __m256i *a5@<ymm0>, __int64 a6);
// signed __int64 __usercall sub_1400105B4@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, unsigned int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
// char __usercall sub_140010650@<al>(__int64 a1@<rdx>, _DWORD *a2@<rcx>, int a3@<r8d>, __m256i *a4@<ymm0>);
// signed __int64 __usercall sub_140010738@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
// __int64 __usercall sub_140010824@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, unsigned int a3@<r8d>, __m256i *a4@<ymm0>);
// unsigned __int64 __usercall sub_1400108BC@<rax>(__int64 *a1@<rdx>, char ***a2@<r8>, __int64 *a3@<r9>, __m256i *a4@<ymm0>);
// unsigned __int64 __usercall sub_1400108FC@<rax>(char ***a1@<rcx>, __m256i *a2@<ymm0>);
// unsigned __int64 __usercall sub_14001097C@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>, __int64 a6);
// unsigned __int64 __usercall sub_140010A18@<rax>(unsigned __int64 a1@<rdx>, __m128i *a2@<rcx>, unsigned __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>, __int64 a6);
// unsigned __int64 __usercall sub_140010C2C@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
char __fastcall sub_140010CD0(__int64 a1, unsigned __int64 a2, __int64 a3);
char __fastcall sub_140010D78(__int64 a1, unsigned __int64 a2, __int64 a3);
bool __fastcall sub_140010E24(char a1, __int16 a2, int a3);
// signed __int64 __usercall sub_140010E64@<rax>(char **a1@<rdx>, __int64 a2@<rcx>, signed int a3@<r8d>, unsigned __int8 a4@<r9b>, __m256i *a5@<ymm0>);
// signed __int64 __usercall sub_140011118@<rax>(__int16 **a1@<rdx>, __int64 a2@<rcx>, unsigned int a3@<r8d>, unsigned __int8 a4@<r9b>, __m256i *a5@<ymm0>);
// char __usercall sub_140011890@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// char __usercall sub_140011A94@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// char __usercall sub_140011CA0@<al>(char a1@<dl>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// char __usercall sub_140011EA4@<al>(char a1@<dl>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// char __usercall sub_1400120B0@<al>(char a1@<dl>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// char __usercall sub_1400122B4@<al>(char a1@<dl>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
signed __int64 __fastcall sub_1400124C0(__int64 a1, unsigned int a2);
signed __int64 __fastcall sub_140012530(__int64 a1, unsigned int a2);
signed __int64 __fastcall sub_1400125B4(__int64 a1, unsigned int a2, char a3);
signed __int64 __fastcall sub_140012660(__int64 a1, unsigned int a2, char a3);
signed __int64 __fastcall sub_140012720(__int64 a1, unsigned int a2, char a3);
signed __int64 __fastcall sub_1400127A4(__int64 a1, unsigned int a2, char a3);
signed __int64 __fastcall sub_140012844(__int64 a1, unsigned __int64 a2);
signed __int64 __fastcall sub_1400128B4(__int64 a1, unsigned __int64 a2);
signed __int64 __fastcall sub_14001293C(__int64 a1, unsigned __int64 a2, char a3);
signed __int64 __fastcall sub_1400129EC(__int64 a1, unsigned __int64 a2, char a3);
signed __int64 __fastcall sub_140012AB0(__int64 a1, unsigned __int64 a2, char a3);
signed __int64 __fastcall sub_140012B34(__int64 a1, unsigned __int64 a2, char a3);
char __fastcall sub_140012BD4(char *a1, __int64 a2);
// char __usercall sub_140012C40@<al>(_DWORD *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// char __usercall sub_140012CD0@<al>(_DWORD *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// signed __int64 __usercall sub_140012D60@<rax>(_QWORD *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// signed __int64 __usercall sub_1400130E0@<rax>(_QWORD *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// char __usercall sub_1400133B8@<al>(unsigned __int64 a1@<rax>, __int64 a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// char __usercall sub_140013540@<al>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// char __usercall sub_1400136F0@<al>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// char __usercall sub_140013AF4@<al>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
char __fastcall sub_140013F58(__int64 a1);
char __fastcall sub_140013FD4(__int64 a1);
// char __usercall sub_140014054@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// char __usercall sub_1400142A8@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// char __usercall sub_140014510@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// char __usercall sub_1400145E4@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// char __usercall sub_1400146A8@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// char __usercall sub_140014760@<al>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm1>);
// char __usercall sub_1400147FC@<al>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// __int64 __usercall sub_140014898@<rax>(int a1@<edx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// __int64 __usercall sub_140014910@<rax>(signed __int64 *a1@<rcx>, __m256i *a2@<ymm0>);
void __fastcall sub_140014988(_QWORD *a1, const __m128i *a2, int a3, _DWORD *a4);
void __fastcall sub_140014A2C(_QWORD *a1, const __m128i *a2, int a3, _DWORD *a4);
// __int64 __usercall sub_140014AD4@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>, __m128i *a8, __int64 a9);
// __int64 __usercall sub_140014D28@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>, __m128i *a8, __int64 a9);
__int64 __fastcall sub_140014F84(_QWORD, _QWORD); // weak
void __fastcall sub_140014F8C(LPVOID lpMem);
__int64 __fastcall sub_140014FA0(_QWORD); // weak
signed __int64 __fastcall sub_140014FC0(_QWORD *a1, __int64 a2, unsigned __int64 a3);
signed __int64 sub_140015040();
char *__fastcall sub_140015160(unsigned int a1);
// void __usercall sub_140015180(__m256i *a1@<ymm0>);
void __fastcall sub_1400151DC(__int64 a1);
void __fastcall sub_1400151E8(__int64 a1);
char *__fastcall sub_1400151F4(unsigned __int64 a1);
signed __int64 __fastcall sub_140015260(int a1);
__int64 __fastcall sub_1400152A8(int a1);
signed __int64 __fastcall sub_1400152F0(int a1, __int64 a2);
void *sub_140015314();
void *sub_140015334();
// const char *__usercall sub_140015354@<rax>(int a1@<ecx>, __m256i *a2@<ymm0>);
__int64 __fastcall sub_1400153F4(const CHAR *a1, __int64 a2, __int64 a3, UINT a4);
// signed __int64 __usercall sub_140015570@<rax>(__m128i *lpRootPathName@<rcx>, _OWORD *a2@<rdx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// char __usercall sub_1400156C4@<al>(int a1@<edx>, __m128i *a2@<rcx>, void *a3@<r8>, __int64 a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>);
__int64 __fastcall sub_14001586C(FILETIME a1, __int64 a2);
// __int64 __usercall sub_14001590C@<rax>(__m128i *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// __int16 __usercall sub_1400159A8@<ax>(const __m128i *a1@<rdx>, unsigned int a2@<ecx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// char __usercall sub_140015AE4@<al>(int *a1@<rdx>, unsigned __int16 *a2@<rcx>, __m256i *a3@<ymm0>);
char __fastcall sub_140015B44(_WORD *a1);
// char __usercall sub_140015BE8@<al>(LPCWSTR lpRootPathName@<rcx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_140015CF8@<rax>(_OWORD *a1@<rdx>, const CHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
__int64 __fastcall sub_140015DFC(LPCWSTR lpRootPathName); // idb
// __int64 __usercall sub_140015E04@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
_BYTE *__fastcall sub_140015E40(_BYTE *a1, char *a2, unsigned __int64 a3);
// unsigned __int8 *__usercall sub_140015FD8@<rax>(unsigned __int8 *a1@<rdx>, unsigned __int8 *a2@<rcx>, __m256i *a3@<ymm0>);
signed __int64 __fastcall sub_140016008(__int64 a1, LPCWSTR *a2);
__int64 __fastcall sub_14001607C(__int64 a1, LPCWSTR *a2);
// __m128i *__usercall sub_140016154@<rax>(__int64 *a1@<rcx>, __m256i *a2@<ymm0>);
// __m128i *__usercall sub_140016238@<rax>(_WORD *a1@<rdx>, __m128i *a2@<rcx>, unsigned __int64 a3@<r8>, __m256i *a4@<ymm0>);
// __int64 __usercall sub_1400162EC@<rax>(__int16 *a1@<rdx>, const WCHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// __int64 __usercall sub_1400163B8@<rax>(__int16 *a1@<rdx>, const WCHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// signed __int64 __usercall sub_1400163C4@<rax>(unsigned __int8 **a1@<rdx>, __int64 a2@<rcx>, unsigned int a3@<r8d>, unsigned __int8 a4@<r9b>, __m256i *a5@<ymm0>);
// signed __int64 __usercall sub_1400166B4@<rax>(WCHAR **a1@<rdx>, __int64 a2@<rcx>, unsigned int a3@<r8d>, unsigned __int8 a4@<r9b>, __m256i *a5@<ymm0>);
// __int64 __usercall sub_140016E50@<rax>(__int16 a1@<dx>, int a2@<ecx>, __m128i *a3@<r8>, __m256i *a4@<ymm0>);
// __int64 __usercall sub_140016EC8@<rax>(__int64 *a1@<rdx>, __int64 a2@<rcx>, unsigned int a3@<r8d>, __m256i *a4@<ymm0>);
// __int64 __usercall sub_140016F7C@<rax>(__int64 *a1@<rdx>, __int64 a2@<rcx>, unsigned int a3@<r8d>, __m256i *a4@<ymm0>);
// signed __int64 __usercall sub_140017030@<rax>(const CHAR *a1@<rdx>, WCHAR *a2@<rcx>, unsigned __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
// signed __int64 __usercall sub_14001722C@<rax>(const CHAR *a1@<rdx>, WCHAR *a2@<rcx>, unsigned __int64 a3@<r8>, __m256i *a4@<ymm0>);
signed __int64 __fastcall sub_1400172E0(unsigned __int8 *a1, __int64 a2);
// void __usercall sub_140017348(__int64 a1@<rcx>, __int64 *a2@<rdx>, __int64 **a3@<r8>, __int64 *a4@<r9>, __m256i *a5@<ymm0>);
// void __usercall sub_1400173E4(__int64 a1@<rcx>, int *a2@<rdx>, _QWORD *a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
// __int64 __usercall sub_1400174C8@<rax>(__int64 *a1@<rdx>, __int64 **a2@<r8>, __int64 *a3@<r9>, __m256i *a4@<ymm0>);
// __int64 __usercall sub_140017508@<rax>(char a1@<cl>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_140017568@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// __int64 __usercall sub_1400175F4@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_1400176C8@<rax>(__m256i *a1@<ymm0>);
// __int64 __usercall sub_1400176D0@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
__int64 __fastcall sub_140017750(__int64 a1, _BYTE *a2, unsigned __int64 a3);
// _WORD *__usercall sub_1400178B4@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
_WORD *__fastcall sub_140017938(_WORD *a1, __int64 a2, __int64 a3);
// __int64 __usercall sub_140017980@<rax>(__m128i *a1@<rdx>, __m128i *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// signed __int64 __usercall sub_1400179C0@<rax>(__m128i *a1@<rdx>, __m128i *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// _WORD *__usercall sub_140017A54@<rax>(__m128i *a1@<rdx>, __m128i *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
bool __fastcall sub_140017BA8(const WCHAR *a1, const WCHAR *a2);
// __int64 __usercall sub_140017CFC@<rax>(__m128i *a1@<rdx>, __m128i *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
signed __int64 __fastcall sub_140017D34(const WCHAR *a1);
// HANDLE __usercall sub_140017D5C@<rax>(__int64 a1@<rdx>, const WCHAR *a2@<rcx>, __m256i *a3@<ymm0>);
// __int64 __usercall sub_140017EA4@<rax>(__int64 a1@<rdx>, void *a2@<rcx>, __m256i *a3@<ymm0>);
__int64 __fastcall sub_140017FCC(const FILETIME *a1);
signed __int64 __fastcall sub_14001805C(void *a1);
__int64 __fastcall sub_140018084(_QWORD, _QWORD); // weak
__int64 __fastcall sub_14001808C(_QWORD, _QWORD); // weak
char *sub_140018094();
void __fastcall sub_14001813C(LPCRITICAL_SECTION lpCriticalSection);
// signed __int64 __usercall sub_14001818C@<rax>(unsigned int a1@<ecx>, __m256i *a2@<ymm0>);
void __fastcall sub_140018234(int a1);
signed __int64 __fastcall sub_14001825C(signed int a1, void *a2);
void __fastcall sub_14001831C(int a1);
__int64 sub_140018344();
signed __int64 __fastcall sub_140018484(signed int a1);
// signed __int64 __usercall sub_140018540@<rax>(unsigned __int64 a1@<rcx>, __m256i *a2@<ymm0>);
signed __int64 __fastcall sub_1400185B8(const WCHAR *a1);
// _WORD *__usercall sub_1400185E0@<rax>(__int64 a1@<rdx>, const WCHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// char __usercall sub_140018814@<al>(_WORD *a1@<rdx>, const WCHAR *a2@<rcx>, unsigned __int64 a3@<r8>, unsigned __int64 a4@<r9>, __m256i *a5@<ymm0>);
_WORD *__fastcall sub_140018908(__int16 *a1);
// _WORD *__usercall sub_1400189B4@<rax>(__int64 a1@<rdx>, const WCHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
__int64 __fastcall sub_1400189D0(_QWORD); // weak
// __int64 __usercall sub_1400189D8@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_140018A8C@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// signed __int64 __usercall sub_140018AF8@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// signed __int64 __usercall sub_140018C48@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
// signed __int64 __usercall sub_140018DA4@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
signed __int64 __fastcall sub_140018F28(_BYTE *a1, _BYTE *a2, char a3);
// signed __int64 __usercall sub_140018F80@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
__int64 __fastcall sub_14001901C(_QWORD, _QWORD); // weak
__int64 __fastcall sub_140019024(WCHAR a1, unsigned __int16 a2);
signed __int64 __fastcall sub_140019090(int a1, __int64 a2);
__int64 sub_140019214();
void __fastcall sub_14001921C(int a1);
bool sub_140019224();
void __fastcall sub_140019244(__int64 a1);
__int64 __fastcall sub_14001924C(__int64 a1);
void __fastcall sub_140019288(__int64 a1);
__int64 __fastcall sub_1400192B0(signed __int16 *a1, signed __int16 **a2, signed __int16 *a3, _QWORD *a4, _QWORD *a5);
LPVOID __fastcall sub_140019454(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3);
// __int64 __usercall sub_1400194B4@<rax>(int a1@<ecx>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_140019638@<rax>(__m256i *a1@<ymm0>);
// signed __int64 __usercall sub_1400196AC@<rax>(__m256i *a1@<ymm0>);
// void **__usercall sub_14001971C@<rax>(char *a1@<rcx>, __m256i *a2@<ymm0>);
// void **__usercall sub_14001982C@<rax>(__int16 *a1@<rcx>, __m256i *a2@<ymm0>);
void __fastcall sub_140019948(void **lpMem);
const WCHAR *sub_14001998C();
const CHAR *sub_140019A6C();
void __fastcall sub_140019B28(void ***a1);
void __fastcall sub_140019B44(void ***a1);
// LPVOID __usercall sub_140019B60@<rax>(__m256i *a1@<ymm0>);
// LPVOID __usercall sub_140019B9C@<rax>(__m256i *a1@<ymm0>);
void sub_140019BD8();
__int64 sub_140019C1C(void); // weak
unsigned __int16 *sub_140019C24();
__int64 __fastcall sub_140019C78(__int64 *a1, __int64 *a2);
__int64 __fastcall sub_140019CBC(_QWORD *a1, _QWORD *a2);
void __fastcall sub_140019D04(__int64 a1, int *a2, int **a3, int *a4);
int *__fastcall sub_140019D3C(int **a1);
void __fastcall sub_140019E08(UINT uExitCode, int a2, int a3);
void __fastcall __noreturn sub_140019ED0(UINT uExitCode); // idb
bool sub_140019F04();
int __fastcall sub_140019F28(unsigned int a1);
void __fastcall sub_140019F98(__int64 a1);
void sub_140019FA0();
void sub_140019FB0();
void __fastcall sub_140019FC0(UINT a1);
// __int64 __usercall sub_140019FCC@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
void __fastcall sub_14001A00C(UINT a1);
// signed __int64 __usercall sub_14001A018@<rax>(_DWORD *a1@<rcx>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_14001A048@<rax>(signed __int32 a1@<ecx>, __m256i *a2@<ymm0>);
signed __int64 __fastcall sub_14001A088(int a1, int a2);
void __fastcall sub_14001A16C(__int64 a1, int *a2, __int64 a3, int *a4);
__int64 sub_14001A1DC();
void sub_14001A1F0();
// signed __int64 __usercall sub_14001A220@<rax>(int a1@<ecx>, __m256i *a2@<ymm0>);
__int64 sub_14001A28C();
// signed __int64 __usercall sub_14001A294@<rax>(unsigned __int32 a1@<ecx>, __m256i *a2@<ymm0>);
int *sub_14001A2C0();
// __int64 __usercall sub_14001A2C8@<rax>(int *a1@<rdx>, _QWORD **a2@<r8>, int *a3@<r9>, __m256i *a4@<ymm0>);
__int64 __fastcall sub_14001A304(__int64 a1, int *a2, _QWORD **a3, int *a4);
// signed __int64 __usercall sub_14001A340@<rax>(_QWORD **a1@<rcx>, __m256i *a2@<ymm0>);
signed __int64 __fastcall sub_14001A4F0(_QWORD **a1);
// __int64 __usercall sub_14001A610@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
__int64 __fastcall sub_14001A620(__int64 a1);
signed __int64 __fastcall sub_14001A664(uintptr_t *a1);
// __int64 __usercall sub_14001A68C@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
char sub_14001A6E0();
char sub_14001A700();
char sub_14001A730();
char sub_14001A740();
char sub_14001A780();
char sub_14001A790();
char sub_14001A7D0();
char sub_14001A82C();
// char __usercall sub_14001A840@<al>(char a1@<cl>, __m256i *a2@<ymm0>);
// void __usercall __noreturn sub_14001A878(__m256i *a1@<ymm0>);
// DWORD __stdcall GetCurrentProcessId();
// _BYTE *__usercall sub_14001A8AC@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_14001A924@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_14001A94C@<rax>(__int64 a1@<rdx>, _BYTE *a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
// void __usercall __noreturn sub_14001A9AC(__m256i *a1@<ymm0>);
__int64 __fastcall sub_14001AA04(_WORD *a1, _WORD *a2, __int64 a3);
signed __int64 __fastcall sub_14001AA30(signed __int64 *a1);
signed __int64 __fastcall sub_14001AA9C(__int64 a1, __int64 a2);
// void __usercall sub_14001AAE8(int a1@<edx>, int a2@<ecx>, int a3@<r8d>, __m256i *a4@<ymm0>);
void __fastcall sub_14001AC44(__int64 a1);
// _DWORD *__usercall sub_14001AC4C@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>, __int64 a3);
// __int64 __usercall sub_14001ACE8@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>, __int64 a3, signed __int64 *a4);
// _DWORD *__usercall sub_14001ADB4@<rax>(__m256i *a1@<ymm0>);
// BOOL __usercall sub_14001ADD4@<eax>(__m256i *a1@<ymm0>);
void __fastcall sub_14001AE1C(LPVOID lpMem);
// __int64 __usercall sub_14001AE58@<rax>(int *a1@<rdx>, unsigned int **a2@<r8>, int *a3@<r9>, __m256i *a4@<ymm0>);
// __int64 __usercall sub_14001AED0@<rax>(__int64 a1@<rdx>, signed int a2@<ecx>, __m256i *a3@<ymm0>);
// __int64 __usercall sub_14001AF94@<rax>(unsigned int a1@<ecx>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_14001B02C@<rax>(__int64 a1@<rdx>, unsigned int a2@<ecx>, __m256i *a3@<ymm0>);
__int64 *__fastcall sub_14001B0FC(__int64 *a1);
__int64 __fastcall sub_14001B154(__int64 a1);
__int64 *__fastcall sub_14001B170(__int64 *a1);
__int64 __fastcall sub_14001B25C(__int64 a1);
void __fastcall sub_14001B2A0(__int64 a1, int *a2, __int64 a3, int *a4);
void __fastcall sub_14001B2E0(__int64 a1, int *a2, __int64 **a3, int *a4);
void __fastcall sub_14001B320(__int64 a1, int *a2, __int64 a3, int *a4);
void __fastcall sub_14001B368(__int64 a1, int *a2, __int64 a3, int *a4);
void __fastcall sub_14001B3C8(__int64 a1);
void __fastcall Callback(PVOID lpFlsData);
void __fastcall sub_14001B4C0(LPVOID *a1);
void __fastcall sub_14001B5B8(__int64 a1, __int64 a2);
// __int64 __usercall sub_14001B620@<rax>(__m256i *a1@<ymm0>);
// __int64 __usercall sub_14001B6F4@<rax>(__m256i *a1@<ymm0>);
__int64 sub_14001B798();
signed __int64 __fastcall sub_14001B860(__int64 a1, __int64 a2);
char sub_14001B920();
char sub_14001B960();
// __int64 __usercall sub_14001B984@<rax>(_WORD *a1@<rdx>, signed int a2@<ecx>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
// signed __int64 __usercall sub_14001BB44@<rax>(const CHAR *a1@<rdx>, signed int a2@<ecx>, __int64 a3@<r8>, WCHAR *a4@<r9>, __m256i *a5@<ymm0>, int a6);
// signed __int64 __usercall sub_14001BE0C@<rax>(WCHAR *a1@<rdx>, int a2@<ecx>, unsigned int a3@<r8d>, __m256i *a4@<ymm0>);
// signed __int64 __usercall sub_14001BF2C@<rax>(WCHAR *a1@<rdx>, signed int a2@<ecx>, unsigned int a3@<r8d>, __m256i *a4@<ymm0>);
// __int64 __usercall sub_14001C37C@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_14001C4E4@<rax>(LARGE_INTEGER a1@<rdx>, int a2@<ecx>, DWORD a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
// LARGE_INTEGER __usercall sub_14001C604@<rax>(LARGE_INTEGER a1@<rdx>, unsigned int a2@<ecx>, DWORD a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
// signed __int64 __usercall sub_14001C6B0@<rax>(LARGE_INTEGER a1@<rdx>, int a2@<ecx>, DWORD a3@<r8d>, __m256i *a4@<ymm0>);
__int64 __fastcall sub_14001C74C(_QWORD, _QWORD, _QWORD, _QWORD); // weak
// LARGE_INTEGER __usercall sub_14001C754@<rax>(LARGE_INTEGER a1@<rdx>, unsigned int a2@<ecx>, DWORD a3@<r8d>, __m256i *a4@<ymm0>);
__int64 __fastcall sub_14001C7F0(_QWORD, _QWORD, _QWORD); // weak
// void __usercall sub_14001C7F8(__m256i *a1@<ymm0>);
unsigned __int64 sub_14001C8E8();
// char __usercall sub_14001C9F0@<al>(__m256i *a1@<ymm0>);
char sub_14001CA30();
// __int64 __usercall sub_14001CA70@<rax>(int a1@<edx>, __int64 a2@<rcx>, unsigned __int64 a3@<r8>, unsigned int a4@<r9d>, __m256i *a5@<ymm0>);
DWORD *__fastcall sub_14001CEE8(DWORD *a1, int a2, char *a3, int a4);
DWORD *__fastcall sub_14001CFEC(DWORD *a1, int a2, __int16 *a3, unsigned int a4);
DWORD *__fastcall sub_14001D108(DWORD *a1, int a2, __int16 *a3, unsigned int a4);
// __int64 __usercall sub_14001D278@<rax>(unsigned __int16 *a1@<rdx>, int a2@<ecx>, unsigned int a3@<r8d>, __m256i *a4@<ymm0>);
// signed __int64 __usercall sub_14001D310@<rax>(unsigned __int16 *a1@<rdx>, int a2@<ecx>, unsigned int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
// signed __int64 __usercall sub_14001D430@<rax>(unsigned __int16 *a1@<rdx>, signed int a2@<ecx>, unsigned int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
// bool __usercall sub_14001D738@<al>(__int64 a1@<rdx>, char a2@<cl>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
// bool __usercall sub_14001D830@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_14001D8AC@<rax>(__int64 a1@<rdx>, unsigned __int8 a2@<cl>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
// bool __usercall sub_14001D978@<al>(char *a1@<rcx>, __m256i *a2@<ymm0>);
// char __usercall sub_14001D9C4@<al>(char *a1@<rcx>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_14001DA8C@<rax>(__int64 a1@<rdx>, char a2@<cl>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
LPVOID __fastcall sub_14001DACC(unsigned __int64 a1);
// char *__usercall sub_14001DB2C@<rax>(unsigned __int64 a1@<rdx>, __m128i *a2@<rcx>, __int128 *__struct_ptr _XMM1@<xmm1>, __m256i *__struct_ptr _YMM1@<ymm1>);
// signed __int64 __usercall sub_14001DC7C@<rax>(unsigned __int64 a1@<rdx>, __m128i *a2@<rcx>, __int128 *__struct_ptr _XMM1@<xmm1>, __m256i *__struct_ptr _YMM1@<ymm1>);
// __int64 __usercall sub_14001DE54@<rax>(__int64 *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// __int64 __usercall sub_14001DE88@<rax>(__int64 *a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
// volatile signed __int32 *__usercall sub_14001DEC0@<rax>(LPVOID *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// volatile signed __int32 *__usercall sub_14001DEF4@<rax>(_QWORD *a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
// __int64 __usercall sub_14001DF2C@<rax>(signed __int64 a1@<rdx>, unsigned __int64 *a2@<rcx>, unsigned __int64 a3@<r8>, _BYTE *a4@<r9>, __m256i *a5@<ymm0>, __int64 a6, int a7, char a8, int a9, int a10, __int64 a11);
// __int64 __usercall sub_14001E2C4@<rax>(_BYTE *a1@<rdx>, unsigned __int64 *a2@<rcx>, unsigned __int64 a3@<r8>, _BYTE *a4@<r9>, __m256i *a5@<ymm0>, __int64 a6, int a7, char a8, int a9, int a10, __int64 a11);
// signed __int64 __usercall sub_14001E3C0@<rax>(unsigned __int64 a1@<rdx>, _BYTE *a2@<rcx>, int a3@<r8d>, char a4@<r9b>, __m256i *a5@<ymm0>, int a6, __int64 a7, unsigned __int8 a8, __int64 a9);
// __int64 __usercall sub_14001E5A4@<rax>(_BYTE *a1@<rdx>, unsigned __int64 *a2@<rcx>, __int64 a3@<r8>, _BYTE *a4@<r9>, __m256i *a5@<ymm0>, __int64 a6, __int64 a7, int a8, __int64 a9);
// __int64 __usercall sub_14001E67C@<rax>(_BYTE *a1@<rcx>, int a2@<r8d>, __int64 a3@<r9>, __m256i *a4@<ymm0>, char a5, __int64 a6);
// __int64 __usercall sub_14001E7D4@<rax>(_BYTE *a1@<rdx>, unsigned __int64 *a2@<rcx>, unsigned __int64 a3@<r8>, _BYTE *a4@<r9>, __m256i *a5@<ymm0>, __int64 a6, int a7, char a8, int a9, int a10, __int64 a11);
bool __fastcall sub_14001E928(unsigned __int64 *a1, __int64 a2, __int16 a3, int a4);
// signed __int64 __usercall sub_14001EA40@<rax>(_BYTE *a1@<rdx>, unsigned __int64 *a2@<rcx>, unsigned __int64 a3@<r8>, _BYTE *a4@<r9>, __m256i *a5@<ymm0>, __int64 a6, __int64 a7, int a8, unsigned __int64 a9, __int64 a10, __int64 a11);
// signed __int64 __usercall sub_14001ED28@<rax>(CHAR *a1@<rdx>, int *a2@<rcx>, unsigned __int64 a3@<r8>, unsigned __int16 a4@<r9w>, __m256i *a5@<ymm0>, __int64 a6);
// unsigned __int64 __usercall sub_14001EED8@<rax>(CHAR *a1@<rdx>, WCHAR *a2@<rcx>, unsigned __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
_BOOL8 sub_14001F050();
LPVOID __fastcall sub_14001F068(unsigned __int64 a1, unsigned __int64 a2);
FARPROC __fastcall sub_14001F0E0(unsigned int a1, const CHAR *a2, unsigned int *a3, unsigned int *a4);
__int64 sub_14001F29C();
__int64 sub_14001F2F4();
int __fastcall sub_14001F338(unsigned __int16 *a1, DWORD a2, const WCHAR *a3, int a4, const WCHAR *lpString2, int cchCount2);
// DWORD __stdcall FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback);
// BOOL __stdcall FlsFree(DWORD dwFlsIndex);
// PVOID __stdcall FlsGetValue(DWORD dwFlsIndex);
// BOOL __stdcall FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData);
int __fastcall sub_14001F444(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
int __fastcall sub_14001F4B4(unsigned __int16 *a1, DWORD a2, const WCHAR *a3, int a4, WCHAR *lpDestStr, int cchDest);
__int64 __fastcall sub_14001F5A0(unsigned __int16 *a1);
char sub_14001F600();
char __fastcall sub_14001F630(char a1);
// __int64 __usercall sub_14001F674@<rax>(__m256i *a1@<ymm0>);
char **sub_14001F728();
const char *sub_14001F730();
// __int64 __usercall sub_14001F738@<rax>(__int64 a1@<rdx>, _BYTE *a2@<rcx>, __int64 a3@<r8>, signed __int64 a4@<r9>, __m256i *a5@<ymm0>);
// __int64 __usercall sub_14001F828@<rax>(__m256i *a1@<ymm0>);
_WORD *__fastcall sub_14001F920(_WORD *a1, __int16 *a2);
__int64 __fastcall sub_14001F954(unsigned __int16 *a1, unsigned __int16 *a2);
// __int64 __usercall sub_14001F994@<rax>(unsigned __int16 *a1@<rdx>, unsigned __int16 *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// signed __int64 __usercall sub_14001F9DC@<rax>(unsigned __int16 *a1@<rdx>, unsigned __int16 *a2@<rcx>, __m128i *a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>);
int __fastcall sub_14001FB10(UINT a1, char a2, const CHAR *a3, int a4, WCHAR *a5, int a6);
bool __fastcall sub_14001FBA0(int a1);
// signed __int64 __usercall sub_14001FBFC@<rax>(int a1@<edx>, int a2@<ecx>, int a3@<r8d>, int a4@<r9d>, __m256i *a5@<ymm0>, unsigned int a6, unsigned int a7, int a8);
__int64 __fastcall sub_14001FE30(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// __int64 __usercall sub_14001FE38@<rax>(__int64 *a1@<rdx>, __int64 a2@<r8>, __int64 *a3@<r9>, __m256i *a4@<ymm0>);
// signed __int64 __usercall sub_14001FE78@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_14001FF60@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
unsigned __int8 *__fastcall sub_140020098(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 **a3);
// __m128i *__usercall sub_1400201C0@<rax>(__m128i *a1@<rdx>, unsigned int a2@<ecx>, int a3@<r8d>, __m256i *a4@<ymm0>);
// signed __int64 __usercall sub_14002032C@<rax>(unsigned int a1@<ecx>, __m256i *a2@<ymm0>);
// __m128i *__usercall sub_1400203B0@<rax>(int a1@<edx>, __m128i *a2@<rcx>, __m256i *a3@<ymm0>);
int __fastcall sub_1400203D8(UINT a1, int a2, const WCHAR *a3, int a4, CHAR *a5, __int64 a6, const CHAR *a7, BOOL *a8);
// int *__usercall sub_1400204B8@<rax>(__int16 *a1@<rdx>, int *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// __int64 __usercall sub_1400207BC@<rax>(__int16 *a1@<rdx>, const WCHAR *a2@<rcx>, __int64 a3@<r9>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>);
// __int64 __usercall sub_140020858@<rax>(__m256i *a1@<ymm0>);
// __int64 __usercall sub_140020888@<rax>(int a1@<edx>, int a2@<ecx>, __m128i *a3@<r8>, __m256i *a4@<ymm0>);
unsigned __int64 __fastcall sub_140020990(signed __int16 *a1, char *a2, unsigned __int64 a3, _QWORD *a4, __int64 a5);
signed __int64 __fastcall sub_1400209D4(_WORD *a1, char **a2, unsigned __int64 a3, _QWORD *a4, __int64 a5);
char sub_140020B80();
void __fastcall sub_140020BC8(int a1);
char sub_140020BF0();
void __fastcall sub_140020C28(int a1);
// __int64 __usercall sub_140020C44@<rax>(int *a1@<rdx>, signed int **a2@<r8>, int *a3@<r9>, __m256i *a4@<ymm0>);
// __int64 __usercall sub_140020CD0@<rax>(signed int a1@<ecx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_140020D64@<rax>(__int64 a1@<rdx>, _WORD *a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
LPVOID __fastcall sub_140020DCC(LPVOID lpMem, SIZE_T dwBytes);
// __int64 __usercall sub_140020E48@<rax>(LPVOID lpMem@<rcx>, int a2@<edx>, __m256i *a3@<ymm0>);
// __int64 __usercall sub_1400211A0@<rax>(LPVOID lpMem@<rcx>, int a2@<edx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
// _BYTE *__usercall sub_140021504@<rax>(__int64 *a1@<rcx>, __m256i *a2@<ymm0>);
// _BYTE *__usercall sub_1400215EC@<rax>(__int64 *a1@<rcx>, __m256i *a2@<ymm0>);
__int64 __fastcall sub_1400216DC(LPVOID lpMem); // idb
__int64 __fastcall sub_1400216E4(LPVOID lpMem); // idb
// signed __int64 __usercall sub_1400216EC@<rax>(_WORD *a1@<rdx>, unsigned int a2@<ecx>, unsigned __int64 a3@<r8>, unsigned int a4@<r9d>, __m256i *a5@<ymm0>, char a6);
// signed __int64 __usercall sub_1400217D0@<rax>(_WORD *a1@<rdx>, unsigned int a2@<ecx>, unsigned __int64 a3@<r8>, unsigned int a4@<r9d>, __m256i *a5@<ymm0>, unsigned __int8 a6);
// signed __int64 __usercall sub_14002183C@<rax>(_WORD *a1@<rdx>, unsigned int a2@<ecx>, unsigned __int64 a3@<r8>, unsigned int a4@<r9d>, __m256i *a5@<ymm0>);
// __int64 __usercall sub_140021850@<rax>(__int64 *a1@<rdx>, _QWORD *a2@<rcx>, __m128i *a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>);
// signed __int64 __usercall sub_140021948@<rax>(__m128i *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>);
// __int64 __usercall sub_1400219E0@<rax>(_WORD *a1@<rdx>, unsigned __int64 *a2@<rcx>, unsigned __int64 a3@<r8>, __m128i *a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>);
// __int64 __usercall sub_140021AD8@<rax>(__int64 *a1@<rdx>, _QWORD *a2@<rcx>, __m128i *a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>);
__int64 __fastcall sub_140021AF8(_QWORD, _QWORD, _QWORD, _QWORD); // weak
// __int64 __usercall sub_140021B00@<rax>(__int64 a1@<rdx>, _WORD *a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
// signed __int64 __usercall sub_140021B78@<rax>(unsigned int a1@<edx>, const WCHAR *a2@<rcx>, __m256i *a3@<ymm0>);
// __int64 __usercall sub_140021C30@<rax>(__m256i *a1@<ymm0>);
// __int64 __usercall sub_140021C44@<rax>(__m256i *a1@<ymm0>);
// BOOL __stdcall GetStringTypeW(DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// __int64 __usercall sub_140021CE0@<rax>(__int64 a1@<rdx>, _WORD *a2@<rcx>, __int64 a3@<r8>, signed __int64 a4@<r9>, __m256i *a5@<ymm0>);
char __fastcall sub_140021DE0(unsigned __int64 a1, unsigned __int64 a2);
// signed __int64 __usercall sub_140021DF4@<rax>(_QWORD *a1@<rdx>, __int64 *a2@<rcx>, __m256i *a3@<ymm0>);
// signed __int64 __usercall sub_1400221E4@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, signed __int64 a3@<r8>, LPVOID *a4@<r9>, __m256i *a5@<ymm0>);
__int64 __fastcall sub_14002236C(_QWORD, _QWORD); // weak
// void __usercall sub_140022374(int *a1@<rdx>, volatile signed __int32 ****a2@<r8>, int *a3@<r9>, __m256i *a4@<ymm0>);
// __int64 __usercall sub_140022544@<rax>(UINT a1@<ecx>, __m256i *a2@<ymm0>);
// char __usercall sub_1400225C4@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// char __usercall sub_14002265C@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_140022844@<rax>(char a1@<dl>, UINT a2@<ecx>, __int64 a3@<r8>, volatile signed __int32 **a4@<r9>, __m256i *a5@<ymm0>);
// volatile signed __int32 *__usercall sub_140022AB4@<rax>(volatile signed __int32 **a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// char __usercall sub_140022B70@<al>(__m256i *a1@<ymm0>);
// volatile signed __int32 *__usercall sub_140022BD0@<rax>(__m256i *a1@<ymm0>);
// signed __int64 __usercall sub_140022BEC@<rax>(__int64 a1@<rdx>, UINT a2@<ecx>, __m256i *a3@<ymm0>);
CHAR *sub_140022EAC();
LPWCH sub_140022FBC();
char sub_140023058();
__int64 sub_140023074();
__int64 sub_14002308C();
__int64 sub_1400230C0();
// __int64 __usercall sub_1400230DC@<rax>(__m256i *a1@<ymm0>);
void __fastcall sub_14002310C(_QWORD *a1);
void __fastcall sub_140023218(void **a1);
void __fastcall sub_140023284(LPVOID *a1, __int64 a2);
void __fastcall sub_1400232B8(LPVOID *a1);
// __int64 __usercall sub_1400233C0@<rax>(DWORD a1@<edx>, __m128i *a2@<rcx>, const CHAR *a3@<r8>, int a4@<r9d>, __m256i *a5@<ymm0>, WORD *lpCharType, UINT a7, int a8);
signed __int64 __fastcall sub_140023550(__int64 a1);
void __fastcall sub_1400235DC(LPVOID lpMem);
void __fastcall sub_14002377C(LPVOID lpMem);
signed __int64 __fastcall sub_1400237B4(__int64 a1);
void __fastcall sub_1400237DC(__int64 a1);
// __int64 __usercall sub_140023884@<rax>(__m256i *a1@<ymm0>);
__int64 __fastcall sub_1400238F4(__int64 *a1, __int64 a2);
// __int64 __usercall sub_14002395C@<rax>(LPVOID lpMem@<rcx>, unsigned __int64 a2@<rdx>, unsigned __int64 a3@<r8>, __m256i *a4@<ymm0>);
bool sub_140023A00();
char sub_140023A20();
char __fastcall sub_140023A2C(_QWORD *a1, _QWORD *a2);
char __fastcall sub_140023AC0(__int64 a1, __int64 a2);
void __fastcall sub_140023B08(__int64 a1);
__int64 __fastcall sub_140023B10(__int64 a1);
__int64 sub_140023B50();
__int64 __fastcall sub_140023B88(__int64 a1, int *a2, __int64 a3, int *a4);
__int64 sub_140023BD0();
void __fastcall sub_140023C00(__int64 a1);
// signed __int64 __usercall sub_140023C20@<rax>(unsigned int a1@<ecx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_140023E9C@<rax>(signed int a1@<ecx>, __m256i *a2@<ymm0>);
__int64 __fastcall sub_140023EFC(__int64 a1);
signed __int64 __fastcall sub_140023F68(unsigned __int16 a1);
bool __fastcall sub_140023FA4(_BYTE *a1, _BYTE *a2, int a3, int a4, int a5);
// __int64 __usercall sub_140024074@<rax>(unsigned __int64 a1@<rdx>, _BYTE *a2@<rcx>, int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>, __int64 a6, int a7, __int64 a8);
// __int64 __usercall sub_140024190@<rax>(unsigned int *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// __int64 __usercall sub_14002462C@<rax>(int a1@<edx>, unsigned __int64 a2@<rcx>, int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>, _BYTE *a6, __int64 a7);
// signed __int64 __usercall sub_1400258BC@<rax>(unsigned __int64 a1@<rdx>, __m128i *a2@<rcx>, const __m128i *a3@<r8>, unsigned __int64 a4@<r9>, __m256i *a5@<ymm0>);
__int64 sub_140025944();
__int64 __fastcall sub_140025958(_BYTE *a1, unsigned int a2, _QWORD *a3, __int64 a4);
__int64 __fastcall sub_1400259FC(unsigned __int16 *a1);
// signed __int64 __usercall sub_140025AA0@<rax>(__m128i *a1@<rdx>, unsigned __int16 a2@<cx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>);
__int64 sub_140025BA0();
int *sub_140025BF0();
int *sub_140025BF8();
int *sub_140025C00();
__int64 sub_140025C08();
__int64 sub_140025C10();
// signed __int64 __usercall sub_140025C18@<rax>(_DWORD *a1@<rcx>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_140025C48@<rax>(_DWORD *a1@<rcx>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_140025C78@<rax>(_DWORD *a1@<rcx>, __m256i *a2@<ymm0>);
// signed __int64 __usercall sub_140025CA8@<rax>(_DWORD *a1@<rcx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_140025FA4@<rax>(int a1@<edx>, int a2@<ecx>, int a3@<r8d>, int a4@<r9d>, __m256i *a5@<ymm0>, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
// int __usercall sub_14002619C@<eax>(WCHAR *a1@<rdx>, __int64 a2@<rcx>, CHAR *a3@<r8>, signed __int64 a4@<r9>, __m256i *a5@<ymm0>);
// void __usercall sub_140026280(unsigned __int16 *a1@<rcx>, __m256i *a2@<ymm0>);
// int *__usercall sub_1400264FC@<rax>(__m256i *a1@<ymm0>);
// void __usercall sub_140026684(__m256i *a1@<ymm0>);
// int __usercall sub_140026794@<eax>(_WORD *a1@<rdx>, __int64 a2@<rcx>, CHAR *a3@<r8>, UINT a4@<r9d>, __m256i *a5@<ymm0>);
// void __usercall sub_140026814(__m256i *a1@<ymm0>);
// __int64 __usercall sub_140026858@<rax>(_DWORD *a1@<rcx>, __m256i *a2@<ymm0>);
__int64 __fastcall sub_140026888(unsigned __int16 *a1, unsigned __int16 *a2, __int64 a3);
// __int64 __usercall sub_1400268D4@<rax>(unsigned __int16 *a1@<rdx>, unsigned __int16 *a2@<rcx>, __int64 a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>);
// signed __int64 __usercall sub_14002691C@<rax>(unsigned __int16 *a1@<rdx>, unsigned __int16 *a2@<rcx>, __int64 a3@<r8>, __m128i *a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>);
__int64 __fastcall sub_140026A70(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3);
// __int64 __usercall sub_140026ABC@<rax>(unsigned __int8 *a1@<rdx>, unsigned __int8 *a2@<rcx>, unsigned __int64 a3@<r8>, __m256i *a4@<ymm0>);
// signed __int64 __usercall sub_140026B0C@<rax>(unsigned __int8 *a1@<rdx>, unsigned __int8 *a2@<rcx>, unsigned __int64 a3@<r8>, __m128i *a4@<r9>, __m256i *a5@<ymm0>);
// signed __int64 __usercall sub_140026BBC@<rax>(int a1@<edx>, const WCHAR *a2@<rcx>, int a3@<r9d>, __m256i *a4@<ymm0>, int *a5, int a6);
// __int64 __usercall sub_140026C80@<rax>(__int64 a1@<rdx>, signed int a2@<ecx>, int a3@<r8d>, _BYTE *a4@<r9>, __m256i *a5@<ymm0>);
// _BYTE *__usercall sub_140026F00@<rax>(int a1@<edx>, _BYTE *a2@<rcx>, int a3@<r8d>, char a4@<r9b>, __m256i *a5@<ymm0>);
// __int64 __usercall sub_140027108@<rax>(int a1@<ecx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_1400271CC@<rax>(unsigned __int64 a1@<rdx>, unsigned __int64 a2@<rcx>, const WCHAR *a3@<r8>, int a4@<r9d>, __m256i *a5@<ymm0>);
// signed __int64 __usercall sub_1400275BC@<rax>(const WCHAR *a1@<rdx>, int *a2@<rcx>, int a3@<r8d>, __m256i *a4@<ymm0>, int a5);
__int64 __fastcall sub_1400275F0(__int64 a1, char *a2, unsigned __int64 a3, _QWORD *a4, __int64 a5);
// __int64 __usercall sub_1400277CC@<rax>(__m128i *a1@<rdx>, __m128i *a2@<rcx>, unsigned __int64 a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>);
// signed __int64 __usercall sub_14002781C@<rax>(__m128i *a1@<rdx>, __m128i *a2@<rcx>, unsigned __int64 a3@<r8>, __m128i *a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>);
// __int64 __usercall sub_14002790C@<rax>(unsigned __int8 *a1@<rdx>, CHAR *a2@<rcx>, unsigned __int64 a3@<r8>, __m256i *a4@<ymm0>);
// __int64 __usercall sub_140027924@<rax>(unsigned __int8 *a1@<rdx>, CHAR *a2@<rcx>, unsigned __int64 a3@<r8>, __m128i *a4@<r9>, __m256i *a5@<ymm0>);
// __int64 __usercall sub_140027A24@<rax>(const CHAR *a1@<rdx>, const CHAR *a2@<rcx>, __m256i *a3@<ymm0>);
int *sub_140027BC4();
// void __usercall sub_140027C20(unsigned __int64 a1@<rdx>, unsigned __int64 a2@<rcx>, unsigned __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
int __fastcall sub_140028030(__int64 a1, unsigned __int16 *a2, DWORD a3, CHAR *a4, int a5, WCHAR *a6, int a7, UINT a8, int a9);
// int __usercall sub_140028364@<eax>(unsigned __int16 *a1@<rdx>, __m128i *a2@<rcx>, DWORD a3@<r8d>, CHAR *a4@<r9>, __m256i *a5@<ymm0>, int a6, WCHAR *a7, int a8, UINT a9, int a10);
// _BOOL8 __usercall sub_140028400@<rax>(__m256i *a1@<ymm0>);
// SIZE_T __usercall sub_140028418@<rax>(const void *a1@<rcx>, __m256i *a2@<ymm0>);
__int64 sub_140028454();
BOOL sub_1400284B0();
__int64 __fastcall sub_1400284CC(void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten); // idb
// signed __int64 __usercall sub_14002858C@<rax>(unsigned int a1@<edx>, _DWORD *a2@<rcx>, int a3@<r8d>, __m256i *a4@<ymm0>);
__int64 __fastcall sub_1400285F0(_DWORD *a1);
signed __int64 __fastcall sub_140028610(unsigned int *a1);
signed __int64 __fastcall sub_140028668(__int64 *a1);
double __fastcall sub_1400286B8(double result);
// unsigned __int64 __usercall sub_140028780@<rax>(__int64 a1@<rcx>, __m128i *__struct_ptr _XMM0@<xmm0>);
__int64 __fastcall sub_140028D2C(__int16 a1);
__int64 sub_140028D38();
__int64 sub_140028E1C();
__int64 __fastcall sub_140028E74(unsigned int a1);
__int64 __fastcall sub_140028FAC(unsigned int a1);
__int64 __fastcall sub_140029020(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_140029028(_QWORD *a1, __int64 a2);
// int __usercall sub_14002903C@<eax>(DWORD a1@<edx>, unsigned __int16 *a2@<rcx>, __m128i *a3@<r8>, int a4@<r9d>, __int128 *a5@<xmm1>, __m256i *a6@<ymm1>, WCHAR *a7, int a8);
// __int64 __usercall sub_1400290C4@<rax>(LARGE_INTEGER a1@<rdx>, unsigned int a2@<ecx>, __m256i *a3@<ymm0>);
// __int64 __usercall sub_14002915C@<rax>(LARGE_INTEGER a1@<rdx>, unsigned int a2@<ecx>, __int64 a3@<r8>, __m256i *a4@<ymm0>);
// int __usercall sub_1400292F0@<eax>(DWORD a1@<edx>, unsigned __int16 *a2@<rcx>, __m128i *a3@<r8>, int a4@<r9d>, __int128 *a5@<xmm1>, __m256i *a6@<ymm1>, __m128i *a7, int a8);
__int64 __fastcall sub_1400293B0(__int64 a1, unsigned __int16 *a2, DWORD a3, CHAR *a4, int a5, __int64 CodePage, signed int a7, UINT CodePagea);
// __int64 __usercall sub_140029734@<rax>(unsigned __int16 *a1@<rdx>, __m128i *a2@<rcx>, DWORD a3@<r8d>, CHAR *a4@<r9>, __m256i *a5@<ymm0>, int a6, __int64 CodePage, signed int a8, UINT a9);
__int64 __fastcall sub_1400297C0(_BYTE *a1, __int64 a2);
__int64 sub_1400297D8();
__int64 __fastcall sub_140029844(_QWORD, _QWORD); // weak
__int64 __fastcall sub_14002984C(int a1, int a2);
double __fastcall sub_140029AE8(int a1, __int64 a2, __int64 a3, double a4, __int64 a5, double a6, int a7);
_BOOL8 __fastcall sub_140029B50(char a1, __int64 a2);
double __fastcall sub_140029C0C(__int64 a1, __int16 a2, __int64 a3, int a4);
__int64 sub_140029D50();
__int64 __fastcall sub_140029DC0(__int64 a1);
__int64 __fastcall sub_140029DE0(__int64); // weak
__int64 sub_140029E90();
void __fastcall sub_140029EA0(unsigned int a1);
void sub_140029EAA();
__int64 __fastcall sub_140029EE0(ULONG_PTR a1, _QWORD *a2, char a3, __int16 a4, _DWORD *a5, _DWORD *a6);
__int64 __fastcall sub_140029F08(ULONG_PTR a1, _QWORD *a2, char a3, __int16 a4, _DWORD *a5, _DWORD *a6, int a7);
void __fastcall sub_14002A210(int a1);
__int64 sub_14002A240();
__int64 __fastcall sub_14002A260(int a1, int a2);
void __fastcall sub_14002A2DC(char a1);
__int64 sub_14002A2FC();
signed __int64 __fastcall sub_14002A310(__int64 a1, unsigned __int64 a2);
signed __int64 __fastcall sub_14002A360(__int64 a1);
_BOOL8 __fastcall sub_14002A3B0(__int64 a1);
_QWORD *__fastcall sub_14002A3E0(_QWORD *a1, char a2);
__int64 __fastcall sub_14002A40C(_QWORD, _QWORD); // weak
// __int64 __usercall sub_14002A49C@<rax>(void *a1@<rdx>, EXCEPTION_RECORD *a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>);
signed __int64 __fastcall sub_14002A4E8(const __m128i *a1, unsigned __int16 a2);
__int64 __fastcall sub_14002A5B0();
__int64 __fastcall sub_14002A5D0(_QWORD); // weak
signed __int64 __fastcall sub_14002A5E0(int **a1);
_BOOL8 __fastcall sub_14002A5FE(_DWORD **a1);
// __int64 __usercall sub_14002A616@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// signed __int64 __usercall sub_14002A6AC@<rax>(_QWORD *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>);
// signed __int64 __usercall sub_14002A74F@<rax>(__int64 a1@<rdx>, __int64 *a2@<rcx>, __m256i *a3@<ymm0>);
// _QWORD *__usercall sub_14002A774@<rax>(__int64 a1@<rdx>, __m256i *a2@<ymm0>);
// __int64 __usercall sub_14002A7FA@<rax>(_DWORD **a1@<rcx>, __m256i *a2@<ymm0>);
// _DWORD *__usercall sub_14002A810@<rax>(__m256i *a1@<ymm0>);
void __fastcall sub_14002A833(__int64 a1, __int64 a2);
void __fastcall sub_14002A84B(__int64 a1, __int64 a2);
void __fastcall sub_14002A863(__int64 a1, __int64 a2);
void __fastcall sub_14002A87E(__int64 a1, __int64 a2);
void __fastcall sub_14002A8A9(__int64 a1, __int64 a2);
void sub_14002A8C6();
void sub_14002A8DF();
void sub_14002A8F8();
void __fastcall sub_14002A911(__int64 a1, __int64 a2);
void __fastcall sub_14002A929(__int64 a1, __int64 a2);
__int64 __fastcall sub_14002A943(int **a1, __int64 a2);
void __fastcall sub_14002A970(__int64 a1, __int64 a2);
void __fastcall sub_14002A98A(__int64 a1, __int64 a2);
void sub_14002A9A4();
void __fastcall sub_14002A9BD(__int64 a1, __int64 a2);
void __fastcall sub_14002A9D4(__int64 a1, __int64 a2);
void sub_14002A9EB();
void __fastcall sub_14002AA04(__int64 a1, __int64 a2);
void sub_14002AA1E();
void __fastcall sub_14002AA37(__int64 a1, __int64 a2);
void sub_14002AA51();
void sub_14002AA6A();
void sub_14002AA83();
void __fastcall sub_14002AA99(__int64 a1, __int64 a2);
void sub_14002AABA();
void __fastcall sub_14002AAD3(__int64 a1, __int64 a2);
_BOOL8 __fastcall sub_14002AB4B(_DWORD **a1);
_BOOL8 __fastcall sub_14002AB80(_DWORD **a1);
// BOOL __stdcall OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// BOOL __stdcall GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// __int64 __fastcall COMCTL32_380(_QWORD, _QWORD, _QWORD, _QWORD); weak
// HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
// BOOL __stdcall DeleteObject(HGDIOBJ ho);
// HFONT __stdcall CreateFontIndirectW(const LOGFONTW *lplf);
// BOOL __stdcall GetStringTypeW(DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// BOOL __stdcall GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// BOOL __stdcall FlushFileBuffers(HANDLE hFile);
// DWORD __stdcall GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);
// BOOL __stdcall IsValidCodePage(UINT CodePage);
// UINT __stdcall GetACP();
// HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);
// int __stdcall MulDiv(int nNumber, int nNumerator, int nDenominator);
// DWORD __stdcall GetLastError();
// BOOL __stdcall SetDllDirectoryW(LPCWSTR lpPathName);
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// BOOLEAN __stdcall CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// LPWSTR __stdcall GetCommandLineW();
// DWORD __stdcall GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// UINT __stdcall GetOEMCP();
// DWORD __stdcall ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
// BOOL __stdcall CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// DWORD __stdcall GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// void __stdcall Sleep(DWORD dwMilliseconds);
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode);
// BOOL __stdcall CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// void __stdcall GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// HMODULE __stdcall LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// BOOL __stdcall SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add);
// BOOL __stdcall FindClose(HANDLE hFindFile);
// HANDLE __stdcall FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// HANDLE __stdcall GetCurrentProcess();
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// DWORD __stdcall FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// BOOL __stdcall GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo);
// LPWCH __stdcall GetEnvironmentStringsW();
// BOOL __stdcall FreeEnvironmentStringsW(LPWCH);
// HANDLE __stdcall GetProcessHeap();
// DWORD __stdcall GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
// SIZE_T __stdcall HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// BOOL __stdcall WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
// BOOL __stdcall SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue);
// void __stdcall RtlUnwindEx(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue, PCONTEXT ContextRecord, PUNWIND_HISTORY_TABLE HistoryTable);
// void __stdcall RtlCaptureContext(PCONTEXT ContextRecord);
// PRUNTIME_FUNCTION __stdcall RtlLookupFunctionEntry(DWORD64 ControlPc, PDWORD64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable);
// PEXCEPTION_ROUTINE __stdcall RtlVirtualUnwind(DWORD HandlerType, DWORD64 ImageBase, DWORD64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PDWORD64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// DWORD __stdcall GetCurrentProcessId();
// DWORD __stdcall GetCurrentThreadId();
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// void __stdcall InitializeSListHead(PSLIST_HEADER ListHead);
// BOOL __stdcall IsDebuggerPresent();
// BOOL __stdcall SetEndOfFile(HANDLE hFile);
// void __stdcall SetLastError(DWORD dwErrCode);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
// DWORD __stdcall TlsAlloc();
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// BOOL __stdcall TlsFree(DWORD dwTlsIndex);
// PVOID __stdcall EncodePointer(PVOID Ptr);
// void __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// PVOID __stdcall RtlPcToFileHeader(PVOID PcValue, PVOID *BaseOfImage);
// LPSTR __stdcall GetCommandLineA();
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// UINT __stdcall GetDriveTypeW(LPCWSTR lpRootPathName);
// BOOL __stdcall GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
// DWORD __stdcall GetFileType(HANDLE hFile);
// BOOL __stdcall PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage);
// BOOL __stdcall SystemTimeToTzSpecificLocalTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime);
// BOOL __stdcall FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// DWORD __stdcall GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
// BOOL __stdcall RemoveDirectoryW(LPCWSTR lpPathName);
// BOOL __stdcall FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// BOOL __stdcall DeleteFileW(LPCWSTR lpFileName);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// BOOL __stdcall GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// BOOL __stdcall ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl);
// BOOL __stdcall SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// UINT __stdcall GetConsoleOutputCP();
// BOOL __stdcall GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// int __stdcall CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2);
// int __stdcall LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// BOOL __stdcall SystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// BOOL __stdcall DestroyIcon(HICON hIcon);
// LONG_PTR __stdcall SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong);
// LONG_PTR __stdcall GetWindowLongPtrW(HWND hWnd, int nIndex);
// BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect);
// BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase);
// int __stdcall ReleaseDC(HWND hWnd, HDC hDC);
// HDC __stdcall GetDC(HWND hWnd);
// int __stdcall DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format);
// int __stdcall GetDialogBaseUnits();
// BOOL __stdcall EndDialog(HWND hDlg, INT_PTR nResult);
// INT_PTR __stdcall DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
// LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

//-------------------------------------------------------------------------
// Data declarations

char byte_14000C055 = ''; // weak
char byte_14000C1FD[3] = { '', '', '' }; // weak
char byte_14000C332 = ''; // weak
char byte_1400153F0 = ''; // weak
char byte_140017935 = ''; // weak
char byte_140017FCA = ''; // weak
char byte_140018812 = ''; // weak
char byte_140018904 = ''; // weak
char byte_14001982A = ''; // weak
char byte_140019946 = ''; // weak
char byte_14001A920 = ''; // weak
char byte_14001AA01 = ''; // weak
char byte_14001E5A0 = ''; // weak
char byte_14001ED24 = ''; // weak
char byte_14001FE2E = ''; // weak
char byte_1400201BC = ''; // weak
char byte_140021944 = ''; // weak
char byte_140021AD6 = ''; // weak
char byte_1400221E0 = ''; // weak
char byte_140022369 = ''; // weak
char byte_140023E98 = ''; // weak
char byte_1400258B9 = ''; // weak
char byte_140025FA1 = ''; // weak
char byte_140026198 = ''; // weak
char byte_14002627C = ''; // weak
char byte_1400264F9 = ''; // weak
char byte_140027105 = ''; // weak
__int64 (__fastcall *_guard_check_icall_fptr[5])() = { &nullsub_1, &nullsub_1, &sub_14002A5B0, &sub_14002A5D0, &sub_14002A5D0 }; // weak
_UNKNOWN unk_14002B458; // weak
_UNKNOWN unk_14002B468; // weak
_UNKNOWN unk_14002B470; // weak
_UNKNOWN unk_14002B4B0; // weak
_UNKNOWN unk_14002B4B8; // weak
_UNKNOWN unk_14002B4E0; // weak
_UNKNOWN unk_14002B4E8; // weak
_UNKNOWN unk_14002B4F0; // weak
_UNKNOWN unk_14002BDF1; // weak
char aVerbose[8] = "verbose"; // weak
__int16 word_14002DBF0 = 92; // weak
int dword_14002DE60[512] =
{
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918000,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117,
  0,
  2519730039,
  744558318,
  3125873049,
  432303367,
  2415159920,
  900031465,
  2744476830,
  847829774,
  2763578489,
  518641120,
  2295976599,
  726447625,
  3179065726,
  120436967,
  2434645904,
  1678817053,
  4062228586,
  1215412723,
  3728850564,
  2111101466,
  3957644653,
  1370871028,
  3347436419,
  1452829715,
  3232263012,
  2063164157,
  3972621706,
  1331429652,
  3647735395,
  1664946170,
  4111272077,
  3357568571,
  1578133836,
  3829489877,
  1920034722,
  3521381180,
  1205077067,
  4253355474,
  1807026853,
  4205360437,
  1821946434,
  3603545051,
  1090108588,
  3815561266,
  1969020741,
  3473790684,
  1497223595,
  2888882470,
  973135441,
  2152847304,
  375509183,
  3052712993,
  600093526,
  2576726735,
  262520248,
  2662859304,
  143131999,
  3000569030,
  619252657,
  2273079087,
  290220120,
  2870829505,
  1026385590,
  2420235382,
  108124929,
  3156267672,
  705746415,
  2307240305,
  532002310,
  2783231903,
  869578984,
  2731083640,
  888733711,
  2393377174,
  412618465,
  3138218623,
  759000328,
  2540463249,
  22832102,
  4098976619,
  1650551836,
  3627050373,
  1308648178,
  3985966700,
  2074411291,
  3253995650,
  1472466933,
  3336155237,
  1357494034,
  3937975947,
  2089335292,
  3743276386,
  1227741717,
  4085044108,
  1699534075,
  1482797645,
  3461461306,
  1946205347,
  3794844628,
  1101389642,
  3616921661,
  1841615268,
  4227126995,
  1793681731,
  4242107956,
  1183344557,
  3501744346,
  1932330052,
  3843883827,
  1598818986,
  3380350429,
  1014039888,
  2856387111,
  269487038,
  2250247369,
  632645719,
  3011866400,
  164914873,
  2682544590,
  251256414,
  2563365161,
  580440240,
  3030964167,
  389919577,
  2165158958,
  995933623,
  2909584064,
  545503469,
  3065233306,
  216184323,
  2597499252,
  961009130,
  2943865501,
  354867972,
  2199313523,
  302736355,
  2218484884,
  1047162125,
  2824497786,
  198119140,
  2650737043,
  665714698,
  2979923837,
  1150488560,
  3533899911,
  1760690462,
  4274128489,
  1566008055,
  3412551040,
  1899392025,
  3875957614,
  1981535486,
  3760968585,
  1518000656,
  3427458407,
  1876933113,
  4193238670,
  1136572183,
  3582898272,
  3903051478,
  2123616673,
  3301103672,
  1391648591,
  4050107345,
  1733803174,
  3708204351,
  1261875784,
  3660254680,
  1276840623,
  4132045622,
  1618609217,
  3287245023,
  1440704424,
  4019088945,
  2042521926,
  2360566219,
  444819132,
  2698145573,
  920807506,
  2507607244,
  54987707,
  3105227298,
  791020885,
  3191585477,
  671858098,
  2455417899,
  74101596,
  2818561986,
  835702965,
  2342443308,
  497999451,
  2965529755,
  653419500,
  2627955317,
  177433858,
  2835745180,
  1060507371,
  2238121842,
  324468741,
  2185936789,
  343587042,
  2922099067,
  941340172,
  2609828498,
  230610405,
  3085950076,
  568318731,
  3570586502,
  1122161905,
  4172537192,
  1854134815,
  3440819841,
  1529264630,
  3782717551,
  2001188632,
  3864660104,
  1885999103,
  3392865894,
  1544225041,
  4288570767,
  1773036280,
  3556731745,
  1171221526,
  2028079776,
  4006743511,
  1417872462,
  3266511673,
  1629906855,
  4145438928,
  1296525641,
  3682037310,
  1248514478,
  3696940761,
  1712054080,
  4030453815,
  1403960489,
  3315514334,
  2144318023,
  3925849392,
  485670333,
  2328017610,
  814986067,
  2795746340,
  87478458,
  2466699213,
  693624404,
  3211254051,
  779773619,
  3091882436,
  35350621,
  2485874474,
  935201716,
  2710441155,
  467600730,
  2381251117
}; // idb
int dword_14002E660[256] =
{
  0,
  1701264198,
  3402528396,
  2947108298,
  1324215129,
  730517535,
  2216926677,
  3779372691,
  2648430258,
  4173131252,
  1461035070,
  846371704,
  3543547371,
  3058763437,
  435702631,
  2090823713,
  3771116325,
  2241957987,
  705224105,
  1332733679,
  2922070140,
  3410787130,
  1692743408,
  25300406,
  2099084695,
  410666705,
  3084061467,
  3535024221,
  871405262,
  1452780936,
  4181647426,
  2623134468,
  452743179,
  2140891981,
  3492947591,
  3042254273,
  1410448210,
  829849620,
  2665467358,
  4223202968,
  2267514553,
  3795893759,
  1307177013,
  680446835,
  3385486816,
  2897041062,
  50600812,
  1717772330,
  4198169390,
  2673721448,
  821333410,
  1435743972,
  3033993335,
  3517983537,
  2115593979,
  461266365,
  1742810524,
  42342106,
  2905561872,
  3360186454,
  688703173,
  1282145667,
  3821187145,
  2258995983,
  905486358,
  1352637264,
  4281783962,
  2589060572,
  2064993103,
  510816265,
  2983935427,
  3569092229,
  2820896420,
  3443805666,
  1659699240,
  126499694,
  3872300541,
  2208933563,
  738257777,
  1231540279,
  3577613107,
  2958635125,
  535854527,
  2056734457,
  2614354026,
  4273265452,
  1360893670,
  880455072,
  1223024001,
  763553479,
  2183899917,
  3880554571,
  101201624,
  1668222366,
  3435544660,
  2845932306,
  788852765,
  1248054107,
  3855255185,
  2158869975,
  1642666820,
  76423170,
  2871487944,
  3460322958,
  3000968879,
  3619167721,
  2014400547,
  494300005,
  4231187958,
  2572547760,
  922532730,
  1402699836,
  3485621048,
  2862964862,
  84684212,
  1617630962,
  2167386209,
  3829959463,
  1273087725,
  780598699,
  1377406346,
  931051212,
  2564291334,
  4256219200,
  485779155,
  2039700885,
  3594129503,
  3009227545,
  1810972716,
  244743018,
  2705274528,
  3294105062,
  622635893,
  1081839667,
  4023574009,
  2327176895,
  4129986206,
  2471341528,
  1021632530,
  1501813588,
  3100081607,
  3718268545,
  1913195339,
  393097229,
  2335697673,
  3998273615,
  1106877829,
  614377155,
  3319398480,
  2696755990,
  252999388,
  1785941402,
  384581051,
  1938491133,
  3693234999,
  3108335729,
  1476515554,
  1030155684,
  2463080558,
  4155022120,
  1896681511,
  342502241,
  3150145195,
  3735313901,
  1071709054,
  1518846008,
  4113468914,
  2420750004,
  3973498517,
  2310143443,
  639152153,
  1132432223,
  2721787340,
  3344701066,
  1760910144,
  227696646,
  2446048002,
  4104945732,
  1527106958,
  1046673096,
  3743830107,
  3124849437,
  367535831,
  1888427409,
  202403248,
  1769428726,
  3336444732,
  2746818682,
  1123911401,
  664452527,
  2285105253,
  3981757219,
  1577705530,
  997120892,
  2496108214,
  4053839344,
  283380579,
  1971531813,
  3660217839,
  3209512617,
  3285333640,
  2796883406,
  152846340,
  1820031810,
  2369773009,
  3898140311,
  1207020381,
  580292635,
  3201256223,
  3685249113,
  1946238355,
  291899093,
  4028801094,
  2504366848,
  988600010,
  1603005836,
  588553645,
  1181984491,
  3923438369,
  2361249895,
  1845065460,
  144592306,
  2805399672,
  3260037950,
  1156952113,
  563252087,
  2386282173,
  3948740091,
  169368424,
  1870618670,
  3235261924,
  2779846306,
  3643696771,
  3158924741,
  333451279,
  1988569929,
  2546175450,
  4070880924,
  1561197398,
  946520080,
  2754812692,
  3243515986,
  1862102424,
  194664158,
  3940479053,
  2411318027,
  537953985,
  1165475207,
  971558310,
  1552938720,
  4079401770,
  2520875116,
  1996826367,
  308420025,
  3184218227,
  3635178293
}; // idb
int dword_14002EA60[256] =
{
  0,
  3621945432,
  1957955313,
  2740356777,
  3915910626,
  1049267642,
  2648443667,
  1245612875,
  161553797,
  3728973277,
  2098535284,
  2868353836,
  3771273319,
  925601855,
  2491225750,
  1134532302,
  323107594,
  3298868050,
  1744190971,
  2954149283,
  4197070568,
  768128688,
  2392731673,
  1501343809,
  451094159,
  3439437527,
  1851203710,
  3115687974,
  4085984109,
  610904885,
  2269064604,
  1356705220,
  646215188,
  4050056780,
  1378906341,
  2245193917,
  3488381942,
  403635118,
  3143138567,
  1824193887,
  790981521,
  4173851593,
  1536257376,
  2356407608,
  3326961267,
  296740395,
  3002687618,
  1696325850,
  902188318,
  3794062662,
  1098009583,
  2526071735,
  3702407420,
  189579428,
  2820294157,
  2147010133,
  1013403803,
  3951415491,
  1221809770,
  2670843442,
  3574553977,
  49143073,
  2713410440,
  1985600464,
  1292430376,
  2599054448,
  968682201,
  3999165057,
  2757812682,
  1937924498,
  3503613755,
  121005923,
  1151988141,
  2471195125,
  807270236,
  3892279044,
  2915171407,
  2049145879,
  3648387774,
  244808422,
  1581963042,
  2309511034,
  721342931,
  4246491531,
  3072514752,
  1623218840,
  3281443889,
  343170153,
  1475070631,
  2148092671,
  593480790,
  4106046478,
  3196307269,
  1767982877,
  3392651700,
  500515308,
  1804376636,
  3161332324,
  523803853,
  3369737365,
  2196019166,
  1426462598,
  4132475183,
  565318007,
  1647151033,
  3050244065,
  379158856,
  3246063888,
  2336590427,
  1554450947,
  4294020266,
  672337138,
  2026807606,
  2938904942,
  209364935,
  3684181919,
  2443619540,
  1178872972,
  3843205669,
  854600317,
  1903148211,
  2794274027,
  98286146,
  3526965786,
  2550640977,
  1340420361,
  3971200928,
  995178488,
  2584860752,
  1307793416,
  4003847841,
  960978681,
  1937364402,
  2761643498,
  130929475,
  3492762395,
  2477835733,
  1146242445,
  3875848996,
  820396924,
  2061027383,
  2906277999,
  242011846,
  3649982110,
  2303976282,
  1588683522,
  4259833259,
  704996851,
  1614540472,
  3084480224,
  344975433,
  3278727185,
  2163408607,
  1460698759,
  4098291758,
  597981302,
  1771762493,
  3195564901,
  489616844,
  3402397076,
  3163926084,
  1802972700,
  3357649077,
  532883693,
  1442685862,
  2183078910,
  558474583,
  4138411279,
  3040129985,
  1658205081,
  3246437680,
  375534952,
  1549581859,
  2344500859,
  686340306,
  4278859914,
  2950141262,
  2016744726,
  3680736191,
  209785831,
  1186961580,
  2438797556,
  839622237,
  3857260037,
  2792786123,
  1905526931,
  3535965754,
  85986914,
  1327400233,
  2566653297,
  1001030616,
  3964142464,
  3608753272,
  16495648,
  2746036873,
  1951380177,
  1047607706,
  3918772674,
  1254440811,
  2636627763,
  3736611325,
  156936613,
  2852925196,
  2112794452,
  936387615,
  3761415239,
  1130636014,
  2491851446,
  3294302066,
  330927914,
  2968455555,
  1728940507,
  758317712,
  4208034504,
  1502020705,
  2389017657,
  3455718135,
  437818031,
  3108901894,
  1856803934,
  613555989,
  4084244301,
  1344674276,
  2277808572,
  4053615212,
  645906996,
  2234074269,
  1389085893,
  418729870,
  3474444246,
  1816217983,
  3148073255,
  4164706281,
  803135409,
  2357745944,
  1533729088,
  290738699,
  3333870163,
  1709200634,
  2986529954,
  3806296422,
  893253950,
  2523627415,
  1099562959,
  196572292,
  3696620764,
  2130932341,
  2833379885,
  3950929123,
  1016915131,
  2680840722,
  1210638922,
  35023105,
  3589597529,
  1990356976,
  2705387432
}; // idb
int dword_14002EE60[256] =
{
  0,
  4015175393,
  97807235,
  3934707042,
  195614470,
  3841614311,
  243055749,
  3777890916,
  391228940,
  4160952557,
  310756751,
  4258755438,
  486111498,
  4088123371,
  422384265,
  4135560296,
  782457880,
  3253857017,
  729233307,
  3290792314,
  621513502,
  3394846207,
  551542941,
  3482146428,
  972222996,
  3600827637,
  1009162647,
  3547606902,
  844768530,
  3708326899,
  932073105,
  3638360176,
  1564915760,
  2987658961,
  1486017459,
  3082839378,
  1458466614,
  3116161495,
  1396311221,
  3160978004,
  1243027004,
  2772803805,
  1338211775,
  2693909342,
  1103085882,
  2934798299,
  1147906745,
  2872646744,
  1944445992,
  2629259977,
  1982959531,
  2573416778,
  2018325294,
  2535425487,
  2107201709,
  2462838348,
  1689537060,
  2347171013,
  1633690023,
  2385680198,
  1864146210,
  2152606659,
  1791555233,
  2241478720,
  3129831520,
  1440728705,
  3210288099,
  1342942466,
  2972034918,
  1584861575,
  3035745509,
  1537440260,
  2916933228,
  1116629133,
  2819143151,
  1197081358,
  2792622442,
  1227276171,
  2745197289,
  1290982408,
  2486054008,
  2071763609,
  2449098747,
  2125000986,
  2676423550,
  1892961695,
  2589102333,
  1962944028,
  2206171764,
  1814901909,
  2259413495,
  1777950486,
  2295813490,
  1736827795,
  2365800177,
  1649510416,
  3888891984,
  144277169,
  3793724371,
  223155506,
  3965919062,
  53586359,
  3921114325,
  115720756,
  4036650588,
  533254333,
  4115533279,
  438090558,
  4214403418,
  341837755,
  4276542169,
  297036856,
  3379074120,
  641344169,
  3434938315,
  602818858,
  3267380046,
  764605871,
  3339987149,
  675716652,
  3728292420,
  829131941,
  3689763271,
  884991782,
  3583110466,
  985881507,
  3494217409,
  1058484256,
  2926306945,
  1094275168,
  2881457410,
  1156398051,
  2781032839,
  1251051366,
  2685884932,
  1329982693,
  3107604621,
  1449721452,
  3169723150,
  1404868079,
  2995953547,
  1572874602,
  3074880520,
  1477722857,
  2160638617,
  1872366712,
  2233258266,
  1783523323,
  2338352543,
  1681054590,
  2394162716,
  1642508541,
  2543391893,
  2026611316,
  2454552342,
  2099235319,
  2620507027,
  1935897970,
  2581964816,
  1991712497,
  4079836849,
  478144592,
  4143527218,
  430670803,
  4169501111,
  399982422,
  4250001972,
  302208213,
  3833393341,
  187582044,
  3785923390,
  251276767,
  4023658427,
  8819034,
  3925888056,
  89324249,
  3717071529,
  853324872,
  3629803818,
  923328459,
  3592869295,
  963928910,
  3555900972,
  1017120973,
  3403656357,
  630004292,
  3473655590,
  542732743,
  3245833123,
  774229314,
  3299020832,
  737257153,
  350656225,
  4222885888,
  288554338,
  4267723651,
  525222375,
  4028430086,
  446311012,
  4123565189,
  62339309,
  3974467084,
  107172718,
  3912361359,
  136310763,
  3880605962,
  231441512,
  3801690761,
  977652473,
  3575086104,
  1066508666,
  3502446491,
  837623295,
  3737103134,
  876181116,
  3681271965,
  756311285,
  3259421204,
  683675510,
  3348281751,
  649901043,
  3387819282,
  594073712,
  3426381457,
  1235234513,
  2800916528,
  1282688338,
  2737238963,
  1107884503,
  2908376886,
  1205637716,
  2827887797,
  1592885469,
  2980263484,
  1529211742,
  3027721663,
  1431918555,
  3121340730,
  1351433304,
  3219098297,
  1728279241,
  2287060008,
  1658263882,
  2374348715,
  1823188431,
  2214138670,
  1769983564,
  2251126957,
  1884478661,
  2667604516,
  1971763014,
  2597585319,
  2079984579,
  2494086434,
  2116968512,
  2440877729
}; // idb
int dword_14002F260[1312] =
{
  0,
  2275855171,
  3560739015,
  1402624900,
  1929914319,
  4105104524,
  2805249800,
  546470987,
  3859828638,
  1639351517,
  841801561,
  3045725210,
  2501404753,
  314483474,
  1092941974,
  3330421717,
  391223677,
  2432127550,
  3278703034,
  1154204409,
  1683603122,
  3825169905,
  2959421045,
  935585078,
  4047623907,
  1994857888,
  628966948,
  2732297575,
  2185883948,
  99564143,
  1450533355,
  3520309928,
  782447354,
  2835741113,
  4204765757,
  2100914558,
  1571493173,
  3658342006,
  2308408818,
  238112433,
  3367206244,
  1326822951,
  479194531,
  2603165408,
  3149617835,
  1008570856,
  1871170156,
  3894477103,
  972204935,
  3193200836,
  3989715776,
  1785262083,
  1257933896,
  3445376779,
  2663783567,
  425777100,
  3756188697,
  1480863578,
  199128286,
  2356723613,
  2901066710,
  726403221,
  2027311889,
  4285569106,
  1564894708,
  3672157879,
  2306536755,
  249314928,
  776880699,
  2850589048,
  4201829116,
  2111052223,
  3142986346,
  1022419241,
  1869265581,
  3905712622,
  3361607077,
  1341703910,
  476224866,
  2613335585,
  1243085961,
  3450943434,
  2653645902,
  428713741,
  958389062,
  3199799301,
  3978513281,
  1787134146,
  2886185751,
  732002388,
  2017141712,
  4288538771,
  3742340312,
  1487495067,
  187892767,
  2358628188,
  1944409870,
  4098071629,
  2816067529,
  545197194,
  15560897,
  2269887362,
  3570524166,
  1400318789,
  2515867792,
  307483603,
  1103726679,
  3329180436,
  3875356511,
  1633416220,
  851554200,
  3043452123,
  1689570931,
  3809609008,
  2961727156,
  925799927,
  398256572,
  2417631999,
  3279976827,
  1143386680,
  2191819245,
  84036270,
  1452806442,
  3510557289,
  4054623778,
  1980394849,
  630208229,
  2721512870,
  3129789416,
  1026162859,
  1857051439,
  3910570092,
  3380931623,
  1310861156,
  498629856,
  2585704355,
  1553761398,
  3678031669,
  2292192433,
  252108786,
  798270393,
  2821875962,
  4222104446,
  2081355837,
  2916962965,
  712743382,
  2044838482,
  4266068241,
  3738531162,
  1500757529,
  183100829,
  2370776798,
  1271733515,
  3429619272,
  2683407820,
  408372879,
  952449732,
  3210998151,
  3975784963,
  1801412928,
  2486171922,
  327758417,
  1075014101,
  3350569622,
  3878149853,
  1619072414,
  857427482,
  3032319321,
  1916778124,
  4120477135,
  2785224267,
  564522248,
  20418883,
  2257672704,
  3574268292,
  1387121351,
  2206097519,
  81308460,
  1464004776,
  3504618475,
  4034283424,
  2010156259,
  608884583,
  2750159908,
  1701720049,
  3804816562,
  2974990134,
  921990261,
  375785534,
  2445329277,
  3260717305,
  1174164410,
  3888819740,
  1617716575,
  871775963,
  3025204632,
  2495777235,
  325337744,
  1090394388,
  3344486999,
  31121794,
  2256284353,
  3588649285,
  1379973638,
  1926415949,
  4118023438,
  2800637578,
  558407113,
  4036704097,
  2000550946,
  614967206,
  2734779621,
  2207453358,
  70638573,
  1471119465,
  3490269994,
  378239231,
  2435691452,
  3266832440,
  1158751099,
  1703108400,
  3794113651,
  2982137847,
  907609268,
  3379141862,
  1322211237,
  492112929,
  2599667554,
  3126967081,
  1036480618,
  1851599854,
  3925598381,
  796513144,
  2833193019,
  4215620543,
  2095286524,
  1550972087,
  3688316916,
  2286773360,
  267104051,
  3728213403,
  1503579864,
  168072540,
  2376228383,
  2905612884,
  714533143,
  2030875283,
  4272585168,
  942164485,
  3213787462,
  3960789698,
  1806832001,
  1260416458,
  3431376521,
  2669477133,
  414856782,
  0,
  1137419911,
  3348118740,
  2220595795,
  3475441779,
  2364321524,
  146224295,
  1266455072,
  2655981798,
  3716462177,
  1507798066,
  437553845,
  1365776533,
  312720914,
  2532844609,
  3576922822,
  2107199767,
  1045624720,
  3121180099,
  4190292804,
  2998819172,
  4051042275,
  1965974960,
  921027383,
  3822469617,
  2686314358,
  608599333,
  1737350050,
  754010498,
  1866133253,
  3949032790,
  2829767633,
  4197622574,
  3120104873,
  1034067962,
  2120825213,
  890612573,
  1994264026,
  4068841353,
  2974691598,
  1685959624,
  666244431,
  2750254876,
  3760597403,
  2874850235,
  3901824316,
  1825212271,
  788603368,
  2276192825,
  3294647486,
  1077661421,
  66087018,
  1217198666,
  189226189,
  2401027742,
  3436666905,
  434430687,
  1513047128,
  3732200971,
  2646571148,
  3603163820,
  2500348971,
  290707064,
  1385722111,
  4100277853,
  3081691354,
  871725705,
  1883167758,
  994201134,
  2022303913,
  4241650426,
  3206141053,
  1781159611,
  702672956,
  2914675311,
  4000435432,
  2769116872,
  3871799375,
  1654481436,
  559334555,
  2314999626,
  3392647629,
  1315711902,
  229084441,
  1188765497,
  84982206,
  2169185261,
  3263202666,
  397608876,
  1417191723,
  3491969912,
  2481495551,
  3633582047,
  2606737752,
  520368907,
  1557108108,
  240641395,
  1302086644,
  3385317799,
  2316074784,
  3245403392,
  2193312647,
  115397076,
  1160476499,
  2417554837,
  3553841938,
  1468582209,
  339963846,
  1598029286,
  485776225,
  2561655090,
  3680790453,
  1942926436,
  805638883,
  3026094256,
  4153749047,
  3169434647,
  4280425104,
  2071560387,
  951199300,
  3984696450,
  2924085765,
  705796182,
  1775910609,
  581348593,
  1634536054,
  3845558309,
  2801612450,
  3905653946,
  2868914749,
  794538094,
  1821382377,
  669811913,
  1680286286,
  3766269981,
  2746687130,
  1988402268,
  894384859,
  2970919048,
  4074702351,
  3114505263,
  4201132712,
  2117314811,
  1039666812,
  2505235885,
  3600382762,
  1388503417,
  285820926,
  1517671902,
  431911769,
  2649090314,
  3727576973,
  186502475,
  1222011852,
  3431854495,
  2403751704,
  3292185912,
  2280743871,
  61536748,
  1080123243,
  318320532,
  1362266387,
  3580433216,
  2527245767,
  3722323943,
  2652209504,
  441326387,
  1501937076,
  2360754034,
  3481115125,
  1260782502,
  149792033,
  1133590273,
  5935494,
  2214661077,
  3351948626,
  1868594819,
  749459460,
  2834317911,
  3946570960,
  2689038064,
  3817656439,
  1742162468,
  605875363,
  4046417509,
  3001338082,
  918508209,
  1970598966,
  1040737814,
  2109980817,
  4187511490,
  3126066245,
  481217255,
  1600482400,
  3678336563,
  2566213812,
  3549020820,
  2420270099,
  337247808,
  1473403079,
  2195839489,
  3240787078,
  1165092565,
  112869458,
  1304875634,
  235762933,
  2320952998,
  3382528033,
  1631034352,
  586956151,
  2796005156,
  3849060771,
  2920321923,
  3990566148,
  1770041175,
  709560784,
  4286090006,
  3165859217,
  954775490,
  2065895749,
  811565925,
  1939088866,
  4157587377,
  3020167478,
  3869010377,
  2773995342,
  554456349,
  1657271194,
  700146106,
  1785775933,
  3995819374,
  2917202921,
  2027125039,
  991485864,
  3208857083,
  4236829564,
  3086250332,
  4097824731,
  1885621640,
  867166991,
  2600810718,
  3637419609,
  1553269770,
  526295693,
  1411526829,
  401184298,
  2477919353,
  3497634558,
  88746040,
  1182895807,
  3269072108,
  2165420651,
  3396149323,
  2309392076,
  234691743,
  1312209432,
  0,
  3786822383,
  2204881925,
  1658685162,
  114796555,
  3881958116,
  2243722254,
  1678388961,
  212750615,
  3977774072,
  2412086546,
  1853085693,
  175765788,
  3956255731,
  2299669785,
  1755611126,
  408724270,
  4192924097,
  2604103467,
  2055284164,
  512428837,
  4282210762,
  2648760096,
  2086047183,
  351466041,
  4114915542,
  2543396412,
  1982821587,
  304437810,
  4086499549,
  2437844535,
  1895357656,
  817383005,
  3507360946,
  3016987224,
  1382400183,
  913305174,
  3621371065,
  3036953171,
  1420978364,
  1008080714,
  3718268325,
  3212690255,
  1590399392,
  985775937,
  3682069934,
  3114953540,
  1478244779,
  686089587,
  3377641372,
  2878288246,
  1245275033,
  775114104,
  3481608087,
  2908264829,
  1290718098,
  608875620,
  3321685643,
  2803982433,
  1184313998,
  580721775,
  3274395264,
  2717304938,
  1077975685,
  1617989050,
  2177294165,
  3810220479,
  44895056,
  1722230193,
  2266068830,
  3855413684,
  75146075,
  1826544813,
  2372439618,
  4021618856,
  235100743,
  1779004582,
  2344560201,
  3915554979,
  148173388,
  2016161428,
  2577038459,
  4215798417,
  452044926,
  2130413215,
  2672678000,
  4254093978,
  472252533,
  1954709379,
  2503224684,
  4159286150,
  375388521,
  1918228360,
  2481161575,
  4047373197,
  277369186,
  1355336679,
  2977863944,
  3550683106,
  840256781,
  1444897772,
  3081318659,
  3581196265,
  885187846,
  1550228208,
  3184576543,
  3742191349,
  1052449818,
  1521562363,
  3137822740,
  3655001854,
  946648081,
  1217685705,
  2837592614,
  3422534860,
  709488163,
  1313063106,
  2952106541,
  3441956039,
  748570152,
  1144666590,
  2777443121,
  3344035291,
  652721972,
  1122865621,
  2740699962,
  3246802384,
  540022591,
  2179361710,
  1615870273,
  42844075,
  3812355396,
  2268185509,
  1720160586,
  73013152,
  3857466703,
  2370321081,
  1828612182,
  237235900,
  4019567699,
  2342490802,
  1781121117,
  150226615,
  3913421912,
  2579155072,
  2014091887,
  449911941,
  4217851498,
  2674745483,
  2128294500,
  470201486,
  4256228961,
  2501155223,
  1956825976,
  377441682,
  4157153149,
  2479042972,
  1920295795,
  279504281,
  4045322102,
  2975739379,
  1357414172,
  842398198,
  3548621593,
  3079243256,
  1447024407,
  887247357,
  3579052818,
  3186654436,
  1548103179,
  1050388705,
  3744332302,
  3139949807,
  1519486464,
  944505066,
  3657060869,
  2835517149,
  1219812402,
  711547608,
  3420391479,
  2949981910,
  1315140665,
  750711507,
  3439894588,
  2779570122,
  1142590757,
  650578895,
  3346094368,
  2742777793,
  1120740654,
  537961412,
  3248943403,
  3784762900,
  2143483,
  1660760593,
  2202755326,
  3879816735,
  116858096,
  1680513562,
  2241644789,
  3979917059,
  210691564,
  1850958598,
  2414162409,
  3958316808,
  173624807,
  1753533197,
  2301794786,
  4190782778,
  410785749,
  2057408831,
  2602025936,
  4280151345,
  514572254,
  2088122676,
  2646633435,
  4116976685,
  349324994,
  1980743720,
  2545521351,
  4088642598,
  302378697,
  1893230627,
  2439920332,
  3509493833,
  815329958,
  1380283468,
  3019056803,
  3623422018,
  911170221,
  1418910791,
  3039071912,
  3716215134,
  1010213809,
  1592468827,
  3210573748,
  3679934805,
  987827130,
  1480363344,
  3112886207,
  3379692391,
  683954568,
  1243207522,
  2880406925,
  3483741036,
  773060995,
  1288601449,
  2910334342,
  3319550576,
  610926751,
  1186432629,
  2801915034,
  3272342139,
  582854804,
  1080045182,
  2715188369,
  0,
  1484841687,
  4043748468,
  2844153507,
  3792529641,
  3129838142,
  319544477,
  1267416650,
  2233311497,
  3718071262,
  1947932029,
  748418986,
  1729153504,
  1066412855,
  2518056340,
  3465977667,
  171655699,
  1388028100,
  4215141991,
  2747077808,
  3895864058,
  2964768813,
  422616718,
  1102085209,
  2401690394,
  3617980877,
  2116048750,
  648066489,
  1831570419,
  900426020,
  2620211079,
  3299728720,
  343311398,
  1291216625,
  3849334866,
  3186676357,
  4135316687,
  2935688728,
  125655227,
  1610463852,
  2439718191,
  3387672568,
  1617793371,
  955085708,
  1936084422,
  736538385,
  2187393458,
  3672120165,
  508413493,
  1187849442,
  4014699073,
  3083571350,
  4232097500,
  2764065803,
  222698152,
  1439103103,
  2605737788,
  3285222891,
  1784075080,
  852898207,
  2036142037,
  568192258,
  2287713185,
  3504036214,
  686557261,
  1886186138,
  3656039481,
  2171231982,
  3403767972,
  2455863923,
  1005049040,
  1667708423,
  2918295876,
  4117842835,
  1559698736,
  74973159,
  1341964717,
  394011514,
  3204085209,
  3866793742,
  584534622,
  2052565129,
  3553754666,
  2337348861,
  3235521207,
  2556084320,
  836540099,
  1767666708,
  2815093591,
  4283042176,
  1456234275,
  239910388,
  1170703294,
  491217257,
  3032561610,
  3963737373,
  1016761451,
  1679453884,
  3449567263,
  2501696200,
  3734496386,
  2249655893,
  798052598,
  1997648417,
  3112643938,
  3775385525,
  1216452886,
  268532673,
  1535788427,
  51029852,
  2861363711,
  4060877608,
  916573816,
  1847667887,
  3349641740,
  2670172379,
  3568084625,
  2351711302,
  631902949,
  2099966002,
  3015470961,
  3946614182,
  1119542021,
  440023506,
  1370556312,
  154264911,
  2696393708,
  4164374843,
  1356337562,
  140047181,
  2715723246,
  4183705401,
  3000334707,
  3931478948,
  1137954055,
  458436560,
  3586502803,
  2370130500,
  616760551,
  2084824624,
  935909498,
  1867004589,
  3335416846,
  2655948505,
  1524847497,
  40087902,
  2883971069,
  4083483946,
  3102620512,
  3765361079,
  1239977748,
  292056515,
  3758027392,
  2273185879,
  788023028,
  1987617827,
  1039374953,
  1702066366,
  3438620189,
  2490748106,
  1152292284,
  472807275,
  3047694792,
  3978871583,
  2795765077,
  4263714690,
  1470449953,
  254127094,
  3249747125,
  2570311266,
  817201345,
  1748328982,
  599678044,
  2067709579,
  3535333416,
  2318928639,
  1318442927,
  370488696,
  3214107611,
  3876815116,
  2895691590,
  4095237521,
  1570638642,
  85912037,
  3414718118,
  2466813041,
  982434514,
  1645092869,
  696589903,
  1896217752,
  3632507451,
  2147698924,
  2016680407,
  548731648,
  2301799843,
  3518123892,
  2587455806,
  3266941929,
  1799341386,
  868165533,
  4247369950,
  2779339273,
  204410026,
  1420815997,
  522506295,
  1201943264,
  3995231299,
  3064104596,
  1913609156,
  714062099,
  2198466480,
  3683192167,
  2416063277,
  3364016634,
  1627686745,
  964978062,
  4145216205,
  2945587226,
  101994169,
  1586801774,
  354390564,
  1302294771,
  3826853456,
  3164193927,
  1816305137,
  885161766,
  2638489989,
  3318008658,
  2387604760,
  3603896271,
  2135507308,
  667526075,
  3915332856,
  2984238639,
  408520844,
  1087990363,
  189944849,
  1406318278,
  4199866469,
  2731803314,
  1719263202,
  1056521525,
  2541710230,
  3489630529,
  2222241547,
  3707000284,
  1970406271,
  770892200,
  3815014123,
  3152321596,
  308464287,
  1256335432,
  23664130,
  1508504789,
  4033847926,
  2834251937,
  0,
  1178298213,
  2356596426,
  3394087343,
  1508633934,
  533760555,
  3583845252,
  2477147361,
  3000425373,
  4109221112,
  1050678615,
  2023453234,
  3946657491,
  2902872502,
  1733031961,
  561028988,
  632014560,
  1670422917,
  2849835050,
  4024856399,
  2084580270,
  981159115,
  4030129508,
  3054338561,
  2541559165,
  3511056920,
  453759927,
  1563473106,
  3465998387,
  2293077846,
  1121992441,
  81484188,
  189856794,
  1298897791,
  2267427536,
  3239925173,
  1387991380,
  343963185,
  3738034078,
  2566306043,
  3112576903,
  4290592994,
  904980813,
  1942720040,
  3765291721,
  2790698412,
  1813709827,
  706765670,
  788216570,
  1757437343,
  2727212080,
  3837170517,
  1997592500,
  824946897,
  4217772414,
  3177020955,
  2620252519,
  3658909186,
  274411437,
  1449150664,
  3318090793,
  2214423372,
  1236320995,
  260810118,
  379648053,
  1352376144,
  2597730047,
  3706540442,
  1330320763,
  158364190,
  3275611057,
  2231811284,
  2759205800,
  3796714701,
  671149410,
  1849395719,
  4254977766,
  3148261763,
  1911226412,
  936404809,
  856374997,
  1966102960,
  3212701727,
  4182153082,
  1793119131,
  752596222,
  3868597585,
  2695723572,
  2178803016,
  3353772589,
  229321602,
  1267748071,
  3627419654,
  2651680611,
  1413531340,
  310092201,
  502268975,
  1540055882,
  2441530085,
  3619532160,
  1142679905,
  35687940,
  3362596779,
  2388017358,
  2938560434,
  3911039191,
  592449912,
  1701541405,
  4140643068,
  2968933785,
  2059140150,
  1015061331,
  945537743,
  2120263082,
  3022851077,
  4061555552,
  1638936449,
  663439588,
  3989233995,
  2885518894,
  2324502866,
  3434511927,
  117168024,
  1086370045,
  3546739740,
  2505937785,
  1594899158,
  422272435,
  742453611,
  1786484238,
  2687909793,
  3859634372,
  1974148133,
  865106752,
  4192064239,
  3219568010,
  2660641526,
  3635236243,
  316728380,
  1423672153,
  3346909112,
  2168889565,
  1259014514,
  221277719,
  166410123,
  1339052270,
  2241722689,
  3282476580,
  1342233285,
  373013920,
  3698725903,
  2588767082,
  3141397526,
  4245064563,
  927671004,
  1903183289,
  3805675864,
  2767021629,
  1856032658,
  681289975,
  655363441,
  1630235156,
  2875638715,
  3982337246,
  2130436159,
  952141658,
  4069338869,
  3031845264,
  2512836332,
  3556618633,
  430970918,
  1602977603,
  3425516450,
  2316721351,
  1079768424,
  106992141,
  45861777,
  1149283572,
  2395800923,
  3371590206,
  1531979487,
  493568442,
  3609651221,
  2434633584,
  2959937548,
  4132861801,
  1008459462,
  2048965027,
  3917937986,
  2948438567,
  1710240648,
  600528109,
  987760990,
  2094755387,
  3063334804,
  4037910769,
  1661723664,
  623936373,
  4017957594,
  2839956927,
  2285294275,
  3457004966,
  71310345,
  1115388780,
  3520937869,
  2548455656,
  1571549511,
  462460450,
  525062078,
  1500555483,
  2470248820,
  3573966353,
  1184899824,
  10175893,
  3403082810,
  2364377951,
  2912752675,
  3953554246,
  569105129,
  1741733260,
  4101437805,
  2991431176,
  2013280167,
  1044074690,
  833680708,
  2005635617,
  3183885198,
  4227685611,
  1750800394,
  778076015,
  3828209344,
  2719396261,
  2204511961,
  3311225276,
  252764179,
  1227589494,
  3666723735,
  2629215474,
  1459293533,
  281045560,
  337327012,
  1377850561,
  2557345134,
  3730217483,
  1307631338,
  197900687,
  3246788640,
  2277340997,
  2798512185,
  3774254940,
  716908275,
  1820344726,
  4280681847,
  3105710610,
  1934674877,
  896249048,
  1073741824,
  536870912,
  134217728,
  8388608,
  32768,
  3988292384,
  2984685714,
  2691310871,
  3982654894,
  2295415911,
  3619421802,
  3963911953,
  2390663536,
  1680310286,
  1296546528,
  167662735,
  2206543119,
  808857370,
  2069535939,
  838779241,
  2683044394,
  1821240772,
  366380877,
  1608415822,
  3134787127,
  776888047,
  1319870996,
  2829349568,
  1117427358,
  344797226,
  3289097936,
  3303156796
}; // idb
_UNKNOWN unk_140030F40; // weak
__int16 word_140030FC0[20] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15, 0 }; // idb
_UNKNOWN unk_1400311D0; // weak
_UNKNOWN unk_140031210; // weak
_UNKNOWN unk_140031250; // weak
_UNKNOWN unk_140031290; // weak
struct _EXCEPTION_POINTERS ExceptionInfo = { &dword_14003FF40, &ContextRecord }; // idb
__int128 xmmword_1400313C0 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFi64; // weak
__int64 (__fastcall *off_1400313D0)() = &sub_14000DA00; // weak
wchar_t *off_1400321B8[3] =
{
  L"api-ms-win-core-fibers-l1-1-1",
  L"api-ms-win-core-synch-l1-2-0",
  L"kernel32"
}; // weak
_UNKNOWN unk_140032278; // weak
_UNKNOWN unk_140032290; // weak
_UNKNOWN unk_1400322A0; // weak
_UNKNOWN unk_1400322B8; // weak
_UNKNOWN unk_1400322D0; // weak
char asc_140032300[2] = ")"; // weak
void *std::exception::`vftable' = &sub_14000F640; // weak
void *std::bad_exception::`vftable' = &sub_14000F640; // weak
unsigned __int8 byte_1400323F0[256] =
{
  0u,
  6u,
  0u,
  0u,
  0u,
  0u,
  0u,
  6u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  3u,
  0u,
  6u,
  0u,
  0u,
  0u,
  6u,
  0u,
  2u,
  1u,
  0u,
  0u,
  4u,
  4u,
  5u,
  4u,
  5u,
  4u,
  5u,
  0u,
  5u,
  0u,
  5u,
  0u,
  5u,
  0u,
  5u,
  0u,
  5u,
  3u,
  5u,
  3u,
  0u,
  0u,
  0u,
  5u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2u,
  8u,
  2u,
  0u,
  3u,
  8u,
  5u,
  0u,
  5u,
  8u,
  0u,
  7u,
  0u,
  8u,
  0u,
  0u,
  3u,
  7u,
  3u,
  0u,
  3u,
  0u,
  5u,
  7u,
  5u,
  0u,
  0u,
  7u,
  0u,
  0u,
  0u,
  0u,
  2u,
  0u,
  2u,
  0u,
  0u,
  8u,
  0u,
  7u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  8u,
  6u,
  0u,
  6u,
  8u,
  6u,
  0u,
  6u,
  0u,
  6u,
  0u,
  6u,
  0u,
  0u,
  0u,
  0u,
  0u,
  7u,
  8u,
  7u,
  0u,
  7u,
  8u,
  7u,
  8u,
  7u,
  8u,
  7u,
  8u,
  0u,
  8u,
  0u,
  7u,
  0u,
  8u,
  0u,
  7u,
  0u,
  0u,
  0u,
  7u,
  0u,
  0u,
  0u,
  8u,
  0u,
  8u,
  0u,
  8u,
  0u,
  0u,
  0u,
  0u,
  0u,
  8u,
  0u,
  7u,
  0u,
  8u,
  0u,
  0u,
  0u,
  7u,
  0u,
  8u,
  0u,
  0u,
  0u,
  7u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
unsigned int dword_140032510[92] =
{
  1u,
  22u,
  2u,
  2u,
  3u,
  2u,
  4u,
  24u,
  5u,
  13u,
  6u,
  9u,
  7u,
  12u,
  8u,
  12u,
  9u,
  12u,
  10u,
  7u,
  11u,
  8u,
  12u,
  22u,
  13u,
  22u,
  15u,
  2u,
  16u,
  13u,
  17u,
  18u,
  18u,
  2u,
  33u,
  13u,
  53u,
  2u,
  65u,
  13u,
  67u,
  2u,
  80u,
  17u,
  82u,
  13u,
  83u,
  13u,
  87u,
  22u,
  89u,
  11u,
  108u,
  13u,
  109u,
  32u,
  112u,
  28u,
  114u,
  9u,
  128u,
  10u,
  129u,
  10u,
  130u,
  9u,
  131u,
  22u,
  132u,
  13u,
  145u,
  41u,
  158u,
  13u,
  161u,
  2u,
  164u,
  11u,
  167u,
  13u,
  183u,
  17u,
  206u,
  2u,
  215u,
  11u,
  1113u,
  42u,
  1816u,
  12u,
  0u,
  0u
}; // idb
_UNKNOWN unk_140032730; // weak
_UNKNOWN unk_140032734; // weak
_UNKNOWN unk_140032738; // weak
_UNKNOWN unk_140032750; // weak
__int64 (__fastcall *off_1400328F0)() = &sub_14001A6E0; // weak
void *off_1400329F0 = &unk_140032CB0; // weak
void *off_1400330A0 = &unk_140033120; // weak
wchar_t *off_140033180[21] =
{
  L"api-ms-win-core-datetime-l1-1-1",
  L"api-ms-win-core-file-l1-2-4",
  L"api-ms-win-core-file-l1-2-2",
  L"api-ms-win-core-localization-l1-2-1",
  L"api-ms-win-core-localization-obsolete-l1-2-0",
  L"api-ms-win-core-processthreads-l1-1-2",
  L"api-ms-win-core-string-l1-1-0",
  L"api-ms-win-core-synch-l1-2-0",
  L"api-ms-win-core-sysinfo-l1-2-1",
  L"api-ms-win-core-winrt-l1-1-0",
  L"api-ms-win-core-xstate-l2-1-0",
  L"api-ms-win-rtcore-ntuser-window-l1-1-0",
  L"api-ms-win-security-systemfunctions-l1-1-0",
  L"ext-ms-win-ntuser-dialogbox-l1-1-0",
  L"ext-ms-win-ntuser-windowstation-l1-1-0",
  L"advapi32",
  L"kernel32",
  L"kernelbase",
  L"ntdll",
  L"api-ms-win-appmodel-runtime-l1-1-2",
  L"user32"
}; // weak
_UNKNOWN unk_1400336D8; // weak
_UNKNOWN unk_1400336DC; // weak
_UNKNOWN unk_1400336F0; // weak
_UNKNOWN unk_140033710; // weak
_UNKNOWN unk_140033728; // weak
_UNKNOWN unk_140033744; // weak
char *off_140033780[86] =
{
  "address in use",
  "address not available",
  "address family not supported",
  "connection already in progress",
  "bad message",
  "operation canceled",
  "connection aborted",
  "connection refused",
  "connection reset",
  "destination address required",
  "host unreachable",
  "identifier removed",
  "operation in progress",
  "already connected",
  "too many symbolic link levels",
  "message size",
  "network down",
  "network reset",
  "network unreachable",
  "no buffer space",
  "no message available",
  "no link",
  "no message",
  "no protocol option",
  "no stream resources",
  "not a stream",
  "not connected",
  "state not recoverable",
  "not a socket",
  "not supported",
  "operation not supported",
  "Unknown error",
  "value too large",
  "owner dead",
  "protocol error",
  "protocol not supported",
  "wrong protocol type",
  "stream timeout",
  "timed out",
  "text file busy",
  "operation would block",
  "Unknown error",
  "No error",
  "Operation not permitted",
  "No such file or directory",
  "No such process",
  "Interrupted function call",
  "Input/output error",
  "No such device or address",
  "Arg list too long",
  "Exec format error",
  "Bad file descriptor",
  "No child processes",
  "Resource temporarily unavailable",
  "Not enough space",
  "Permission denied",
  "Bad address",
  "Unknown error",
  "Resource device",
  "File exists",
  "Improper link",
  "No such device",
  "Not a directory",
  "Is a directory",
  "Invalid argument",
  "Too many open files in system",
  "Too many open files",
  "Inappropriate I/O control operation",
  "Unknown error",
  "File too large",
  "No space left on device",
  "Invalid seek",
  "Read-only file system",
  "Too many links",
  "Broken pipe",
  "Domain error",
  "Result too large",
  "Unknown error",
  "Resource deadlock avoided",
  "Unknown error",
  "Filename too long",
  "No locks available",
  "Function not implemented",
  "Directory not empty",
  "Illegal byte sequence",
  "Unknown error"
}; // weak
char *off_1400338D0[44] =
{
  "No error",
  "Operation not permitted",
  "No such file or directory",
  "No such process",
  "Interrupted function call",
  "Input/output error",
  "No such device or address",
  "Arg list too long",
  "Exec format error",
  "Bad file descriptor",
  "No child processes",
  "Resource temporarily unavailable",
  "Not enough space",
  "Permission denied",
  "Bad address",
  "Unknown error",
  "Resource device",
  "File exists",
  "Improper link",
  "No such device",
  "Not a directory",
  "Is a directory",
  "Invalid argument",
  "Too many open files in system",
  "Too many open files",
  "Inappropriate I/O control operation",
  "Unknown error",
  "File too large",
  "No space left on device",
  "Invalid seek",
  "Read-only file system",
  "Too many links",
  "Broken pipe",
  "Domain error",
  "Result too large",
  "Unknown error",
  "Resource deadlock avoided",
  "Unknown error",
  "Filename too long",
  "No locks available",
  "Function not implemented",
  "Directory not empty",
  "Illegal byte sequence",
  "Unknown error"
}; // weak
_UNKNOWN unk_140034750; // weak
_UNKNOWN unk_1400349C0; // weak
__int16 word_1400352D0[] = { 0 }; // weak
char byte_1400352D2[] = { '\0' }; // weak
char byte_1400352D3[148] =
{
  '\x02',
  '\x02',
  '\0',
  '\0',
  '\x03',
  '\x05',
  '\0',
  '\0',
  '\x04',
  '\t',
  '\0',
  '\x01',
  '\x04',
  '\r',
  '\0',
  '\x01',
  '\x05',
  '\x12',
  '\0',
  '\x01',
  '\x06',
  '\x18',
  '\0',
  '\x02',
  '\x06',
  '\x1E',
  '\0',
  '\x02',
  '\a',
  '%',
  '\0',
  '\x02',
  '\b',
  '-',
  '\0',
  '\x03',
  '\b',
  '5',
  '\0',
  '\x03',
  '\t',
  '>',
  '\0',
  '\x03',
  '\n',
  'H',
  '\0',
  '\x04',
  '\n',
  'R',
  '\0',
  '\x04',
  '\v',
  ']',
  '\0',
  '\x04',
  '\f',
  'i',
  '\0',
  '\x05',
  '\f',
  'u',
  '\0',
  '\x05',
  '\r',
  '',
  '\0',
  '\x05',
  '\x0E',
  '',
  '\0',
  '\x05',
  '\x0F',
  '',
  '\0',
  '\x06',
  '\x0F',
  '',
  '\0',
  '\x06',
  '\x10',
  '',
  '\0',
  '\x06',
  '\x11',
  '',
  '\0',
  '\a',
  '\x11',
  '',
  '\0',
  '\a',
  '\x12',
  '',
  '\0',
  '\a',
  '\x13',
  '\x05',
  '\x01',
  '\b',
  '\x13',
  '\x18',
  '\x01',
  '\b',
  '\x15',
  '-',
  '\x01',
  '\b',
  '\x16',
  'C',
  '\x01',
  '\t',
  '\x16',
  'Y',
  '\x01',
  '\t',
  '\x17',
  'p',
  '\x01',
  '\t',
  '\x18',
  '',
  '\x01',
  '\n',
  '\x18',
  '',
  '\x01',
  '\n',
  '\x19',
  '',
  '\x01',
  '\n',
  '\x1A',
  '',
  '\x01',
  '\n',
  '\x1B',
  '',
  '\x01',
  '\v',
  '\x1B',
  '\t',
  '\x02',
  '\v',
  '\x1C',
  '%',
  '\x02',
  '\v'
}; // idb
int dword_140035368[9] = { 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 }; // idb
_UNKNOWN unk_14003538C; // weak
int dword_1400353B0[] = { 1 }; // weak
void *off_140036E10 = &unk_140036400; // weak
int dword_140036E18[] = { 66 }; // weak
int dword_1400386AC[] = { 0 }; // weak
int dword_1400386B0[13] = { 4294967295, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364 }; // idb
int dword_1400386E4[] = { 0 }; // weak
int dword_1400386E8[14] = { 4294967295, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365, 0 }; // idb
__int128 xmmword_140038750 = 9218868437227405312i64; // weak
__int128 xmmword_140038780 = 1023i64; // weak
__int128 xmmword_1400387A0 = 4503599627370495i64; // weak
__int128 xmmword_1400387B0 = 4486007441326080i64; // weak
__int128 xmmword_1400387C0 = 8796093022208i64; // weak
__int128 xmmword_140038830 = 4607182418800017408i64; // weak
__int128 xmmword_140038840 = 4602678819172646912i64; // weak
__int128 xmmword_1400388D0 = 2045i64; // weak
__int128 xmmword_140038920 = 9223372036854775807i64; // weak
double dbl_140038990[258] =
{
   0.0,
   0.001693158003035933,
   0.003379740635864437,
   0.005059798713773489,
   0.00673338258638978,
   0.008400541730225086,
   0.01006132597103715,
   0.01171578280627728,
   0.01336396113038063,
   0.01500590844079852,
   0.01664167083799839,
   0.01827129535377026,
   0.01989482808858156,
   0.02151231467723846,
   0.0231237979605794,
   0.02472932543605566,
   0.02632893808186054,
   0.0279226815328002,
   0.02951059676706791,
   0.03109272848814726,
   0.03266911581158638,
   0.03423980250954628,
   0.03580483049154282,
   0.03736423701047897,
   0.03891806490719318,
   0.04046635329723358,
   0.0420091412961483,
   0.04354646988213062,
   0.04507837444543839,
   0.04660489410161972,
   0.04812606610357761,
   0.0496419295668602,
   0.05115252174437046,
   0.05265787616372108,
   0.05415803194046021,
   0.05565302260220051,
   0.05714288540184498,
   0.0586276538670063,
   0.06010736338794231,
   0.06158204935491085,
   0.0630517452955246,
   0.06451648101210594,
   0.06597629562020302,
   0.06743122264742851,
   0.06888128817081451,
   0.07032652944326401,
   0.07176697626709938,
   0.07320266216993332,
   0.07463361695408821,
   0.07605987042188644,
   0.077481459826231,
   0.07889840751886368,
   0.08031075075268745,
   0.08171851187944412,
   0.08312172815203667,
   0.08452042192220688,
   0.08591462671756744,
   0.08730436861515045,
   0.08868968114256859,
   0.09007058665156364,
   0.09144711494445801,
   0.09281929582357407,
   0.09418715164065361,
   0.09555071592330933,
   0.096910011023283,
   0.09826506674289703,
   0.0996159054338932,
   0.1009625568985939,
   0.1023050434887409,
   0.1036433950066566,
   0.1049776338040829,
   0.1063077859580517,
   0.1076338775455952,
   0.1089559309184551,
   0.1102739721536636,
   0.1115880273282528,
   0.1128981150686741,
   0.1142042651772499,
   0.115506500005722,
   0.116804838180542,
   0.1180993095040321,
   0.119389932602644,
   0.1206767335534096,
   0.1219597309827805,
   0.1232389509677887,
   0.1245144121348858,
   0.1257861405611038,
   0.1270541474223137,
   0.1283184736967087,
   0.1295791268348694,
   0.1308361291885376,
   0.1320895031094551,
   0.1333392783999443,
   0.1345854550600052,
   0.1358280777931213,
   0.1370671465992928,
   0.1383026912808418,
   0.1395347341895103,
   0.1407632902264595,
   0.1419883817434311,
   0.1432100310921669,
   0.1444282457232475,
   0.1456430554389954,
   0.1468544825911522,
   0.1480625346302986,
   0.1492672339081764,
   0.1504686027765274,
   0.1516666561365128,
   0.1528614163398743,
   0.1540528982877731,
   0.1552411168813705,
   0.1564260944724083,
   0.1576078459620476,
   0.1587863937020302,
   0.1599617525935173,
   0.1611339375376701,
   0.1623029708862305,
   0.1634688600897789,
   0.1646316349506378,
   0.1657912954688072,
   0.1669478788971901,
   0.1681013777852058,
   0.1692518293857574,
   0.1703992411494255,
   0.1715436279773712,
   0.1726850047707558,
   0.173823393881321,
   0.1749588027596474,
   0.1760912537574768,
   0.1772207617759705,
   0.1783473342657089,
   0.179470993578434,
   0.1805917546153069,
   0.1817096322774887,
   0.1828246414661407,
   0.1839367896318436,
   0.185046099126339,
   0.1861525848507881,
   0.1872562542557716,
   0.1883571296930313,
   0.1894552186131477,
   0.1905505359172821,
   0.1916431039571762,
   0.1927329301834106,
   0.193820022046566,
   0.1949044018983841,
   0.1959860846400261,
   0.1970650777220726,
   0.1981413960456848,
   0.1992150545120239,
   0.2002860680222511,
   0.2013544365763664,
   0.2024201974272728,
   0.2034833356738091,
   0.2045438885688782,
   0.2056018561124802,
   0.2066572457551956,
   0.2077100798487663,
   0.2087603732943535,
   0.2098081260919571,
   0.2108533605933189,
   0.2118960842490196,
   0.2129363119602203,
   0.2139740511775017,
   0.2150093242526054,
   0.216042123734951,
   0.2170724794268608,
   0.2181003987789154,
   0.2191258892416954,
   0.2201489582657814,
   0.2211696282029152,
   0.2221879065036774,
   0.2232038006186485,
   0.2242173254489899,
   0.225228488445282,
   0.2262373045086861,
   0.2272437810897827,
   0.2282479256391525,
   0.2292497605085373,
   0.230249285697937,
   0.2312465235590935,
   0.2322414666414261,
   0.2332341447472572,
   0.2342245504260063,
   0.2352127060294151,
   0.2361986190080643,
   0.2371822968125343,
   0.2381637543439865,
   0.2391429990530014,
   0.2401200383901596,
   0.2410948872566223,
   0.2420675531029701,
   0.2430380433797836,
   0.244006372988224,
   0.2449725419282913,
   0.2459365725517273,
   0.246898464858532,
   0.2478582337498665,
   0.2488158866763115,
   0.2497714310884476,
   0.2507248669862747,
   0.2516762316226959,
   0.25262551009655,
   0.2535727173089981,
   0.2545178532600403,
   0.2554609477519989,
   0.256402000784874,
   0.2573410123586655,
   0.2582780122756958,
   0.2592129856348038,
   0.2601459473371506,
   0.2610769122838974,
   0.2620058804750443,
   0.2629328668117523,
   0.2638578861951828,
   0.2647809386253357,
   0.265702024102211,
   0.2666211724281311,
   0.2675383687019348,
   0.2684536427259445,
   0.269366979598999,
   0.2702784091234207,
   0.2711879312992096,
   0.2720955461263657,
   0.2730012685060501,
   0.2739050984382629,
   0.2748070657253265,
   0.2757071554660797,
   0.2766053825616837,
   0.2775017619132996,
   0.2783962935209274,
   0.2792889922857285,
   0.2801798433065414,
   0.28106889128685,
   0.2819561064243317,
   0.2828415185213089,
   0.2837251275777817,
   0.2846069484949112,
   0.2854869812726974,
   0.2863652259111404,
   0.2872416973114014,
   0.2881164103746414,
   0.2889893651008606,
   0.2898605763912201,
   0.2907300293445587,
   0.2915977537631989,
   0.2924637496471405,
   0.2933280169963837,
   0.2941905707120895,
   0.2950514107942581,
   0.2959105372428894,
   0.2967679798603058,
   0.2976237386465073,
   0.2984778136014938,
   0.2993302047252655,
   0.3001809269189835,
   0.3010299950838089,
   0.0
}; // idb
double dbl_1400391A0[258] =
{
   0.0,
   1.640904267367217e-11,
   1.551616057750947e-11,
   5.56287768123427e-11,
   7.257862266577723e-11,
   2.962063140008332e-10,
   3.685874488456072e-11,
   3.716310321768732e-10,
   4.276008714833693e-10,
   1.841597676674721e-10,
   4.812190355546235e-10,
   6.989554042661796e-10,
   6.283577008244619e-10,
   1.331995402184861e-11,
   8.865583548809831e-10,
   1.265005075634663e-10,
   6.404886053878509e-10,
   1.961062779025198e-10,
   7.414704928260317e-10,
   3.02658298542661e-11,
   9.417817648754888e-10,
   1.243052712160619e-9,
   1.146838977981516e-10,
   9.512690191581768e-10,
   1.123176475530857e-9,
   1.295996749611038e-9,
   1.711363235042177e-9,
   3.303100509852712e-10,
   2.897497298006304e-10,
   5.950409214487269e-10,
   1.713615829629966e-9,
   1.855282564537107e-9,
   7.030108284385851e-10,
   1.280977210775702e-9,
   6.466463205448106e-10,
   1.071857219251803e-9,
   7.347237514594339e-10,
   1.175253592653964e-9,
   1.712365418075339e-9,
   1.311402582812104e-9,
   4.515644235717874e-10,
   2.993256849152912e-9,
   3.144202653572715e-9,
   3.651515737911289e-10,
   1.23699836142496e-9,
   8.387297878390338e-10,
   1.378201689879737e-9,
   1.020522130768508e-9,
   1.342815969621807e-9,
   3.613049832870301e-9,
   1.343499433826436e-9,
   2.646473245066182e-9,
   4.3590724595635e-10,
   2.233540958441735e-9,
   3.703864510866757e-10,
   1.792781065181003e-9,
   1.989025786585182e-9,
   3.619448471438059e-9,
   1.618796782008473e-9,
   1.826187303969442e-9,
   2.362096248899888e-9,
   1.082327866681208e-9,
   3.031929506202355e-9,
   1.82202224020126e-9,
   1.984773409598041e-9,
   3.501254827282517e-10,
   9.500881393484695e-10,
   1.206594257787016e-10,
   1.40602165687717e-9,
   6.603681703406005e-10,
   9.520065706605206e-10,
   1.390384829267075e-9,
   8.542343493733345e-10,
   1.719669609515157e-9,
   2.41237428108141e-9,
   1.135616384539831e-9,
   3.323512645025913e-9,
   3.017220401241329e-9,
   1.493992867589466e-9,
   3.544453685037982e-9,
   2.573962352142523e-9,
   2.956845097805299e-9,
   1.412395595500822e-9,
   1.908452141837375e-9,
   7.626168657549351e-10,
   1.545762370743126e-9,
   1.831816488294358e-10,
   7.30860724024119e-9,
   3.562971871137175e-9,
   2.92655517447353e-9,
   4.292389450408107e-9,
   6.369569048182868e-9,
   2.347870479255194e-10,
   6.587325146841979e-9,
   1.245304735897941e-9,
   4.554681764254724e-9,
   6.885439627716405e-9,
   5.886462658328173e-9,
   6.487478757885683e-9,
   5.999813437860585e-9,
   1.568858712806344e-9,
   5.07709610676133e-9,
   5.893029441746085e-9,
   6.753173949445088e-10,
   8.251390888056693e-10,
   2.685631939243615e-9,
   2.444788739008415e-9,
   3.58775020073786e-9,
   1.997332161058163e-9,
   8.56852011826518e-10,
   3.20119056025101e-9,
   4.467831481599883e-9,
   7.399620521108524e-9,
   7.145180625504791e-9,
   6.161628131631742e-9,
   6.76552617913725e-9,
   3.683817476929299e-9,
   6.407059143650501e-9,
   1.937992785411385e-9,
   6.947062069484915e-9,
   7.186213943513843e-10,
   7.108737453764987e-9,
   5.139618329812065e-9,
   3.506797273629754e-9,
   3.327589379219849e-9,
   5.593013972009838e-9,
   3.718538217769731e-9,
   5.897125809284369e-9,
   5.298204435440664e-9,
   2.420680655554391e-9,
   5.094196470761222e-9,
   6.128627848806717e-9,
   5.667050826253881e-9,
   3.736369466038942e-9,
   2.485088977213094e-10,
   2.452173678803504e-9,
   2.582268726615504e-9,
   2.127890199400929e-10,
   2.257952923912681e-9,
   6.21579360036015e-10,
   2.000515008462119e-9,
   5.533983399674749e-9,
   2.804662075107756e-9,
   1.914880233024165e-10,
   3.969546819196081e-9,
   5.409948650596448e-9,
   3.13259441241869e-9,
   3.107187285844939e-9,
   3.753070588539629e-9,
   3.390795066475211e-9,
   2.430934223985001e-10,
   7.337004051288193e-9,
   3.507575931356439e-10,
   7.021683190385919e-9,
   2.839007758971375e-9,
   4.517394805738246e-10,
   4.966089416212856e-9,
   6.495785132358665e-9,
   2.514695901854239e-9,
   5.308286054623953e-9,
   4.721574244356304e-9,
   5.412888333238815e-9,
   4.502965298876299e-9,
   6.476944069674031e-9,
   8.3344546327865e-10,
   6.788867726447046e-9,
   6.222963489259213e-9,
   3.284277372020927e-9,
   2.039187665511563e-9,
   6.47268057381489e-9,
   5.587954165241294e-9,
   3.209496934723991e-9,
   3.082673940499373e-9,
   1.423884817377759e-9,
   1.822454982273302e-9,
   3.40195973366541e-10,
   4.132798161863781e-10,
   5.402363354132686e-9,
   3.692123851402279e-9,
   5.944850755985474e-9,
   3.976429885762831e-10,
   5.017146192268418e-9,
   4.449927392072269e-10,
   4.504265491785158e-9,
   5.144922738852532e-9,
   5.147924704285045e-9,
   7.224707998975111e-9,
   6.567233487289724e-9,
   5.749768859012451e-9,
   7.278922420866299e-9,
   6.143669992525878e-9,
   4.717116790551464e-9,
   5.306510809913644e-9,
   2.703249583668099e-9,
   6.535202796865624e-9,
   4.014383678627825e-9,
   4.641000599608496e-9,
   2.951115826858487e-9,
   8.689428606869548e-10,
   2.568152721942901e-10,
   1.036631070352438e-8,
   3.135304737792072e-9,
   2.595469639838789e-9,
   2.916413570805186e-9,
   1.310968422916848e-8,
   1.232579968199758e-8,
   9.459401979858928e-9,
   1.334743810765569e-8,
   2.967335505696641e-9,
   1.943300588065426e-9,
   4.041000031962498e-9,
   2.970365201475796e-9,
   7.287230222025846e-9,
   1.05914813838155e-8,
   6.428685102411339e-9,
   3.191710918987223e-9,
   9.220027215656805e-9,
   2.997830901929752e-9,
   7.660300684340552e-9,
   1.587072490355976e-9,
   7.809644564532452e-9,
   4.604843643181106e-9,
   1.059723778926397e-12,
   1.976347996765959e-9,
   3.557687546576791e-9,
   1.262371926485192e-8,
   7.201673479494774e-9,
   9.973582873251047e-9,
   1.377087925543281e-8,
   1.137711453431384e-8,
   1.042951639077975e-8,
   3.61705631616345e-9,
   1.338431961494596e-8,
   2.52492070763927e-9,
   8.292332434675458e-9,
   8.289810012117998e-9,
   9.877729083275912e-9,
   5.470469260315449e-9,
   2.339099915516198e-9,
   7.710578716522074e-9,
   1.386694653162425e-8,
   1.30468411366381e-8,
   1.234700737892849e-8,
   3.920320259682556e-9,
   9.679610527256036e-9,
   6.792197303030129e-9,
   2.186029269914689e-9,
   2.747694168396125e-9,
   4.215861906593588e-10,
   2.012553699675757e-9,
   1.428506014882493e-8,
   1.416118062786531e-8,
   8.325562429780959e-9,
   3.423415349408947e-9,
   6.060821301195598e-9,
   7.903879710604034e-9,
   5.801722962879576e-10,
   0.0
}; // idb
double dbl_1400399B0[258] =
{
   2.0,
   1.992217898832685,
   1.984496124031008,
   1.976833976833977,
   1.969230769230769,
   1.961685823754789,
   1.954198473282443,
   1.946768060836502,
   1.939393939393939,
   1.932075471698113,
   1.924812030075188,
   1.917602996254682,
   1.91044776119403,
   1.903345724907063,
   1.896296296296296,
   1.88929889298893,
   1.882352941176471,
   1.875457875457875,
   1.868613138686131,
   1.861818181818182,
   1.855072463768116,
   1.848375451263538,
   1.841726618705036,
   1.835125448028674,
   1.828571428571429,
   1.822064056939502,
   1.815602836879433,
   1.809187279151943,
   1.802816901408451,
   1.796491228070175,
   1.79020979020979,
   1.78397212543554,
   1.777777777777778,
   1.771626297577855,
   1.76551724137931,
   1.759450171821306,
   1.753424657534246,
   1.747440273037543,
   1.741496598639456,
   1.735593220338983,
   1.72972972972973,
   1.723905723905724,
   1.718120805369127,
   1.712374581939799,
   1.706666666666667,
   1.700996677740864,
   1.695364238410596,
   1.68976897689769,
   1.684210526315789,
   1.678688524590164,
   1.673202614379085,
   1.667752442996743,
   1.662337662337662,
   1.656957928802589,
   1.651612903225806,
   1.646302250803859,
   1.641025641025641,
   1.635782747603834,
   1.630573248407643,
   1.625396825396825,
   1.620253164556962,
   1.615141955835962,
   1.610062893081761,
   1.605015673981191,
   1.6,
   1.595015576323987,
   1.590062111801242,
   1.585139318885449,
   1.580246913580247,
   1.575384615384615,
   1.570552147239264,
   1.565749235474006,
   1.560975609756098,
   1.556231003039514,
   1.551515151515152,
   1.546827794561934,
   1.542168674698795,
   1.537537537537538,
   1.532934131736527,
   1.528358208955224,
   1.523809523809524,
   1.519287833827893,
   1.514792899408284,
   1.510324483775811,
   1.505882352941176,
   1.501466275659824,
   1.497076023391813,
   1.492711370262391,
   1.488372093023256,
   1.484057971014493,
   1.479768786127168,
   1.475504322766571,
   1.471264367816092,
   1.467048710601719,
   1.462857142857143,
   1.458689458689459,
   1.454545454545455,
   1.45042492917847,
   1.446327683615819,
   1.442253521126761,
   1.438202247191011,
   1.434173669467787,
   1.430167597765363,
   1.426183844011142,
   1.422222222222222,
   1.418282548476454,
   1.414364640883978,
   1.410468319559229,
   1.406593406593407,
   1.402739726027397,
   1.398907103825137,
   1.395095367847411,
   1.391304347826087,
   1.387533875338753,
   1.383783783783784,
   1.380053908355795,
   1.376344086021505,
   1.372654155495979,
   1.368983957219251,
   1.365333333333333,
   1.361702127659574,
   1.358090185676393,
   1.354497354497354,
   1.350923482849604,
   1.347368421052632,
   1.343832020997375,
   1.340314136125655,
   1.336814621409922,
   1.333333333333333,
   1.32987012987013,
   1.326424870466321,
   1.322997416020672,
   1.319587628865979,
   1.316195372750643,
   1.312820512820513,
   1.309462915601023,
   1.306122448979592,
   1.302798982188295,
   1.299492385786802,
   1.29620253164557,
   1.292929292929293,
   1.289672544080604,
   1.28643216080402,
   1.283208020050125,
   1.28,
   1.276807980049875,
   1.27363184079602,
   1.270471464019851,
   1.267326732673267,
   1.264197530864198,
   1.261083743842365,
   1.257985257985258,
   1.254901960784314,
   1.251833740831296,
   1.248780487804878,
   1.245742092457421,
   1.242718446601942,
   1.239709443099274,
   1.236714975845411,
   1.233734939759036,
   1.230769230769231,
   1.227817745803357,
   1.22488038277512,
   1.221957040572792,
   1.219047619047619,
   1.216152019002375,
   1.213270142180095,
   1.210401891252955,
   1.207547169811321,
   1.204705882352941,
   1.2018779342723,
   1.199063231850117,
   1.196261682242991,
   1.193473193473193,
   1.190697674418605,
   1.187935034802784,
   1.185185185185185,
   1.182448036951501,
   1.179723502304147,
   1.177011494252874,
   1.174311926605505,
   1.17162471395881,
   1.168949771689498,
   1.16628701594533,
   1.163636363636364,
   1.160997732426304,
   1.158371040723982,
   1.155756207674943,
   1.153153153153153,
   1.150561797752809,
   1.147982062780269,
   1.145413870246085,
   1.142857142857143,
   1.140311804008909,
   1.137777777777778,
   1.135254988913525,
   1.132743362831858,
   1.130242825607064,
   1.127753303964758,
   1.125274725274725,
   1.12280701754386,
   1.12035010940919,
   1.117903930131004,
   1.115468409586057,
   1.11304347826087,
   1.110629067245119,
   1.108225108225108,
   1.105831533477322,
   1.103448275862069,
   1.101075268817204,
   1.098712446351931,
   1.096359743040685,
   1.094017094017094,
   1.091684434968017,
   1.08936170212766,
   1.087048832271762,
   1.084745762711864,
   1.082452431289641,
   1.080168776371308,
   1.077894736842105,
   1.07563025210084,
   1.073375262054507,
   1.071129707112971,
   1.068893528183716,
   1.066666666666667,
   1.064449064449065,
   1.062240663900415,
   1.060041407867495,
   1.057851239669422,
   1.055670103092784,
   1.053497942386831,
   1.051334702258727,
   1.049180327868853,
   1.047034764826176,
   1.044897959183674,
   1.042769857433808,
   1.040650406504065,
   1.038539553752535,
   1.036437246963563,
   1.034343434343434,
   1.032258064516129,
   1.030181086519115,
   1.028112449799197,
   1.026052104208417,
   1.024,
   1.021956087824351,
   1.0199203187251,
   1.017892644135189,
   1.015873015873016,
   1.013861386138614,
   1.011857707509881,
   1.009861932938856,
   1.007874015748031,
   1.005893909626719,
   1.003921568627451,
   1.001956947162427,
   1.0,
   0.0
}; // idb
void *type_info::`vftable' = &sub_14002A3E0; // weak
_UNKNOWN unk_14003AB70; // weak
_UNKNOWN unk_14003AB80; // weak
int _TI2_AVbad_exception_std__ = 0; // weak
int dword_14003E000 = 1; // weak
int dword_14003E004 = 4294967295; // weak
__int64 qword_14003E010 = -47936899621427i64; // weak
uintptr_t _security_cookie = 47936899621426ui64;
int dword_14003E024 = 1; // weak
int dword_14003E028 = 1; // weak
int dword_14003E02C = 2; // weak
__int64 qword_14003E030 = 524288i64; // weak
__int64 qword_14003E038 = 33554432i64; // weak
DWORD dwTlsIndex = 4294967295u; // idb
_UNKNOWN unk_14003E050; // weak
_UNKNOWN unk_14003E068; // weak
_UNKNOWN unk_14003E158; // weak
_UNKNOWN unk_14003E15C; // weak
char byte_14003E160 = '\x02'; // weak
DWORD dwFlsIndex = 4294967295u; // idb
wchar_t *off_14003E170 = L"         (((((                  H"; // weak
_UNKNOWN off_14003E2C8; // weak
_UNKNOWN unk_14003E2D8; // weak
char byte_14003E2E0[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_14003E3E0; // weak
void *off_14003E428 = &unk_140034752; // weak
int dword_14003E430 = 1; // weak
_UNKNOWN unk_14003E440; // weak
_UNKNOWN unk_14003E458; // weak
_UNKNOWN unk_14003E559; // weak
_UNKNOWN unk_14003E670; // weak
_UNKNOWN unk_14003E780; // weak
_UNKNOWN unk_14003E880; // weak
_UNKNOWN unk_14003E890; // weak
void *off_14003E980 = &unk_14003EA18; // weak
void *off_14003E988 = &unk_1400411AC; // weak
void *off_14003E990 = &unk_1400411AC; // weak
void *off_14003E998 = &unk_1400411AC; // weak
void *off_14003E9A0 = &unk_1400411AC; // weak
void *off_14003E9A8 = &unk_1400411AC; // weak
void *off_14003E9B0 = &unk_1400411AC; // weak
void *off_14003E9B8 = &unk_1400411AC; // weak
void *off_14003E9C0 = &unk_1400411AC; // weak
void *off_14003E9C8 = &unk_1400411AC; // weak
void *off_14003E9D8 = &unk_14003EA1C; // weak
void *off_14003E9E0 = &unk_1400411B0; // weak
void *off_14003E9E8 = &unk_1400411B0; // weak
void *off_14003E9F0 = &unk_1400411B0; // weak
void *off_14003E9F8 = &unk_1400411B0; // weak
void *off_14003EA00 = &unk_1400411B0; // weak
void *off_14003EA08 = &unk_1400411B0; // weak
void *off_14003EA10 = &unk_1400411B0; // weak
int dword_14003EA20 = 4294967294; // weak
void *off_14003EBB0 = &unk_14003EA30; // weak
wchar_t *off_14003EBC0[2] = { L"PST", L"PDT" }; // weak
int dword_14003EBD0 = 4294967295; // weak
int dword_14003EBD4 = 0; // weak
int dword_14003EBD8 = 0; // weak
int dword_14003EBE0 = 4294967295; // weak
int dword_14003EBE4 = 0; // weak
int dword_14003EBE8 = 0; // weak
HANDLE hObject = (HANDLE)0xFFFFFFFFFFFFFFFEi64; // idb
char byte_14003EC00 = '\x01'; // weak
char byte_14003EC10 = '\x01'; // weak
__int64 qword_14003EC20 = 0i64; // weak
int dword_14003EC94 = 0; // weak
__int64 qword_14003EC98 = 0i64; // weak
__int64 qword_14003ECA0 = 0i64; // weak
__int64 qword_14003ECA8 = 0i64; // weak
__int64 qword_14003ECB0 = 0i64; // weak
__int64 qword_14003ECB8 = 0i64; // weak
__int64 qword_14003ECC0 = 0i64; // weak
__int64 qword_14003ECC8 = 0i64; // weak
__int64 qword_14003ECD0 = 0i64; // weak
__int64 qword_14003ECD8 = 0i64; // weak
__int64 qword_14003ECE0 = 0i64; // weak
__int64 qword_14003ECE8 = 0i64; // weak
__int64 qword_14003ECF0 = 0i64; // weak
__int64 qword_14003ECF8 = 0i64; // weak
__int64 qword_14003ED00 = 0i64; // weak
__int64 qword_14003ED08 = 0i64; // weak
__int64 qword_14003ED10 = 0i64; // weak
__int64 qword_14003ED18 = 0i64; // weak
__int64 qword_14003ED20 = 0i64; // weak
__int64 qword_14003ED28 = 0i64; // weak
__int64 qword_14003ED30 = 0i64; // weak
__int64 qword_14003ED38 = 0i64; // weak
__int64 qword_14003ED40 = 0i64; // weak
__int64 qword_14003ED48 = 0i64; // weak
__int64 qword_14003ED50 = 0i64; // weak
__int64 qword_14003ED58 = 0i64; // weak
__int64 qword_14003ED60 = 0i64; // weak
__int64 qword_14003ED68 = 0i64; // weak
__int64 qword_14003ED70 = 0i64; // weak
__int64 qword_14003ED78 = 0i64; // weak
__int64 qword_14003ED80 = 0i64; // weak
__int64 qword_14003ED88 = 0i64; // weak
__int64 qword_14003ED90 = 0i64; // weak
__int64 qword_14003ED98 = 0i64; // weak
__int64 qword_14003EDA0 = 0i64; // weak
__int64 qword_14003EDA8 = 0i64; // weak
__int64 qword_14003EDB0 = 0i64; // weak
__int64 qword_14003EDB8 = 0i64; // weak
__int64 qword_14003EDC0 = 0i64; // weak
__int64 qword_14003EDC8 = 0i64; // weak
__int64 qword_14003EDD0 = 0i64; // weak
__int64 qword_14003EDD8 = 0i64; // weak
__int64 qword_14003EDE0 = 0i64; // weak
__int64 qword_14003EDE8 = 0i64; // weak
__int64 qword_14003EDF0 = 0i64; // weak
_UNKNOWN unk_14003EE00; // weak
int dword_14003EE28; // weak
__int64 qword_14003EE30; // weak
__int64 qword_14003EE38; // weak
__int64 qword_14003EE40; // weak
__int64 qword_14003EE48; // weak
__int64 qword_14003EE50; // weak
__int64 qword_14003EE58; // weak
__int64 qword_14003EE60; // weak
__int64 qword_14003EE68; // weak
__int64 qword_14003EE70; // weak
__int64 qword_14003EE78; // weak
__int64 qword_14003EE80; // weak
__int64 qword_14003EE88; // weak
__int64 qword_14003EE90; // weak
__int64 qword_14003EE98; // weak
__int64 qword_14003EEA0; // weak
__int64 qword_14003EEA8; // weak
__int64 qword_14003EEB0; // weak
__int64 qword_14003EEB8; // weak
__int64 qword_14003EEC0; // weak
__int64 qword_14003EEC8; // weak
__int64 qword_14003EED0; // weak
__int64 qword_14003EED8; // weak
__int64 qword_14003EEE0; // weak
__int64 qword_14003EEE8; // weak
__int64 qword_14003EEF0; // weak
__int64 qword_14003EEF8; // weak
__int64 qword_14003EF00; // weak
__int64 qword_14003EF08; // weak
__int64 qword_14003EF10; // weak
__int64 qword_14003EF18; // weak
__int64 qword_14003EF20; // weak
CHAR MultiByteStr[4096]; // idb
int dword_14003FF40; // weak
int dword_14003FF44; // weak
__int64 qword_14003FF50; // weak
int dword_14003FF58; // weak
_UNKNOWN unk_14003FF60; // weak
_CONTEXT ContextRecord; // idb
int dword_1400404B0; // weak
__int64 qword_1400404B8; // weak
char byte_1400404C0; // weak
char byte_1400404C1; // weak
__int128 xmmword_1400404C8; // weak
__int64 qword_1400404D8; // weak
__int128 xmmword_1400404E0; // weak
__int64 qword_1400404F0; // weak
_UNKNOWN unk_140040500; // weak
_UNKNOWN unk_140040510; // weak
int dword_140040518; // weak
int dword_14004051C; // weak
__int64 qword_140040520; // weak
_UNKNOWN unk_140040530; // weak
int dword_1400405A8; // weak
_UNKNOWN unk_1400405B0; // weak
int dword_1400405D8; // weak
__int64 qword_140040648[]; // weak
__int64 qword_140040660[6]; // idb
__int64 qword_140040690; // weak
int dword_140040698; // weak
LPVOID qword_1400406A0; // idb
LPVOID qword_1400406A8; // idb
__int64 qword_1400406B0; // weak
__int64 qword_1400406B8; // weak
int dword_1400406C0; // weak
LPVOID lpMem; // idb
int dword_1400406D0; // weak
int dword_1400406D4; // weak
__int64 qword_1400406D8; // weak
WCHAR Filename; // idb
LPVOID qword_1400408F0; // idb
LPVOID qword_1400408F8; // idb
__int64 qword_140040900; // weak
__int64 qword_140040908; // weak
_UNKNOWN unk_140040910; // weak
int dword_140040914; // weak
__int64 qword_140040918; // weak
char byte_140040920; // weak
int dword_140040924; // weak
int dword_140040928; // weak
int dword_14004092C; // weak
_UNKNOWN unk_140040930; // weak
_UNKNOWN unk_140040948; // weak
__int64 qword_140040960; // weak
__int64 qword_140040968[]; // weak
__int64 qword_140040970[128]; // idb
int dword_140040D70; // weak
LPVOID qword_140040D78; // idb
LPVOID qword_140040D80; // idb
__int64 qword_140040D88; // weak
__int64 qword_140040D90; // weak
__int64 qword_140040DA0[21]; // idb
_UNKNOWN unk_140040E48; // weak
__int64 qword_140040E50[32]; // idb
_UNKNOWN unk_140040F50; // weak
int dword_140041180; // weak
int dword_140041184; // weak
__int64 qword_140041188; // weak
__int64 qword_140041190; // weak
LPVOID qword_140041198; // idb
int dword_1400411A0; // weak
char byte_1400411A4; // weak
int dword_1400411A8; // weak
HANDLE hHeap; // idb
__int64 qword_1400411C0; // weak
__int64 qword_1400411C8; // weak
__int64 qword_1400411D0; // weak
__int64 qword_1400411D8; // weak
__int64 qword_1400411E0; // weak
int dword_1400411E8; // weak
int dword_1400411EC; // weak
int dword_1400411F0; // weak
__int64 qword_1400411F8; // weak
__int64 qword_140041200; // weak
LPVOID qword_140041208; // idb
int dword_140041210; // weak
int dword_140041214; // weak
struct _TIME_ZONE_INFORMATION TimeZoneInformation; // idb
_UNKNOWN unk_1400412D0; // weak
_UNKNOWN unk_1400412D8; // weak
_UNKNOWN unk_1400412F0; // weak
int dword_140041308; // weak
int dword_14004130C; // weak
int dword_140041310; // weak
_UNKNOWN unk_140041318; // weak
int dword_140041320; // weak
_UNKNOWN unk_140041328; // weak
_UNKNOWN unk_140041330; // weak
int dword_140045040[9] = { 52550, 52543, 52529, 52515, 52501, 52481, 52461, 52441, 52421 }; // idb
int dword_140045064[9] = { 52854, 52847, 52833, 52819, 52805, 52785, 52765, 52745, 52725 }; // idb
int dword_140045088[10] = { 53202, 53195, 53181, 53167, 53153, 53139, 53125, 53111, 53097, 0 }; // idb
int dword_1400450F0[9] = { 53979, 53972, 53965, 53958, 53951, 53941, 53931, 53921, 53911 }; // idb
int dword_140045114[9] = { 54171, 54164, 54157, 54150, 54143, 54133, 54123, 54113, 54103 }; // idb
int dword_140045138[946] =
{
  54403,
  54396,
  54389,
  54382,
  54375,
  54368,
  54361,
  54354,
  54347,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  
}; // idb


//----- (0000000140001000) ----------------------------------------------------
signed __int64 __usercall sub_140001000@<rax>(__int128 *a1@<xmm1>, __m256i *a2@<ymm0>, __m256i *a3@<ymm1>)
{
  LPVOID v3; // rbx
  int *v4; // rax
  __int64 *v5; // rbx
  int *v6; // rax

  v3 = *sub_14000FF70();
  v4 = sub_14000FF68();
  v5 = (__int64 *)sub_140008670((__int64)v3, *v4, a1, a2, a3);
  v6 = sub_14000FF68();
  return sub_140003910(v5, *v6, a1, a2, a3);
}

//----- (0000000140001040) ----------------------------------------------------
void *sub_140001040()
{
  return &unk_140041318;
}

//----- (0000000140001050) ----------------------------------------------------
signed __int64 __usercall sub_140001050@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __m128i *a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>)
{
  __int64 v7; // r14
  __int64 v8; // rbx
  __int64 v9; // rdi
  __m128i *v10; // rsi
  __m128i *v11; // rbp
  unsigned int v12; // er15
  signed __int64 result; // rax
  void *v14; // r13
  unsigned __int64 v15; // r12
  unsigned __int64 v16; // rbx
  int v17; // eax
  int v18; // edi
  signed __int64 v19; // rbx
  void *v20; // [rsp+20h] [rbp-98h]
  int v21; // [rsp+28h] [rbp-90h]
  __m128i *v22; // [rsp+30h] [rbp-88h]
  unsigned int v23; // [rsp+38h] [rbp-80h]
  __int64 v24; // [rsp+50h] [rbp-68h]
  __int64 v25; // [rsp+58h] [rbp-60h]
  __int64 v26; // [rsp+60h] [rbp-58h]
  __int64 v27; // [rsp+C0h] [rbp+8h]

  v27 = a2;
  v7 = a3;
  v8 = a1;
  v24 = 0i64;
  v9 = a2;
  v25 = 0i64;
  v26 = 0i64;
  v21 = 0;
  v20 = 0i64;
  v10 = a4;
  v11 = 0i64;
  v12 = sub_14000B500(&v20, "1.2.13", 88);
  if ( v12 )
  {
    sub_140002AD0((__int64)"Failed to extract %s: inflateInit() failed with return code %d!\n", a5, a6, a7);
    result = 0xFFFFFFFFi64;
  }
  else
  {
    v14 = (void *)sub_140014FA0(0x2000i64);
    if ( v14 )
    {
      v11 = (__m128i *)sub_140014FA0(0x2000i64);
      if ( v11 )
      {
        v15 = *(unsigned int *)(v8 + 8);
LABEL_8:
        v16 = v15;
        if ( v15 > 0x2000 )
          v16 = 0x2000i64;
        if ( sub_1400104EC(1ui64, (__int64)v14, v16, v9, a6) != v16 || (unsigned int)sub_140010260(v9, a6) )
        {
          v12 = -1;
        }
        else
        {
          v15 -= v16;
          v21 = v16;
          v20 = v14;
          while ( 1 )
          {
            v22 = v11;
            v23 = 0x2000;
            v17 = sub_140009950((__int64)&v20, 0);
            v18 = v17;
            v12 = -1;
            if ( (unsigned int)(v17 + 4) <= 2 || v17 == 2 )
              break;
            v19 = 0x2000i64 - v23;
            if ( v7 )
            {
              if ( sub_140010C2C(1i64, (__int64)v11, v19, v7, a6) != v19 || (unsigned int)sub_140010260(v7, a6) )
                break;
            }
            else if ( v10 )
            {
              sub_14000CA50(v10, v11, v19);
              v10 = (__m128i *)((char *)v10 + v19);
            }
            if ( v23 )
            {
              if ( v18 == 1 )
              {
                v12 = 0;
                goto LABEL_28;
              }
              if ( v15 )
              {
                v9 = v27;
                goto LABEL_8;
              }
              break;
            }
          }
          sub_140002AD0(
            (__int64)"Failed to extract %s: decompression resulted in return code %d!\n",
            a5,
            a6,
            a7,
            v20,
            *(_QWORD *)&v21);
        }
      }
      else
      {
        sub_140002830(
          (__int64)"Failed to extract %s: failed to allocate temporary output buffer!\n",
          (__int64)"malloc",
          a5,
          a6,
          a7);
      }
    }
    else
    {
      sub_140002830(
        (__int64)"Failed to extract %s: failed to allocate temporary input buffer!\n",
        (__int64)"malloc",
        a5,
        a6,
        a7);
    }
LABEL_28:
    sub_14000B1E0(&v20);
    sub_140014F8C(v14);
    sub_140014F8C(v11);
    result = v12;
  }
  return result;
}
// 140014FA0: using guessed type __int64 __fastcall sub_140014FA0(_QWORD);

//----- (00000001400012B0) ----------------------------------------------------
__int64 __usercall sub_1400012B0@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  __int64 v5; // rsi
  _QWORD *v6; // r13
  unsigned int v7; // ebp
  __int64 v8; // rax
  __int64 v9; // r14
  __m128i *v10; // rbx
  __m128i *v11; // rax
  __m128i *v12; // r12
  __int64 v13; // r9
  signed __int64 v14; // rsi
  unsigned __int64 v16; // rdi
  __int64 v17; // r15
  unsigned __int64 v18; // rbp
  __int64 v19; // [rsp+20h] [rbp-1058h]
  char v20; // [rsp+30h] [rbp-1048h]

  v5 = a1;
  v6 = (_QWORD *)a2;
  v7 = -1;
  v8 = sub_140003F60("rb", (const CHAR *)(a2 + 112), a3, a4, a5);
  v9 = v8;
  if ( !v8 )
  {
    sub_140002AD0((__int64)"Failed to extract %s: failed to open archive file!\n", a3, a4, a5);
    v10 = 0i64;
    goto LABEL_12;
  }
  if ( (signed int)sub_140010824(*v6 + *(unsigned int *)(v5 + 4), v8, 0, a4) < 0 )
  {
    sub_140002830((__int64)"Failed to extract %s: failed to seek to the entry's data!\n", (__int64)"fseek", a3, a4, a5);
    sub_14001019C(v9, a4);
    v10 = 0i64;
    goto LABEL_12;
  }
  v11 = (__m128i *)sub_140014FA0(*(unsigned int *)(v5 + 12));
  v12 = v11;
  v10 = v11;
  if ( !v11 )
  {
    v13 = *(unsigned int *)(v5 + 12);
    sub_140002830(
      (__int64)"Failed to extract %s: failed to allocate data buffer (%u bytes)!\n",
      (__int64)"malloc",
      a3,
      a4,
      a5);
    sub_14001019C(v9, a4);
    goto LABEL_12;
  }
  if ( *(_BYTE *)(v5 + 16) != 1 )
  {
    v16 = *(unsigned int *)(v5 + 12);
    v17 = (__int64)v11;
    if ( !*(_DWORD *)(v5 + 12) )
      goto LABEL_9;
    while ( 1 )
    {
      v18 = v16;
      if ( v16 > 0x2000 )
        v18 = 0x2000i64;
      if ( sub_1400104EC(v18, v17, 1ui64, v9, a4) < 1 )
        break;
      v17 += v18;
      v16 -= v18;
      if ( !v16 )
      {
        v7 = -1;
        goto LABEL_9;
      }
    }
    sub_140002830((__int64)"Failed to extract %s: failed to read data chunk!\n", (__int64)"fread", a3, a4, a5);
    v7 = -1;
LABEL_20:
    sub_140014F8C(v12);
    sub_14001019C(v9, a4);
    v10 = 0i64;
    goto LABEL_12;
  }
  if ( (unsigned int)sub_140001050(v5, v9, 0i64, v11, a3, a4, a5) )
    goto LABEL_20;
LABEL_9:
  v14 = v5 + 18;
  sub_14001019C(v9, a4);
  if ( (signed int)sub_140007780(a3, a4, a5) >= 0 )
  {
    LODWORD(v19) = 92;
    if ( (signed int)sub_140001E90(4096i64, (__int64)&v20, (__int64)"%s%c%s", a3, a4, a5, v19, v14) < 4096 )
      v7 = sub_140004100(&v20, (const CHAR *)v12->m128i_i64, a3, a4, a5);
  }
LABEL_12:
  sub_140014F8C(v10);
  return v7;
}
// 140014FA0: using guessed type __int64 __fastcall sub_140014FA0(_QWORD);

//----- (00000001400014F0) ----------------------------------------------------
signed __int64 __usercall sub_1400014F0@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __int64 v4; // rdi
  signed int *v5; // rbx
  const CHAR *v6; // rdx

  v4 = a1;
  if ( *(_DWORD *)(a1 + 20596) != 1 )
  {
    v5 = *(signed int **)(a1 + 8);
    if ( (unsigned __int64)v5 >= *(_QWORD *)(a1 + 16) )
    {
LABEL_6:
      v6 = 0i64;
    }
    else
    {
      while ( *((_BYTE *)v5 + 17) != 111
           || (unsigned int)sub_140014FC0((signed int *)((char *)v5 + 18), (__int64)"pyi-runtime-tmpdir", 0x12ui64) )
      {
        v5 = (signed int *)((char *)v5 + *v5);
        if ( (unsigned __int64)v5 >= *(_QWORD *)(v4 + 16) )
          goto LABEL_6;
      }
      v6 = (const CHAR *)(v5 + 9);
      if ( *((_BYTE *)v5 + 36) )
        v6 = (char *)v5 + 37;
    }
    if ( !(unsigned int)sub_140007910(v6, (CHAR *)(v4 + 12400), a2, a3, a4) )
    {
      sub_140002AD0((__int64)"Cannot create temporary directory!\n", a2, a3, a4);
      return 0xFFFFFFFFi64;
    }
    *(_DWORD *)(v4 + 20596) = 1;
  }
  return 0i64;
}

//----- (00000001400015A0) ----------------------------------------------------
__m128i *__usercall sub_1400015A0@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  __int64 v5; // rsi
  _QWORD *v6; // rbx
  __m128i *v7; // r14
  __int64 v8; // rax
  __int64 v9; // r15
  __m128i *v11; // rax
  __int64 v12; // r9
  unsigned __int64 v13; // rbx
  __int64 v14; // rbp
  unsigned __int64 v15; // rdi

  v5 = a1;
  v6 = (_QWORD *)a2;
  v7 = 0i64;
  v8 = sub_140003F60("rb", (const CHAR *)(a2 + 112), a3, a4, a5);
  v9 = v8;
  if ( !v8 )
  {
    sub_140002AD0((__int64)"Failed to extract %s: failed to open archive file!\n", a3, a4, a5);
    return 0i64;
  }
  if ( (signed int)sub_140010824(*v6 + *(unsigned int *)(v5 + 4), v8, 0, a4) >= 0 )
  {
    v11 = (__m128i *)sub_140014FA0(*(unsigned int *)(v5 + 12));
    v7 = v11;
    if ( v11 )
    {
      if ( *(_BYTE *)(v5 + 16) == 1 )
      {
        if ( !(unsigned int)sub_140001050(v5, v9, 0i64, v11, a3, a4, a5) )
          goto LABEL_18;
      }
      else
      {
        v13 = *(unsigned int *)(v5 + 12);
        v14 = (__int64)v11;
        if ( !*(_DWORD *)(v5 + 12) )
          goto LABEL_18;
        while ( 1 )
        {
          v15 = v13;
          if ( v13 > 0x2000 )
            v15 = 0x2000i64;
          if ( sub_1400104EC(v15, v14, 1ui64, v9, a4) < 1 )
            break;
          v14 += v15;
          v13 -= v15;
          if ( !v13 )
            goto LABEL_18;
        }
        sub_140002830((__int64)"Failed to extract %s: failed to read data chunk!\n", (__int64)"fread", a3, a4, a5);
      }
      sub_140014F8C(v7);
      v7 = 0i64;
      goto LABEL_18;
    }
    v12 = *(unsigned int *)(v5 + 12);
    sub_140002830(
      (__int64)"Failed to extract %s: failed to allocate data buffer (%u bytes)!\n",
      (__int64)"malloc",
      a3,
      a4,
      a5);
  }
  else
  {
    sub_140002830((__int64)"Failed to extract %s: failed to seek to the entry's data!\n", (__int64)"fseek", a3, a4, a5);
  }
LABEL_18:
  sub_14001019C(v9, a4);
  return v7;
}
// 140014FA0: using guessed type __int64 __fastcall sub_140014FA0(_QWORD);

//----- (0000000140001710) ----------------------------------------------------
signed __int64 __usercall sub_140001710@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r15>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>)
{
  __int64 v6; // rdi
  __int64 v7; // rbx
  signed __int64 result; // rax
  unsigned int v9; // ebx
  __int64 v10; // r12
  __int64 v11; // rax
  __int64 v12; // r15
  unsigned int v13; // ebx
  void *v14; // r14
  unsigned __int64 v15; // rdi
  signed __int64 v16; // rsi
  const char *v17; // rdx
  const char *v18; // rcx
  __int64 v19; // [rsp+20h] [rbp-28h]

  v6 = a1;
  v7 = a2;
  if ( *(_DWORD *)(a2 + 20596) == 1 )
  {
    if ( *(_BYTE *)(a1 + 17) == 110 )
    {
      v9 = sub_1400012B0(a1, a2, a4, a5, a6);
      if ( (v9 & 0x80000000) != 0 )
        sub_140002AD0((__int64)"Failed to create symbolic link %s!\n", a4, a5, a6);
      result = v9;
    }
    else
    {
      v10 = sub_140007BD0(a1 + 18, a4, a5, a6);
      if ( v10 )
      {
        v19 = a3;
        v11 = sub_140003F60("rb", (const CHAR *)(v7 + 112), a4, a5, a6);
        v12 = v11;
        if ( v11 )
        {
          if ( (signed int)sub_140010824(*(_QWORD *)v7 + *(unsigned int *)(v6 + 4), v11, 0, a5) >= 0 )
          {
            if ( *(_BYTE *)(v6 + 16) == 1 )
            {
              v13 = sub_140001050(v6, v12, v10, 0i64, a4, a5, a6);
            }
            else
            {
              v13 = 0;
              v14 = (void *)sub_140014FA0(0x2000i64);
              if ( v14 )
              {
                v15 = *(unsigned int *)(v6 + 12);
                if ( v15 )
                {
                  while ( 1 )
                  {
                    v16 = v15;
                    if ( v15 > 0x2000 )
                      v16 = 0x2000i64;
                    if ( sub_1400104EC(v16, (__int64)v14, 1ui64, v12, a5) < 1 )
                      break;
                    if ( sub_140010C2C(v16, (__int64)v14, 1i64, v10, a5) < 1 )
                    {
                      v17 = "Failed to extract %s: failed to write data chunk!\n";
                      v18 = "fwrite";
                      goto LABEL_26;
                    }
                    v15 -= v16;
                    if ( !v15 )
                      goto LABEL_27;
                  }
                  v17 = "Failed to extract %s: failed to read data chunk!\n";
                  v18 = "fread";
LABEL_26:
                  sub_140002830((__int64)v17, (__int64)v18, a4, a5, a6, v19);
                  v13 = -1;
                }
LABEL_27:
                sub_140014F8C(v14);
              }
              else
              {
                sub_140002830(
                  (__int64)"Failed to extract %s: failed to allocate temporary buffer!\n",
                  (__int64)"malloc",
                  a4,
                  a5,
                  a6,
                  v19);
                v13 = -1;
              }
            }
          }
          else
          {
            sub_140002830(
              (__int64)"Failed to extract %s: failed to seek to the entry's data!\n",
              (__int64)"fseek",
              a4,
              a5,
              a6,
              v19);
            v13 = -1;
          }
          sub_14001019C(v12, a5);
        }
        else
        {
          sub_140002AD0((__int64)"Failed to extract %s: failed to open archive file!\n", a4, a5, a6, v19);
          v13 = v12 - 1;
        }
        sub_14001019C(v10, a5);
        result = v13;
      }
      else
      {
        sub_140002830((__int64)"Failed to extract %s: failed to open target file!\n", (__int64)"fopen", a4, a5, a6);
        result = 0xFFFFFFFFi64;
      }
    }
  }
  else
  {
    sub_140002AD0((__int64)"pyi_arch_extract2fs was called before temporary directory was initialized!\n", a4, a5, a6);
    result = 0xFFFFFFFFi64;
  }
  return result;
}
// 140001710: could not find valid save-restore pair for r15
// 140014FA0: using guessed type __int64 __fastcall sub_140014FA0(_QWORD);

//----- (0000000140001950) ----------------------------------------------------
signed int *__fastcall sub_140001950(__int64 a1, __int64 a2)
{
  signed int *v2; // r8
  __int64 v3; // r11
  unsigned __int64 v4; // r10
  unsigned __int8 *v5; // rax
  int v6; // ecx
  int v7; // edx

  v2 = *(signed int **)(a1 + 8);
  v3 = a2;
  v4 = *(_QWORD *)(a1 + 16);
  if ( (unsigned __int64)v2 >= v4 )
    return 0i64;
  while ( 1 )
  {
    v5 = (unsigned __int8 *)v2 + 18;
    do
    {
      v6 = v5[v3 - ((_QWORD)v2 + 18)];
      v7 = *v5 - v6;
      if ( *v5 != v6 )
        break;
      ++v5;
    }
    while ( v6 );
    if ( !v7 )
      break;
    v2 = (signed int *)((char *)v2 + *v2);
    if ( (unsigned __int64)v2 >= v4 )
      return 0i64;
  }
  return v2;
}

//----- (00000001400019A0) ----------------------------------------------------
_BYTE *__fastcall sub_1400019A0(__int64 a1, __int64 a2)
{
  signed int *v2; // rbx
  __int64 v3; // rsi
  __int64 v4; // rbp
  unsigned __int64 v5; // rdi
  _BYTE *result; // rax

  v2 = *(signed int **)(a1 + 8);
  v3 = a2;
  v4 = a1;
  v5 = -1i64;
  do
    ++v5;
  while ( *(_BYTE *)(a2 + v5) );
  if ( (unsigned __int64)v2 >= *(_QWORD *)(a1 + 16) )
    return 0i64;
  while ( *((_BYTE *)v2 + 17) != 111 || (unsigned int)sub_140014FC0((signed int *)((char *)v2 + 18), v3, v5) )
  {
    v2 = (signed int *)((char *)v2 + *v2);
    if ( (unsigned __int64)v2 >= *(_QWORD *)(v4 + 16) )
      return 0i64;
  }
  result = (char *)v2 + v5 + 18;
  if ( *result )
    result = (char *)v2 + v5 + 19;
  return result;
}

//----- (0000000140001A30) ----------------------------------------------------
char *__fastcall sub_140001A30(__int64 a1, signed int *a2)
{
  return (char *)a2 + *a2;
}

//----- (0000000140001A40) ----------------------------------------------------
__int64 __usercall sub_140001A40@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __int64 v4; // rbx
  unsigned int v5; // esi
  __int64 v6; // rdi
  __int64 v7; // rax
  __int64 v8; // rbp
  unsigned int v9; // ecx
  unsigned int v10; // eax
  unsigned __int32 v11; // ecx
  unsigned __int32 v12; // eax
  __int64 v13; // rax
  unsigned int *i; // rax
  unsigned int v15; // edx
  signed __int32 v16; // edx
  __int64 v18; // [rsp+20h] [rbp-18h]

  v4 = a1;
  v5 = -1;
  v6 = sub_140003F60("rb", (const CHAR *)(a1 + 112), a2, a3, a4);
  if ( v6 )
  {
    v18 = 1011913583640528205i64;
    BYTE3(v18) = 12;
    v7 = sub_140008270((__int64)&v18, v6, 8ui64, a3);
    v8 = v7;
    if ( v7 )
    {
      if ( (signed int)sub_140010824(v7, v6, 0, a3) >= 0 )
      {
        if ( sub_1400104EC(0x58ui64, v4 + 24, 1ui64, v6, a3) >= 1 )
        {
          v9 = *(_DWORD *)(v4 + 32);
          *(_DWORD *)(v4 + 36) = _byteswap_ulong(*(_DWORD *)(v4 + 36));
          *(_DWORD *)(v4 + 40) = _byteswap_ulong(*(_DWORD *)(v4 + 40));
          v10 = *(_DWORD *)(v4 + 44);
          v11 = _byteswap_ulong(v9);
          *(_DWORD *)(v4 + 32) = v11;
          v12 = _byteswap_ulong(v10);
          *(_DWORD *)(v4 + 44) = v12;
          *(_QWORD *)v4 = v8 - v11 + 88;
          *(_DWORD *)(v4 + 20600) = 0;
          dword_14003EC94 = v12;
          sub_140010824(*(_QWORD *)v4 + *(unsigned int *)(v4 + 36), v6, 0, a3);
          v13 = sub_140014FA0(*(signed int *)(v4 + 40));
          *(_QWORD *)(v4 + 8) = v13;
          if ( v13 )
          {
            if ( sub_1400104EC(*(signed int *)(v4 + 40), v13, 1ui64, v6, a3) >= 1 )
            {
              *(_QWORD *)(v4 + 16) = *(_QWORD *)(v4 + 8) + *(signed int *)(v4 + 40);
              if ( (unsigned int)sub_140010260(v6, a3) )
              {
                sub_140002AD0((__int64)"Error on file.\n", a2, a3, a4, v18);
              }
              else
              {
                for ( i = *(unsigned int **)(v4 + 8);
                      (unsigned __int64)i < *(_QWORD *)(v4 + 16);
                      i = (unsigned int *)((char *)i + v16) )
                {
                  v15 = *i;
                  i[1] = _byteswap_ulong(i[1]);
                  i[2] = _byteswap_ulong(i[2]);
                  i[3] = _byteswap_ulong(i[3]);
                  v16 = _byteswap_ulong(v15);
                  *i = v16;
                }
                v5 = 0;
              }
            }
            else
            {
              sub_140002830((__int64)"Could not read full TOC!\n", (__int64)"fread", a2, a3, a4, v18);
            }
          }
          else
          {
            sub_140002830((__int64)"Could not allocate buffer for TOC!\n", (__int64)"malloc", a2, a3, a4, v18);
          }
        }
        else
        {
          sub_140002830((__int64)"Failed to read cookie!\n", (__int64)"fread", a2, a3, a4, v18);
        }
      }
      else
      {
        sub_140002830((__int64)"Failed to seek to cookie position!\n", (__int64)"fseek", a2, a3, a4, v18);
      }
    }
    sub_14001019C(v6, a3);
  }
  return v5;
}
// 140014FA0: using guessed type __int64 __fastcall sub_140014FA0(_QWORD);
// 14003EC94: using guessed type int dword_14003EC94;

//----- (0000000140001C50) ----------------------------------------------------
signed __int64 __usercall sub_140001C50@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __int64 v4; // rdi
  signed int *v5; // rcx
  unsigned __int64 v6; // rdx
  signed int v7; // er8
  unsigned int v8; // eax
  signed int *v9; // rbx
  char *v10; // rbx
  __int64 v11; // rdi
  char v12; // cl
  char *v14; // rsi
  char v15; // [rsp+20h] [rbp-2028h]
  char v16; // [rsp+1020h] [rbp-1028h]

  v4 = a1;
  if ( (signed int)sub_140001E90(4096i64, a1 + 112, (__int64)"%s", a2, a3, a4) >= 4096
    || (signed int)sub_140001E90(4096i64, v4 + 4208, (__int64)"%s", a2, a3, a4) >= 4096
    || (unsigned int)sub_140001A40(v4, a2, a3, a4) )
  {
    return 0i64;
  }
  v5 = *(signed int **)(v4 + 8);
  v6 = *(_QWORD *)(v4 + 16);
  *(_DWORD *)(v4 + 20592) = 0;
  if ( (unsigned __int64)v5 < v6 )
  {
    v7 = 1074791681;
    while ( 1 )
    {
      v8 = *((unsigned __int8 *)v5 + 17);
      LOBYTE(v8) = v8 - 90;
      if ( (unsigned __int8)v8 <= 0x1Eu )
      {
        if ( _bittest(&v7, v8) )
          break;
      }
      v5 = (signed int *)((char *)v5 + *v5);
      if ( (unsigned __int64)v5 >= v6 )
        goto LABEL_11;
    }
    *(_DWORD *)(v4 + 20592) = 1;
  }
LABEL_11:
  sub_140003DD0((__int64)&v16, a2, a3, a4);
  v9 = *(signed int **)(v4 + 8);
  if ( (unsigned __int64)v9 >= *(_QWORD *)(v4 + 16) )
    goto LABEL_15;
  while ( *((_BYTE *)v9 + 17) != 111
       || (unsigned int)sub_140014FC0((signed int *)((char *)v9 + 18), (__int64)"pyi-contents-directory", 0x16ui64) )
  {
    v9 = (signed int *)((char *)v9 + *v9);
    if ( (unsigned __int64)v9 >= *(_QWORD *)(v4 + 16) )
      goto LABEL_15;
  }
  v14 = (char *)v9 + (*((_BYTE *)v9 + 40) != 0) + 40;
  if ( !v14 || *(_DWORD *)(v4 + 20592) )
  {
LABEL_15:
    v10 = (char *)(v4 + 8304);
    sub_140003DD0(v4 + 8304, a2, a3, a4);
  }
  else
  {
    sub_140003DD0((__int64)&v15, a2, a3, a4);
    v10 = (char *)(v4 + 8304);
    sub_140003FE0(v4 + 8304, v14, a2, a3, a4);
  }
  *(_DWORD *)(v4 + 20596) = 0;
  v11 = v4 - (_QWORD)v10;
  do
  {
    v12 = *v10;
    v10[v11 + 16496] = *v10;
    ++v10;
  }
  while ( v12 );
  return 1i64;
}

//----- (0000000140001E20) ----------------------------------------------------
void __fastcall sub_140001E20(LPVOID *a1)
{
  LPVOID *v1; // rbx

  if ( a1 )
  {
    v1 = a1;
    sub_140014F8C(a1[1]);
    sub_140014F8C(v1);
  }
}

//----- (0000000140001E50) ----------------------------------------------------
__int64 __usercall sub_140001E50@<rax>(__int128 *a1@<xmm1>, __m256i *a2@<ymm0>, __m256i *a3@<ymm1>)
{
  __int64 result; // rax
  __int64 v4; // rbx

  result = sub_140014F84(1i64, 20616i64);
  v4 = result;
  if ( !result )
  {
    sub_140002830((__int64)"Cannot allocate memory for ARCHIVE_STATUS\n", (__int64)"calloc", a1, a2, a3);
    result = v4;
  }
  return result;
}
// 140014F84: using guessed type __int64 __fastcall sub_140014F84(_QWORD, _QWORD);

//----- (0000000140001E90) ----------------------------------------------------
__int64 __usercall sub_140001E90@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>, ...)
{
  __int64 v6; // rsi
  __int64 v7; // rbx
  __int64 v8; // rdi
  _QWORD *v9; // rax
  __int64 result; // rax
  va_list va; // [rsp+78h] [rbp+20h]

  va_start(va, a6);
  v6 = a3;
  v7 = a1;
  v8 = a2;
  v9 = sub_140001040();
  result = sub_140014AD4(v8, *v9 | 2i64, v7, v6, a4, a5, a6, 0i64, (__int64)va);
  if ( (signed int)result < 0 )
    result = 0xFFFFFFFFi64;
  return result;
}

//----- (0000000140001EF0) ----------------------------------------------------
BOOL __usercall sub_140001EF0@<eax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __int64 v4; // r9
  __int64 v5; // rdi
  int v6; // eax
  unsigned __int16 v7; // bh^1
  __int16 v8; // ax
  HFONT v9; // rax
  HWND v10; // rax
  LPARAM v11; // r9
  HWND v12; // rcx
  WPARAM v13; // r8
  BOOL result; // eax
  struct tagRECT Rect; // [rsp+60h] [rbp-228h]
  int pvParam; // [rsp+70h] [rbp-218h]
  char v17; // [rsp+74h] [rbp-214h]
  LOGFONTW lf; // [rsp+208h] [rbp-80h]

  v4 = *(_QWORD *)(a1 + 16);
  v5 = a1;
  sub_1400027D0(
    4096i64,
    a1 + 40,
    (__int64)L"Failed to execute script '%ls' due to unhandled exception: %ls",
    a2,
    a3,
    a4,
    *(_QWORD *)(a1 + 24));
  v6 = GetDialogBaseUnits();
  v7 = HIWORD(v6);
  *(_WORD *)(v5 + 8282) = MulDiv((unsigned __int16)v6, 50, 4);
  v8 = MulDiv(v7, 14, 8);
  *(_DWORD *)(v5 + 8286) = 2097184;
  *(_WORD *)(v5 + 8284) = v8;
  *(_WORD *)(v5 + 8280) = 8;
  sub_14000D100(0i64, (__int64)&v17, 0x1F4ui64, a3);
  pvParam = 504;
  if ( SystemParametersInfoW(0x29u, 0x1F8u, &pvParam, 0) )
    v9 = CreateFontIndirectW(&lf);
  else
    v9 = 0i64;
  *(_QWORD *)(v5 + 8264) = v9;
  COMCTL32_380(0i64, 32513i64, 1i64, v5 + 8272);
  *(_QWORD *)(v5 + 8232) = CreateWindowExW(
                             0,
                             L"STATIC",
                             0i64,
                             0x50000003u,
                             2147483648,
                             2147483648,
                             2147483648,
                             2147483648,
                             *(HWND *)(v5 + 8),
                             0i64,
                             *(HINSTANCE *)v5,
                             0i64);
  *(_QWORD *)(v5 + 8240) = CreateWindowExW(
                             0,
                             L"STATIC",
                             0i64,
                             0x50000000u,
                             2147483648,
                             2147483648,
                             2147483648,
                             2147483648,
                             *(HWND *)(v5 + 8),
                             0i64,
                             *(HINSTANCE *)v5,
                             0i64);
  *(_QWORD *)(v5 + 8248) = CreateWindowExW(
                             0x200u,
                             L"EDIT",
                             0i64,
                             0x50300884u,
                             2147483648,
                             2147483648,
                             2147483648,
                             2147483648,
                             *(HWND *)(v5 + 8),
                             0i64,
                             *(HINSTANCE *)v5,
                             0i64);
  v10 = CreateWindowExW(
          0,
          L"BUTTON",
          L"Close",
          0x50000001u,
          2147483648,
          2147483648,
          2147483648,
          2147483648,
          *(HWND *)(v5 + 8),
          (HMENU)1,
          *(HINSTANCE *)v5,
          0i64);
  v11 = *(_QWORD *)(v5 + 8272);
  v12 = *(HWND *)(v5 + 8);
  *(_QWORD *)(v5 + 8256) = v10;
  SendMessageW(v12, 0x80u, 0i64, v11);
  SendMessageW(*(HWND *)(v5 + 8), 0x80u, 1ui64, *(_QWORD *)(v5 + 8272));
  SendMessageW(*(HWND *)(v5 + 8232), 0x172u, 1ui64, *(_QWORD *)(v5 + 8272));
  v13 = *(_QWORD *)(v5 + 8264);
  if ( v13 )
  {
    SendMessageW(*(HWND *)(v5 + 8), 0x30u, v13, 1i64);
    SendMessageW(*(HWND *)(v5 + 8240), 0x30u, *(_QWORD *)(v5 + 8264), 1i64);
    SendMessageW(*(HWND *)(v5 + 8248), 0x30u, *(_QWORD *)(v5 + 8264), 1i64);
    SendMessageW(*(HWND *)(v5 + 8256), 0x30u, *(_QWORD *)(v5 + 8264), 1i64);
  }
  SendMessageW(*(HWND *)(v5 + 8240), 0xCu, 0i64, v5 + 40);
  SendMessageW(*(HWND *)(v5 + 8248), 0xCu, 0i64, *(_QWORD *)(v5 + 32));
  result = GetClientRect(*(HWND *)(v5 + 8), &Rect);
  if ( result )
    result = sub_140002390(v5, LOWORD(Rect.right) - LOWORD(Rect.left), LOWORD(Rect.bottom) - LOWORD(Rect.top));
  return result;
}
// 14002B028: using guessed type __int64 __fastcall COMCTL32_380(_QWORD, _QWORD, _QWORD, _QWORD);
// 14002BB00: using guessed type wchar_t aFailedToExecut[63];

//----- (00000001400022D0) ----------------------------------------------------
INT_PTR __usercall DialogFunc@<rax>(HWND a1@<rcx>, int a2@<edx>, unsigned __int16 a3@<r8w>, LONG_PTR a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>)
{
  __int64 v7; // rdi
  HWND v8; // rbx
  int v9; // edx
  int v10; // edx
  int v11; // edx
  INT_PTR v12; // rdx
  __int64 v14; // rax

  v7 = a4;
  v8 = a1;
  v9 = a2 - 5;
  if ( v9 )
  {
    v10 = v9 - 11;
    if ( !v10 )
    {
      v12 = 2i64;
      goto LABEL_7;
    }
    v11 = v10 - 256;
    if ( !v11 )
    {
      *(_QWORD *)(a4 + 8) = a1;
      SetWindowLongPtrW(a1, 16, a4);
      sub_140001EF0(v7, a5, a6, a7);
      return 1i64;
    }
    if ( v11 == 1 )
    {
      if ( (unsigned __int16)(a3 - 1) > 1u )
        return 1i64;
      v12 = a3;
LABEL_7:
      EndDialog(a1, v12);
      return 1i64;
    }
  }
  else
  {
    v14 = GetWindowLongPtrW(a1, 16);
    sub_140002390(v14, v7, SWORD1(v7));
    InvalidateRect(v8, 0i64, 0);
  }
  return 0i64;
}

//----- (0000000140002390) ----------------------------------------------------
BOOL __fastcall sub_140002390(__int64 a1, unsigned __int16 a2, __int16 a3)
{
  __int64 v3; // rsi
  int v4; // ebp
  __int16 v5; // r14
  HDC v6; // rbx
  int v7; // ecx
  HGDIOBJ v8; // rdi
  int v9; // eax
  void *v10; // rdx
  unsigned __int16 v11; // dx
  int v12; // ecx
  unsigned __int16 v13; // ax
  int v14; // ebx
  __int16 v15; // di
  unsigned __int16 v16; // cx
  int v17; // edx
  struct tagRECT rc; // [rsp+30h] [rbp-48h]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = GetDC(*(HWND *)(a1 + 8240));
  if ( v6 )
  {
    v7 = *(unsigned __int16 *)(v3 + 8280);
    v8 = 0i64;
    v9 = *(unsigned __int16 *)(v3 + 8286);
    *(_QWORD *)&rc.left = 0i64;
    rc.bottom = 0;
    v10 = *(void **)(v3 + 8264);
    *(_QWORD *)&rc.right = (unsigned int)(v4 - 3 * v7 - v9);
    if ( v10 )
      v8 = SelectObject(v6, v10);
    DrawTextW(v6, (LPCWSTR)(v3 + 40), -1, &rc, 0x2550u);
    if ( *(_QWORD *)(v3 + 8264) )
      SelectObject(v6, v8);
    ReleaseDC(*(HWND *)(v3 + 8240), v6);
    v11 = LOWORD(rc.bottom) - LOWORD(rc.top);
  }
  else
  {
    v11 = 20;
  }
  v12 = *(unsigned __int16 *)(v3 + 8288);
  v13 = v12;
  if ( v11 >= (unsigned __int16)v12 )
    v13 = v11;
  v14 = v13;
  MoveWindow(
    *(HWND *)(v3 + 8232),
    *(unsigned __int16 *)(v3 + 8280),
    *(unsigned __int16 *)(v3 + 8280),
    *(unsigned __int16 *)(v3 + 8286),
    v12,
    1);
  v15 = *(_WORD *)(v3 + 8280);
  v16 = *(_WORD *)(v3 + 8286) + 2 * *(_WORD *)(v3 + 8280);
  MoveWindow(*(HWND *)(v3 + 8240), v16, *(unsigned __int16 *)(v3 + 8280), (unsigned __int16)(v4 - v15 - v16), v14, 1);
  v17 = *(unsigned __int16 *)(v3 + 8280);
  MoveWindow(
    *(HWND *)(v3 + 8248),
    v17,
    (unsigned __int16)(v14 + v17 + v15),
    (unsigned __int16)(v4 - v17 - v17),
    (unsigned __int16)(v5 - 2 * v17 - *(_WORD *)(v3 + 8284) - (v14 + v17 + v15)),
    1);
  return MoveWindow(
           *(HWND *)(v3 + 8256),
           (unsigned __int16)(v4 - *(_WORD *)(v3 + 8280) - *(_WORD *)(v3 + 8282)),
           (unsigned __int16)(v5 - *(_WORD *)(v3 + 8280) - *(_WORD *)(v3 + 8284)),
           *(unsigned __int16 *)(v3 + 8282),
           *(unsigned __int16 *)(v3 + 8284),
           1);
}

//----- (00000001400025A0) ----------------------------------------------------
__int64 __usercall sub_1400025A0@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>)
{
  __int64 v6; // rbx
  __int64 v7; // r14
  __int64 v8; // rdi
  HMODULE v9; // rsi
  unsigned int v10; // ebx
  LPARAM dwInitParam; // [rsp+30h] [rbp-D0h]
  __int64 v13; // [rsp+38h] [rbp-C8h]
  _WORD *v14; // [rsp+40h] [rbp-C0h]
  _WORD *v15; // [rsp+48h] [rbp-B8h]
  _WORD *v16; // [rsp+50h] [rbp-B0h]
  char v17; // [rsp+58h] [rbp-A8h]
  HGDIOBJ ho; // [rsp+2078h] [rbp+1F78h]
  HICON hIcon; // [rsp+2080h] [rbp+1F80h]
  DLGTEMPLATE hDialogTemplate; // [rsp+20A0h] [rbp+1FA0h]
  __int16 v21; // [rsp+20B4h] [rbp+1FB4h]
  char v22; // [rsp+20B6h] [rbp+1FB6h]

  v6 = a2;
  v7 = a3;
  v8 = a1;
  v9 = GetModuleHandleW(0i64);
  sub_14000D100(0i64, (__int64)&v22, 0x102ui64, a5);
  hDialogTemplate.style = -1865676668;
  *(_QWORD *)&hDialogTemplate.dwExtendedStyle = 0i64;
  v21 = 0;
  *(_DWORD *)&hDialogTemplate.y = 13107200;
  *(_DWORD *)&hDialogTemplate.cy = 150;
  sub_1400027D0(64i64, (__int64)&v22, (__int64)L"Unhandled exception in script", a4, a5, a6);
  v13 = 0i64;
  sub_14000D100(0i64, (__int64)&v17, 0x2040ui64, a5);
  dwInitParam = (LPARAM)v9;
  v14 = sub_1400178B4(v6, a5);
  v15 = sub_1400178B4(v8, a5);
  v16 = sub_1400178B4(v7, a5);
  v10 = DialogBoxIndirectParamW(v9, &hDialogTemplate, 0i64, (DLGPROC)DialogFunc, (LPARAM)&dwInitParam);
  sub_140014F8C(v14);
  sub_140014F8C(v15);
  sub_140014F8C(v16);
  if ( ho )
    DeleteObject(ho);
  if ( hIcon )
    DestroyIcon(hIcon);
  return v10;
}
// 14002BBC0: using guessed type wchar_t aUnhandledExcep[30];

//----- (0000000140002710) ----------------------------------------------------
__int64 __usercall sub_140002710@<rax>(LPCSTR lpMultiByteStr@<rcx>, LPCSTR a2@<rdx>, LPCSTR a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>)
{
  WCHAR *v6; // rdi
  const CHAR *v7; // rbx
  const CHAR *v8; // rsi
  WCHAR *v9; // r14
  WCHAR *v10; // rbp
  const wchar_t *v11; // r8
  unsigned int v12; // ebx

  v6 = 0i64;
  v7 = a3;
  v8 = a2;
  v9 = 0i64;
  v10 = 0i64;
  if ( lpMultiByteStr )
    v6 = sub_140008AA0(0i64, lpMultiByteStr, 0, a4, a5, a6);
  if ( v8 )
    v9 = sub_140008AA0(0i64, v8, 0, a4, a5, a6);
  if ( v7 )
    v10 = sub_140008AA0(0i64, v7, 0, a4, a5, a6);
  v11 = L"Failed to obtain/convert traceback!";
  if ( v10 )
    v11 = v10;
  v12 = sub_1400025A0((__int64)v9, (__int64)v6, (__int64)v11, a4, a5, a6);
  sub_140014F8C(v6);
  sub_140014F8C(v9);
  sub_140014F8C(v10);
  return v12;
}
// 14002BC00: using guessed type wchar_t aFailedToObtain[36];

//----- (00000001400027D0) ----------------------------------------------------
__int64 __usercall sub_1400027D0@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>, ...)
{
  __int64 v6; // rsi
  __int64 v7; // rbx
  __int64 v8; // rdi
  __int64 *v9; // rax
  __int64 result; // rax
  va_list va; // [rsp+78h] [rbp+20h]

  va_start(va, a6);
  v6 = a3;
  v7 = a1;
  v8 = a2;
  v9 = (__int64 *)sub_140001040();
  result = sub_140014D28(v8, *v9, v7, v6, a4, a5, a6, 0i64, (__int64)va);
  if ( (signed int)result < 0 )
    result = 0xFFFFFFFFi64;
  return result;
}

//----- (0000000140002830) ----------------------------------------------------
int __usercall sub_140002830@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>, ...)
{
  __int64 v5; // rbx
  __int64 v6; // rdi
  _QWORD *v7; // rax
  int *v8; // rax
  const char *v9; // rax
  CHAR MultiByteStr; // [rsp+30h] [rbp-1828h]
  char v12; // [rsp+430h] [rbp-1428h]
  WCHAR Caption; // [rsp+830h] [rbp-1028h]
  WCHAR Text; // [rsp+1030h] [rbp-828h]
  va_list va; // [rsp+1870h] [rbp+18h]

  va_start(va, a5);
  v5 = a1;
  v6 = a2;
  v7 = sub_140001040();
  sub_140014AD4((__int64)&v12, *v7 | 2i64, 1024i64, v5, a3, a4, a5, 0i64, (__int64)va);
  v8 = (int *)sub_140015334();
  v9 = sub_140015354(*v8, a4);
  sub_140001E90(1024i64, (__int64)&MultiByteStr, (__int64)"%s%s: %s", a3, a4, a5, v6, v9);
  sub_14000D100(0i64, (__int64)&Caption, 0x800ui64, a4);
  if ( !sub_140008AA0(&Text, &MultiByteStr, 1024, a3, a4, a5) )
    return MessageBoxA(0i64, &MultiByteStr, "Fatal error detected", 0x30u);
  sub_140008AA0(&Caption, "Fatal error detected", 1024, a3, a4, a5);
  return MessageBoxW(0i64, &Text, &Caption, 0x30u);
}

//----- (0000000140002980) ----------------------------------------------------
int __usercall sub_140002980@<eax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>, __int64 a6@<r8>, __int64 a7@<r9>, ...)
{
  __int64 v7; // rdi
  DWORD v8; // ebx
  _QWORD *v9; // rax
  const char *v10; // rax
  CHAR MultiByteStr; // [rsp+30h] [rbp-1828h]
  char v13; // [rsp+430h] [rbp-1428h]
  WCHAR Caption; // [rsp+830h] [rbp-1028h]
  WCHAR Text; // [rsp+1030h] [rbp-828h]
  __int64 v16; // [rsp+1868h] [rbp+10h]
  __int64 v17; // [rsp+1870h] [rbp+18h]
  __int64 v18; // [rsp+1878h] [rbp+20h]

  v16 = a1;
  v17 = a6;
  v18 = a7;
  v7 = a2;
  v8 = GetLastError();
  v9 = sub_140001040();
  sub_140014AD4((__int64)&v13, *v9 | 2i64, 1024i64, v16, a3, a4, a5, 0i64, (__int64)&v17);
  v10 = sub_140008520(v8, a3, a4, a5);
  sub_140001E90(1024i64, (__int64)&MultiByteStr, (__int64)"%s%s: %s", a3, a4, a5, v7, v10);
  sub_14000D100(0i64, (__int64)&Caption, 0x800ui64, a4);
  if ( !sub_140008AA0(&Text, &MultiByteStr, 1024, a3, a4, a5) )
    return MessageBoxA(0i64, &MultiByteStr, "Fatal error detected", 0x30u);
  sub_140008AA0(&Caption, "Fatal error detected", 1024, a3, a4, a5);
  return MessageBoxW(0i64, &Text, &Caption, 0x30u);
}

//----- (0000000140002AD0) ----------------------------------------------------
int __usercall sub_140002AD0@<eax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>, ...)
{
  __int64 v4; // rbx
  _QWORD *v5; // rax
  CHAR MultiByteStr; // [rsp+30h] [rbp-1428h]
  WCHAR Caption; // [rsp+430h] [rbp-1028h]
  WCHAR Text; // [rsp+C30h] [rbp-828h]
  va_list va; // [rsp+1468h] [rbp+10h]

  va_start(va, a4);
  v4 = a1;
  v5 = sub_140001040();
  sub_140014AD4((__int64)&MultiByteStr, *v5 | 2i64, 1024i64, v4, a2, a3, a4, 0i64, (__int64)va);
  sub_14000D100(0i64, (__int64)&Caption, 0x800ui64, a3);
  if ( !sub_140008AA0(&Text, &MultiByteStr, 1024, a2, a3, a4) )
    return MessageBoxA(0i64, &MultiByteStr, "Fatal error detected", 0x30u);
  sub_140008AA0(&Caption, "Fatal error detected", 1024, a2, a3, a4);
  return MessageBoxW(0i64, &Text, &Caption, 0x30u);
}

//----- (0000000140002BE0) ----------------------------------------------------
int __usercall sub_140002BE0@<eax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>, ...)
{
  __int64 v4; // rbx
  _QWORD *v5; // rax
  CHAR MultiByteStr; // [rsp+30h] [rbp-1428h]
  WCHAR Caption; // [rsp+430h] [rbp-1028h]
  WCHAR Text; // [rsp+C30h] [rbp-828h]
  va_list va; // [rsp+1468h] [rbp+10h]

  va_start(va, a4);
  v4 = a1;
  v5 = sub_140001040();
  sub_140014AD4((__int64)&MultiByteStr, *v5 | 2i64, 1024i64, v4, a2, a3, a4, 0i64, (__int64)va);
  sub_14000D100(0i64, (__int64)&Caption, 0x800ui64, a3);
  if ( !sub_140008AA0(&Text, &MultiByteStr, 1024, a2, a3, a4) )
    return MessageBoxA(0i64, &MultiByteStr, "Error detected", 0x30u);
  sub_140008AA0(&Caption, "Error detected", 1024, a2, a3, a4);
  return MessageBoxW(0i64, &Text, &Caption, 0x30u);
}

//----- (0000000140002CF0) ----------------------------------------------------
signed __int64 __usercall sub_140002CF0@<rax>(__int64 *a1@<rcx>, __int64 a2@<r15>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  __int64 v5; // rbx
  __int64 *v6; // rsi
  _BYTE *v7; // rax
  char *v8; // rcx
  char *v9; // rdx
  char v10; // al
  _BYTE *v11; // rax
  int v12; // eax
  const char *v13; // rcx
  __int64 v15; // rbx
  signed int v16; // edi
  signed __int64 v17; // r9
  unsigned __int8 *v18; // rax
  int v19; // ecx
  int v20; // edx
  __int64 v21; // rax
  signed __int64 v22; // r9
  signed __int64 v23; // r9
  signed int *v24; // rdx
  unsigned __int8 *v25; // rax
  int v26; // ecx
  int v27; // er8
  __int64 v28; // [rsp+28h] [rbp-D8h]
  __int64 v29; // [rsp+38h] [rbp-C8h]
  char v30; // [rsp+50h] [rbp-B0h]
  char v31[4096]; // [rsp+1050h] [rbp+F50h]
  char v32[4096]; // [rsp+2050h] [rbp+1F50h]
  char v33; // [rsp+3050h] [rbp+2F50h]
  char v34; // [rsp+4050h] [rbp+3F50h]
  char v35; // [rsp+5050h] [rbp+4F50h]

  v5 = *a1;
  v6 = a1;
  if ( (signed int)sub_140001E90(4096i64, (__int64)&v30, (__int64)"%s", a3, a4, a5) < 4096 )
  {
    v7 = sub_14000D488((__int64)&v30, 0x3Au);
    if ( v7 )
    {
      v8 = v7 + 1;
      *v7 = 0;
      v9 = (char *)(v31 - (v7 + 1));
      do
      {
        v10 = *v8;
        v8[(_QWORD)v9] = *v8;
        ++v8;
      }
      while ( v10 );
      if ( v30 && v31[0] )
      {
        sub_140003DD0((__int64)&v33, a3, a4, a5);
        sub_140003DD0((__int64)&v35, a3, a4, a5);
        v11 = sub_1400019A0(v5, (__int64)"pyi-contents-directory");
        if ( v11 )
        {
          LODWORD(v29) = 92;
          LODWORD(v28) = 92;
          v12 = sub_140003140((__int64)"%s%c%s%c%s%c%s", &v34, a3, a4, a5, &v35, v28, v11, v29, v31);
        }
        else
        {
          LODWORD(v28) = 92;
          v12 = sub_140003140((__int64)"%s%c%s%c%s", &v34, a3, a4, a5, &v35, v28, v31);
        }
        if ( !v12 )
        {
          if ( (unsigned int)sub_140007560(&v34, (__int64)v31, a3, a4, a5) == -1 )
          {
            sub_140002AD0((__int64)"Failed to copy file %s from %s!\n", a3, a4, a5);
            return 0xFFFFFFFFi64;
          }
          return 0i64;
        }
        if ( (unsigned int)sub_140003140((__int64)"%s%c%s.pkg", v32, a3, a4, a5, &v30)
          && (unsigned int)sub_140003140((__int64)"%s%c%s.exe", v32, a3, a4, a5, &v30)
          && (unsigned int)sub_140003140((__int64)"%s%c%s", v32, a3, a4, a5, &v30) )
        {
          v13 = "Referenced dependency archive %s not found.\n";
LABEL_17:
          sub_140002AD0((__int64)v13, a3, a4, a5);
          return 0xFFFFFFFFi64;
        }
        v15 = v6[1];
        v16 = 1;
        if ( v15 )
        {
          v17 = 1i64;
          while ( 1 )
          {
            v18 = (unsigned __int8 *)(v15 + 112);
            do
            {
              v19 = (unsigned __int8)v32[(_QWORD)v18 - 112 - v15];
              v20 = *v18 - v19;
              if ( *v18 != v19 )
                break;
              ++v18;
            }
            while ( v19 );
            if ( !v20 )
              break;
            v15 = v6[v17++ + 1];
            ++v16;
            if ( !v15 )
              goto LABEL_27;
          }
          if ( !v15 )
          {
            v13 = "Failed to open referenced dependency archive %s.\n";
            goto LABEL_17;
          }
LABEL_36:
          v24 = *(signed int **)(v15 + 8);
          if ( (unsigned __int64)v24 >= *(_QWORD *)(v15 + 16) )
            goto LABEL_42;
          while ( 1 )
          {
            v25 = (unsigned __int8 *)v24 + 18;
            do
            {
              v26 = v25[v31 - ((char *)v24 + 18)];
              v27 = *v25 - v26;
              if ( *v25 != v26 )
                break;
              ++v25;
            }
            while ( v26 );
            if ( !v27 )
              break;
            v24 = (signed int *)sub_140001A30(v15, v24);
            if ( (unsigned __int64)v24 >= *(_QWORD *)(v15 + 16) )
              goto LABEL_42;
          }
          if ( (unsigned int)sub_140001710((__int64)v24, v15, a2, a3, a4, a5) == -1 )
          {
LABEL_42:
            sub_140002AD0((__int64)"Failed to extract %s from referenced dependency archive %s.\n", a3, a4, a5);
            return 0xFFFFFFFFi64;
          }
          return 0i64;
        }
LABEL_27:
        v21 = sub_140001E50(a3, a4, a5);
        v15 = v21;
        if ( v21 )
        {
          if ( (signed int)sub_140001E90(4096i64, v21 + 112, (__int64)"%s", a3, a4, a5) >= 4096
            || (v22 = *v6 + 8304, (signed int)sub_140001E90(4096i64, v15 + 8304, (__int64)"%s", a3, a4, a5) >= 4096)
            || (v23 = *v6 + 12400, (signed int)sub_140001E90(4096i64, v15 + 12400, (__int64)"%s", a3, a4, a5) >= 4096) )
          {
            sub_140002AD0((__int64)"Archive path exceeds PATH_MAX\n", a3, a4, a5);
          }
          else
          {
            *(_DWORD *)(v15 + 20596) = *(_DWORD *)(*v6 + 20596);
            if ( !(unsigned int)sub_140001A40(v15, a3, a4, a5) )
            {
              v6[v16] = v15;
              goto LABEL_36;
            }
            sub_140002AD0((__int64)"Failed to open archive %s!\n", a3, a4, a5);
          }
          sub_140001E20((LPVOID *)v15);
        }
        v13 = "Failed to open referenced dependency archive %s.\n";
        goto LABEL_17;
      }
    }
  }
  return 0xFFFFFFFFi64;
}
// 140002CF0: using guessed type char var_5020[4096];
// 140002CF0: using guessed type char var_4020[4096];

//----- (0000000140003140) ----------------------------------------------------
__int64 __usercall sub_140003140@<rax>(__int64 a1@<rdx>, const CHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>, ...)
{
  __int64 v5; // rbx
  const CHAR *v6; // rdi
  _QWORD *v7; // rax
  signed int v8; // eax
  __int64 result; // rax
  char v10; // [rsp+30h] [rbp-58h]
  va_list va; // [rsp+A0h] [rbp+18h]

  va_start(va, a5);
  v5 = a1;
  v6 = a2;
  v7 = sub_140001040();
  v8 = sub_140014AD4((__int64)v6, *v7 | 2i64, 4096i64, v5, a3, a4, a5, 0i64, (__int64)va);
  if ( v8 < 0 )
    v8 = -1;
  if ( v8 < 4096 )
    result = sub_140015CF8(&v10, v6, a3, a4, a5);
  else
    result = 0xFFFFFFFFi64;
  return result;
}

//----- (00000001400031E0) ----------------------------------------------------
_BYTE *__usercall sub_1400031E0@<rax>(int a1@<r9d>, __m256i *a2@<ymm0>)
{
  int v2; // edi
  _BYTE *v3; // r14
  __int64 v4; // rbp
  __int64 v5; // rbx
  __int64 v6; // rax

  v2 = a1;
  v3 = 0i64;
  if ( sub_14002A5B0() )
  {
    if ( sub_14002A5B0() )
    {
      if ( sub_14002A5B0() )
      {
        if ( v2 )
        {
          sub_14002A5B0();
          v4 = sub_14002A5B0();
          sub_14002A5B0();
          if ( v2 == 2 )
          {
            sub_14002A5B0();
            sub_14002A5B0();
            v5 = sub_14002A5B0();
            sub_14002A5B0();
            sub_14002A5B0();
            sub_14002A5B0();
            v4 = v5;
          }
        }
        else
        {
          v4 = sub_14002A5B0();
        }
        if ( v4 )
        {
          v6 = sub_14002A5B0();
          if ( v6 )
            v3 = sub_14001A8AC(v6, a2);
        }
      }
      sub_14002A5B0();
      sub_14002A5B0();
    }
    sub_14002A5B0();
  }
  sub_14002A5B0();
  return v3;
}

//----- (00000001400033F0) ----------------------------------------------------
signed __int64 __usercall sub_1400033F0@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __int64 v4; // rbx
  signed __int64 result; // rax

  v4 = a1;
  if ( (unsigned int)sub_140005B80(a1, a2, a3, a4)
    || (*(_DWORD *)(v4 + 20600) = 1, (unsigned int)sub_140005CE0(v4, a2, a3, a4))
    || (unsigned int)sub_1400058E0(v4, a2, a3, a4)
    || (unsigned int)sub_140005A50(v4, a2, a3, a4) )
  {
    result = 0xFFFFFFFFi64;
  }
  else
  {
    result = sub_1400035C0(v4, a2, a3, a4);
  }
  return result;
}

//----- (0000000140003450) ----------------------------------------------------
__int64 __usercall sub_140003450@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r15>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>)
{
  char *v6; // rbx
  unsigned int v7; // esi
  __int64 v8; // rbp
  __int64 v9; // rdi
  signed int v10; // er14
  int v11; // ecx
  LPVOID *v12; // rcx
  signed __int64 v13; // rbx
  __int64 v15; // [rsp+20h] [rbp-C8h]
  __int128 v16; // [rsp+28h] [rbp-C0h]
  __int128 v17; // [rsp+38h] [rbp-B0h]
  __int128 v18; // [rsp+48h] [rbp-A0h]
  __int128 v19; // [rsp+58h] [rbp-90h]
  __int128 v20; // [rsp+68h] [rbp-80h]
  __int128 v21; // [rsp+78h] [rbp-70h]
  __int128 v22; // [rsp+88h] [rbp-60h]
  __int128 v23; // [rsp+98h] [rbp-50h]
  __int128 v24; // [rsp+A8h] [rbp-40h]
  __int64 v25; // [rsp+B8h] [rbp-30h]

  v6 = *(char **)(a2 + 8);
  v16 = 0i64;
  v17 = 0i64;
  v7 = 0;
  v8 = a1;
  v9 = a2;
  v18 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v25 = 0i64;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v15 = a2;
  if ( (unsigned __int64)v6 < *(_QWORD *)(a2 + 16) )
  {
    v10 = 1074790657;
    do
    {
      v11 = (unsigned __int8)v6[17];
      if ( (unsigned __int8)(v11 - 90) <= 0x1Eu && _bittest(&v10, v11 - 90) )
      {
        if ( v8 )
          sub_140006DE0(v8, (__int64)v6);
        if ( (unsigned int)sub_140001710((__int64)v6, v9, a3, a4, a5, a6) )
        {
LABEL_8:
          v7 = -1;
          break;
        }
      }
      else if ( (_BYTE)v11 == 100 && (unsigned int)sub_140002CF0(&v15, a3, a4, a5, a6) == -1 )
      {
        goto LABEL_8;
      }
      v6 = sub_140001A30(v9, (signed int *)v6);
    }
    while ( (unsigned __int64)v6 < *(_QWORD *)(v9 + 16) );
  }
  v12 = (LPVOID *)v16;
  v13 = 1i64;
  if ( (_QWORD)v16 )
  {
    do
    {
      sub_140001E20(v12);
      v12 = (LPVOID *)*(&v15 + ++v13);
    }
    while ( v12 );
  }
  return v7;
}

//----- (00000001400035C0) ----------------------------------------------------
signed __int64 __usercall sub_1400035C0@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  char *v4; // rbx
  __int64 v5; // rsi
  const CHAR *v7; // r14
  __m128i *v8; // rbp
  __int64 v9; // rdx
  CHAR *v10; // rdi
  __int64 v11; // rax
  CHAR *v12; // rax
  CHAR *v13; // rbx
  __int64 v14; // [rsp+20h] [rbp-1068h]
  char v15; // [rsp+50h] [rbp-1038h]

  v4 = *(char **)(a1 + 8);
  v5 = a1;
  if ( !sub_14002A5B0() )
  {
    sub_140002AD0((__int64)"Could not get __main__ module.\n", a2, a3, a4);
    return 0xFFFFFFFFi64;
  }
  if ( !sub_14002A5B0() )
  {
    sub_140002AD0((__int64)"Could not get __main__ module's dict.\n", a2, a3, a4);
    return 0xFFFFFFFFi64;
  }
  if ( (unsigned __int64)v4 >= *(_QWORD *)(v5 + 16) )
    return 0i64;
  while ( v4[17] != 115 )
  {
LABEL_11:
    v4 = sub_140001A30(v5, (signed int *)v4);
    if ( (unsigned __int64)v4 >= *(_QWORD *)(v5 + 16) )
      return 0i64;
  }
  v7 = v4 + 18;
  LODWORD(v14) = 92;
  v8 = sub_1400015A0((__int64)v4, v5, a2, a3, a4);
  if ( (signed int)sub_140001E90(4096i64, (__int64)&v15, (__int64)"%s%c%s.py", a2, a3, a4, v14, v4 + 18) >= 4096 )
  {
    sub_140002AD0((__int64)"Absolute path to script exceeds PATH_MAX\n", a2, a3, a4);
    return 0xFFFFFFFFi64;
  }
  sub_14002A5B0();
  sub_14002A5B0();
  sub_14002A5B0();
  v9 = *((unsigned int *)v4 + 3);
  if ( !sub_14002A5B0() )
  {
    sub_140002AD0((__int64)"Failed to unmarshal code object for %s\n", a2, a3, a4);
    sub_14002A5B0();
    return 0xFFFFFFFFi64;
  }
  sub_14002A5B0();
  if ( sub_14002A5B0() )
  {
    sub_140014F8C(v8);
    goto LABEL_11;
  }
  sub_14002A5B0();
  sub_14002A5B0();
  v10 = 0i64;
  sub_14002A5B0();
  v11 = sub_14002A5B0();
  if ( v11 )
    v10 = sub_14001A8AC(v11, a3);
  sub_14002A5B0();
  if ( sub_1400019A0(v5, (__int64)"pyi-disable-windowed-traceback") )
    v12 = sub_14001A8AC((__int64)"Traceback is disabled via bootloader option.", a3);
  else
    v12 = sub_1400031E0(2, a3);
  v13 = v12;
  sub_14002A5B0();
  sub_14002A5B0();
  sub_140002710(v7, v10, v13, a2, a3, a4);
  sub_140014F8C(v10);
  sub_140014F8C(v13);
  return 1i64;
}

//----- (0000000140003910) ----------------------------------------------------
signed __int64 __usercall sub_140003910@<rax>(__int64 *a1@<rdx>, int a2@<ecx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  int v5; // er13
  __int64 *v6; // r12
  char *v7; // rax
  __int64 v8; // rdi
  __int64 v9; // rdx
  BOOL v10; // er14
  const CHAR *v11; // rsi
  __int64 v12; // r15
  _BYTE *v13; // rax
  int v14; // ebx
  signed __int64 result; // rax
  __int64 v16; // rbx
  __m128i *v17; // rax
  unsigned __int8 *v18; // rax
  int v19; // ecx
  int v20; // edx
  char *v21; // rbx
  char v22; // al
  unsigned int v23; // ebx
  unsigned int v24; // ebx
  __m128i *v25; // [rsp+20h] [rbp-E0h]
  __int64 v26; // [rsp+28h] [rbp-D8h]
  char v27; // [rsp+30h] [rbp-D0h]
  char v28; // [rsp+1030h] [rbp+F30h]
  WCHAR PathName; // [rsp+2030h] [rbp+1F30h]

  v5 = a2;
  v6 = a1;
  v7 = sub_140015160(2u);
  sub_140015E04(0i64, (__int64)v7, a4);
  v8 = sub_140001E50(a3, a4, a5);
  if ( !v8 )
    return 0xFFFFFFFFi64;
  v9 = *v6;
  if ( !(unsigned int)sub_140003E50(&v27, a3, a4, a5) || !(unsigned int)sub_140003D20((__int64)&v28, &v27) )
    return 0xFFFFFFFFi64;
  v10 = 0;
  v11 = sub_140007B20("_MEIPASS2", a3, a4, a5);
  v12 = v11 != 0i64;
  if ( v11 )
  {
    v13 = sub_140007B20("_PYI_ONEDIR_MODE", a3, a4, a5);
    if ( v13 )
    {
      v14 = (unsigned __int8)*v13 - 49;
      if ( *v13 == 49 )
        v14 = (unsigned __int8)v13[1];
      sub_140014F8C(v13);
      sub_140008000("_PYI_ONEDIR_MODE", a3, a4, a5);
      if ( v14 )
        v10 = v11 != 0i64;
      v12 = (unsigned int)v10;
    }
  }
  sub_140008000("_MEIPASS2", a3, a4, a5);
  if ( !(unsigned int)sub_140001C50(v8, a3, a4, a5) )
  {
    if ( !(unsigned int)sub_140001C50(v8, a3, a4, a5) )
    {
      sub_140002AD0(
        (__int64)"Cannot open PyInstaller archive from executable (%s) or external archive (%s)\n",
        a3,
        a4,
        a5);
      return 0xFFFFFFFFi64;
    }
    if ( !v11 )
    {
      v16 = sub_140003F60("rb", &v27, a3, a4, a5);
      if ( !v16 )
      {
LABEL_20:
        sub_140002AD0((__int64)"Cannot side-load external archive %s (code %d)!\n", a3, a4, a5);
        return 0xFFFFFFFFi64;
      }
      v26 = 1011913583640528205i64;
      BYTE3(v26) = 13;
      if ( !sub_140008270((__int64)&v26, v16, 8ui64, a4) )
      {
        sub_14001019C(v16, a4);
        goto LABEL_20;
      }
    }
  }
  *(_DWORD *)(v8 + 20604) = v5;
  *(_QWORD *)(v8 + 20608) = v6;
  if ( !(_DWORD)v12 && *(_DWORD *)(v8 + 20592) && (unsigned int)sub_1400014F0(v8, a3, a4, a5) == -1 )
    return 0xFFFFFFFFi64;
  if ( v11 || !*(_DWORD *)(v8 + 20592) && (v11 = (const CHAR *)(v8 + 8304), v8 != -8304) )
  {
    if ( !sub_140008AA0(&PathName, v11, 4096, a3, a4, a5) )
    {
      sub_140002AD0((__int64)"Failed to convert DLL search path!\n", a3, a4, a5);
      return 0xFFFFFFFFi64;
    }
    SetDllDirectoryW(&PathName);
  }
  v17 = (__m128i *)sub_140006DA0(a3, a4, a5);
  v25 = v17;
  if ( !(_DWORD)v12 && !(unsigned int)sub_140006A50(v8, (__int64)v17, a3, a4, a5) )
  {
    if ( !(unsigned int)sub_1400065B0(v25, v8, a3, a4, a5) && !(unsigned int)sub_140006530((__int64)v25, a3, a4, a5) )
    {
      sub_140006BF0((__int64)v25, a3, a4, a5);
      goto LABEL_37;
    }
    sub_140006800((__int64)v25);
  }
  sub_140006D20((_QWORD **)&v25);
LABEL_37:
  if ( v11 )
  {
    v18 = (unsigned __int8 *)(v8 + 8304);
    do
    {
      v19 = (unsigned __int8)v11[(_QWORD)v18 - 8304 - v8];
      v20 = *v18 - v19;
      if ( *v18 != v19 )
        break;
      ++v18;
    }
    while ( v19 );
    if ( v20 )
    {
      v21 = (char *)(v8 + 12400);
      if ( (signed int)sub_140001E90(4096i64, v8 + 12400, (__int64)"%s", a3, a4, a5, v25) >= 4096 )
        return 0xFFFFFFFFi64;
      *(_DWORD *)(v8 + 20596) = 1;
      do
      {
        v22 = *v21;
        v21[4096] = *v21;
        ++v21;
      }
      while ( v22 );
    }
    nullsub_1(v8);
    v23 = sub_1400033F0(v8, a3, a4, a5);
    sub_1400035A0(v8);
    sub_140006800((__int64)v25);
    sub_140006D20((_QWORD **)&v25);
    result = v23;
  }
  else
  {
    if ( (unsigned int)sub_140003450((__int64)v25, v8, v12, a3, a4, a5) )
      return 0xFFFFFFFFi64;
    sub_140007F90("_MEIPASS2", (LPCSTR)(v8 + 12400), a3, a4, a5);
    sub_140007B20("_MEIPASS2", a3, a4, a5);
    ((void (*)(void))nullsub_1)();
    v24 = sub_140008040(&v27, a3, a4, a5);
    sub_140006800((__int64)v25);
    sub_140006D20((_QWORD **)&v25);
    if ( *(_DWORD *)(v8 + 20596) == 1 )
      sub_140007D00((const CHAR *)(v8 + 12400), a3, a4, a5);
    sub_140001E20((LPVOID *)v8);
    result = v24;
  }
  return result;
}
// 1400035A0: using guessed type __int64 __fastcall sub_1400035A0(_QWORD);
// 1400035B0: using guessed type __int64 __fastcall nullsub_1(_QWORD);

//----- (0000000140003D20) ----------------------------------------------------
signed __int64 __fastcall sub_140003D20(__int64 a1, char *a2)
{
  __int64 v2; // r8
  char v3; // al
  signed __int64 v4; // rax

  v2 = a1 - (_QWORD)a2;
  do
  {
    v3 = *a2;
    a2[v2] = *a2;
    ++a2;
  }
  while ( v3 );
  v4 = -1i64;
  while ( *(_BYTE *)(a1 + v4++ + 1) != 0 )
    ;
  *(_DWORD *)(v4 + a1 - 3) = 6777712;
  return 1i64;
}

//----- (0000000140003D70) ----------------------------------------------------
signed __int64 __fastcall sub_140003D70(__int64 a1, __m128i *a2)
{
  __m128i *v2; // rbx
  __int64 v3; // rdi
  __m128i *v4; // rax
  __int64 v5; // rdi
  char v6; // al

  v2 = a2;
  v3 = a1;
  v4 = sub_14000D508(a2, 92);
  if ( v4 || (v4 = sub_14000D508(v2, 47)) != 0i64 )
    v2 = (__m128i *)((char *)v4 + 1);
  v5 = v3 - (_QWORD)v2;
  do
  {
    v6 = v2->m128i_i64[0];
    *((_BYTE *)v2->m128i_i64 + v5) = v2->m128i_i64[0];
    v2 = (__m128i *)((char *)v2 + 1);
  }
  while ( v6 );
  return 1i64;
}

//----- (0000000140003DD0) ----------------------------------------------------
signed __int64 __usercall sub_140003DD0@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __m128i *v4; // rbx
  signed __int64 v6; // rax
  __m128i *v8; // rax

  v4 = (__m128i *)a1;
  if ( (signed int)sub_140001E90(4096i64, a1, (__int64)"%s", a2, a3, a4) >= 4096 )
    return 0i64;
  v6 = -1i64;
  while ( *((_BYTE *)v4->m128i_i64 + v6++ + 1) != 0 )
    ;
  if ( *((_BYTE *)v4->m128i_i64 + v6 - 1) == 92 )
    *((_BYTE *)v4->m128i_i64 + v6 - 1) = 0;
  v8 = sub_14000D508(v4, 92);
  if ( v8 )
    LOBYTE(v8->m128i_i64[0]) = 0;
  else
    LOWORD(v4->m128i_i64[0]) = 46;
  return 1i64;
}

//----- (0000000140003E50) ----------------------------------------------------
signed __int64 __usercall sub_140003E50@<rax>(CHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  CHAR *v4; // rbx
  __int64 v5; // r8
  __int64 v6; // r9
  signed __int64 result; // rax
  WCHAR Filename; // [rsp+20h] [rbp-2018h]

  v4 = a1;
  if ( GetModuleFileNameW(0i64, &Filename, 0x1000u) )
  {
    if ( sub_140008BB0(v4, &Filename, 4096, a2, a3, a4) )
    {
      result = 1i64;
    }
    else
    {
      sub_140002AD0((__int64)"Failed to convert executable path to UTF-8.\n", a2, a3, a4);
      result = 0i64;
    }
  }
  else
  {
    sub_140002980((__int64)"Failed to get executable path.\n", (__int64)"GetModuleFileNameW", a2, a3, a4, v5, v6);
    result = 0i64;
  }
  return result;
}

//----- (0000000140003EF0) ----------------------------------------------------
_BOOL8 __usercall sub_140003EF0@<rax>(const CHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  WCHAR WideCharStr; // [rsp+50h] [rbp-2028h]

  sub_140008AA0(&WideCharStr, a1, 4096, a2, a3, a4);
  return (unsigned int)sub_140015DFC(&WideCharStr) == 0;
}

//----- (0000000140003F60) ----------------------------------------------------
__int64 __usercall sub_140003F60@<rax>(const CHAR *a1@<rdx>, const CHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  const CHAR *v5; // rbx
  WCHAR v7; // [rsp+20h] [rbp-2038h]
  WCHAR WideCharStr; // [rsp+40h] [rbp-2018h]

  v5 = a1;
  sub_140008AA0(&WideCharStr, a2, 4096, a3, a4, a5);
  sub_140008AA0(&v7, v5, 10, a3, a4, a5);
  return sub_1400163B8((__int16 *)&v7, &WideCharStr, a3, a4, a5);
}

//----- (0000000140003FE0) ----------------------------------------------------
_BYTE *__usercall sub_140003FE0@<rax>(__int64 a1@<rcx>, char *a2@<r8>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  char *v5; // rsi
  _BYTE *v6; // rdi
  int v7; // eax
  signed __int64 v8; // rcx
  signed __int64 v9; // rbx
  unsigned __int64 v10; // rbp
  unsigned __int64 v11; // rax
  _BYTE *result; // rax

  v5 = a2;
  v6 = (_BYTE *)a1;
  v7 = sub_140001E90(4096i64, a1, (__int64)"%s", a3, a4, a5);
  v8 = v7;
  if ( (unsigned __int64)v7 >= 0xFFF )
    return 0i64;
  if ( v6[v7 - 1] != 92 )
  {
    *(_WORD *)&v6[v7] = 92;
    v8 = v7 + 2i64;
  }
  v9 = -1i64;
  v10 = 4096 - v8;
  v11 = -1i64;
  do
    ++v11;
  while ( v5[v11] );
  if ( v11 >= v10 )
    return 0i64;
  if ( v5[v11 - 1] == 92 )
  {
    sub_140015E40(v6, v5, v10);
    while ( v6[v9++ + 1] != 0 )
      ;
    v6[v9 - 1] = 0;
    result = v6;
  }
  else
  {
    sub_140015E40(v6, v5, v10);
    result = v6;
  }
  return result;
}

//----- (00000001400040A0) ----------------------------------------------------
signed __int64 __usercall sub_1400040A0@<rax>(const CHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  WCHAR WideCharStr; // [rsp+20h] [rbp-2018h]

  sub_140008AA0(&WideCharStr, a1, 4096, a2, a3, a4);
  return sub_140008910(&WideCharStr, a2, a3, a4);
}

//----- (0000000140004100) ----------------------------------------------------
__int64 __usercall sub_140004100@<rax>(const CHAR *a1@<rdx>, const CHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  const CHAR *v5; // rbx
  const CHAR *v6; // rdi
  DWORD v7; // er8
  WCHAR TargetFileName; // [rsp+20h] [rbp-4018h]
  WCHAR SymlinkFileName; // [rsp+2020h] [rbp-2018h]

  v5 = a1;
  v6 = a2;
  if ( sub_140008AA0(&TargetFileName, a2, 4096, a3, a4, a5) && sub_140008AA0(&SymlinkFileName, v5, 4096, a3, a4, a5) )
  {
    v7 = 0;
    if ( dword_14003E000 )
      v7 = 2;
    if ( CreateSymbolicLinkW(&SymlinkFileName, &TargetFileName, v7) )
      return 0i64;
    if ( dword_14003E000 && GetLastError() == 87 )
    {
      dword_14003E000 = 0;
      return sub_140004100(v6, v5);
    }
  }
  return 0xFFFFFFFFi64;
}
// 14003E000: using guessed type int dword_14003E000;

//----- (00000001400041E0) ----------------------------------------------------
__int64 __usercall sub_1400041E0@<rax>(_QWORD *a1@<rdx>, const CHAR *a2@<rcx>, __m256i *a3@<ymm0>)
{
  _QWORD *v3; // rbx
  _WORD *v4; // rax
  char v6; // [rsp+20h] [rbp-2028h]

  v3 = a1;
  sub_14001722C(a2, (WCHAR *)&v6, 0x1000ui64, a3);
  v4 = sub_1400178B4((__int64)&v6, a3);
  *v3 = v4;
  return (unsigned int)(v4 != 0i64) - 1;
}

//----- (0000000140004250) ----------------------------------------------------
signed __int64 __fastcall sub_140004250(_DWORD *a1)
{
  _DWORD *v1; // rbx
  __int128 *v3; // rax
  __int128 v4; // xmm0
  __int128 v5; // xmm1
  __int128 *v6; // rax
  __int128 v7; // xmm0
  __int128 v8; // xmm1
  __int128 *v9; // rax
  __int128 v10; // xmm0
  __int128 v11; // xmm1

  v1 = a1;
  switch ( dword_14003EC94 )
  {
    case 308:
    case 309:
      v9 = (__int128 *)sub_14002A5B0();
      v10 = *v9;
      v11 = v9[1];
      v1[62] = 1;
      break;
    case 310:
      v6 = (__int128 *)sub_14002A5B0();
      v7 = *v6;
      v8 = v6[1];
      v1[70] = 1;
      break;
    case 311:
    case 312:
      v3 = (__int128 *)sub_14002A5B0();
      v4 = *v3;
      v5 = v3[1];
      v1[76] = 1;
      break;
    default:
      return 0xFFFFFFFFi64;
  }
  return (unsigned int)-((unsigned int)sub_14002A5B0() != 0);
}
// 14003EC94: using guessed type int dword_14003EC94;

//----- (0000000140004360) ----------------------------------------------------
signed __int64 __usercall sub_140004360@<rax>(const CHAR *a1@<r8>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  WCHAR *v4; // rbx
  __int128 *v6; // rax
  __int128 v7; // ST30_16
  __int128 v8; // ST50_16

  v4 = sub_140008AA0(0i64, a1, 0, a2, a3, a4);
  if ( !v4 )
    return 0xFFFFFFFFi64;
  v6 = (__int128 *)sub_14002A5B0();
  v7 = *v6;
  v8 = v6[1];
  sub_140014F8C(v4);
  return (unsigned int)-((unsigned int)sub_14002A5B0() != 0);
}
// 14003ECF0: using guessed type __int64 qword_14003ECF0;
// 14003EDA8: using guessed type __int64 qword_14003EDA8;

//----- (0000000140004420) ----------------------------------------------------
__int64 sub_140004420()
{
  switch ( dword_14003EC94 )
  {
    case 308:
      return sub_140014F84(1i64, 360i64);
    case 309:
      return sub_140014F84(1i64, 392i64);
    case 310:
      return sub_140014F84(1i64, 400i64);
    case 311:
    case 312:
      return sub_140014F84(1i64, 432i64);
  }
  return 0i64;
}
// 140014F84: using guessed type __int64 __fastcall sub_140014F84(_QWORD, _QWORD);
// 14003EC94: using guessed type int dword_14003EC94;

//----- (0000000140004490) ----------------------------------------------------
void __fastcall sub_140004490(void *a1)
{
  void *v1; // rbx

  v1 = a1;
  sub_14002A5B0();
  sub_140014F8C(v1);
}
// 14003ECD0: using guessed type __int64 qword_14003ECD0;

//----- (00000001400044C0) ----------------------------------------------------
__int64 __fastcall sub_1400044C0(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // ST80_4
  int v3; // ST84_4
  __int128 *v4; // rax
  __int128 v5; // xmm0
  __int128 v6; // ST30_16

  v1 = a1;
  sub_14002A5B0();
  v2 = *(_DWORD *)(v1 + 20);
  v3 = *(_DWORD *)(v1 + 24);
  v4 = (__int128 *)sub_14002A5B0();
  v5 = *v4;
  v6 = v4[1];
  return (unsigned int)-((unsigned int)sub_14002A5B0() != 0);
}

//----- (0000000140004560) ----------------------------------------------------
signed __int64 __usercall sub_140004560@<rax>(__int64 a1@<rdx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  int v4; // ebx
  __int64 v5; // rbp
  int v6; // esi
  LPVOID *v7; // r15
  int v9; // er12
  __int64 v10; // rdi
  WCHAR *v11; // rax
  __int128 *v12; // rax
  __int128 v13; // xmm0
  __int128 v14; // ST40_16
  LPVOID *v15; // rdi

  v4 = 0;
  v5 = a1;
  v6 = 0;
  v7 = (LPVOID *)sub_140014F84(*(signed int *)(a1 + 20604), 8i64);
  if ( !v7 )
    return 0xFFFFFFFFi64;
  v9 = 0;
  if ( *(_DWORD *)(v5 + 20604) <= 0 )
    goto LABEL_22;
  v10 = 0i64;
  do
  {
    v11 = sub_140008AA0(0i64, *(LPCSTR *)(v10 * 8 + *(_QWORD *)(v5 + 20608)), 0, a2, a3, a4);
    v7[v10] = v11;
    ++v10;
    if ( !v11 )
      v6 = -1;
    ++v9;
  }
  while ( v9 < *(_DWORD *)(v5 + 20604) );
  if ( v6 >= -1 )
  {
LABEL_22:
    if ( dword_14003EC94 == 308
      || dword_14003EC94 == 309
      || dword_14003EC94 == 310
      || dword_14003EC94 == 311
      || dword_14003EC94 == 312 )
    {
      v12 = (__int128 *)sub_14002A5B0();
      v13 = *v12;
      v14 = v12[1];
      v6 = -((unsigned int)sub_14002A5B0() != 0);
    }
    else
    {
      v6 = -1;
    }
  }
  if ( *(_DWORD *)(v5 + 20604) > 0 )
  {
    v15 = v7;
    do
    {
      sub_140014F8C(*v15);
      ++v4;
      ++v15;
    }
    while ( v4 < *(_DWORD *)(v5 + 20604) );
  }
  sub_140014F8C(v7);
  return (unsigned int)v6;
}
// 140014F84: using guessed type __int64 __fastcall sub_140014F84(_QWORD, _QWORD);
// 14003EC94: using guessed type int dword_14003EC94;
// 14003ECF8: using guessed type __int64 qword_14003ECF8;
// 14003EDA8: using guessed type __int64 qword_14003EDA8;

//----- (00000001400046D0) ----------------------------------------------------
signed __int64 __usercall sub_1400046D0@<rax>(__int64 a1@<rdx>, _DWORD *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  signed __int64 v5; // rsi
  _DWORD *v6; // r15
  signed __int64 v7; // rbx
  signed int v8; // edi
  signed __int64 v9; // r14
  __int64 v10; // rsi
  WCHAR *v11; // rax
  __int64 v13; // [rsp+20h] [rbp-2098h]
  __int64 v14; // [rsp+20h] [rbp-2098h]
  LPCSTR lpMultiByteStr; // [rsp+30h] [rbp-2088h]
  char *v16; // [rsp+38h] [rbp-2080h]
  __int64 v17; // [rsp+40h] [rbp-2078h]
  __int64 v18[3]; // [rsp+48h] [rbp-2070h]
  char v19; // [rsp+60h] [rbp-2058h]
  char v20; // [rsp+1070h] [rbp-1048h]

  v5 = a1 + 16496;
  v6 = a2;
  v7 = 0i64;
  LODWORD(v13) = 92;
  v8 = 0;
  if ( (signed int)sub_140001E90(4096i64, (__int64)&v19, (__int64)"%s%c%s", a3, a4, a5, v13, "base_library.zip") >= 4096 )
    return 0xFFFFFFFFi64;
  LODWORD(v14) = 92;
  if ( (signed int)sub_140001E90(4096i64, (__int64)&v20, (__int64)"%s%c%s", a3, a4, a5, v14, "lib-dynload") >= 4096 )
    return 0xFFFFFFFFi64;
  lpMultiByteStr = &v19;
  v17 = v5;
  v16 = &v20;
  v9 = 3i64;
  v10 = 0i64;
  do
  {
    v11 = sub_140008AA0(0i64, (&lpMultiByteStr)[v10], 0, a3, a4, a5);
    v18[v10] = (__int64)v11;
    ++v10;
    if ( !v11 )
      v8 = -1;
    --v9;
  }
  while ( v9 );
  if ( v8 >= -1 )
    v8 = sub_140004250(v6);
  do
    sub_140014F8C((LPVOID)v18[v7++]);
  while ( v7 < 3 );
  return (unsigned int)v8;
}
// 1400046D0: using guessed type __int64 var_2070[3];

//----- (0000000140004830) ----------------------------------------------------
signed __int64 __usercall sub_140004830@<rax>(__int64 a1@<rdx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  const CHAR *v4; // r8

  if ( dword_14003EC94 != 308 )
  {
    switch ( dword_14003EC94 )
    {
      case 309:
        v4 = (const CHAR *)(a1 + 4208);
        break;
      case 310:
        v4 = (const CHAR *)(a1 + 4208);
        break;
      case 311:
      case 312:
        v4 = (const CHAR *)(a1 + 4208);
        break;
      default:
        return 0xFFFFFFFFi64;
    }
    if ( (signed int)sub_140004360(v4, a2, a3, a4) >= 0 )
      return 0i64;
    return 0xFFFFFFFFi64;
  }
  return (unsigned int)((signed int)sub_140004360((const CHAR *)(a1 + 4208), a2, a3, a4) >= 0) - 1;
}
// 14003EC94: using guessed type int dword_14003EC94;

//----- (00000001400048C0) ----------------------------------------------------
signed __int64 __usercall sub_1400048C0@<rax>(__int64 a1@<rdx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  switch ( dword_14003EC94 )
  {
    case 308:
    case 309:
      return sub_140004360((const CHAR *)(a1 + 16496), a2, a3, a4);
    case 310:
      return sub_140004360((const CHAR *)(a1 + 16496), a2, a3, a4);
    case 311:
    case 312:
      return sub_140004360((const CHAR *)(a1 + 16496), a2, a3, a4);
  }
  return 0xFFFFFFFFi64;
}
// 14003EC94: using guessed type int dword_14003EC94;

//----- (0000000140004930) ----------------------------------------------------
signed __int64 __fastcall sub_140004930(_DWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // ST20_8
  __int128 *v4; // rax
  __int128 v5; // xmm0
  __int128 v6; // ST40_16
  __int64 v7; // ST20_8
  __int128 *v8; // rax
  __int128 v9; // xmm0
  __int128 v10; // ST40_16
  __int64 v12; // ST20_8
  __int128 *v13; // rax
  __int128 v14; // xmm0
  __int128 v15; // ST40_16
  __int64 v16; // ST20_8
  __int128 *v17; // rax
  __int128 v18; // xmm0
  __int128 v19; // ST40_16
  __int64 v20; // ST20_8
  __int128 *v21; // rax
  __int128 v22; // xmm0
  __int128 v23; // ST40_16
  __int64 v24; // ST20_8
  __int128 *v25; // rax
  __int128 v26; // xmm0
  __int128 v27; // ST40_16

  v2 = a2;
  if ( dword_14003EC94 != 308 )
  {
    if ( dword_14003EC94 == 309 )
    {
      a1[46] = 1;
      a1[36] = 0;
      a1[42] = 0;
      a1[40] = *(_DWORD *)(a2 + 8);
      a1[47] = *(_DWORD *)(a2 + 4) == 0;
      a1[43] = *(_DWORD *)a2;
      a1[5] = *(_DWORD *)(a2 + 12);
      a1[6] = *(_DWORD *)(a2 + 16);
      a1[3] = *(_DWORD *)(a2 + 24);
      if ( *(_DWORD *)(a2 + 28) )
      {
        v16 = *(_QWORD *)(a2 + 32);
        v17 = (__int128 *)sub_14002A5B0();
        v18 = *v17;
        v19 = v17[1];
        if ( (unsigned int)sub_14002A5B0() )
          return 0xFFFFFFFFi64;
      }
      if ( !*(_DWORD *)(v2 + 40) )
        return 0i64;
    }
    else
    {
      if ( dword_14003EC94 != 310 )
      {
        if ( dword_14003EC94 == 311 || dword_14003EC94 == 312 )
        {
          a1[53] = 1;
          a1[42] = 0;
          a1[49] = 0;
          a1[47] = *(_DWORD *)(a2 + 8);
          a1[54] = *(_DWORD *)(a2 + 4) == 0;
          a1[50] = *(_DWORD *)a2;
          a1[5] = *(_DWORD *)(a2 + 12);
          a1[6] = *(_DWORD *)(a2 + 16);
          a1[3] = *(_DWORD *)(a2 + 24);
          if ( !*(_DWORD *)(a2 + 28)
            || (v3 = *(_QWORD *)(a2 + 32),
                v4 = (__int128 *)sub_14002A5B0(),
                v5 = *v4,
                v6 = v4[1],
                !(unsigned int)sub_14002A5B0()) )
          {
            if ( !*(_DWORD *)(v2 + 40) )
              return 0i64;
            goto LABEL_9;
          }
        }
        return 0xFFFFFFFFi64;
      }
      a1[49] = 1;
      a1[38] = 0;
      a1[45] = 0;
      a1[43] = *(_DWORD *)(a2 + 8);
      a1[50] = *(_DWORD *)(a2 + 4) == 0;
      a1[46] = *(_DWORD *)a2;
      a1[5] = *(_DWORD *)(a2 + 12);
      a1[6] = *(_DWORD *)(a2 + 16);
      a1[3] = *(_DWORD *)(a2 + 24);
      if ( *(_DWORD *)(a2 + 28) )
      {
        v12 = *(_QWORD *)(a2 + 32);
        v13 = (__int128 *)sub_14002A5B0();
        v14 = *v13;
        v15 = v13[1];
        if ( (unsigned int)sub_14002A5B0() )
          return 0xFFFFFFFFi64;
      }
      if ( !*(_DWORD *)(v2 + 40) )
        return 0i64;
    }
LABEL_9:
    v7 = *(_QWORD *)(v2 + 48);
    v8 = (__int128 *)sub_14002A5B0();
    v9 = *v8;
    v10 = v8[1];
    if ( !(unsigned int)sub_14002A5B0() )
      return 0i64;
    return 0xFFFFFFFFi64;
  }
  a1[46] = 1;
  a1[36] = 0;
  a1[42] = 0;
  a1[40] = *(_DWORD *)(a2 + 8);
  a1[47] = *(_DWORD *)(a2 + 4) == 0;
  a1[43] = *(_DWORD *)a2;
  a1[5] = *(_DWORD *)(a2 + 12);
  a1[6] = *(_DWORD *)(a2 + 16);
  a1[3] = *(_DWORD *)(a2 + 24);
  if ( *(_DWORD *)(a2 + 28) )
  {
    v20 = *(_QWORD *)(a2 + 32);
    v21 = (__int128 *)sub_14002A5B0();
    v22 = *v21;
    v23 = v21[1];
    if ( (unsigned int)sub_14002A5B0() )
      return 0xFFFFFFFFi64;
  }
  if ( !*(_DWORD *)(v2 + 40) )
    return 0i64;
  v24 = *(_QWORD *)(v2 + 48);
  v25 = (__int128 *)sub_14002A5B0();
  v26 = *v25;
  v27 = v25[1];
  return (unsigned int)-((unsigned int)sub_14002A5B0() != 0);
}
// 14003EC94: using guessed type int dword_14003EC94;

//----- (0000000140004D00) ----------------------------------------------------
void __fastcall sub_140004D00(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rbx
  int v3; // edi
  int v4; // esi
  __int64 v5; // rbp
  __int64 v6; // rsi

  if ( a1 )
  {
    v1 = *(_DWORD *)(a1 + 28);
    v2 = a1;
    v3 = 0;
    if ( v1 )
    {
      v4 = 0;
      if ( v1 > 0 )
      {
        v5 = 0i64;
        do
        {
          sub_140014F8C(*(LPVOID *)(*(_QWORD *)(v2 + 32) + v5));
          ++v4;
          v5 += 8i64;
        }
        while ( v4 < *(_DWORD *)(v2 + 28) );
      }
    }
    sub_140014F8C(*(LPVOID *)(v2 + 32));
    if ( *(_DWORD *)(v2 + 40) > 0 )
    {
      v6 = 0i64;
      do
      {
        sub_140014F8C(*(LPVOID *)(*(_QWORD *)(v2 + 48) + v6));
        ++v3;
        v6 += 8i64;
      }
      while ( v3 < *(_DWORD *)(v2 + 40) );
    }
    sub_140014F8C(*(LPVOID *)(v2 + 48));
    sub_140014F8C((LPVOID)v2);
  }
}

//----- (0000000140004DA0) ----------------------------------------------------
__int64 __usercall sub_140004DA0@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // r15
  int v3; // ebp
  int v4; // er14
  __int64 result; // rax
  _QWORD *v6; // rbx
  char *i; // rsi
  __int64 v8; // rcx
  char v9; // al
  char v10; // al
  _BYTE *v11; // rcx
  __int64 v12; // rax
  char *v13; // rsi
  char v14; // al
  unsigned __int8 *v15; // rcx
  int v16; // edx
  char v17; // al
  unsigned __int8 *v18; // rcx
  int v19; // er8
  int v20; // eax
  int v21; // esi
  __int64 v22; // rdi
  int v23; // eax
  int v24; // esi
  __int64 v25; // rdi

  v2 = a1;
  v3 = 0;
  v4 = 0;
  result = sub_140014F84(1i64, 56i64);
  v6 = (_QWORD *)result;
  if ( result )
  {
    *(_DWORD *)(result + 20) = -1;
    for ( i = *(char **)(v2 + 8); (unsigned __int64)i < *(_QWORD *)(v2 + 16); i = sub_140001A30(v2, (signed int *)i) )
    {
      if ( (unsigned int)sub_140014FC0(i + 18, (__int64)"pyi-", 4ui64) )
      {
        if ( i[18] != 118 || i[19] )
        {
          v8 = 0i64;
          while ( 1 )
          {
            v9 = i[v8++ + 18];
            if ( v9 != aVerbose[v8 - 1] )
              break;
            if ( v8 == 8 )
              goto LABEL_9;
          }
          if ( (i[18] != 117 || i[19]) && (unsigned int)sub_1400172E0((unsigned __int8 *)i + 18, (__int64)"unbuffered") )
          {
            if ( (i[18] != 79 || i[19]) && (unsigned int)sub_1400172E0((unsigned __int8 *)i + 18, (__int64)"optimize") )
            {
              if ( (unsigned int)sub_140014FC0(i + 18, (__int64)"W ", 2ui64) )
              {
                if ( (unsigned int)sub_140014FC0(i + 18, (__int64)"X ", 2ui64) )
                {
                  if ( !(unsigned int)sub_140014FC0(i + 18, (__int64)"hash_seed", 9ui64) )
                  {
                    v10 = i[27];
                    v11 = i + 27;
                    if ( !v10 )
                      goto LABEL_25;
                    if ( v10 == 61 || v10 == 32 )
                    {
                      v11 = i + 28;
LABEL_25:
                      if ( v11 && *v11 )
                      {
                        *((_DWORD *)v6 + 3) = 1;
                        *((_DWORD *)v6 + 4) = sub_140016EC8(0i64, (__int64)v11, 0xAu, a2);
                      }
                      continue;
                    }
                  }
                }
                else
                {
                  ++v4;
                }
              }
              else
              {
                ++v3;
              }
            }
            else
            {
              ++*((_DWORD *)v6 + 2);
            }
          }
          else
          {
            *((_DWORD *)v6 + 1) = 1;
          }
        }
        else
        {
LABEL_9:
          ++*(_DWORD *)v6;
        }
      }
    }
    v6[4] = sub_140014F84(v3, 8i64);
    v12 = sub_140014F84(v4, 8i64);
    v6[6] = v12;
    if ( v6[4] && v12 )
    {
      v13 = *(char **)(v2 + 8);
      if ( (unsigned __int64)v13 < *(_QWORD *)(v2 + 16) )
      {
        while ( 1 )
        {
          if ( !(unsigned int)sub_140014FC0(v13 + 18, (__int64)"W ", 2ui64) )
          {
            if ( (signed int)sub_1400041E0((_QWORD *)(v6[4] + 8i64 * *((signed int *)v6 + 7)), v13 + 20, a2) < 0 )
              goto LABEL_63;
            ++*((_DWORD *)v6 + 7);
            goto LABEL_61;
          }
          if ( (unsigned int)sub_140014FC0(v13 + 18, (__int64)"X ", 2ui64) )
            goto LABEL_61;
          if ( (signed int)sub_1400041E0((_QWORD *)(v6[6] + 8i64 * *((signed int *)v6 + 10)), v13 + 20, a2) < 0 )
            goto LABEL_63;
          ++*((_DWORD *)v6 + 10);
          if ( !(unsigned int)sub_140014FC0(v13 + 20, (__int64)"utf8", 4ui64) )
          {
            v14 = v13[24];
            v15 = (unsigned __int8 *)(v13 + 24);
            if ( !v14 )
              goto LABEL_44;
            if ( v14 == 61 || v14 == 32 )
              break;
          }
LABEL_50:
          if ( !(unsigned int)sub_140014FC0(v13 + 20, (__int64)"dev", 3ui64) )
          {
            v17 = v13[23];
            v18 = (unsigned __int8 *)(v13 + 23);
            if ( !v17 )
              goto LABEL_55;
            if ( v17 == 61 || v17 == 32 )
            {
              v18 = (unsigned __int8 *)(v13 + 24);
LABEL_55:
              if ( v18 )
              {
                if ( *v18 )
                {
                  v19 = *v18 - 48;
                  if ( *v18 == 48 )
                    v19 = v18[1];
                  *((_DWORD *)v6 + 6) = v19 != 0;
                }
                else
                {
                  *((_DWORD *)v6 + 6) = 1;
                }
              }
              goto LABEL_61;
            }
          }
LABEL_61:
          v13 = sub_140001A30(v2, (signed int *)v13);
          if ( (unsigned __int64)v13 >= *(_QWORD *)(v2 + 16) )
            goto LABEL_72;
        }
        v15 = (unsigned __int8 *)(v13 + 25);
LABEL_44:
        if ( v15 )
        {
          if ( *v15 )
          {
            v16 = *v15 - 48;
            if ( *v15 == 48 )
              v16 = v15[1];
            *((_DWORD *)v6 + 5) = v16 != 0;
          }
          else
          {
            *((_DWORD *)v6 + 5) = 1;
          }
        }
        goto LABEL_50;
      }
    }
    else
    {
LABEL_63:
      v20 = *((_DWORD *)v6 + 7);
      if ( v20 )
      {
        v21 = 0;
        if ( v20 > 0 )
        {
          v22 = 0i64;
          do
          {
            sub_140014F8C(*(LPVOID *)(v22 + v6[4]));
            ++v21;
            v22 += 8i64;
          }
          while ( v21 < *((_DWORD *)v6 + 7) );
        }
      }
      sub_140014F8C((LPVOID)v6[4]);
      v23 = *((_DWORD *)v6 + 10);
      if ( v23 )
      {
        v24 = 0;
        if ( v23 > 0 )
        {
          v25 = 0i64;
          do
          {
            sub_140014F8C(*(LPVOID *)(v25 + v6[6]));
            ++v24;
            v25 += 8i64;
          }
          while ( v24 < *((_DWORD *)v6 + 10) );
        }
      }
      sub_140014F8C((LPVOID)v6[6]);
      sub_140014F8C(v6);
      v6 = 0i64;
    }
LABEL_72:
    result = (__int64)v6;
  }
  return result;
}
// 140014F84: using guessed type __int64 __fastcall sub_140014F84(_QWORD, _QWORD);

//----- (00000001400051A0) ----------------------------------------------------
__int64 __usercall sub_1400051A0@<rax>(HMODULE hModule@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  HMODULE v4; // rbx
  __int64 v5; // r8
  __int64 v6; // r9
  const char *v7; // rdx

  v4 = hModule;
  qword_14003EC98 = (__int64)GetProcAddress(hModule, "Py_DecRef");
  if ( !qword_14003EC98 )
  {
    v7 = "Failed to get address for Py_DecRef\n";
LABEL_3:
    sub_140002980((__int64)v7, (__int64)"GetProcAddress", a2, a3, a4, v5, v6);
    return 0xFFFFFFFFi64;
  }
  qword_14003ECA0 = (__int64)GetProcAddress(v4, "Py_DecodeLocale");
  if ( !qword_14003ECA0 )
  {
    v7 = "Failed to get address for Py_DecodeLocale\n";
    goto LABEL_3;
  }
  qword_14003ECA8 = (__int64)GetProcAddress(v4, "Py_ExitStatusException");
  if ( !qword_14003ECA8 )
  {
    v7 = "Failed to get address for Py_ExitStatusException\n";
    goto LABEL_3;
  }
  qword_14003ECB0 = (__int64)GetProcAddress(v4, "Py_Finalize");
  if ( !qword_14003ECB0 )
  {
    v7 = "Failed to get address for Py_Finalize\n";
    goto LABEL_3;
  }
  qword_14003ECB8 = (__int64)GetProcAddress(v4, "Py_InitializeFromConfig");
  if ( !qword_14003ECB8 )
  {
    v7 = "Failed to get address for Py_InitializeFromConfig\n";
    goto LABEL_3;
  }
  qword_14003ECC0 = (__int64)GetProcAddress(v4, "Py_IsInitialized");
  if ( !qword_14003ECC0 )
  {
    v7 = "Failed to get address for Py_IsInitialized\n";
    goto LABEL_3;
  }
  qword_14003ECC8 = (__int64)GetProcAddress(v4, "Py_PreInitialize");
  if ( !qword_14003ECC8 )
  {
    v7 = "Failed to get address for Py_PreInitialize\n";
    goto LABEL_3;
  }
  qword_14003ECD0 = (__int64)GetProcAddress(v4, "PyConfig_Clear");
  if ( !qword_14003ECD0 )
  {
    v7 = "Failed to get address for PyConfig_Clear\n";
    goto LABEL_3;
  }
  qword_14003ECD8 = (__int64)GetProcAddress(v4, "PyConfig_InitIsolatedConfig");
  if ( !qword_14003ECD8 )
  {
    v7 = "Failed to get address for PyConfig_InitIsolatedConfig\n";
    goto LABEL_3;
  }
  qword_14003ECE0 = (__int64)GetProcAddress(v4, "PyConfig_Read");
  if ( !qword_14003ECE0 )
  {
    v7 = "Failed to get address for PyConfig_Read\n";
    goto LABEL_3;
  }
  qword_14003ECE8 = (__int64)GetProcAddress(v4, "PyConfig_SetBytesString");
  if ( !qword_14003ECE8 )
  {
    v7 = "Failed to get address for PyConfig_SetBytesString\n";
    goto LABEL_3;
  }
  qword_14003ECF0 = (__int64)GetProcAddress(v4, "PyConfig_SetString");
  if ( !qword_14003ECF0 )
  {
    v7 = "Failed to get address for PyConfig_SetString\n";
    goto LABEL_3;
  }
  qword_14003ECF8 = (__int64)GetProcAddress(v4, "PyConfig_SetWideStringList");
  if ( !qword_14003ECF8 )
  {
    v7 = "Failed to get address for PyConfig_SetWideStringList\n";
    goto LABEL_3;
  }
  qword_14003ED00 = (__int64)GetProcAddress(v4, "PyErr_Clear");
  if ( !qword_14003ED00 )
  {
    v7 = "Failed to get address for PyErr_Clear\n";
    goto LABEL_3;
  }
  qword_14003ED08 = (__int64)GetProcAddress(v4, "PyErr_Fetch");
  if ( !qword_14003ED08 )
  {
    v7 = "Failed to get address for PyErr_Fetch\n";
    goto LABEL_3;
  }
  qword_14003ED10 = (__int64)GetProcAddress(v4, "PyErr_NormalizeException");
  if ( !qword_14003ED10 )
  {
    v7 = "Failed to get address for PyErr_NormalizeException\n";
    goto LABEL_3;
  }
  qword_14003ED18 = (__int64)GetProcAddress(v4, "PyErr_Occurred");
  if ( !qword_14003ED18 )
  {
    v7 = "Failed to get address for PyErr_Occurred\n";
    goto LABEL_3;
  }
  qword_14003ED20 = (__int64)GetProcAddress(v4, "PyErr_Print");
  if ( !qword_14003ED20 )
  {
    v7 = "Failed to get address for PyErr_Print\n";
    goto LABEL_3;
  }
  qword_14003ED28 = (__int64)GetProcAddress(v4, "PyErr_Restore");
  if ( !qword_14003ED28 )
  {
    v7 = "Failed to get address for PyErr_Restore\n";
    goto LABEL_3;
  }
  qword_14003ED30 = (__int64)GetProcAddress(v4, "PyEval_EvalCode");
  if ( !qword_14003ED30 )
  {
    v7 = "Failed to get address for PyEval_EvalCode\n";
    goto LABEL_3;
  }
  qword_14003ED38 = (__int64)GetProcAddress(v4, "PyImport_AddModule");
  if ( !qword_14003ED38 )
  {
    v7 = "Failed to get address for PyImport_AddModule\n";
    goto LABEL_3;
  }
  qword_14003ED40 = (__int64)GetProcAddress(v4, "PyImport_ExecCodeModule");
  if ( !qword_14003ED40 )
  {
    v7 = "Failed to get address for PyImport_ExecCodeModule\n";
    goto LABEL_3;
  }
  qword_14003ED48 = (__int64)GetProcAddress(v4, "PyImport_ImportModule");
  if ( !qword_14003ED48 )
  {
    v7 = "Failed to get address for PyImport_ImportModule\n";
    goto LABEL_3;
  }
  qword_14003ED50 = (__int64)GetProcAddress(v4, "PyList_Append");
  if ( !qword_14003ED50 )
  {
    v7 = "Failed to get address for PyList_Append\n";
    goto LABEL_3;
  }
  qword_14003ED58 = (__int64)GetProcAddress(v4, "PyMarshal_ReadObjectFromString");
  if ( !qword_14003ED58 )
  {
    v7 = "Failed to get address for PyMarshal_ReadObjectFromString\n";
    goto LABEL_3;
  }
  qword_14003ED60 = (__int64)GetProcAddress(v4, "PyMem_RawFree");
  if ( !qword_14003ED60 )
  {
    v7 = "Failed to get address for PyMem_RawFree\n";
    goto LABEL_3;
  }
  qword_14003ED68 = (__int64)GetProcAddress(v4, "PyModule_GetDict");
  if ( !qword_14003ED68 )
  {
    v7 = "Failed to get address for PyModule_GetDict\n";
    goto LABEL_3;
  }
  qword_14003ED70 = (__int64)GetProcAddress(v4, "PyObject_CallFunction");
  if ( !qword_14003ED70 )
  {
    v7 = "Failed to get address for PyObject_CallFunction\n";
    goto LABEL_3;
  }
  qword_14003ED78 = (__int64)GetProcAddress(v4, "PyObject_CallFunctionObjArgs");
  if ( !qword_14003ED78 )
  {
    v7 = "Failed to get address for PyObject_CallFunctionObjArgs\n";
    goto LABEL_3;
  }
  qword_14003ED80 = (__int64)GetProcAddress(v4, "PyObject_GetAttrString");
  if ( !qword_14003ED80 )
  {
    v7 = "Failed to get address for PyObject_GetAttrString\n";
    goto LABEL_3;
  }
  qword_14003ED88 = (__int64)GetProcAddress(v4, "PyObject_SetAttrString");
  if ( !qword_14003ED88 )
  {
    v7 = "Failed to get address for PyObject_SetAttrString\n";
    goto LABEL_3;
  }
  qword_14003ED90 = (__int64)GetProcAddress(v4, "PyObject_Str");
  if ( !qword_14003ED90 )
  {
    v7 = "Failed to get address for PyObject_Str\n";
    goto LABEL_3;
  }
  qword_14003ED98 = (__int64)GetProcAddress(v4, "PyPreConfig_InitIsolatedConfig");
  if ( !qword_14003ED98 )
  {
    v7 = "Failed to get address for PyPreConfig_InitIsolatedConfig\n";
    goto LABEL_3;
  }
  qword_14003EDA0 = (__int64)GetProcAddress(v4, "PyRun_SimpleStringFlags");
  if ( !qword_14003EDA0 )
  {
    v7 = "Failed to get address for PyRun_SimpleStringFlags\n";
    goto LABEL_3;
  }
  qword_14003EDA8 = (__int64)GetProcAddress(v4, "PyStatus_Exception");
  if ( !qword_14003EDA8 )
  {
    v7 = "Failed to get address for PyStatus_Exception\n";
    goto LABEL_3;
  }
  qword_14003EDB0 = (__int64)GetProcAddress(v4, "PySys_GetObject");
  if ( !qword_14003EDB0 )
  {
    v7 = "Failed to get address for PySys_GetObject\n";
    goto LABEL_3;
  }
  qword_14003EDB8 = (__int64)GetProcAddress(v4, "PySys_SetObject");
  if ( !qword_14003EDB8 )
  {
    v7 = "Failed to get address for PySys_SetObject\n";
    goto LABEL_3;
  }
  qword_14003EDC0 = (__int64)GetProcAddress(v4, "PyUnicode_AsUTF8");
  if ( !qword_14003EDC0 )
  {
    v7 = "Failed to get address for PyUnicode_AsUTF8\n";
    goto LABEL_3;
  }
  qword_14003EDC8 = (__int64)GetProcAddress(v4, "PyUnicode_Decode");
  if ( !qword_14003EDC8 )
  {
    v7 = "Failed to get address for PyUnicode_Decode\n";
    goto LABEL_3;
  }
  qword_14003EDD0 = (__int64)GetProcAddress(v4, "PyUnicode_DecodeFSDefault");
  if ( !qword_14003EDD0 )
  {
    v7 = "Failed to get address for PyUnicode_DecodeFSDefault\n";
    goto LABEL_3;
  }
  qword_14003EDD8 = (__int64)GetProcAddress(v4, "PyUnicode_FromFormat");
  if ( !qword_14003EDD8 )
  {
    v7 = "Failed to get address for PyUnicode_FromFormat\n";
    goto LABEL_3;
  }
  qword_14003EDE0 = (__int64)GetProcAddress(v4, "PyUnicode_FromString");
  if ( !qword_14003EDE0 )
  {
    v7 = "Failed to get address for PyUnicode_FromString\n";
    goto LABEL_3;
  }
  qword_14003EDE8 = (__int64)GetProcAddress(v4, "PyUnicode_Join");
  if ( !qword_14003EDE8 )
  {
    v7 = "Failed to get address for PyUnicode_Join\n";
    goto LABEL_3;
  }
  qword_14003EDF0 = (__int64)GetProcAddress(v4, "PyUnicode_Replace");
  if ( !qword_14003EDF0 )
  {
    v7 = "Failed to get address for PyUnicode_Replace\n";
    goto LABEL_3;
  }
  return 0i64;
}
// 14003EC98: using guessed type __int64 qword_14003EC98;
// 14003ECA0: using guessed type __int64 qword_14003ECA0;
// 14003ECA8: using guessed type __int64 qword_14003ECA8;
// 14003ECB0: using guessed type __int64 qword_14003ECB0;
// 14003ECB8: using guessed type __int64 qword_14003ECB8;
// 14003ECC0: using guessed type __int64 qword_14003ECC0;
// 14003ECC8: using guessed type __int64 qword_14003ECC8;
// 14003ECD0: using guessed type __int64 qword_14003ECD0;
// 14003ECD8: using guessed type __int64 qword_14003ECD8;
// 14003ECE0: using guessed type __int64 qword_14003ECE0;
// 14003ECE8: using guessed type __int64 qword_14003ECE8;
// 14003ECF0: using guessed type __int64 qword_14003ECF0;
// 14003ECF8: using guessed type __int64 qword_14003ECF8;
// 14003ED00: using guessed type __int64 qword_14003ED00;
// 14003ED08: using guessed type __int64 qword_14003ED08;
// 14003ED10: using guessed type __int64 qword_14003ED10;
// 14003ED18: using guessed type __int64 qword_14003ED18;
// 14003ED20: using guessed type __int64 qword_14003ED20;
// 14003ED28: using guessed type __int64 qword_14003ED28;
// 14003ED30: using guessed type __int64 qword_14003ED30;
// 14003ED38: using guessed type __int64 qword_14003ED38;
// 14003ED40: using guessed type __int64 qword_14003ED40;
// 14003ED48: using guessed type __int64 qword_14003ED48;
// 14003ED50: using guessed type __int64 qword_14003ED50;
// 14003ED58: using guessed type __int64 qword_14003ED58;
// 14003ED60: using guessed type __int64 qword_14003ED60;
// 14003ED68: using guessed type __int64 qword_14003ED68;
// 14003ED70: using guessed type __int64 qword_14003ED70;
// 14003ED78: using guessed type __int64 qword_14003ED78;
// 14003ED80: using guessed type __int64 qword_14003ED80;
// 14003ED88: using guessed type __int64 qword_14003ED88;
// 14003ED90: using guessed type __int64 qword_14003ED90;
// 14003ED98: using guessed type __int64 qword_14003ED98;
// 14003EDA0: using guessed type __int64 qword_14003EDA0;
// 14003EDA8: using guessed type __int64 qword_14003EDA8;
// 14003EDB0: using guessed type __int64 qword_14003EDB0;
// 14003EDB8: using guessed type __int64 qword_14003EDB8;
// 14003EDC0: using guessed type __int64 qword_14003EDC0;
// 14003EDC8: using guessed type __int64 qword_14003EDC8;
// 14003EDD0: using guessed type __int64 qword_14003EDD0;
// 14003EDD8: using guessed type __int64 qword_14003EDD8;
// 14003EDE0: using guessed type __int64 qword_14003EDE0;
// 14003EDE8: using guessed type __int64 qword_14003EDE8;
// 14003EDF0: using guessed type __int64 qword_14003EDF0;

//----- (00000001400058A0) ----------------------------------------------------
void __fastcall sub_1400058A0(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 20600) == 1 )
  {
    if ( (unsigned int)sub_14002A5B0() )
      sub_14002A5B0();
  }
}

//----- (00000001400058E0) ----------------------------------------------------
signed __int64 __usercall sub_1400058E0@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __int64 v4; // rbp
  signed __int64 v5; // rdx
  signed __int64 v6; // rcx
  char *v8; // rbx
  __m128i *v9; // rax
  __int64 v10; // rdx
  __m128i *v11; // r14
  __int64 v12; // rsi

  v4 = a1;
  v5 = -1i64;
  v6 = a1 + 16496;
  do
    ++v5;
  while ( *(_BYTE *)(v6 + v5) );
  if ( !sub_14002A5B0() )
  {
    sub_140002AD0((__int64)"Failed to get _MEIPASS as PyObject.\n", a2, a3, a4);
    return 0xFFFFFFFFi64;
  }
  sub_14002A5B0();
  v8 = *(char **)(v4 + 8);
  if ( (unsigned __int64)v8 >= *(_QWORD *)(v4 + 16) )
    return 0i64;
  while ( (v8[17] - 77) & 0xDF )
  {
LABEL_15:
    v8 = sub_140001A30(v4, (signed int *)v8);
    if ( (unsigned __int64)v8 >= *(_QWORD *)(v4 + 16) )
      return 0i64;
  }
  v9 = sub_1400015A0((__int64)v8, v4, a2, a3, a4);
  v10 = *((unsigned int *)v8 + 3);
  v11 = v9;
  if ( sub_14002A5B0() )
  {
    v12 = sub_14002A5B0();
    if ( v12 )
      goto LABEL_12;
  }
  else
  {
    v12 = 0i64;
  }
  sub_140002AD0((__int64)"Module object for %s is NULL!\n", a2, a3, a4);
LABEL_12:
  if ( sub_14002A5B0() )
  {
    sub_14002A5B0();
    sub_14002A5B0();
  }
  sub_140014F8C(v11);
  if ( v12 )
    goto LABEL_15;
  return 0xFFFFFFFFi64;
}

//----- (0000000140005A50) ----------------------------------------------------
signed __int64 __usercall sub_140005A50@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  char *v4; // rdi
  _QWORD *v5; // rsi
  unsigned __int8 v6; // cf
  signed __int64 v7; // rdx
  int v8; // ebx

  v4 = *(char **)(a1 + 8);
  v5 = (_QWORD *)a1;
  if ( (unsigned __int64)v4 >= *(_QWORD *)(a1 + 16) )
    return 0i64;
  while ( 1 )
  {
    if ( v4[17] != 122 )
      goto LABEL_8;
    v6 = __CFADD__(*v5, *((unsigned int *)v4 + 1));
    v7 = -1i64;
    do
      ++v7;
    while ( *((_BYTE *)v5 + v7 + 112) );
    sub_14002A5B0();
    sub_14002A5B0();
    sub_14002A5B0();
    if ( !sub_14002A5B0() )
      break;
    v8 = sub_14002A5B0();
    if ( v8 )
    {
      sub_140002AD0((__int64)"Failed to append PYZ entry to sys.path!\n", a2, a3, a4);
      if ( v8 < 0 )
        return 0xFFFFFFFFi64;
    }
LABEL_8:
    v4 = sub_140001A30((__int64)v5, (signed int *)v4);
    if ( (unsigned __int64)v4 >= v5[2] )
      return 0i64;
  }
  sub_140002AD0((__int64)"Installing PYZ: Could not get sys.path!\n", a2, a3, a4);
  sub_14002A5B0();
  return 0xFFFFFFFFi64;
}

//----- (0000000140005B80) ----------------------------------------------------
__int64 __usercall sub_140005B80@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __int64 v4; // rbx
  __int64 result; // rax
  HMODULE v6; // rax
  __int64 v7; // r9
  char v8; // [rsp+20h] [rbp-2058h]
  char v9; // [rsp+60h] [rbp-2018h]
  char v10; // [rsp+1060h] [rbp-1018h]

  v4 = a1;
  if ( (unsigned __int64)(signed int)sub_140001E90(64i64, (__int64)&v8, (__int64)"%s", a2, a3, a4) < 0x40 )
  {
    if ( *(_DWORD *)(v4 + 20596) )
    {
      if ( !sub_140003FE0((__int64)&v9, "ucrtbase.dll", a2, a3, a4) )
        sub_140002AD0((__int64)"Path of ucrtbase.dll (%s) length exceeds buffer[%d] space\n", a2, a3, a4);
      if ( (unsigned int)sub_140003EF0(&v9, a2, a3, a4) )
        sub_140008220(&v9, a2, a3, a4);
    }
    if ( !sub_140003FE0((__int64)&v10, &v8, a2, a3, a4) )
      sub_140002AD0((__int64)"Path of DLL (%s) length exceeds buffer[%d] space\n", a2, a3, a4);
    v6 = sub_140008220(&v10, a2, a3, a4);
    if ( v6 )
    {
      result = sub_1400051A0(v6, a2, a3, a4);
    }
    else
    {
      sub_140002980((__int64)"Error loading Python DLL '%s'.\n", (__int64)"LoadLibrary", a2, a3, a4, (__int64)&v10, v7);
      result = 0xFFFFFFFFi64;
    }
  }
  else
  {
    sub_140002AD0((__int64)"Reported length (%d) of DLL name (%s) length exceeds buffer[%d] space\n", a2, a3, a4);
    result = 0xFFFFFFFFi64;
  }
  return result;
}
// 14003EC94: using guessed type int dword_14003EC94;

//----- (0000000140005CE0) ----------------------------------------------------
__int64 __usercall sub_140005CE0@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  _DWORD *v4; // rbx
  __int64 v5; // rsi
  unsigned int v6; // ebp
  __int64 v7; // rax
  __int64 v8; // rdi
  char *v9; // rax
  char *v10; // rax
  __int128 *v11; // rax
  __int128 v12; // xmm1
  __int128 v14; // [rsp+20h] [rbp-68h]
  __int128 v15; // [rsp+30h] [rbp-58h]
  __int128 v16; // [rsp+40h] [rbp-48h]
  __int128 v17; // [rsp+50h] [rbp-38h]

  v4 = 0i64;
  v5 = a1;
  v6 = -1;
  v7 = sub_140004DA0(a1, a3);
  v8 = v7;
  if ( v7 )
  {
    if ( (signed int)sub_1400044C0(v7) >= 0 )
    {
      v4 = (_DWORD *)sub_140004420();
      if ( v4 )
      {
        sub_14002A5B0();
        if ( (signed int)sub_140004830(v5, a2, a3, a4) >= 0 )
        {
          if ( (signed int)sub_1400048C0(v5, a2, a3, a4) >= 0 )
          {
            if ( (signed int)sub_1400046D0(v5, v4, a2, a3, a4) >= 0 )
            {
              if ( (signed int)sub_140004560(v5, a2, a3, a4) >= 0 )
              {
                if ( (signed int)sub_140004930(v4, v8) >= 0 )
                {
                  if ( *(_DWORD *)(v8 + 4) )
                  {
                    v9 = sub_140015160(1u);
                    sub_1400176D0((__int64)v9, a3);
                    v10 = sub_140015160(2u);
                    sub_1400176D0((__int64)v10, a3);
                  }
                  v11 = (__int128 *)sub_14002A5B0();
                  v12 = v11[1];
                  v14 = *v11;
                  v17 = v11[1];
                  v15 = v11[1];
                  v16 = *v11;
                  if ( (unsigned int)sub_14002A5B0() )
                  {
                    sub_140002AD0(
                      (__int64)"Failed to start embedded python interpreter!\n",
                      (__int128 *)v12,
                      a3,
                      a4,
                      v14,
                      v15,
                      v16,
                      v17);
                    sub_14002A5B0();
                  }
                  else
                  {
                    v6 = 0;
                  }
                }
                else
                {
                  sub_140002AD0((__int64)"Failed to set run-time options!\n", a2, a3, a4);
                }
              }
              else
              {
                sub_140002AD0((__int64)"Failed to set sys.argv!\n", a2, a3, a4);
              }
            }
            else
            {
              sub_140002AD0((__int64)"Failed to set module search paths!\n", a2, a3, a4);
            }
          }
          else
          {
            sub_140002AD0((__int64)"Failed to set python home path!\n", a2, a3, a4);
          }
        }
        else
        {
          sub_140002AD0((__int64)"Failed to set program name!\n", a2, a3, a4);
        }
      }
      else
      {
        sub_140002AD0((__int64)"Failed to allocate PyConfig structure! Unsupported python version?\n", a2, a3, a4);
      }
    }
    else
    {
      sub_140002AD0((__int64)"Failed to pre-initialize embedded python interpreter!\n", a2, a3, a4);
    }
  }
  else
  {
    sub_140002AD0((__int64)"Failed to parse run-time options!\n", a2, a3, a4);
  }
  sub_140004490(v4);
  sub_140004D00(v8);
  return v6;
}
// 14003ECA8: using guessed type __int64 qword_14003ECA8;
// 14003ECB8: using guessed type __int64 qword_14003ECB8;
// 14003ECD8: using guessed type __int64 qword_14003ECD8;
// 14003EDA8: using guessed type __int64 qword_14003EDA8;

//----- (0000000140005EE0) ----------------------------------------------------
__int64 __fastcall sub_140005EE0(_QWORD *a1)
{
  __int64 v1; // rcx

  v1 = *a1;
  sub_14002A5B0();
  return 0i64;
}

//----- (0000000140005F20) ----------------------------------------------------
signed __int64 __fastcall sub_140005F20(_QWORD *a1)
{
  int v1; // edi
  _QWORD *v2; // rbx
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // rcx

  v1 = 0;
  v2 = a1;
  if ( a1[6] )
  {
    v3 = a1[7];
    v4 = a1[2];
    v1 = sub_14002A5B0();
  }
  if ( !*((_DWORD *)v2 + 6) )
  {
    sub_14002A5B0();
    *(_DWORD *)v2[5] = v1;
    v5 = v2[4];
    sub_14002A5B0();
    sub_14002A5B0();
  }
  return 1i64;
}

//----- (0000000140005FA0) ----------------------------------------------------
__int64 __fastcall sub_140005FA0(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rcx
  __int64 v3; // rax
  __int64 v4; // rcx
  BOOL v5; // ebx
  __int64 v6; // rax
  __int64 v7; // rcx
  int v8; // edi
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rcx
  int v14; // ebx
  __int64 v15; // rcx
  __int64 v16; // rcx
  int v17; // eax
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // rdx
  __int64 v25; // rcx
  __int64 v26; // rcx

  v1 = a1;
  sub_14002A5B0();
  dword_14003EE28 = 0;
  *(_QWORD *)v1 = sub_14002A5B0();
  if ( !*(_QWORD *)(v1 + 8) )
    *(_QWORD *)(v1 + 8) = sub_14002A5B0();
  v2 = *(_QWORD *)v1;
  v3 = sub_14002A5B0();
  v4 = *(_QWORD *)v1;
  v5 = v3 == 0;
  v6 = sub_14002A5B0();
  v7 = *(_QWORD *)v1;
  v8 = v5 || v6 == 0;
  v9 = sub_14002A5B0();
  v10 = *(_QWORD *)v1;
  if ( !v9 )
    v8 = 1;
  sub_14002A5B0();
  v11 = *(_QWORD *)v1;
  v12 = sub_14002A5B0();
  v13 = *(_QWORD *)v1;
  if ( v8 | (v12 == 0) )
    goto LABEL_18;
  v14 = sub_14002A5B0();
  if ( v14 )
  {
    v15 = *(_QWORD *)v1;
    sub_14002A5B0();
    sub_14002A5B0();
  }
  v16 = *(_QWORD *)v1;
  v17 = sub_14002A5B0();
  v18 = *(_QWORD *)v1;
  if ( v17 | v14 )
  {
LABEL_18:
    sub_14002A5B0();
    sub_14002A5B0();
  }
  else
  {
    sub_14002A5B0();
    v19 = *(_QWORD *)v1;
    sub_14002A5B0();
    v20 = *(unsigned int *)(v1 + 16424);
    v21 = *(_QWORD *)(v1 + 16416);
    sub_14002A5B0();
    v22 = *(_QWORD *)v1;
    sub_14002A5B0();
    sub_140014F8C(*(LPVOID *)(v1 + 16416));
    v23 = *(unsigned int *)(v1 + 16408);
    v24 = *(_QWORD *)(v1 + 16400);
    v25 = *(_QWORD *)v1;
    *(_QWORD *)(v1 + 16416) = 0i64;
    if ( (unsigned int)sub_14002A5B0() )
    {
      v26 = *(_QWORD *)v1;
      sub_14002A5B0();
      sub_14002A5B0();
    }
    sub_14002A5B0();
    sub_14002A5B0();
    sub_14002A5B0();
    while ( (signed int)sub_14002A5B0() > 0 )
    {
      if ( dword_14003EE28 )
        break;
      sub_14002A5B0();
    }
  }
  sub_140006800(v1);
  sub_14002A5B0();
  sub_14002A5B0();
  sub_14002A5B0();
  sub_14002A5B0();
  sub_14002A5B0();
  sub_14002A5B0();
  sub_14002A5B0();
  sub_14002A5B0();
  return 0i64;
}
// 14003EE28: using guessed type int dword_14003EE28;
// 14003EE30: using guessed type __int64 qword_14003EE30;
// 14003EE38: using guessed type __int64 qword_14003EE38;
// 14003EE48: using guessed type __int64 qword_14003EE48;
// 14003EE58: using guessed type __int64 qword_14003EE58;
// 14003EE70: using guessed type __int64 qword_14003EE70;
// 14003EE78: using guessed type __int64 qword_14003EE78;
// 14003EE80: using guessed type __int64 qword_14003EE80;
// 14003EE90: using guessed type __int64 qword_14003EE90;
// 14003EEB0: using guessed type __int64 qword_14003EEB0;
// 14003EEC0: using guessed type __int64 qword_14003EEC0;
// 14003EEC8: using guessed type __int64 qword_14003EEC8;
// 14003EED8: using guessed type __int64 qword_14003EED8;
// 14003EEE0: using guessed type __int64 qword_14003EEE0;
// 14003EEE8: using guessed type __int64 qword_14003EEE8;
// 14003EEF8: using guessed type __int64 qword_14003EEF8;
// 14003EF18: using guessed type __int64 qword_14003EF18;
// 14003EF20: using guessed type __int64 qword_14003EF20;

//----- (0000000140006340) ----------------------------------------------------
__int64 sub_140006340()
{
  return 0i64;
}

//----- (0000000140006350) ----------------------------------------------------
__int64 sub_140006350()
{
  dword_14003EE28 = 1;
  return 0i64;
}
// 14003EE28: using guessed type int dword_14003EE28;

//----- (0000000140006360) ----------------------------------------------------
__int64 __usercall sub_140006360@<rax>(__int64 a1@<r9>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __int64 v4; // rcx
  __int64 v5; // rdi
  _QWORD *v6; // rax
  __int64 v7; // rcx
  char *v8; // rax
  char v10; // [rsp+30h] [rbp-1028h]

  v4 = *(_QWORD *)(a1 + 32);
  v5 = a1;
  v6 = (_QWORD *)sub_14002A5B0();
  if ( (unsigned int)sub_140014FC0(v6, (__int64)"tk.tcl", 0x40ui64) )
    return 1i64;
  v7 = *(_QWORD *)(v5 + 32);
  v8 = (char *)sub_14002A5B0();
  sub_140003FE0((__int64)&v10, v8, a2, a3, a4);
  sub_14002A5B0();
  return sub_14002A5B0();
}
// 14003EEB8: using guessed type __int64 qword_14003EEB8;
// 14003EEC8: using guessed type __int64 qword_14003EEC8;
// 14003EEF0: using guessed type __int64 qword_14003EEF0;

//----- (0000000140006440) ----------------------------------------------------
__int64 __usercall sub_140006440@<rax>(int a1@<r8d>, __int64 a2@<r9>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  __int64 v5; // rbx
  signed __int64 v6; // rbp
  __int64 v7; // rcx
  const CHAR *v8; // rax
  _QWORD *v9; // rdi
  _QWORD *v10; // rcx
  __int64 v11; // rbx
  signed __int64 v12; // rdx
  unsigned int v13; // ebx

  v5 = a2;
  v6 = a1;
  v7 = *(_QWORD *)(a2 + 8i64 * a1 - 8);
  v8 = (const CHAR *)sub_14002A5B0();
  if ( !(unsigned int)sub_140003EF0(v8, a3, a4, a5) )
    return 0i64;
  v9 = (_QWORD *)sub_14002A5B0();
  *v9 = sub_14002A5B0();
  if ( v6 > 1 )
  {
    v10 = v9 + 1;
    v11 = v5 - (_QWORD)v9;
    v12 = v6 - 1;
    do
    {
      *v10 = *(_QWORD *)((char *)v10 + v11);
      ++v10;
      --v12;
    }
    while ( v12 );
  }
  v13 = sub_14002A5B0();
  sub_14002A5B0();
  return v13;
}
// 14003EEC8: using guessed type __int64 qword_14003EEC8;
// 14003EED0: using guessed type __int64 qword_14003EED0;
// 14003EF00: using guessed type __int64 qword_14003EF00;
// 14003EF08: using guessed type __int64 qword_14003EF08;
// 14003EF10: using guessed type __int64 qword_14003EF10;

//----- (0000000140006530) ----------------------------------------------------
signed __int64 __usercall sub_140006530@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __int64 v4; // rbx
  HMODULE v5; // rax
  HMODULE v6; // rcx

  v4 = a1;
  *(_DWORD *)(a1 + 16444) = 0;
  *(_QWORD *)(a1 + 16448) = sub_140008220((LPCSTR)(a1 + 16), a2, a3, a4);
  v5 = sub_140008220((LPCSTR)(v4 + 4112), a2, a3, a4);
  v6 = *(HMODULE *)(v4 + 16448);
  *(_QWORD *)(v4 + 16456) = v5;
  if ( v6 && v5 )
  {
    if ( (signed int)sub_140006EB0(v6, v5, a2, a3, a4) >= 0 )
    {
      *(_DWORD *)(v4 + 16444) = 1;
      return 0i64;
    }
  }
  else
  {
    sub_140002AD0((__int64)"SPLASH: Failed to load Tcl/Tk libraries!\n", a2, a3, a4);
  }
  return 0xFFFFFFFFi64;
}

//----- (00000001400065B0) ----------------------------------------------------
__int64 __usercall sub_1400065B0@<rax>(__m128i *a1@<rdx>, __int64 a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  __m128i *v5; // rbp
  __int64 v6; // r13
  signed int v7; // edi
  __m128i *v8; // r12
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // rbx
  const __m128i *v11; // rax
  const __m128i *v12; // r14
  signed __int64 v13; // rax
  int v14; // ecx
  signed __int64 v15; // rax
  signed __int64 v16; // rax
  unsigned int v17; // ebx
  _QWORD v19[2]; // [rsp+20h] [rbp-2058h]
  char v20; // [rsp+30h] [rbp-2048h]
  char v21; // [rsp+1030h] [rbp-1048h]

  v5 = a1;
  v6 = a2;
  v7 = 0;
  v8 = (__m128i *)sub_140014F84(1i64, 4116i64);
  v9 = 0i64;
  if ( v5[1027].m128i_i32[2] <= 0u )
  {
LABEL_17:
    sub_140017750((__int64)&v21, (_BYTE *)(v6 + 8304), 0x1000ui64);
  }
  else
  {
    do
    {
      v10 = v9 + v5[1027].m128i_i64[0];
      v11 = (const __m128i *)sub_140001950(v6, v9 + v5[1027].m128i_i64[0]);
      v12 = v11;
      if ( v11 )
      {
        LODWORD(v19[0]) = 1;
        sub_14000CA50(v8, v11, SLODWORD(v11->m128i_i64[0]));
        sub_140003FE0((__int64)v8[1].m128i_i64 + 2, &v12[1].m128i_i8[2], a3, a4, a5);
        v13 = -1i64;
        do
          ++v13;
        while ( v12[1].m128i_i8[v13 + 2] );
        v14 = LODWORD(v12->m128i_i64[0]) - v13;
        v15 = -1i64;
        do
          ++v15;
        while ( v8[1].m128i_i8[v15 + 2] );
        LODWORD(v8->m128i_i64[0]) = v15 + v14;
        if ( (unsigned int)sub_140001710((__int64)v8, v6, v9, a3, a4, a5) )
        {
          sub_140002AD0((__int64)"SPLASH: Cannot extract requirement %s.\n", a3, a4, a5, v19[0]);
          v17 = -2;
          goto LABEL_19;
        }
        v7 = 1;
      }
      else if ( v7 )
      {
        sub_140002AD0((__int64)"SPLASH: Cannot find requirement %s in archive.\n", a3, a4, a5, v19[0]);
        v17 = -1;
        goto LABEL_19;
      }
      v16 = -1i64;
      do
        ++v16;
      while ( *(_BYTE *)(v10 + v16) );
      v9 += v16 + 1;
    }
    while ( v9 < v5[1027].m128i_i32[2] );
    if ( !v7 )
      goto LABEL_17;
    sub_140003FE0((__int64)&v21, v5[769].m128i_i8, a3, a4, a5);
  }
  sub_140017750((__int64)&v20, (__m128i *)v5[1].m128i_i8, 0x1000ui64);
  sub_140003FE0((__int64)v5[1].m128i_i64, &v20, a3, a4, a5);
  sub_140017750((__int64)&v20, (__m128i *)v5[257].m128i_i8, 0x1000ui64);
  sub_140003FE0((__int64)v5[257].m128i_i64, &v20, a3, a4, a5);
  sub_140003D70((__int64)&v20, v5 + 513);
  sub_140003FE0((__int64)v5[513].m128i_i64, &v20, a3, a4, a5);
  v17 = 0;
LABEL_19:
  sub_140014F8C(v8);
  return v17;
}
// 140014F84: using guessed type __int64 __fastcall sub_140014F84(_QWORD, _QWORD);

//----- (0000000140006800) ----------------------------------------------------
__int64 __fastcall sub_140006800(__int64 a1)
{
  __int64 *v1; // rbx
  HMODULE v2; // rcx
  __int64 v3; // rax
  __int64 v4; // rcx
  __int64 result; // rax
  HMODULE v6; // rcx

  v1 = (__int64 *)a1;
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 16444) != 1 )
    {
      v2 = *(HMODULE *)(a1 + 16448);
LABEL_10:
      if ( v2 )
      {
        sub_140008200(v2);
        v1[2056] = 0i64;
      }
      v6 = (HMODULE)v1[2057];
      if ( v6 )
      {
        sub_140008200(v6);
        v1[2057] = 0i64;
      }
      return 0i64;
    }
    v3 = sub_14002A5B0();
    v4 = *v1;
    if ( v1[1] != v3 )
    {
      if ( v4 )
      {
        sub_14002A5B0();
        dword_14003EE28 = 1;
        sub_140006930((__int64)v1, 1, 0i64, 0i64);
        sub_14002A5B0();
        sub_14002A5B0();
        sub_14002A5B0();
      }
      sub_14002A5B0();
      v2 = (HMODULE)v1[2056];
      goto LABEL_10;
    }
    if ( v4 )
    {
      sub_14002A5B0();
      result = 0i64;
      *v1 = 0i64;
      return result;
    }
  }
  return 0i64;
}
// 14003EE28: using guessed type int dword_14003EE28;
// 14003EE50: using guessed type __int64 qword_14003EE50;
// 14003EE60: using guessed type __int64 qword_14003EE60;
// 14003EE70: using guessed type __int64 qword_14003EE70;
// 14003EE78: using guessed type __int64 qword_14003EE78;
// 14003EE80: using guessed type __int64 qword_14003EE80;
// 14003EE88: using guessed type __int64 qword_14003EE88;
// 14003EE98: using guessed type __int64 qword_14003EE98;

//----- (0000000140006930) ----------------------------------------------------
__int64 __fastcall sub_140006930(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbp
  __int64 v5; // rdi
  __int64 v6; // rsi
  int v7; // er14
  __int64 v8; // rax
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v12; // [rsp+40h] [rbp+8h]
  unsigned int v13; // [rsp+48h] [rbp+10h]

  v4 = a1;
  v13 = 0;
  v5 = a4;
  v12 = 0i64;
  v6 = a3;
  v7 = a2;
  v8 = sub_14002A5B0();
  *(_QWORD *)v8 = sub_140005F20;
  *(_QWORD *)(v8 + 32) = &v12;
  *(_QWORD *)(v8 + 40) = &v13;
  *(_QWORD *)(v8 + 16) = v4;
  *(_DWORD *)(v8 + 24) = v7;
  *(_QWORD *)(v8 + 48) = v5;
  *(_QWORD *)(v8 + 56) = v6;
  sub_14002A5B0();
  v9 = *(_QWORD *)(v4 + 8);
  sub_14002A5B0();
  v10 = *(_QWORD *)(v4 + 8);
  sub_14002A5B0();
  if ( !v7 )
  {
    sub_14002A5B0();
    sub_14002A5B0();
  }
  sub_14002A5B0();
  return v13;
}
// 14003EE78: using guessed type __int64 qword_14003EE78;
// 14003EE80: using guessed type __int64 qword_14003EE80;
// 14003EE88: using guessed type __int64 qword_14003EE88;
// 14003EE98: using guessed type __int64 qword_14003EE98;
// 14003EEA0: using guessed type __int64 qword_14003EEA0;
// 14003EEA8: using guessed type __int64 qword_14003EEA8;
// 14003EF08: using guessed type __int64 qword_14003EF08;

//----- (0000000140006A50) ----------------------------------------------------
signed __int64 __usercall sub_140006A50@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  char *v5; // rax
  __int64 v6; // rbx
  __int64 v7; // rsi
  __m128i *v8; // rax
  __m128i *v9; // rdi
  unsigned __int32 v10; // eax
  signed __int32 v11; // eax
  signed __int32 v12; // eax
  __int64 v13; // rax
  __m128i *v14; // rcx

  v5 = *(char **)(a1 + 8);
  v6 = a1;
  v7 = a2;
  if ( (unsigned __int64)v5 < *(_QWORD *)(a1 + 16) )
  {
    while ( v5[17] != 108 )
    {
      v5 = sub_140001A30(v6, (signed int *)v5);
      if ( (unsigned __int64)v5 >= *(_QWORD *)(v6 + 16) )
        return 0xFFFFFFFFi64;
    }
    v8 = sub_1400015A0((__int64)v5, v6, a3, a4, a5);
    v9 = v8;
    if ( v8 )
    {
      sub_140017750(v7 + 16, v8, 0x10ui64);
      sub_140017750(v7 + 4112, (__m128i *)v9[1].m128i_i8, 0x10ui64);
      sub_140017750(v7 + 12304, (__m128i *)v9[3].m128i_i8, 0x10ui64);
      sub_140003FE0(v7 + 8208, v9[2].m128i_i8, a3, a4, a5);
      v10 = _byteswap_ulong(v9[4].m128i_u32[0]);
      *(_DWORD *)(v7 + 16408) = v10;
      *(_QWORD *)(v7 + 16400) = sub_140014F84(1i64, (signed int)(v10 + 1));
      v11 = _byteswap_ulong(v9[4].m128i_u32[2]);
      *(_DWORD *)(v7 + 16424) = v11;
      *(_QWORD *)(v7 + 16416) = sub_140014FA0(v11);
      v12 = _byteswap_ulong(v9[5].m128i_u32[0]);
      *(_DWORD *)(v7 + 16440) = v12;
      v13 = sub_140014FA0(v12);
      v14 = *(__m128i **)(v7 + 16400);
      *(_QWORD *)(v7 + 16432) = v13;
      if ( v14 && *(_QWORD *)(v7 + 16416) && v13 )
      {
        sub_14000CA50(v14, (__m128i *)((char *)v9 + _byteswap_ulong(v9[4].m128i_u32[1])), *(signed int *)(v7 + 16408));
        sub_14000CA50(
          *(__m128i **)(v7 + 16416),
          (__m128i *)((char *)v9 + _byteswap_ulong(v9[4].m128i_u32[3])),
          *(signed int *)(v7 + 16424));
        sub_14000CA50(
          *(__m128i **)(v7 + 16432),
          (__m128i *)((char *)v9 + _byteswap_ulong(v9[5].m128i_u32[1])),
          *(signed int *)(v7 + 16440));
        sub_140014F8C(v9);
        return 0i64;
      }
      sub_140002AD0((__int64)"Cannot allocate memory for necessary files.\n", a3, a4, a5);
    }
  }
  return 0xFFFFFFFFi64;
}
// 140014F84: using guessed type __int64 __fastcall sub_140014F84(_QWORD, _QWORD);
// 140014FA0: using guessed type __int64 __fastcall sub_140014FA0(_QWORD);

//----- (0000000140006BF0) ----------------------------------------------------
signed __int64 __usercall sub_140006BF0@<rax>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __int64 v4; // rbx
  _QWORD v6[3]; // [rsp+20h] [rbp-18h]

  v4 = a1;
  sub_14002A5B0();
  if ( !*(_QWORD *)(v4 + 16448) || !*(_QWORD *)(v4 + 16456) )
    return 0xFFFFFFFFi64;
  sub_14002A5B0();
  LODWORD(v6[0]) = 0;
  if ( (unsigned int)sub_14002A5B0() )
  {
    sub_140002AD0((__int64)"SPLASH: Tcl is not threaded. Only threaded tcl is supported.\n", a2, a3, a4, v6[0]);
    sub_14002A5B0();
    sub_140006800(v4);
    return 0xFFFFFFFFi64;
  }
  sub_14002A5B0();
  sub_14002A5B0();
  sub_14002A5B0();
  sub_14002A5B0();
  sub_14002A5B0();
  return 0i64;
}
// 14003EE40: using guessed type __int64 qword_14003EE40;
// 14003EE68: using guessed type __int64 qword_14003EE68;
// 14003EE78: using guessed type __int64 qword_14003EE78;
// 14003EE80: using guessed type __int64 qword_14003EE80;
// 14003EE88: using guessed type __int64 qword_14003EE88;
// 14003EE98: using guessed type __int64 qword_14003EE98;

//----- (0000000140006D20) ----------------------------------------------------
void __fastcall sub_140006D20(_QWORD **a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rdi
  void *v3; // rcx
  void *v4; // rcx
  void *v5; // rcx

  v1 = *a1;
  v2 = a1;
  if ( *a1 )
  {
    v3 = (void *)v1[2050];
    if ( v3 )
      sub_140014F8C(v3);
    v4 = (void *)v1[2052];
    if ( v4 )
      sub_140014F8C(v4);
    v5 = (void *)v1[2054];
    if ( v5 )
      sub_140014F8C(v5);
    sub_140014F8C(v1);
    *v2 = 0i64;
  }
  else
  {
    *a1 = 0i64;
  }
}

//----- (0000000140006DA0) ----------------------------------------------------
__int64 __usercall sub_140006DA0@<rax>(__int128 *a1@<xmm1>, __m256i *a2@<ymm0>, __m256i *a3@<ymm1>)
{
  __int64 result; // rax
  __int64 v4; // rbx

  result = sub_140014F84(1i64, 16464i64);
  v4 = result;
  if ( !result )
  {
    sub_140002830((__int64)"Cannot allocate memory for SPLASH_STATUS.\n", (__int64)"calloc", a1, a2, a3);
    result = v4;
  }
  return result;
}
// 140014F84: using guessed type __int64 __fastcall sub_140014F84(_QWORD, _QWORD);

//----- (0000000140006DE0) ----------------------------------------------------
__int64 __fastcall sub_140006DE0(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rcx
  unsigned int v8; // [rsp+30h] [rbp+8h]
  __int64 v9; // [rsp+38h] [rbp+10h]

  v2 = a1;
  v8 = 0;
  v3 = a2;
  v9 = 0i64;
  v4 = sub_14002A5B0();
  *(_QWORD *)v4 = sub_140005F20;
  *(_QWORD *)(v4 + 32) = &v9;
  *(_QWORD *)(v4 + 40) = &v8;
  *(_QWORD *)(v4 + 48) = sub_140005EE0;
  *(_QWORD *)(v4 + 16) = v2;
  *(_DWORD *)(v4 + 24) = 1;
  *(_QWORD *)(v4 + 56) = v3;
  sub_14002A5B0();
  v5 = *(_QWORD *)(v2 + 8);
  sub_14002A5B0();
  v6 = *(_QWORD *)(v2 + 8);
  sub_14002A5B0();
  sub_14002A5B0();
  return v8;
}

//----- (0000000140006EB0) ----------------------------------------------------
__int64 __usercall sub_140006EB0@<rax>(HMODULE hModule@<rcx>, HMODULE a2@<rdx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  HMODULE v5; // rdi
  HMODULE v6; // rbx
  __int64 v7; // r8
  __int64 v8; // r9
  const char *v9; // rdx

  v5 = a2;
  v6 = hModule;
  qword_14003EE30 = (__int64)GetProcAddress(hModule, "Tcl_Init");
  if ( !qword_14003EE30 )
  {
    v9 = "Failed to get address for Tcl_Init\n";
LABEL_3:
    sub_140002980((__int64)v9, (__int64)"GetProcAddress", a3, a4, a5, v7, v8);
    return 0xFFFFFFFFi64;
  }
  qword_14003EE38 = (__int64)GetProcAddress(v6, "Tcl_CreateInterp");
  if ( !qword_14003EE38 )
  {
    v9 = "Failed to get address for Tcl_CreateInterp\n";
    goto LABEL_3;
  }
  qword_14003EE40 = (__int64)GetProcAddress(v6, "Tcl_FindExecutable");
  if ( !qword_14003EE40 )
  {
    v9 = "Failed to get address for Tcl_FindExecutable\n";
    goto LABEL_3;
  }
  qword_14003EE48 = (__int64)GetProcAddress(v6, "Tcl_DoOneEvent");
  if ( !qword_14003EE48 )
  {
    v9 = "Failed to get address for Tcl_DoOneEvent\n";
    goto LABEL_3;
  }
  qword_14003EE50 = (__int64)GetProcAddress(v6, "Tcl_Finalize");
  if ( !qword_14003EE50 )
  {
    v9 = "Failed to get address for Tcl_Finalize\n";
    goto LABEL_3;
  }
  qword_14003EE58 = (__int64)GetProcAddress(v6, "Tcl_FinalizeThread");
  if ( !qword_14003EE58 )
  {
    v9 = "Failed to get address for Tcl_FinalizeThread\n";
    goto LABEL_3;
  }
  qword_14003EE60 = (__int64)GetProcAddress(v6, "Tcl_DeleteInterp");
  if ( !qword_14003EE60 )
  {
    v9 = "Failed to get address for Tcl_DeleteInterp\n";
    goto LABEL_3;
  }
  qword_14003EE68 = (__int64)GetProcAddress(v6, "Tcl_CreateThread");
  if ( !qword_14003EE68 )
  {
    v9 = "Failed to get address for Tcl_CreateThread\n";
    goto LABEL_3;
  }
  qword_14003EE70 = (__int64)GetProcAddress(v6, "Tcl_GetCurrentThread");
  if ( !qword_14003EE70 )
  {
    v9 = "Failed to get address for Tcl_GetCurrentThread\n";
    goto LABEL_3;
  }
  qword_14003EE78 = (__int64)GetProcAddress(v6, "Tcl_MutexLock");
  if ( !qword_14003EE78 )
  {
    v9 = "Failed to get address for Tcl_MutexLock\n";
    goto LABEL_3;
  }
  qword_14003EE80 = (__int64)GetProcAddress(v6, "Tcl_MutexUnlock");
  if ( !qword_14003EE80 )
  {
    v9 = "Failed to get address for Tcl_MutexUnlock\n";
    goto LABEL_3;
  }
  qword_14003EE88 = (__int64)GetProcAddress(v6, "Tcl_ConditionFinalize");
  if ( !qword_14003EE88 )
  {
    v9 = "Failed to get address for Tcl_ConditionFinalize\n";
    goto LABEL_3;
  }
  qword_14003EE90 = (__int64)GetProcAddress(v6, "Tcl_ConditionNotify");
  if ( !qword_14003EE90 )
  {
    v9 = "Failed to get address for Tcl_ConditionNotify\n";
    goto LABEL_3;
  }
  qword_14003EE98 = (__int64)GetProcAddress(v6, "Tcl_ConditionWait");
  if ( !qword_14003EE98 )
  {
    v9 = "Failed to get address for Tcl_ConditionWait\n";
    goto LABEL_3;
  }
  qword_14003EEA0 = (__int64)GetProcAddress(v6, "Tcl_ThreadQueueEvent");
  if ( !qword_14003EEA0 )
  {
    v9 = "Failed to get address for Tcl_ThreadQueueEvent\n";
    goto LABEL_3;
  }
  qword_14003EEA8 = (__int64)GetProcAddress(v6, "Tcl_ThreadAlert");
  if ( !qword_14003EEA8 )
  {
    v9 = "Failed to get address for Tcl_ThreadAlert\n";
    goto LABEL_3;
  }
  qword_14003EEB0 = (__int64)GetProcAddress(v6, "Tcl_GetVar2");
  if ( !qword_14003EEB0 )
  {
    v9 = "Failed to get address for Tcl_GetVar2\n";
    goto LABEL_3;
  }
  qword_14003EEB8 = (__int64)GetProcAddress(v6, "Tcl_SetVar2");
  if ( !qword_14003EEB8 )
  {
    v9 = "Failed to get address for Tcl_SetVar2\n";
    goto LABEL_3;
  }
  qword_14003EEC0 = (__int64)GetProcAddress(v6, "Tcl_CreateObjCommand");
  if ( !qword_14003EEC0 )
  {
    v9 = "Failed to get address for Tcl_CreateObjCommand\n";
    goto LABEL_3;
  }
  qword_14003EEC8 = (__int64)GetProcAddress(v6, "Tcl_GetString");
  if ( !qword_14003EEC8 )
  {
    v9 = "Failed to get address for Tcl_GetString\n";
    goto LABEL_3;
  }
  qword_14003EED0 = (__int64)GetProcAddress(v6, "Tcl_NewStringObj");
  if ( !qword_14003EED0 )
  {
    v9 = "Failed to get address for Tcl_NewStringObj\n";
    goto LABEL_3;
  }
  qword_14003EED8 = (__int64)GetProcAddress(v6, "Tcl_NewByteArrayObj");
  if ( !qword_14003EED8 )
  {
    v9 = "Failed to get address for Tcl_NewByteArrayObj\n";
    goto LABEL_3;
  }
  qword_14003EEE0 = (__int64)GetProcAddress(v6, "Tcl_SetVar2Ex");
  if ( !qword_14003EEE0 )
  {
    v9 = "Failed to get address for Tcl_SetVar2Ex\n";
    goto LABEL_3;
  }
  qword_14003EEE8 = (__int64)GetProcAddress(v6, "Tcl_GetObjResult");
  if ( !qword_14003EEE8 )
  {
    v9 = "Failed to get address for Tcl_GetObjResult\n";
    goto LABEL_3;
  }
  qword_14003EEF0 = (__int64)GetProcAddress(v6, "Tcl_EvalFile");
  if ( !qword_14003EEF0 )
  {
    v9 = "Failed to get address for Tcl_EvalFile\n";
    goto LABEL_3;
  }
  qword_14003EEF8 = (__int64)GetProcAddress(v6, "Tcl_EvalEx");
  if ( !qword_14003EEF8 )
  {
    v9 = "Failed to get address for Tcl_EvalEx\n";
    goto LABEL_3;
  }
  qword_14003EF00 = (__int64)GetProcAddress(v6, "Tcl_EvalObjv");
  if ( !qword_14003EF00 )
  {
    v9 = "Failed to get address for Tcl_EvalObjv\n";
    goto LABEL_3;
  }
  qword_14003EF08 = (__int64)GetProcAddress(v6, "Tcl_Alloc");
  if ( !qword_14003EF08 )
  {
    v9 = "Failed to get address for Tcl_Alloc\n";
    goto LABEL_3;
  }
  qword_14003EF10 = (__int64)GetProcAddress(v6, "Tcl_Free");
  if ( !qword_14003EF10 )
  {
    v9 = "Failed to get address for Tcl_Free\n";
    goto LABEL_3;
  }
  qword_14003EF18 = (__int64)GetProcAddress(v5, "Tk_Init");
  if ( !qword_14003EF18 )
  {
    v9 = "Failed to get address for Tk_Init\n";
    goto LABEL_3;
  }
  qword_14003EF20 = (__int64)GetProcAddress(v5, "Tk_GetNumMainWindows");
  if ( !qword_14003EF20 )
  {
    v9 = "Failed to get address for Tk_GetNumMainWindows\n";
    goto LABEL_3;
  }
  return 0i64;
}
// 14003EE30: using guessed type __int64 qword_14003EE30;
// 14003EE38: using guessed type __int64 qword_14003EE38;
// 14003EE40: using guessed type __int64 qword_14003EE40;
// 14003EE48: using guessed type __int64 qword_14003EE48;
// 14003EE50: using guessed type __int64 qword_14003EE50;
// 14003EE58: using guessed type __int64 qword_14003EE58;
// 14003EE60: using guessed type __int64 qword_14003EE60;
// 14003EE68: using guessed type __int64 qword_14003EE68;
// 14003EE70: using guessed type __int64 qword_14003EE70;
// 14003EE78: using guessed type __int64 qword_14003EE78;
// 14003EE80: using guessed type __int64 qword_14003EE80;
// 14003EE88: using guessed type __int64 qword_14003EE88;
// 14003EE90: using guessed type __int64 qword_14003EE90;
// 14003EE98: using guessed type __int64 qword_14003EE98;
// 14003EEA0: using guessed type __int64 qword_14003EEA0;
// 14003EEA8: using guessed type __int64 qword_14003EEA8;
// 14003EEB0: using guessed type __int64 qword_14003EEB0;
// 14003EEB8: using guessed type __int64 qword_14003EEB8;
// 14003EEC0: using guessed type __int64 qword_14003EEC0;
// 14003EEC8: using guessed type __int64 qword_14003EEC8;
// 14003EED0: using guessed type __int64 qword_14003EED0;
// 14003EED8: using guessed type __int64 qword_14003EED8;
// 14003EEE0: using guessed type __int64 qword_14003EEE0;
// 14003EEE8: using guessed type __int64 qword_14003EEE8;
// 14003EEF0: using guessed type __int64 qword_14003EEF0;
// 14003EEF8: using guessed type __int64 qword_14003EEF8;
// 14003EF00: using guessed type __int64 qword_14003EF00;
// 14003EF08: using guessed type __int64 qword_14003EF08;
// 14003EF10: using guessed type __int64 qword_14003EF10;
// 14003EF18: using guessed type __int64 qword_14003EF18;
// 14003EF20: using guessed type __int64 qword_14003EF20;

//----- (00000001400073C0) ----------------------------------------------------
signed __int64 __fastcall HandlerRoutine(DWORD CtrlType)
{
  if ( CtrlType >= 2 )
    Sleep(0x4E20u);
  return 1i64;
}

//----- (00000001400073E0) ----------------------------------------------------
const __m128i *__usercall sub_1400073E0@<rax>(const CHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  WCHAR *v4; // rax
  WCHAR *v5; // rdi
  const __m128i *result; // rax
  DWORD v7; // ebx
  __m128i *v8; // rax
  const __m128i *v9; // rbx
  const __m128i *i; // rdi
  WCHAR Dst; // [rsp+20h] [rbp-4018h]
  WCHAR PathName; // [rsp+2020h] [rbp-2018h]

  v4 = sub_140008AA0(0i64, a1, 0, a2, a3, a4);
  v5 = v4;
  if ( v4 )
  {
    v7 = ExpandEnvironmentStringsW(v4, &Dst, 0x1000u);
    sub_140014F8C(v5);
    if ( v7 )
    {
      if ( (unsigned int)sub_140008810(&Dst) )
        v8 = (__m128i *)sub_1400178B4((__int64)&Dst, a3);
      else
        v8 = sub_140016238(&Dst, 0i64, 0x1000ui64, a3);
      v9 = v8;
      if ( v8 )
      {
        sub_14000D100(0i64, (__int64)&PathName, 0x2000ui64, a3);
        for ( i = sub_14000D644(v9, 0x5Cu); i; i = sub_14000D644((const __m128i *)((char *)i + 2), 0x5Cu) )
        {
          sub_140017938(&PathName, (__int64)v9, (((char *)i - (char *)v9) >> 1) + 1);
          CreateDirectoryW(&PathName, 0i64);
        }
        CreateDirectoryW((LPCWSTR)v9, 0i64);
        result = v9;
      }
      else
      {
        sub_140002AD0((__int64)"LOADER: Failed to obtain the absolute path of the runtime-tmpdir.\n", a2, a3, a4);
        result = 0i64;
      }
    }
    else
    {
      sub_140002AD0((__int64)"LOADER: Failed to expand environment variables in the runtime-tmpdir.\n", a2, a3, a4);
      result = 0i64;
    }
  }
  else
  {
    sub_140002AD0((__int64)"LOADER: Failed to convert runtime-tmpdir to a wide string.\n", a2, a3, a4);
    result = 0i64;
  }
  return result;
}

//----- (0000000140007560) ----------------------------------------------------
signed __int64 __usercall sub_140007560@<rax>(const CHAR *a1@<rcx>, __int64 a2@<r8>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  __int64 v5; // rbp
  __int64 v6; // rdi
  unsigned int v7; // esi
  __int64 v8; // rbx
  int v9; // eax
  _BYTE *v10; // rax
  int v11; // edx
  __int64 v12; // rcx
  __int64 v13; // rax
  __int64 v14; // rcx
  __int64 v16; // [rsp+20h] [rbp-2038h]
  char v17; // [rsp+30h] [rbp-2028h]
  char v18; // [rsp+1030h] [rbp-1028h]

  v5 = a2;
  LODWORD(v16) = 92;
  v6 = sub_140003F60("rb", a1, a3, a4, a5);
  if ( (signed int)sub_140001E90(4096i64, (__int64)&v17, (__int64)"%s%c%s", a3, a4, a5, v16, v5) >= 4096 )
  {
    v7 = 0;
    v8 = 0i64;
    goto LABEL_16;
  }
  v7 = 0;
  if ( (unsigned int)sub_140003EF0(&v17, a3, a4, a5) != 1 )
    goto LABEL_13;
  v9 = dword_14003E004;
  if ( dword_14003E004 != -1 )
    goto LABEL_9;
  v10 = sub_140007B20("PYINSTALLER_STRICT_UNPACK_MODE", a3, a4, a5);
  if ( v10 )
  {
    v11 = (unsigned __int8)*v10 - 48;
    if ( *v10 == 48 )
      v11 = (unsigned __int8)v10[1];
    dword_14003E004 = v11 != 0;
    sub_140014F8C(v10);
    v9 = dword_14003E004;
LABEL_9:
    if ( v9 )
    {
      sub_140002BE0((__int64)"ERROR: file already exists but should not: %s\n", a3, a4, a5);
      v8 = 0i64;
      goto LABEL_16;
    }
    goto LABEL_12;
  }
  dword_14003E004 = 0;
LABEL_12:
  sub_140002BE0((__int64)"WARNING: file already exists but should not: %s\n", a3, a4, a5);
LABEL_13:
  if ( (signed int)sub_140007780(a3, a4, a5) >= 0 )
    v8 = sub_140003F60("wb", &v17, a3, a4, a5);
  else
    v8 = 0i64;
LABEL_16:
  if ( !v6 )
  {
    if ( !v8 )
      return 0xFFFFFFFFi64;
    v12 = v8;
LABEL_31:
    sub_14001019C(v12, a4);
    return 0xFFFFFFFFi64;
  }
  v12 = v6;
  if ( !v8 )
    goto LABEL_31;
  if ( (unsigned int)sub_140010234(v6, a4) )
    goto LABEL_28;
  while ( 1 )
  {
    v13 = sub_1400104EC(1ui64, (__int64)&v18, 0x1000ui64, v6, a4);
    if ( v13 )
      break;
    if ( (unsigned int)sub_140010260(v6, a4) )
    {
      v14 = v6;
      goto LABEL_27;
    }
LABEL_24:
    if ( (unsigned int)sub_140010234(v6, a4) )
      goto LABEL_28;
  }
  if ( sub_140010C2C(1i64, (__int64)&v18, v13, v8, a4) && !(unsigned int)sub_140010260(v8, a4) )
    goto LABEL_24;
  v14 = v8;
LABEL_27:
  sub_1400189D0(v14);
  v7 = -1;
LABEL_28:
  sub_14001019C(v6, a4);
  sub_14001019C(v8, a4);
  return v7;
}
// 1400189D0: using guessed type __int64 __fastcall sub_1400189D0(_QWORD);
// 14003E004: using guessed type int dword_14003E004;

//----- (0000000140007780) ----------------------------------------------------
signed __int64 __usercall sub_140007780@<rax>(__int128 *a1@<xmm1>, __m256i *a2@<ymm0>, __m256i *a3@<ymm1>)
{
  unsigned __int64 v3; // rdi
  unsigned __int8 *v4; // rbx
  signed __int64 v5; // rcx
  _WORD *v6; // rcx
  bool v7; // zf
  char *v8; // rax
  __int64 v10; // [rsp+0h] [rbp-2038h]
  char v11[4096]; // [rsp+20h] [rbp-2018h]
  char v12; // [rsp+1020h] [rbp-1018h]

  if ( (signed int)sub_140001E90(4096i64, (__int64)v11, (__int64)"%s", a1, a2, a3) >= 4096
    || (signed int)sub_140001E90(4096i64, (__int64)&v12, (__int64)"%s", a1, a2, a3) >= 4096 )
  {
    return 0xFFFFFFFFi64;
  }
  v3 = -1i64;
  do
    ++v3;
  while ( v11[v3] );
  v4 = sub_140015FD8((unsigned __int8 *)&word_14002DBF0, (unsigned __int8 *)&v12, a2);
  if ( v4 )
  {
    while ( 1 )
    {
      v5 = -1i64;
      do
        ++v5;
      while ( v4[v5] );
      v3 += v5 + 1;
      if ( v3 >= 0xFFF )
        break;
      v6 = (_WORD *)((char *)&v10 + 31);
      do
      {
        v7 = *((_BYTE *)v6 + 1) == 0;
        v6 = (_WORD *)((char *)v6 + 1);
      }
      while ( !v7 );
      *v6 = 92;
      v8 = (char *)&v10 + 31;
      do
        v7 = (v8++)[1] == 0;
      while ( !v7 );
      strcpy(v8, (const char *)v4);
      v4 = sub_140015FD8((unsigned __int8 *)&word_14002DBF0, 0i64, a2);
      if ( !v4 )
        return 0i64;
      if ( !(unsigned int)sub_140003EF0(v11, a1, a2, a3) && (signed int)sub_1400040A0(v11, a1, a2, a3) < 0 )
        return 0xFFFFFFFFi64;
    }
    return 0xFFFFFFFFi64;
  }
  return 0i64;
}
// 14002DBF0: using guessed type __int16 word_14002DBF0;
// 140007780: using guessed type char var_2018[4096];

//----- (0000000140007910) ----------------------------------------------------
signed __int64 __usercall sub_140007910@<rax>(const CHAR *a1@<rdx>, CHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  signed int v5; // edi
  const CHAR *v6; // rbp
  CHAR *v7; // r15
  CHAR *v8; // rsi
  __m128i *v9; // rax
  __m128i *v10; // r14
  int v11; // ebx
  WCHAR *v13; // rbx
  WCHAR *v14; // rax
  __m128i *v15; // rdi
  __m128i *v16; // rbx
  WCHAR *v17; // rbx
  WCHAR *v18; // rax
  __m128i *v19; // rdi
  __m128i *v20; // rbx
  CHAR *v21; // rcx
  WCHAR *v22; // rbx
  char v23; // [rsp+20h] [rbp-2058h]
  WCHAR Buffer; // [rsp+40h] [rbp-2038h]

  v5 = 0;
  v6 = a1;
  v7 = a2;
  v8 = 0i64;
  if ( !a1 )
  {
LABEL_5:
    GetTempPathW(0x1000u, &Buffer);
    GetCurrentProcessId();
    sub_1400027D0(16i64, (__int64)&v23, (__int64)L"_MEI%d", a3, a4, a5);
    do
    {
      v13 = sub_1400189B4((__int64)&v23, &Buffer, a3, a4, a5);
      if ( !(unsigned int)sub_140008910(v13, a3, a4, a5) )
      {
        sub_140008BB0(v7, v13, 4096, a3, a4, a5);
        sub_140014F8C(v13);
        if ( v6 )
        {
          v18 = sub_140008AA0(0i64, "TMP", 0, a3, a4, a5);
          if ( v8 )
          {
            v19 = (__m128i *)v18;
            v20 = (__m128i *)sub_140008AA0(0i64, v8, 0, a3, a4, a5);
            sub_140017CFC(v20, v19, a3, a4, a5);
            sub_140014F8C(v19);
            sub_140014F8C(v20);
            v21 = v8;
          }
          else
          {
            v22 = v18;
            SetEnvironmentVariableW(v18, 0i64);
            v21 = (CHAR *)v22;
          }
          sub_140014F8C(v21);
        }
        return 1i64;
      }
      sub_140014F8C(v13);
      ++v5;
    }
    while ( v5 < 5 );
    if ( !v6 )
      return 0i64;
    v14 = sub_140008AA0(0i64, "TMP", 0, a3, a4, a5);
    if ( v8 )
    {
      v15 = (__m128i *)v14;
      v16 = (__m128i *)sub_140008AA0(0i64, v8, 0, a3, a4, a5);
      sub_140017CFC(v16, v15, a3, a4, a5);
      sub_140014F8C(v15);
      sub_140014F8C(v16);
      sub_140014F8C(v8);
      return 0i64;
    }
    v17 = v14;
    SetEnvironmentVariableW(v14, 0i64);
    sub_140014F8C(v17);
    return 0i64;
  }
  v8 = sub_140007B20("TMP", a3, a4, a5);
  v9 = (__m128i *)sub_1400073E0(v6, a3, a4, a5);
  v10 = v9;
  if ( v9 )
  {
    v11 = sub_140017CFC(v9, (__m128i *)L"TMP", a3, a4, a5);
    sub_140014F8C(v10);
    if ( v11 )
    {
      sub_140002AD0((__int64)"LOADER: Failed to set the TMP environment variable.\n", a3, a4, a5);
      return 0i64;
    }
    goto LABEL_5;
  }
  return 0i64;
}
// 14002DB78: using guessed type wchar_t aTmp[4];
// 14002DBB8: using guessed type wchar_t aMeiD[7];

//----- (0000000140007B20) ----------------------------------------------------
_BYTE *__usercall sub_140007B20@<rax>(const CHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  WCHAR *v4; // rax
  CHAR *v5; // rax
  _BYTE *result; // rax
  WCHAR Buffer; // [rsp+20h] [rbp-4018h]
  WCHAR Dst; // [rsp+2020h] [rbp-2018h]

  v4 = sub_140008AA0(0i64, a1, 0, a2, a3, a4);
  if ( GetEnvironmentVariableW(v4, &Buffer, 0x2000u)
    && (ExpandEnvironmentStringsW(&Buffer, &Dst, 0x2000u), (v5 = sub_140008BB0(0i64, &Buffer, 0, a2, a3, a4)) != 0i64)
    && *v5 )
  {
    result = sub_14001A8AC((__int64)v5, a3);
  }
  else
  {
    result = 0i64;
  }
  return result;
}

//----- (0000000140007BD0) ----------------------------------------------------
__int64 __usercall sub_140007BD0@<rax>(__int64 a1@<rdx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  int v4; // eax
  _BYTE *v5; // rax
  int v6; // edx
  int v7; // er8
  __int64 v9; // [rsp+20h] [rbp-1028h]
  char v10; // [rsp+30h] [rbp-1018h]

  LODWORD(v9) = 92;
  if ( (signed int)sub_140001E90(4096i64, (__int64)&v10, (__int64)"%s%c%s", a2, a3, a4, v9, a1) >= 4096 )
    return 0i64;
  if ( (unsigned int)sub_140003EF0(&v10, a2, a3, a4) == 1 )
  {
    v4 = dword_14003E004;
    if ( dword_14003E004 == -1 )
    {
      v5 = sub_140007B20("PYINSTALLER_STRICT_UNPACK_MODE", a2, a3, a4);
      v6 = 0;
      if ( !v5 )
      {
        dword_14003E004 = 0;
LABEL_13:
        sub_140002BE0((__int64)"WARNING: file already exists but should not: %s\n", a2, a3, a4);
        goto LABEL_14;
      }
      v7 = (unsigned __int8)*v5 - 48;
      if ( *v5 == 48 )
        v7 = (unsigned __int8)v5[1];
      LOBYTE(v6) = v7 != 0;
      dword_14003E004 = v6;
      sub_140014F8C(v5);
      v4 = dword_14003E004;
    }
    if ( v4 )
    {
      sub_140002BE0((__int64)"ERROR: file already exists but should not: %s\n", a2, a3, a4);
      return 0i64;
    }
    goto LABEL_13;
  }
LABEL_14:
  if ( (signed int)sub_140007780(a2, a3, a4) < 0 )
    return 0i64;
  return sub_140003F60("wb", &v10, a2, a3, a4);
}
// 14003E004: using guessed type int dword_14003E004;

//----- (0000000140007D00) ----------------------------------------------------
signed __int64 __usercall sub_140007D00@<rax>(const CHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __int64 v4; // rcx
  __int16 v5; // ax
  __int64 v6; // rbx
  __int16 v7; // ax
  char *v8; // rcx
  bool v9; // zf
  char *v10; // rcx
  void *v11; // rdi
  char *v12; // rcx
  signed __int64 v13; // r8
  char *v14; // rdx
  __int128 v15; // xmm0
  __int128 v16; // xmm1
  __int128 v17; // xmm0
  __int128 v18; // xmm1
  __int128 v19; // xmm0
  __int128 v20; // xmm1
  __int128 v21; // xmm0
  __int128 v22; // xmm1
  __int128 v23; // xmm1
  __int128 v24; // xmm0
  char *v25; // rcx
  signed __int64 v26; // rdx
  char *v27; // rax
  __int128 v28; // xmm0
  __int128 v29; // xmm1
  __int128 v30; // xmm0
  __int128 v31; // xmm1
  __int128 v32; // xmm0
  __int128 v33; // xmm1
  __int128 v34; // xmm0
  __int128 v35; // xmm1
  __int128 v36; // xmm1
  __int128 v37; // xmm0
  __int64 v39; // [rsp+0h] [rbp-44B8h]
  char v40; // [rsp+20h] [rbp-4498h]
  char v41; // [rsp+250h] [rbp-4268h]
  __int16 v42; // [rsp+47Eh] [rbp-403Ah]
  __int16 v43[4104]; // [rsp+480h] [rbp-4038h]
  WCHAR WideCharStr[4104]; // [rsp+2490h] [rbp-2028h]

  sub_140008AA0(WideCharStr, a1, 4096, a2, a3, a4);
  v4 = 0i64;
  do
  {
    v5 = WideCharStr[v4];
    v43[v4] = v5;
    ++v4;
  }
  while ( v5 );
  v6 = -1i64;
  do
    ++v6;
  while ( v43[v6] );
  v7 = *(&v42 + v6);
  if ( v7 != 47 && v7 != 92 )
  {
    v8 = (char *)&v39 + 1150;
    do
    {
      v9 = *((_WORD *)v8 + 1) == 0;
      v8 += 2;
    }
    while ( !v9 );
    ++v6;
    *(_DWORD *)v8 = 92;
  }
  v10 = (char *)&v39 + 1150;
  do
  {
    v9 = *((_WORD *)v10 + 1) == 0;
    v10 += 2;
  }
  while ( !v9 );
  *(_DWORD *)v10 = 42;
  v11 = (void *)sub_140018084(v43, &v41);
  if ( v11 != (void *)-1i64 )
  {
    v12 = &v40;
    v13 = 4i64;
    v14 = &v41;
    do
    {
      v12 += 128;
      v15 = *(_OWORD *)v14;
      v16 = *((_OWORD *)v14 + 1);
      v14 += 128;
      *((_OWORD *)v12 - 8) = v15;
      v17 = *((_OWORD *)v14 - 6);
      *((_OWORD *)v12 - 7) = v16;
      v18 = *((_OWORD *)v14 - 5);
      *((_OWORD *)v12 - 6) = v17;
      v19 = *((_OWORD *)v14 - 4);
      *((_OWORD *)v12 - 5) = v18;
      v20 = *((_OWORD *)v14 - 3);
      *((_OWORD *)v12 - 4) = v19;
      v21 = *((_OWORD *)v14 - 2);
      *((_OWORD *)v12 - 3) = v20;
      v22 = *((_OWORD *)v14 - 1);
      *((_OWORD *)v12 - 2) = v21;
      *((_OWORD *)v12 - 1) = v22;
      --v13;
    }
    while ( v13 );
    v23 = *((_OWORD *)v14 + 1);
    *(_OWORD *)v12 = *(_OWORD *)v14;
    v24 = *((_OWORD *)v14 + 2);
    *((_OWORD *)v12 + 1) = v23;
    *((_OWORD *)v12 + 2) = v24;
    sub_1400083A0(v6, (const WCHAR *)v43, (__int128 *)&v40, a3, a4);
    while ( !(unsigned int)sub_14001808C(v11, &v41) )
    {
      v25 = &v40;
      v26 = 4i64;
      v27 = &v41;
      do
      {
        v25 += 128;
        v28 = *(_OWORD *)v27;
        v29 = *((_OWORD *)v27 + 1);
        v27 += 128;
        *((_OWORD *)v25 - 8) = v28;
        v30 = *((_OWORD *)v27 - 6);
        *((_OWORD *)v25 - 7) = v29;
        v31 = *((_OWORD *)v27 - 5);
        *((_OWORD *)v25 - 6) = v30;
        v32 = *((_OWORD *)v27 - 4);
        *((_OWORD *)v25 - 5) = v31;
        v33 = *((_OWORD *)v27 - 3);
        *((_OWORD *)v25 - 4) = v32;
        v34 = *((_OWORD *)v27 - 2);
        *((_OWORD *)v25 - 3) = v33;
        v35 = *((_OWORD *)v27 - 1);
        *((_OWORD *)v25 - 2) = v34;
        *((_OWORD *)v25 - 1) = v35;
        --v26;
      }
      while ( v26 );
      v36 = *((_OWORD *)v27 + 1);
      *(_OWORD *)v25 = *(_OWORD *)v27;
      v37 = *((_OWORD *)v27 + 2);
      *((_OWORD *)v25 + 1) = v36;
      *((_OWORD *)v25 + 2) = v37;
      sub_1400083A0(v6, (const WCHAR *)v43, (__int128 *)&v40, a3, a4);
    }
    sub_14001805C(v11);
  }
  return sub_140017D34(WideCharStr);
}
// 140018084: using guessed type __int64 __fastcall sub_140018084(_QWORD, _QWORD);
// 14001808C: using guessed type __int64 __fastcall sub_14001808C(_QWORD, _QWORD);
// 140007D00: using guessed type WCHAR WideCharStr[4104];
// 140007D00: using guessed type __int16 var_4038[4104];

//----- (0000000140007F90) ----------------------------------------------------
__int64 __usercall sub_140007F90@<rax>(LPCSTR lpMultiByteStr@<rcx>, LPCSTR a2@<rdx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  const CHAR *v5; // rbx
  __m128i *v6; // rsi
  __m128i *v7; // rdi

  v5 = a2;
  v6 = (__m128i *)sub_140008AA0(0i64, lpMultiByteStr, 0, a3, a4, a5);
  v7 = (__m128i *)sub_140008AA0(0i64, v5, 0, a3, a4, a5);
  LODWORD(v5) = sub_140017CFC(v7, v6, a3, a4, a5);
  sub_140014F8C(v6);
  sub_140014F8C(v7);
  return (unsigned int)v5;
}

//----- (0000000140008000) ----------------------------------------------------
__int64 __usercall sub_140008000@<rax>(LPCSTR lpMultiByteStr@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  WCHAR *v4; // rdi
  unsigned int v5; // ebx

  v4 = sub_140008AA0(0i64, lpMultiByteStr, 0, a2, a3, a4);
  v5 = SetEnvironmentVariableW(v4, 0i64);
  sub_140014F8C(v4);
  return v5;
}

//----- (0000000140008040) ----------------------------------------------------
signed __int64 __usercall sub_140008040@<rax>(const CHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  char *v4; // rax
  unsigned int v5; // eax
  void *v6; // rax
  char *v7; // rax
  unsigned int v8; // eax
  void *v9; // rax
  char *v10; // rax
  unsigned int v11; // eax
  void *v12; // rax
  WCHAR *v13; // rax
  __int64 v14; // r8
  __int64 v15; // r9
  signed __int64 result; // rax
  DWORD ExitCode; // [rsp+50h] [rbp-20C8h]
  struct _SECURITY_ATTRIBUTES ProcessAttributes; // [rsp+58h] [rbp-20C0h]
  struct _PROCESS_INFORMATION ProcessInformation; // [rsp+70h] [rbp-20A8h]
  struct _STARTUPINFOW StartupInfo; // [rsp+90h] [rbp-2088h]
  WCHAR ApplicationName; // [rsp+100h] [rbp-2018h]

  ExitCode = 0;
  sub_140008AA0(&ApplicationName, a1, 4096, a2, a3, a4);
  SetConsoleCtrlHandler((PHANDLER_ROUTINE)HandlerRoutine, 1);
  ProcessAttributes.nLength = 24;
  ProcessAttributes.lpSecurityDescriptor = 0i64;
  ProcessAttributes.bInheritHandle = 1;
  GetStartupInfoW(&StartupInfo);
  StartupInfo.lpReserved = 0i64;
  _mm_store_si128((__m128i *)&StartupInfo.lpDesktop, (__m128i)0i64);
  StartupInfo.dwFlags = 257;
  StartupInfo.wShowWindow = 1;
  v4 = sub_140015160(0);
  v5 = sub_14001A924((__int64)v4, a3);
  v6 = (void *)sub_140018540(v5, a3);
  if ( v6 == (void *)-1i64 )
    v6 = 0i64;
  StartupInfo.hStdInput = v6;
  v7 = sub_140015160(1u);
  v8 = sub_14001A924((__int64)v7, a3);
  v9 = (void *)sub_140018540(v8, a3);
  if ( v9 == (void *)-1i64 )
    v9 = 0i64;
  StartupInfo.hStdOutput = v9;
  v10 = sub_140015160(2u);
  v11 = sub_14001A924((__int64)v10, a3);
  v12 = (void *)sub_140018540(v11, a3);
  if ( v12 == (void *)-1i64 )
    v12 = 0i64;
  StartupInfo.hStdError = v12;
  v13 = GetCommandLineW();
  if ( CreateProcessW(
         &ApplicationName,
         v13,
         &ProcessAttributes,
         0i64,
         1,
         0,
         0i64,
         0i64,
         &StartupInfo,
         &ProcessInformation) )
  {
    WaitForSingleObject(ProcessInformation.hProcess, 0xFFFFFFFF);
    GetExitCodeProcess(ProcessInformation.hProcess, &ExitCode);
    result = ExitCode;
  }
  else
  {
    sub_140002980((__int64)"Error creating child process!\n", (__int64)"CreateProcessW", a2, a3, a4, v14, v15);
    result = 0xFFFFFFFFi64;
  }
  return result;
}

//----- (0000000140008200) ----------------------------------------------------
_BOOL8 __fastcall sub_140008200(HMODULE a1)
{
  return FreeLibrary(a1) == 0;
}

//----- (0000000140008220) ----------------------------------------------------
HMODULE __usercall sub_140008220@<rax>(LPCSTR lpMultiByteStr@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  WCHAR *v4; // rdi
  HMODULE v5; // rbx

  v4 = sub_140008AA0(0i64, lpMultiByteStr, 0, a2, a3, a4);
  v5 = LoadLibraryExW(v4, 0i64, 8u);
  sub_140014F8C(v4);
  return v5;
}

//----- (0000000140008270) ----------------------------------------------------
signed __int64 __usercall sub_140008270@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, unsigned __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  __int64 v4; // r12
  unsigned __int64 v5; // rsi
  __int64 v6; // r14
  signed __int64 v7; // r13
  char *v8; // r15
  unsigned __int64 v9; // rbx
  __int64 v10; // rbp
  unsigned __int64 v11; // rbx
  signed __int64 v12; // rbx
  unsigned __int64 *v13; // rdi

  v4 = a2;
  v5 = a3;
  v6 = a1;
  v7 = 0i64;
  v8 = (char *)sub_140014FA0(0x2000i64);
  if ( v8 )
  {
    if ( (signed int)sub_140010824(0i64, v4, 2u, a4) >= 0 )
    {
      v9 = sub_140018F80(v4, a4);
      if ( v9 >= v5 )
      {
        do
        {
          v10 = v9 - 0x2000;
          if ( v9 < 0x2000 )
            v10 = 0i64;
          v11 = v9 - v10;
          if ( v11 < v5
            || (signed int)sub_140010824(v10, v4, 0, a4) < 0
            || sub_1400104EC(1ui64, (__int64)v8, v11, v4, a4) != v11 )
          {
            break;
          }
          v12 = v11 - v5 + 1;
          if ( v12 )
          {
            v13 = (unsigned __int64 *)&v8[v12 - 1];
            while ( (unsigned int)sub_14000D6D0(v13, v6, v5) )
            {
              v13 = (unsigned __int64 *)((char *)v13 - 1);
              if ( !--v12 )
                goto LABEL_13;
            }
            v7 = v12 + v10 - 1;
            break;
          }
LABEL_13:
          v9 = v10 + v5 - 1;
        }
        while ( v10 );
      }
    }
  }
  sub_140014F8C(v8);
  return v7;
}
// 140014FA0: using guessed type __int64 __fastcall sub_140014FA0(_QWORD);

//----- (00000001400083A0) ----------------------------------------------------
signed __int64 __usercall sub_1400083A0@<rax>(__int64 a1@<rdx>, const WCHAR *a2@<rcx>, __int128 *a3@<r8>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  const WCHAR *v5; // rbx
  char *v6; // rax
  signed __int64 v7; // rcx
  __int128 v8; // xmm0
  __int128 v9; // xmm1
  __int128 v10; // xmm0
  __int128 v11; // xmm1
  __int128 v12; // xmm0
  __int128 v13; // xmm1
  __int128 v14; // xmm0
  __int128 v15; // xmm1
  __int128 v16; // xmm1
  __int128 v17; // xmm0
  signed __int64 result; // rax
  signed __int64 v19; // rcx
  bool v20; // zf
  __int64 v21; // r8
  __int16 v22; // ax
  char v23; // [rsp+20h] [rbp-1258h]
  __int16 v24; // [rsp+44h] [rbp-1234h]
  unsigned __int16 v25; // [rsp+46h] [rbp-1232h]
  __int16 v26; // [rsp+48h] [rbp-1230h]
  CHAR MultiByteStr; // [rsp+250h] [rbp-1028h]

  v5 = a2;
  v6 = &v23;
  v7 = 4i64;
  do
  {
    v6 += 128;
    v8 = *a3;
    v9 = a3[1];
    a3 += 8;
    *((_OWORD *)v6 - 8) = v8;
    v10 = *(a3 - 6);
    *((_OWORD *)v6 - 7) = v9;
    v11 = *(a3 - 5);
    *((_OWORD *)v6 - 6) = v10;
    v12 = *(a3 - 4);
    *((_OWORD *)v6 - 5) = v11;
    v13 = *(a3 - 3);
    *((_OWORD *)v6 - 4) = v12;
    v14 = *(a3 - 2);
    *((_OWORD *)v6 - 3) = v13;
    v15 = *(a3 - 1);
    *((_OWORD *)v6 - 2) = v14;
    *((_OWORD *)v6 - 1) = v15;
    --v7;
  }
  while ( v7 );
  v16 = a3[1];
  *(_OWORD *)v6 = *a3;
  v17 = a3[2];
  *((_OWORD *)v6 + 1) = v16;
  *((_OWORD *)v6 + 2) = v17;
  result = v25;
  if ( v24 != 46 || v25 && (v25 != v24 || v26) )
  {
    v19 = (signed __int64)(v5 - 1);
    v5[a1] = 0;
    do
    {
      v20 = *(_WORD *)(v19 + 2) == 0;
      v19 += 2i64;
    }
    while ( !v20 );
    v21 = 0i64;
    do
    {
      v22 = *(&v24 + v21);
      *(_WORD *)(v19 + 2 * v21++) = v22;
    }
    while ( v22 );
    if ( v23 & 0x10 )
    {
      if ( (unsigned int)sub_140008890(v5) )
      {
        result = sub_140017D34(v5);
      }
      else
      {
        sub_140008BB0(&MultiByteStr, v5, 4096, (__int128 *)v16, a4, a5);
        result = sub_140007D00(&MultiByteStr, (__int128 *)v16, a4, a5);
      }
    }
    else
    {
      result = sub_1400185B8(v5);
      if ( (_DWORD)result )
      {
        Sleep(0x64u);
        result = sub_1400185B8(v5);
      }
    }
  }
  return result;
}

//----- (0000000140008520) ----------------------------------------------------
const char *__usercall sub_140008520@<rax>(DWORD a1@<ecx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  DWORD v4; // eax
  __int64 v5; // r8
  __int64 v6; // r9
  const char *result; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  WCHAR Buffer; // [rsp+40h] [rbp-2018h]

  v4 = a1;
  if ( !a1 )
    v4 = GetLastError();
  if ( FormatMessageW(0x1000u, 0i64, v4, 0x400u, &Buffer, 0x1000u, 0i64) )
  {
    if ( WideCharToMultiByte(0xFDE9u, 0, &Buffer, -1, MultiByteStr, 4096, 0i64, 0i64) )
    {
      result = MultiByteStr;
    }
    else
    {
      sub_140002980((__int64)"Failed to encode wchar_t as UTF-8.\n", (__int64)"WideCharToMultiByte", a2, a3, a4, v8, v9);
      result = "PyInstaller: pyi_win32_utils_to_utf8 failed.";
    }
  }
  else
  {
    sub_140002980((__int64)"No error messages generated.\n", (__int64)"FormatMessageW", a2, a3, a4, v5, v6);
    result = "PyInstaller: FormatMessageW failed.";
  }
  return result;
}

//----- (0000000140008610) ----------------------------------------------------
__int64 __usercall sub_140008610@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>, ...)
{
  __int64 v6; // rsi
  __int64 v7; // rbx
  __int64 v8; // rdi
  _QWORD *v9; // rax
  __int64 result; // rax
  va_list va; // [rsp+78h] [rbp+20h]

  va_start(va, a6);
  v6 = a3;
  v7 = a1;
  v8 = a2;
  v9 = sub_140001040();
  result = sub_140014D28(v8, *v9 | 1i64, v7, v6, a4, a5, a6, 0i64, (__int64)va);
  if ( (signed int)result < 0 )
    result = 0xFFFFFFFFi64;
  return result;
}

//----- (0000000140008670) ----------------------------------------------------
__int64 __usercall sub_140008670@<rax>(__int64 a1@<rdx>, int a2@<ecx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  __int64 v5; // r12
  __int64 v6; // rbp
  __int64 result; // rax
  _QWORD *v8; // r14
  __int64 v9; // rbx
  signed int v10; // er15
  __int64 v11; // rbp
  __int64 v12; // rsi
  _QWORD *v13; // rdi
  int v14; // eax
  __int64 v15; // r8
  __int64 v16; // r9
  int cbMultiByte; // er13
  CHAR *lpMultiByteStr; // rax
  CHAR *v19; // rbp
  const char *v20; // rdx
  const char *v21; // rcx
  __int64 v22; // [rsp+88h] [rbp+10h]
  const WCHAR *lpWideCharStr; // [rsp+90h] [rbp+18h]

  v5 = a2;
  v6 = a1;
  result = sub_140014F84(a2 + 1i64, 8i64);
  v8 = (_QWORD *)result;
  if ( result )
  {
    v9 = 0i64;
    v10 = 0;
    if ( (signed int)v5 <= 0 )
    {
LABEL_16:
      v8[v5] = 0i64;
      result = (__int64)v8;
    }
    else
    {
      v11 = v6 - result;
      v12 = 0i64;
      v22 = v11;
      v13 = (_QWORD *)result;
      while ( 1 )
      {
        lpWideCharStr = *(const WCHAR **)((char *)v13 + v11);
        v14 = WideCharToMultiByte(0xFDE9u, 0, *(LPCWSTR *)((char *)v13 + v11), -1, 0i64, 0, 0i64, 0i64);
        cbMultiByte = v14;
        if ( !v14 )
          break;
        lpMultiByteStr = (CHAR *)sub_140014F84(v14 + 1i64, 1i64);
        v19 = lpMultiByteStr;
        if ( !lpMultiByteStr )
        {
          v20 = "Out of memory.\n";
          v21 = "win32_utils_to_utf8";
          goto LABEL_13;
        }
        if ( !WideCharToMultiByte(0xFDE9u, 0, lpWideCharStr, -1, lpMultiByteStr, cbMultiByte, 0i64, 0i64) )
        {
          v20 = "Failed to encode wchar_t as UTF-8.\n";
          goto LABEL_12;
        }
        *v13 = v19;
        ++v10;
        ++v13;
        ++v12;
        if ( v10 >= (signed int)v5 )
          goto LABEL_16;
        v11 = v22;
      }
      v20 = "Failed to get UTF-8 buffer size.\n";
LABEL_12:
      v21 = "WideCharToMultiByte";
LABEL_13:
      sub_140002980((__int64)v20, (__int64)v21, a3, a4, a5, v15, v16);
      *v13 = 0i64;
      if ( v12 >= 0 )
      {
        do
          sub_140014F8C((LPVOID)v8[v9++]);
        while ( v9 <= v12 );
      }
      sub_140014F8C(v8);
      result = 0i64;
    }
  }
  return result;
}
// 140014F84: using guessed type __int64 __fastcall sub_140014F84(_QWORD, _QWORD);

//----- (0000000140008810) ----------------------------------------------------
_BOOL8 __fastcall sub_140008810(WCHAR *a1)
{
  WCHAR *v1; // rdi
  unsigned __int64 v2; // rbx

  v1 = a1;
  v2 = -1i64;
  do
    ++v2;
  while ( a1[v2] );
  if ( v2 - 2 > 1 || !(unsigned int)sub_140019024(*a1, 0x103u) || v1[1] != 58 )
    return 0i64;
  if ( v2 <= 2 )
    return 1i64;
  return v1[2] == 92;
}

//----- (0000000140008890) ----------------------------------------------------
__int64 __fastcall sub_140008890(const WCHAR *a1)
{
  unsigned int v1; // ebx
  HANDLE v2; // rax
  int FindFileData; // [rsp+30h] [rbp-268h]
  int v5; // [rsp+54h] [rbp-244h]

  v1 = 0;
  v2 = FindFirstFileExW(a1, FindExInfoBasic, &FindFileData, 0, 0i64, 0);
  if ( v2 == (HANDLE)-1i64 )
    return 0i64;
  FindClose(v2);
  if ( !(FindFileData & 0x400) )
    return 0i64;
  LOBYTE(v1) = v5 == -1610612724;
  return v1;
}

//----- (0000000140008910) ----------------------------------------------------
signed __int64 __usercall sub_140008910@<rax>(const WCHAR *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  PSID *v4; // rbx
  const WCHAR *v5; // rdi
  HANDLE v6; // rax
  LPWSTR v7; // rbx
  signed __int64 result; // rax
  DWORD TokenInformationLength; // [rsp+30h] [rbp-2048h]
  HANDLE TokenHandle; // [rsp+38h] [rbp-2040h]
  LPWSTR StringSid; // [rsp+40h] [rbp-2038h]
  struct _SECURITY_ATTRIBUTES SecurityAttributes; // [rsp+48h] [rbp-2030h]
  WCHAR StringSecurityDescriptor; // [rsp+60h] [rbp-2018h]

  v4 = 0i64;
  TokenHandle = (HANDLE)-1i64;
  StringSid = 0i64;
  v5 = a1;
  TokenInformationLength = 0;
  v6 = GetCurrentProcess();
  if ( OpenProcessToken(v6, 8u, &TokenHandle)
    && (GetTokenInformation(TokenHandle, TokenUser, 0i64, 0, &TokenInformationLength) || GetLastError() == 122) )
  {
    v4 = (PSID *)sub_140014F84(1i64, TokenInformationLength);
    if ( v4 )
    {
      if ( GetTokenInformation(TokenHandle, TokenUser, v4, TokenInformationLength, &TokenInformationLength) )
        ConvertSidToStringSidW(*v4, &StringSid);
    }
  }
  sub_140014F8C(v4);
  if ( TokenHandle != (HANDLE)-1i64 )
    CloseHandle(TokenHandle);
  v7 = StringSid;
  sub_140008610(4096i64, (__int64)&StringSecurityDescriptor, (__int64)L"D:(A;;FA;;;%s)", a2, a3, a4);
  LocalFree(v7);
  SecurityAttributes.nLength = 24;
  SecurityAttributes.bInheritHandle = 0;
  if ( ConvertStringSecurityDescriptorToSecurityDescriptorW(
         &StringSecurityDescriptor,
         1u,
         &SecurityAttributes.lpSecurityDescriptor,
         0i64) )
  {
    result = (unsigned int)(CreateDirectoryW(v5, &SecurityAttributes) != 0) - 1;
  }
  else
  {
    result = 0xFFFFFFFFi64;
  }
  return result;
}
// 140014F84: using guessed type __int64 __fastcall sub_140014F84(_QWORD, _QWORD);
// 14002DE38: using guessed type wchar_t aDAFaS[15];

//----- (0000000140008AA0) ----------------------------------------------------
WCHAR *__usercall sub_140008AA0@<rax>(LPWSTR lpWideCharStr@<rcx>, LPCSTR lpMultiByteStr@<rdx>, int cchWideChar@<r8d>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>)
{
  int v6; // edi
  const CHAR *v7; // rsi
  WCHAR *v8; // rbx
  int v9; // eax
  __int64 v10; // r8
  __int64 v11; // r9
  WCHAR *result; // rax
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9

  v6 = cchWideChar;
  v7 = lpMultiByteStr;
  v8 = lpWideCharStr;
  if ( lpWideCharStr )
    goto LABEL_11;
  v9 = MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, -1, 0i64, 0);
  v6 = v9;
  if ( !v9 )
  {
    sub_140002980((__int64)"Failed to get wchar_t buffer size.\n", (__int64)"MultiByteToWideChar", a4, a5, a6, v10, v11);
    return 0i64;
  }
  v8 = (WCHAR *)sub_140014F84(v9 + 1i64, 2i64);
  if ( v8 )
  {
LABEL_11:
    if ( MultiByteToWideChar(0xFDE9u, 0, v7, -1, v8, v6) )
    {
      result = v8;
    }
    else
    {
      sub_140002980(
        (__int64)"Failed to decode wchar_t from UTF-8\n",
        (__int64)"MultiByteToWideChar",
        a4,
        a5,
        a6,
        v15,
        v16);
      result = 0i64;
    }
  }
  else
  {
    sub_140002980((__int64)"Out of memory.\n", (__int64)"win32_utils_from_utf8", a4, a5, a6, v13, v14);
    result = 0i64;
  }
  return result;
}
// 140014F84: using guessed type __int64 __fastcall sub_140014F84(_QWORD, _QWORD);

//----- (0000000140008BB0) ----------------------------------------------------
CHAR *__usercall sub_140008BB0@<rax>(LPSTR lpMultiByteStr@<rcx>, LPCWSTR lpWideCharStr@<rdx>, int cbMultiByte@<r8d>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>)
{
  int v6; // edi
  const WCHAR *v7; // rsi
  CHAR *v8; // rbx
  int v9; // eax
  __int64 v10; // r8
  __int64 v11; // r9
  CHAR *result; // rax
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9

  v6 = cbMultiByte;
  v7 = lpWideCharStr;
  v8 = lpMultiByteStr;
  if ( lpMultiByteStr )
    goto LABEL_11;
  v9 = WideCharToMultiByte(0xFDE9u, 0, lpWideCharStr, -1, 0i64, 0, 0i64, 0i64);
  v6 = v9;
  if ( !v9 )
  {
    sub_140002980((__int64)"Failed to get UTF-8 buffer size.\n", (__int64)"WideCharToMultiByte", a4, a5, a6, v10, v11);
    return 0i64;
  }
  v8 = (CHAR *)sub_140014F84(v9 + 1i64, 1i64);
  if ( v8 )
  {
LABEL_11:
    if ( WideCharToMultiByte(0xFDE9u, 0, v7, -1, v8, v6, 0i64, 0i64) )
    {
      result = v8;
    }
    else
    {
      sub_140002980(
        (__int64)"Failed to encode wchar_t as UTF-8.\n",
        (__int64)"WideCharToMultiByte",
        a4,
        a5,
        a6,
        v15,
        v16);
      result = 0i64;
    }
  }
  else
  {
    sub_140002980((__int64)"Out of memory.\n", (__int64)"win32_utils_to_utf8", a4, a5, a6, v13, v14);
    result = 0i64;
  }
  return result;
}
// 140014F84: using guessed type __int64 __fastcall sub_140014F84(_QWORD, _QWORD);

//----- (0000000140008CA0) ----------------------------------------------------
signed __int64 __fastcall sub_140008CA0(unsigned int a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  unsigned __int8 *v3; // r10
  unsigned int v4; // er9
  unsigned int v5; // edx
  int v6; // er8
  int v7; // ecx
  int v9; // eax
  unsigned int v10; // er8
  unsigned __int64 v11; // r11
  signed int v12; // edx
  unsigned int v13; // ecx
  int v14; // er9
  int v15; // ecx
  int v16; // er9
  int v17; // ecx
  int v18; // er9
  int v19; // ecx
  int v20; // er9
  int v21; // ecx
  int v22; // er9
  int v23; // ecx
  int v24; // er9
  int v25; // ecx
  int v26; // er9
  int v27; // ecx
  int v28; // er9
  int v29; // ecx
  int v30; // er9
  int v31; // ecx
  int v32; // er9
  int v33; // ecx
  int v34; // er9
  int v35; // ecx
  int v36; // er9
  int v37; // ecx
  int v38; // er9
  int v39; // ecx
  int v40; // er9
  int v41; // ecx
  int v42; // eax
  int v43; // er9
  unsigned __int64 v44; // rdx
  unsigned int v45; // ecx
  int v46; // er9
  int v47; // ecx
  int v48; // er9
  int v49; // ecx
  int v50; // er9
  int v51; // ecx
  int v52; // er9
  int v53; // ecx
  int v54; // er9
  int v55; // ecx
  int v56; // er9
  int v57; // ecx
  int v58; // er9
  int v59; // ecx
  int v60; // er9
  int v61; // ecx
  int v62; // er9
  int v63; // ecx
  int v64; // er9
  int v65; // ecx
  int v66; // er9
  int v67; // ecx
  int v68; // er9
  int v69; // ecx
  int v70; // er9
  int v71; // ecx
  int v72; // er9
  int v73; // ecx
  int v74; // eax
  int v75; // er9
  int v76; // eax

  a3 = (unsigned int)a3;
  v3 = a2;
  v4 = a1 >> 16;
  a1 = (unsigned __int16)a1;
  if ( (unsigned int)a3 == 1i64 )
  {
    v5 = a1 + *a2;
    v6 = v5 - 65521;
    if ( v5 < 0xFFF1 )
      v6 = v5;
    v7 = v6 + v4 - 65521;
    if ( v6 + v4 < 0xFFF1 )
      v7 = v6 + v4;
    return v6 | (unsigned int)(v7 << 16);
  }
  if ( !a2 )
    return 1i64;
  if ( a3 >= 0x10 )
  {
    if ( a3 >= 0x15B0 )
    {
      v11 = (unsigned __int64)((a3 * (unsigned __int128)0x79BAA6BB6398B6F7ui64 >> 64)
                             + ((unsigned __int64)(a3 - (a3 * (unsigned __int128)0x79BAA6BB6398B6F7ui64 >> 64)) >> 1)) >> 12;
      a3 += -5552i64 * v11;
      do
      {
        v12 = 347;
        do
        {
          v13 = *v3 + a1;
          v14 = v13 + v4;
          v15 = v3[1] + v13;
          v16 = v15 + v14;
          v17 = v3[2] + v15;
          v18 = v17 + v16;
          v19 = v3[3] + v17;
          v20 = v19 + v18;
          v21 = v3[4] + v19;
          v22 = v21 + v20;
          v23 = v3[5] + v21;
          v24 = v23 + v22;
          v25 = v3[6] + v23;
          v26 = v25 + v24;
          v27 = v3[7] + v25;
          v28 = v27 + v26;
          v29 = v3[8] + v27;
          v30 = v29 + v28;
          v31 = v3[9] + v29;
          v32 = v31 + v30;
          v33 = v3[10] + v31;
          v34 = v33 + v32;
          v35 = v3[11] + v33;
          v36 = v35 + v34;
          v37 = v3[12] + v35;
          v38 = v37 + v36;
          v39 = v3[13] + v37;
          v40 = v39 + v38;
          v41 = v3[14] + v39;
          v42 = v3[15];
          v43 = v41 + v40;
          v3 += 16;
          a1 = v42 + v41;
          v4 = a1 + v43;
          --v12;
        }
        while ( v12 );
        a1 %= 0xFFF1u;
        v4 %= 0xFFF1u;
        --v11;
      }
      while ( v11 );
      if ( !a3 )
        return a1 | (v4 << 16);
      if ( a3 < 0x10 )
        goto LABEL_30;
    }
    v44 = a3 >> 4;
    a3 += -16i64 * (a3 >> 4);
    do
    {
      v45 = *v3 + a1;
      v46 = v45 + v4;
      v47 = v3[1] + v45;
      v48 = v47 + v46;
      v49 = v3[2] + v47;
      v50 = v49 + v48;
      v51 = v3[3] + v49;
      v52 = v51 + v50;
      v53 = v3[4] + v51;
      v54 = v53 + v52;
      v55 = v3[5] + v53;
      v56 = v55 + v54;
      v57 = v3[6] + v55;
      v58 = v57 + v56;
      v59 = v3[7] + v57;
      v60 = v59 + v58;
      v61 = v3[8] + v59;
      v62 = v61 + v60;
      v63 = v3[9] + v61;
      v64 = v63 + v62;
      v65 = v3[10] + v63;
      v66 = v65 + v64;
      v67 = v3[11] + v65;
      v68 = v67 + v66;
      v69 = v3[12] + v67;
      v70 = v69 + v68;
      v71 = v3[13] + v69;
      v72 = v71 + v70;
      v73 = v3[14] + v71;
      v74 = v3[15];
      v75 = v73 + v72;
      v3 += 16;
      a1 = v74 + v73;
      v4 = a1 + v75;
      --v44;
    }
    while ( v44 );
    if ( a3 )
    {
LABEL_30:
      do
      {
        v76 = *v3++;
        a1 += v76;
        v4 += a1;
        --a3;
      }
      while ( a3 );
    }
    a1 %= 0xFFF1u;
    v4 %= 0xFFF1u;
    return a1 | (v4 << 16);
  }
  for ( ; a3; --a3 )
  {
    v9 = *v3++;
    a1 += v9;
    v4 += a1;
  }
  v10 = a1 - 65521;
  if ( a1 < 0xFFF1 )
    v10 = a1;
  return v10 | ((v4 + 15 * (v4 / 0xFFF1)) << 16);
}

//----- (0000000140008F90) ----------------------------------------------------
__int64 __fastcall sub_140008F90(int a1, char *a2, unsigned int a3)
{
  return sub_140008FA0(a1, a2, a3);
}

//----- (0000000140008FA0) ----------------------------------------------------
__int64 __fastcall sub_140008FA0(int a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbp
  char *v4; // rsi
  unsigned int v6; // ecx
  __int64 v7; // rax
  int v8; // er14
  int v9; // er12
  int v10; // er13
  int v11; // edx
  unsigned __int64 v12; // r15
  signed __int64 i; // r15
  unsigned int v14; // edx
  unsigned int v15; // ecx
  unsigned int v16; // er14
  unsigned int v17; // er12
  unsigned int v18; // er13
  int v19; // eax
  unsigned int v20; // ecx
  unsigned int v21; // ecx
  int v22; // ecx
  unsigned int v23; // ecx
  unsigned int v24; // ecx
  int v25; // ecx
  unsigned int v26; // ecx
  unsigned int v27; // ecx
  int v28; // ecx
  unsigned int v29; // ecx
  unsigned int v30; // ecx
  int v31; // ecx
  unsigned int v32; // ecx
  unsigned int v33; // ecx
  unsigned int v34; // ecx
  unsigned __int64 v35; // r8
  unsigned int v36; // ecx
  unsigned int v37; // ecx
  unsigned int v38; // ecx
  unsigned int v39; // ecx
  unsigned int v40; // ecx
  unsigned int v41; // ecx
  __int64 v42; // rax
  char v43; // dl
  unsigned int v44; // ecx
  char v45; // dl
  int v46; // [rsp+38h] [rbp+10h]
  int v47; // [rsp+38h] [rbp+10h]

  v3 = a3;
  v4 = a2;
  if ( !a2 )
    return 0i64;
  v6 = ~a1;
  if ( a3 >= 0x17 )
  {
    do
    {
      if ( !((unsigned __int8)v4 & 3) )
        break;
      v7 = (unsigned __int8)(v6 ^ *v4++);
      v6 = dword_14002DE60[v7] ^ (v6 >> 8);
      --v3;
    }
    while ( v3 );
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = (unsigned __int64)(v3 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 4;
    v46 = 0;
    v3 -= 20 * v12;
    for ( i = v12 - 1; i; --i )
    {
      v14 = *((_DWORD *)v4 + 4) ^ v11;
      v15 = *(_DWORD *)v4 ^ v6;
      v16 = *((_DWORD *)v4 + 1) ^ v8;
      v17 = *((_DWORD *)v4 + 2) ^ v9;
      v18 = *((_DWORD *)v4 + 3) ^ v10;
      v4 += 20;
      v47 = dword_14002E660[(unsigned __int8)v14];
      v6 = dword_14002F260[(unsigned __int64)v15 >> 24] ^ dword_14002EA60[BYTE1(v15)] ^ dword_14002EE60[BYTE2(v15)] ^ dword_14002E660[(unsigned __int8)v15];
      v8 = dword_14002F260[(unsigned __int64)v16 >> 24] ^ dword_14002EA60[BYTE1(v16)] ^ dword_14002EE60[BYTE2(v16)] ^ dword_14002E660[(unsigned __int8)v16];
      v9 = dword_14002F260[(unsigned __int64)v17 >> 24] ^ dword_14002EA60[BYTE1(v17)] ^ dword_14002EE60[BYTE2(v17)] ^ dword_14002E660[(unsigned __int8)v17];
      v10 = dword_14002F260[(unsigned __int64)v18 >> 24] ^ dword_14002EA60[BYTE1(v18)] ^ dword_14002EE60[BYTE2(v18)] ^ dword_14002E660[(unsigned __int8)v18];
      v19 = dword_14002F260[(unsigned __int64)v14 >> 24] ^ dword_14002EA60[BYTE1(v14)] ^ dword_14002EE60[BYTE2(v14)];
      v11 = v19 ^ v47;
      v46 = v19 ^ v47;
    }
    v20 = dword_14002DE60[(unsigned __int8)(*v4 ^ v6)] ^ ((*(_DWORD *)v4 ^ v6) >> 8);
    v21 = dword_14002DE60[(unsigned __int8)v20] ^ (v20 >> 8);
    v22 = dword_14002DE60[(unsigned __int8)v21] ^ (v21 >> 8);
    v23 = dword_14002DE60[(unsigned __int8)(v8 ^ v4[4] ^ v22)] ^ ((v8 ^ *((_DWORD *)v4 + 1) ^ (unsigned int)v22) >> 8);
    v24 = dword_14002DE60[(unsigned __int8)v23] ^ (v23 >> 8);
    v25 = dword_14002DE60[(unsigned __int8)v24] ^ (v24 >> 8);
    v26 = dword_14002DE60[(unsigned __int8)(v9 ^ v4[8] ^ v25)] ^ ((v9 ^ *((_DWORD *)v4 + 2) ^ (unsigned int)v25) >> 8);
    v27 = dword_14002DE60[(unsigned __int8)v26] ^ (v26 >> 8);
    v28 = dword_14002DE60[(unsigned __int8)v27] ^ (v27 >> 8);
    v29 = dword_14002DE60[(unsigned __int8)(v10 ^ v4[12] ^ v28)] ^ ((v10 ^ *((_DWORD *)v4 + 3) ^ (unsigned int)v28) >> 8);
    v30 = dword_14002DE60[(unsigned __int8)v29] ^ (v29 >> 8);
    v31 = dword_14002DE60[(unsigned __int8)v30] ^ (v30 >> 8);
    v32 = dword_14002DE60[(unsigned __int8)(v46 ^ v4[16] ^ v31)] ^ ((v46 ^ *((_DWORD *)v4 + 4) ^ (unsigned int)v31) >> 8);
    v33 = dword_14002DE60[(unsigned __int8)v32] ^ (v32 >> 8);
    v34 = dword_14002DE60[(unsigned __int8)v33] ^ (v33 >> 8);
    v6 = dword_14002DE60[(unsigned __int8)v34] ^ (v34 >> 8);
    v4 += 20;
  }
  if ( v3 >= 8 )
  {
    v35 = v3 >> 3;
    v3 += -8i64 * (v3 >> 3);
    do
    {
      v36 = dword_14002DE60[(unsigned __int8)(v6 ^ *v4)] ^ (v6 >> 8);
      v37 = dword_14002DE60[(unsigned __int8)(v36 ^ v4[1])] ^ (v36 >> 8);
      v38 = dword_14002DE60[(unsigned __int8)(v37 ^ v4[2])] ^ (v37 >> 8);
      v39 = dword_14002DE60[(unsigned __int8)(v38 ^ v4[3])] ^ (v38 >> 8);
      v40 = dword_14002DE60[(unsigned __int8)(v39 ^ v4[4])] ^ (v39 >> 8);
      v41 = dword_14002DE60[(unsigned __int8)(v40 ^ v4[5])] ^ (v40 >> 8);
      v42 = (unsigned __int8)(v41 ^ v4[6]);
      v43 = v4[7];
      v4 += 8;
      v44 = dword_14002DE60[v42] ^ (v41 >> 8);
      v6 = dword_14002DE60[(unsigned __int8)(v44 ^ v43)] ^ (v44 >> 8);
      --v35;
    }
    while ( v35 );
  }
  for ( ; v3; --v3 )
  {
    v45 = *v4++;
    v6 = dword_14002DE60[(unsigned __int8)(v6 ^ v45)] ^ (v6 >> 8);
  }
  return ~v6;
}

//----- (0000000140009450) ----------------------------------------------------
__int64 __fastcall sub_140009450(unsigned __int8 **a1, int a2)
{
  unsigned __int8 *v2; // rsi
  unsigned __int8 *v3; // r8
  __int64 v4; // rax
  unsigned __int8 *v5; // rdi
  int v6; // ecx
  unsigned int v7; // er14
  unsigned __int8 *v8; // r15
  unsigned int v9; // ebx
  unsigned int v10; // er10
  unsigned __int8 *v11; // r11
  __int64 v12; // r12
  __int64 v13; // r13
  int v14; // ecx
  int v15; // edx
  int v16; // esi
  __int64 v17; // rcx
  int v18; // edx
  signed __int64 v19; // r9
  unsigned __int64 v20; // rcx
  unsigned int v21; // er11
  unsigned int v22; // edx
  int v23; // eax
  int v24; // eax
  signed __int64 v25; // r9
  int v26; // ecx
  char v27; // dl
  int v28; // ecx
  unsigned int v29; // edx
  int v30; // eax
  int v31; // eax
  unsigned int v32; // esi
  int v33; // eax
  unsigned int v34; // ecx
  unsigned __int8 *v35; // r9
  unsigned __int8 v36; // al
  unsigned int v37; // eax
  unsigned int v38; // ecx
  signed __int64 v39; // r9
  unsigned int v40; // ecx
  unsigned __int8 v41; // al
  unsigned __int8 v42; // al
  __int64 v43; // rcx
  unsigned __int8 v44; // al
  bool v45; // cf
  bool v46; // zf
  unsigned __int8 *v47; // rcx
  unsigned __int8 v48; // al
  unsigned __int8 *v49; // rsi
  unsigned __int8 **v50; // rdx
  const char *v51; // rax
  unsigned __int8 *v52; // rdi
  int v53; // er10
  __int64 result; // rax
  int i; // [rsp+0h] [rbp-78h]
  unsigned __int8 *v56; // [rsp+8h] [rbp-70h]
  unsigned __int8 *v57; // [rsp+10h] [rbp-68h]
  unsigned __int8 *v58; // [rsp+18h] [rbp-60h]
  int v59; // [rsp+20h] [rbp-58h]
  unsigned __int8 **v60; // [rsp+80h] [rbp+8h]
  int v61; // [rsp+88h] [rbp+10h]
  int v62; // [rsp+90h] [rbp+18h]
  unsigned int v63; // [rsp+98h] [rbp+20h]

  v60 = a1;
  v2 = a1[5];
  v3 = a1[2];
  v4 = (unsigned int)(*((_DWORD *)a1 + 2) - 5);
  v5 = *a1;
  v6 = *((_DWORD *)a1 + 6);
  v7 = *((_DWORD *)v2 + 15);
  v8 = (unsigned __int8 *)*((_QWORD *)v2 + 8);
  v9 = *((_DWORD *)v2 + 18);
  v10 = *((_DWORD *)v2 + 19);
  v11 = &v3[v6 - 257];
  v12 = *((_QWORD *)v2 + 12);
  v13 = *((_QWORD *)v2 + 13);
  v58 = &v5[v4];
  v57 = v2;
  v59 = (_DWORD)v3 - (a2 - v6);
  v14 = *((_DWORD *)v2 + 29);
  v15 = (1 << *((_DWORD *)v2 + 28)) - 1;
  v62 = *((_DWORD *)v2 + 13);
  LODWORD(v4) = *((_DWORD *)v2 + 14);
  v16 = (1 << v14) - 1;
  v56 = v11;
  v61 = (1 << v14) - 1;
  v63 = v4;
  for ( i = v15; ; v15 = i )
  {
    if ( v10 < 0xF )
    {
      v9 += (v5[1] << (v10 + 8)) + (*v5 << v10);
      v5 += 2;
      v10 += 16;
    }
    v17 = v9 & v15;
    v18 = *(unsigned __int8 *)(v12 + 4 * v17);
    v19 = v12 + 4 * v17;
    LODWORD(v17) = *(unsigned __int8 *)(v12 + 4 * v17 + 1);
    v9 >>= v17;
    v10 -= v17;
    if ( v18 )
      break;
LABEL_8:
    *v3++ = *(_BYTE *)(v19 + 2);
LABEL_53:
    if ( v5 >= v58 || v3 >= v11 )
    {
      v50 = v60;
      v49 = v57;
      goto LABEL_63;
    }
  }
  while ( 1 )
  {
    if ( v18 & 0x10 )
    {
      v21 = *(unsigned __int16 *)(v19 + 2);
      v22 = v18 & 0xF;
      if ( v22 )
      {
        if ( v10 < v22 )
        {
          v23 = *v5++ << v10;
          v9 += v23;
          v10 += 8;
        }
        v24 = v9 & ((1 << v22) - 1);
        v9 >>= v22;
        v21 += v24;
        v10 -= v22;
      }
      if ( v10 < 0xF )
      {
        v9 += (v5[1] << (v10 + 8)) + (*v5 << v10);
        v5 += 2;
        v10 += 16;
      }
      v25 = v13 + 4i64 * (v9 & v16);
      v26 = *(unsigned __int8 *)(v25 + 1);
      v27 = *(_BYTE *)v25;
      v10 -= v26;
      v9 >>= v26;
      if ( !(*(_BYTE *)v25 & 0x10) )
      {
        while ( !(v27 & 0x40) )
        {
          v25 = v13 + 4 * (*(unsigned __int16 *)(v25 + 2) + (unsigned __int64)(v9 & ((1 << v27) - 1)));
          v28 = *(unsigned __int8 *)(v25 + 1);
          v27 = *(_BYTE *)v25;
          v10 -= v28;
          v9 >>= v28;
          if ( *(_BYTE *)v25 & 0x10 )
            goto LABEL_18;
        }
        v51 = "invalid distance code";
LABEL_61:
        v50 = v60;
        v49 = v57;
        v60[4] = (unsigned __int8 *)v51;
        *((_DWORD *)v57 + 2) = 16209;
LABEL_63:
        LODWORD(v11) = (_DWORD)v56;
        goto LABEL_64;
      }
LABEL_18:
      v29 = v27 & 0xF;
      if ( v10 < v29 )
      {
        v30 = *v5 << v10;
        v10 += 8;
        v9 += v30;
        ++v5;
        if ( v10 < v29 )
        {
          v9 += *v5++ << v10;
          v10 += 8;
        }
      }
      v10 -= v29;
      v31 = v9 & ((1 << v29) - 1);
      v9 >>= v29;
      v32 = v31 + *(unsigned __int16 *)(v25 + 2);
      v33 = (_DWORD)v3 - v59;
      if ( v32 <= (signed int)v3 - v59 )
      {
        v47 = &v3[-v32];
        do
        {
          v48 = *v47;
          v47 += 3;
          *v3 = v48;
          v21 -= 3;
          v3[1] = *(v47 - 2);
          v3[2] = *(v47 - 1);
          v3 += 3;
        }
        while ( v21 > 2 );
        if ( !v21 )
          goto LABEL_52;
        v16 = v61;
        *v3++ = *v47;
        v45 = v21 < 1;
        v46 = v21 == 1;
        v11 = v56;
        if ( !v45 && !v46 )
          *v3++ = v47[1];
        goto LABEL_53;
      }
      v34 = v32 - v33;
      if ( v32 - v33 > v63 && *((_DWORD *)v57 + 1784) )
      {
        v51 = "invalid distance too far back";
        goto LABEL_61;
      }
      if ( v7 )
      {
        v37 = v7 - v34;
        if ( v7 < v34 )
        {
          v38 = v34 - v7;
          v35 = &v8[v37 + v62];
          if ( v38 >= v21 )
            goto LABEL_41;
          v21 -= v38;
          v39 = v35 - v3;
          do
          {
            *v3 = v3[v39];
            ++v3;
            --v38;
          }
          while ( v38 );
          v35 = v8;
          if ( v7 >= v21 )
            goto LABEL_41;
          v40 = v7;
          v21 -= v7;
          do
          {
            v41 = *v35++;
            *v3++ = v41;
            --v40;
          }
          while ( v40 );
          goto LABEL_40;
        }
        v35 = &v8[v37];
        if ( v34 < v21 )
        {
          v21 -= v34;
          do
          {
            v42 = *v35++;
            *v3++ = v42;
            --v34;
          }
          while ( v34 );
          goto LABEL_40;
        }
      }
      else
      {
        v35 = &v8[v62 - v34];
        if ( v34 < v21 )
        {
          v21 -= v34;
          do
          {
            v36 = *v35++;
            *v3++ = v36;
            --v34;
          }
          while ( v34 );
LABEL_40:
          v35 = &v3[-v32];
          goto LABEL_41;
        }
      }
LABEL_41:
      if ( v21 > 2 )
      {
        v43 = (v21 - 3) / 3 + 1;
        do
        {
          v21 -= 3;
          *v3 = *v35;
          v3[1] = v35[1];
          v44 = v35[2];
          v35 += 3;
          v3[2] = v44;
          v3 += 3;
          --v43;
        }
        while ( v43 );
      }
      if ( !v21 )
      {
LABEL_52:
        v16 = v61;
        v11 = v56;
        goto LABEL_53;
      }
      v16 = v61;
      *v3++ = *v35;
      v45 = v21 < 1;
      v46 = v21 == 1;
      v11 = v56;
      if ( !v45 && !v46 )
        *v3++ = v35[1];
      goto LABEL_53;
    }
    if ( v18 & 0x40 )
      break;
    v20 = *(unsigned __int16 *)(v19 + 2) + (unsigned __int64)(v9 & ((1 << v18) - 1));
    v18 = *(unsigned __int8 *)(v12 + 4 * v20);
    v19 = v12 + 4 * v20;
    LODWORD(v20) = *(unsigned __int8 *)(v12 + 4 * v20 + 1);
    v9 >>= v20;
    v10 -= v20;
    if ( !v18 )
      goto LABEL_8;
  }
  v49 = v57;
  v46 = (v18 & 0x20) == 0;
  v50 = v60;
  if ( v46 )
  {
    v60[4] = "invalid literal/length code";
    *((_DWORD *)v57 + 2) = 16209;
  }
  else
  {
    *((_DWORD *)v57 + 2) = 16191;
  }
LABEL_64:
  v50[2] = v3;
  v52 = &v5[-(v10 >> 3)];
  *((_DWORD *)v50 + 6) = (_DWORD)v11 - (_DWORD)v3 + 257;
  *v50 = v52;
  v53 = v10 - 8 * (v10 >> 3);
  result = (unsigned int)((_DWORD)v58 - (_DWORD)v52 + 5);
  *((_DWORD *)v50 + 2) = result;
  *((_DWORD *)v49 + 19) = v53;
  *((_DWORD *)v49 + 18) = v9 & ((1 << v53) - 1);
  return result;
}

//----- (0000000140009950) ----------------------------------------------------
signed __int64 __fastcall sub_140009950(__int64 a1, int a2)
{
  int v2; // edi
  __int64 v3; // r12
  __int64 v4; // rax
  __int64 v5; // r13
  unsigned int v6; // er10
  __m128i *v7; // r9
  unsigned int v8; // esi
  int v9; // er8
  __m128i *v10; // rbp
  unsigned int v11; // er14
  unsigned int v12; // ebx
  _DWORD *v13; // rdx
  unsigned int *v14; // r11
  int v15; // edx
  __int64 v16; // rax
  unsigned int v17; // eax
  unsigned int v18; // ecx
  int v19; // eax
  int *v20; // rdx
  __int64 v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rax
  __int64 v24; // rax
  unsigned int v25; // ecx
  unsigned int v26; // edi
  __int64 v27; // rax
  __int64 v28; // r10
  unsigned int v29; // er8
  unsigned int v30; // er9
  unsigned int v31; // eax
  unsigned int v32; // edi
  __int64 v33; // rax
  char v34; // r15
  __int64 v35; // rax
  __int64 v36; // rdx
  __int64 v37; // rcx
  __int64 v38; // rax
  unsigned int v39; // edi
  __int64 v40; // rax
  char v41; // r15
  __int64 v42; // rax
  __int64 v43; // rdx
  __int64 v44; // rcx
  __int64 v45; // rax
  int v46; // edx
  __int64 v47; // rax
  int v48; // eax
  int v49; // eax
  int v50; // eax
  int v51; // ecx
  char v52; // al
  unsigned int v53; // er14
  unsigned int v54; // edi
  unsigned int v55; // er15
  int v56; // ecx
  bool v57; // zf
  signed int v58; // eax
  signed __int64 result; // rax
  int v60; // ecx
  unsigned int v61; // ecx
  unsigned int v62; // eax
  unsigned int v63; // er15
  char v64; // cl
  unsigned int v65; // er14
  char v66; // dl
  unsigned int v67; // ecx
  int v68; // eax
  unsigned int v69; // edx
  __int64 i; // rax
  __int16 v71; // cx
  __int64 v72; // r10
  int v73; // er9
  int v74; // eax
  int v75; // er8
  unsigned int v76; // ecx
  int v77; // edx
  unsigned int v78; // edx
  int v79; // ecx
  unsigned int v80; // er8
  unsigned int v81; // edx
  int v82; // er9
  int v83; // eax
  int v84; // edx
  int v85; // edx
  __int16 v86; // r9
  unsigned int v87; // edx
  unsigned int v88; // er14
  char v89; // dl
  int v90; // eax
  unsigned int v91; // edx
  unsigned int v92; // er14
  char v93; // dl
  __int64 v94; // r8
  __int64 v95; // r8
  __int64 v96; // rax
  __int64 v97; // r9
  int v98; // edx
  unsigned int v99; // eax
  int v100; // er8
  unsigned int v101; // er10
  signed int v102; // er11
  unsigned int v103; // edx
  int v104; // eax
  __int64 v105; // r9
  int v106; // edx
  unsigned int v107; // eax
  int v108; // er8
  unsigned int v109; // er10
  signed int v110; // er11
  unsigned int v111; // edx
  int v112; // eax
  __int64 v113; // rcx
  unsigned int v114; // ecx
  unsigned int v115; // eax
  __int64 v116; // rdx
  unsigned int v117; // eax
  char *v118; // rdx
  unsigned int v119; // er8
  unsigned int v120; // ecx
  signed __int64 v121; // rdx
  unsigned __int64 v122; // r8
  unsigned int v123; // ecx
  char *v124; // rdx
  int v125; // eax
  int v126; // ecx
  int v127; // edx
  unsigned int v128; // edi
  int v129; // er10
  unsigned int v130; // ecx
  char *v131; // rdx
  int v132; // eax
  int v133; // edx
  signed int v134; // er9
  signed int v135; // er8
  __int16 v136; // [rsp+30h] [rbp-68h]
  char v137; // [rsp+32h] [rbp-66h]
  char v138; // [rsp+33h] [rbp-65h]
  int v139; // [rsp+34h] [rbp-64h]
  int v140; // [rsp+38h] [rbp-60h]
  __m128i *v141; // [rsp+40h] [rbp-58h]
  int v142; // [rsp+A0h] [rbp+8h]
  int v143; // [rsp+A8h] [rbp+10h]
  unsigned int v144; // [rsp+B0h] [rbp+18h]
  unsigned int v145; // [rsp+B8h] [rbp+20h]

  v143 = a2;
  v2 = a2;
  v3 = a1;
  if ( !a1 )
    return 4294967294i64;
  if ( !*(_QWORD *)(a1 + 48) )
    return 4294967294i64;
  if ( !*(_QWORD *)(a1 + 56) )
    return 4294967294i64;
  v4 = *(_QWORD *)(a1 + 40);
  if ( !v4
    || *(_QWORD *)v4 != a1
    || (unsigned int)(*(_DWORD *)(v4 + 8) - 16180) > 0x1F
    || !*(_QWORD *)(a1 + 16)
    || !*(_QWORD *)a1 && *(_DWORD *)(a1 + 8) )
  {
    return 4294967294i64;
  }
  v5 = *(_QWORD *)(a1 + 40);
  if ( *(_DWORD *)(v5 + 8) == 16191 )
    *(_DWORD *)(v5 + 8) = 16192;
  v6 = *(_DWORD *)(a1 + 24);
  v7 = *(__m128i **)(a1 + 16);
  v8 = *(_DWORD *)(a1 + 8);
  v9 = v6;
  v10 = *(__m128i **)a1;
  v11 = *(_DWORD *)(v5 + 72);
  v12 = *(_DWORD *)(v5 + 76);
  v141 = *(__m128i **)(a1 + 16);
  v145 = v6;
  v140 = v8;
  v142 = v6;
  v144 = 0;
  while ( 2 )
  {
    v13 = (_DWORD *)(v5 + 116);
    v14 = (unsigned int *)(v5 + 112);
    switch ( 0x40000000 )
    {
      case 0:
        v15 = *(_DWORD *)(v5 + 16);
        if ( !v15 )
        {
          *(_DWORD *)(v5 + 8) = 16192;
          goto LABEL_144;
        }
        if ( v12 < 0x10 )
        {
          while ( v8 )
          {
            --v8;
            v11 += LOBYTE(v10->m128i_i64[0]) << v12;
            v10 = (__m128i *)((char *)v10 + 1);
            v12 += 8;
            if ( v12 >= 0x10 )
              goto LABEL_19;
          }
          goto LABEL_166;
        }
LABEL_19:
        if ( v15 & 2 && v11 == 35615 )
        {
          if ( !*(_DWORD *)(v5 + 48) )
            *(_DWORD *)(v5 + 48) = 15;
          *(_DWORD *)(v5 + 32) = sub_140008F90(0, 0i64, 0);
          v136 = v11;
          *(_DWORD *)(v5 + 32) = sub_140008F90(*(_DWORD *)(v5 + 32), (char *)&v136, 2u);
          v11 = 0;
          v12 = 0;
          *(_DWORD *)(v5 + 8) = 16181;
          goto LABEL_143;
        }
        v16 = *(_QWORD *)(v5 + 40);
        if ( v16 )
          *(_DWORD *)(v16 + 64) = -1;
        if ( *(_BYTE *)(v5 + 16) & 1
          && (v11 >> 8) + ((unsigned __int8)v11 << 8) == 31 * (((v11 >> 8) + ((unsigned __int8)v11 << 8)) / 0x1F) )
        {
          if ( (v11 & 0xF) != 8 )
          {
            *(_QWORD *)(v3 + 32) = "unknown compression method";
            *(_DWORD *)(v5 + 8) = 16209;
            goto LABEL_144;
          }
          v17 = *(_DWORD *)(v5 + 48);
          v12 -= 4;
          v11 >>= 4;
          v18 = (v11 & 0xF) + 8;
          if ( !v17 )
          {
            *(_DWORD *)(v5 + 48) = v18;
            v17 = (v11 & 0xF) + 8;
          }
          if ( v18 <= 0xF && v18 <= v17 )
          {
            *(_DWORD *)(v5 + 24) = 0;
            *(_DWORD *)(v5 + 28) = 1 << v18;
            v19 = sub_140008CA0(0, 0i64, 0i64);
            v12 = 0;
            *(_DWORD *)(v5 + 32) = v19;
            *(_DWORD *)(v3 + 76) = v19;
            *(_DWORD *)(v5 + 8) = ~BYTE1(v11) & 2 | 0x3F3D;
            v11 = 0;
            goto LABEL_143;
          }
          *(_QWORD *)(v3 + 32) = "invalid window size";
          *(_DWORD *)(v5 + 8) = 16209;
        }
        else
        {
          *(_QWORD *)(v3 + 32) = "incorrect header check";
          *(_DWORD *)(v5 + 8) = 16209;
        }
        goto LABEL_144;
      case 1:
        if ( v12 >= 0x10 )
          goto LABEL_40;
        do
        {
          if ( !v8 )
            goto LABEL_166;
          --v8;
          v11 += LOBYTE(v10->m128i_i64[0]) << v12;
          v10 = (__m128i *)((char *)v10 + 1);
          v12 += 8;
        }
        while ( v12 < 0x10 );
LABEL_40:
        *(_DWORD *)(v5 + 24) = v11;
        if ( (_BYTE)v11 != 8 )
        {
          *(_QWORD *)(v3 + 32) = "unknown compression method";
          *(_DWORD *)(v5 + 8) = 16209;
          goto LABEL_144;
        }
        if ( v11 & 0xE000 )
        {
          *(_QWORD *)(v3 + 32) = "unknown header flags set";
          *(_DWORD *)(v5 + 8) = 16209;
          goto LABEL_144;
        }
        v20 = *(int **)(v5 + 40);
        if ( v20 )
          *v20 = BYTE1(v11) & 1;
        if ( *(_DWORD *)(v5 + 24) & 0x200 && *(_BYTE *)(v5 + 16) & 4 )
        {
          LOBYTE(v136) = 8;
          HIBYTE(v136) = BYTE1(v11);
          *(_DWORD *)(v5 + 32) = sub_140008F90(*(_DWORD *)(v5 + 32), (char *)&v136, 2u);
        }
        v11 = 0;
        *(_DWORD *)(v5 + 8) = 16182;
        v12 = 0;
        do
        {
LABEL_51:
          if ( !v8 )
            goto LABEL_166;
          --v8;
          v11 += LOBYTE(v10->m128i_i64[0]) << v12;
          v10 = (__m128i *)((char *)v10 + 1);
          v12 += 8;
        }
        while ( v12 < 0x20 );
LABEL_53:
        v21 = *(_QWORD *)(v5 + 40);
        if ( v21 )
          *(_DWORD *)(v21 + 4) = v11;
        if ( *(_DWORD *)(v5 + 24) & 0x200 && *(_BYTE *)(v5 + 16) & 4 )
        {
          v136 = v11;
          v137 = BYTE2(v11);
          v138 = HIBYTE(v11);
          *(_DWORD *)(v5 + 32) = sub_140008F90(*(_DWORD *)(v5 + 32), (char *)&v136, 4u);
        }
        v11 = 0;
        *(_DWORD *)(v5 + 8) = 16183;
        v12 = 0;
        do
        {
LABEL_60:
          if ( !v8 )
            goto LABEL_166;
          --v8;
          v11 += LOBYTE(v10->m128i_i64[0]) << v12;
          v10 = (__m128i *)((char *)v10 + 1);
          v12 += 8;
        }
        while ( v12 < 0x10 );
LABEL_62:
        v22 = *(_QWORD *)(v5 + 40);
        if ( v22 )
        {
          *(_DWORD *)(v22 + 8) = (unsigned __int8)v11;
          *(_DWORD *)(*(_QWORD *)(v5 + 40) + 12i64) = v11 >> 8;
        }
        if ( *(_DWORD *)(v5 + 24) & 0x200 && *(_BYTE *)(v5 + 16) & 4 )
        {
          v136 = v11;
          *(_DWORD *)(v5 + 32) = sub_140008F90(*(_DWORD *)(v5 + 32), (char *)&v136, 2u);
        }
        v11 = 0;
        *(_DWORD *)(v5 + 8) = 16184;
        v12 = 0;
LABEL_68:
        if ( *(_DWORD *)(v5 + 24) & 0x400 )
        {
          if ( v12 < 0x10 )
          {
            while ( v8 )
            {
              --v8;
              v11 += LOBYTE(v10->m128i_i64[0]) << v12;
              v10 = (__m128i *)((char *)v10 + 1);
              v12 += 8;
              if ( v12 >= 0x10 )
                goto LABEL_72;
            }
            goto LABEL_166;
          }
LABEL_72:
          v23 = *(_QWORD *)(v5 + 40);
          *(_DWORD *)(v5 + 80) = v11;
          if ( v23 )
            *(_DWORD *)(v23 + 24) = v11;
          if ( *(_DWORD *)(v5 + 24) & 0x200 && *(_BYTE *)(v5 + 16) & 4 )
          {
            v136 = v11;
            *(_DWORD *)(v5 + 32) = sub_140008F90(*(_DWORD *)(v5 + 32), (char *)&v136, 2u);
          }
          v11 = 0;
          v12 = 0;
        }
        else
        {
          v24 = *(_QWORD *)(v5 + 40);
          if ( v24 )
            *(_QWORD *)(v24 + 16) = 0i64;
        }
        *(_DWORD *)(v5 + 8) = 16185;
LABEL_81:
        if ( *(_DWORD *)(v5 + 24) & 0x400 )
        {
          v25 = *(_DWORD *)(v5 + 80);
          v26 = v8;
          if ( v25 <= v8 )
            v26 = *(_DWORD *)(v5 + 80);
          if ( v26 )
          {
            v27 = *(_QWORD *)(v5 + 40);
            if ( v27 )
            {
              v28 = *(_QWORD *)(v27 + 16);
              if ( v28 )
              {
                v29 = *(_DWORD *)(v27 + 28);
                v30 = *(_DWORD *)(v27 + 24) - v25;
                if ( v30 < v29 )
                {
                  v31 = v26;
                  if ( v26 + v30 > v29 )
                    v31 = v29 - v30;
                  sub_14000CA50((__m128i *)(v28 + v30), v10, v31);
                }
              }
            }
            if ( *(_DWORD *)(v5 + 24) & 0x200 && *(_BYTE *)(v5 + 16) & 4 )
              *(_DWORD *)(v5 + 32) = sub_140008F90(*(_DWORD *)(v5 + 32), (char *)v10->m128i_i64, v26);
            v8 -= v26;
            v10 = (__m128i *)((char *)v10 + v26);
            *(_DWORD *)(v5 + 80) -= v26;
            v25 = *(_DWORD *)(v5 + 80);
          }
          if ( v25 )
            goto LABEL_166;
        }
        *(_DWORD *)(v5 + 80) = 0;
        *(_DWORD *)(v5 + 8) = 16186;
LABEL_97:
        if ( *(_DWORD *)(v5 + 24) & 0x800 )
        {
          if ( !v8 )
            goto LABEL_166;
          v32 = 0;
          do
          {
            v33 = v32++;
            v34 = *((_BYTE *)v10->m128i_i64 + v33);
            v35 = *(_QWORD *)(v5 + 40);
            if ( v35 )
            {
              v36 = *(_QWORD *)(v35 + 32);
              if ( v36 )
              {
                v37 = *(unsigned int *)(v5 + 80);
                if ( (unsigned int)v37 < *(_DWORD *)(v35 + 40) )
                {
                  *(_BYTE *)(v37 + v36) = v34;
                  ++*(_DWORD *)(v5 + 80);
                }
              }
            }
          }
          while ( v34 && v32 < v8 );
          if ( *(_DWORD *)(v5 + 24) & 0x200 && *(_BYTE *)(v5 + 16) & 4 )
            *(_DWORD *)(v5 + 32) = sub_140008F90(*(_DWORD *)(v5 + 32), (char *)v10->m128i_i64, v32);
          v8 -= v32;
          v10 = (__m128i *)((char *)v10 + v32);
          if ( v34 )
            goto LABEL_166;
        }
        else
        {
          v38 = *(_QWORD *)(v5 + 40);
          if ( v38 )
            *(_QWORD *)(v38 + 32) = 0i64;
        }
        *(_DWORD *)(v5 + 80) = 0;
        *(_DWORD *)(v5 + 8) = 16187;
LABEL_114:
        if ( *(_DWORD *)(v5 + 24) & 0x1000 )
        {
          if ( !v8 )
            goto LABEL_166;
          v39 = 0;
          do
          {
            v40 = v39++;
            v41 = *((_BYTE *)v10->m128i_i64 + v40);
            v42 = *(_QWORD *)(v5 + 40);
            if ( v42 )
            {
              v43 = *(_QWORD *)(v42 + 48);
              if ( v43 )
              {
                v44 = *(unsigned int *)(v5 + 80);
                if ( (unsigned int)v44 < *(_DWORD *)(v42 + 56) )
                {
                  *(_BYTE *)(v44 + v43) = v41;
                  ++*(_DWORD *)(v5 + 80);
                }
              }
            }
          }
          while ( v41 && v39 < v8 );
          if ( *(_DWORD *)(v5 + 24) & 0x200 && *(_BYTE *)(v5 + 16) & 4 )
            *(_DWORD *)(v5 + 32) = sub_140008F90(*(_DWORD *)(v5 + 32), (char *)v10->m128i_i64, v39);
          v8 -= v39;
          v10 = (__m128i *)((char *)v10 + v39);
          if ( v41 )
            goto LABEL_166;
        }
        else
        {
          v45 = *(_QWORD *)(v5 + 40);
          if ( v45 )
            *(_QWORD *)(v45 + 48) = 0i64;
        }
        v7 = v141;
        v6 = v145;
        *(_DWORD *)(v5 + 8) = 16188;
LABEL_131:
        v46 = *(_DWORD *)(v5 + 24);
        if ( !_bittest(&v46, 9u) )
          goto LABEL_139;
        if ( v12 < 0x10 )
        {
          while ( v8 )
          {
            --v8;
            v11 += LOBYTE(v10->m128i_i64[0]) << v12;
            v10 = (__m128i *)((char *)v10 + 1);
            v12 += 8;
            if ( v12 >= 0x10 )
              goto LABEL_135;
          }
          goto LABEL_166;
        }
LABEL_135:
        if ( *(_BYTE *)(v5 + 16) & 4 && v11 != *(unsigned __int16 *)(v5 + 32) )
        {
          *(_QWORD *)(v3 + 32) = "header crc mismatch";
          *(_DWORD *)(v5 + 8) = 16209;
          goto LABEL_144;
        }
        v11 = 0;
        v12 = 0;
LABEL_139:
        v47 = *(_QWORD *)(v5 + 40);
        if ( v47 )
        {
          *(_DWORD *)(v47 + 60) = (v46 >> 9) & 1;
          *(_DWORD *)(*(_QWORD *)(v5 + 40) + 64i64) = 1;
        }
        v48 = sub_140008F90(0, 0i64, 0);
        *(_DWORD *)(v5 + 32) = v48;
        *(_DWORD *)(v3 + 76) = v48;
        goto LABEL_142;
      case 2:
        if ( v12 < 0x20 )
          goto LABEL_51;
        goto LABEL_53;
      case 3:
        if ( v12 < 0x10 )
          goto LABEL_60;
        goto LABEL_62;
      case 4:
        goto LABEL_68;
      case 5:
        goto LABEL_81;
      case 6:
        goto LABEL_97;
      case 7:
        goto LABEL_114;
      case 8:
        goto LABEL_131;
      case 9:
        if ( v12 >= 0x20 )
          goto LABEL_149;
        do
        {
          if ( !v8 )
            goto LABEL_166;
          --v8;
          v11 += LOBYTE(v10->m128i_i64[0]) << v12;
          v10 = (__m128i *)((char *)v10 + 1);
          v12 += 8;
        }
        while ( v12 < 0x20 );
LABEL_149:
        v12 = 0;
        v49 = (v11 >> 24) + (((v11 << 16) + (v11 & 0xFF00)) << 8) + ((v11 >> 8) & 0xFF00);
        v11 = 0;
        *(_DWORD *)(v5 + 32) = v49;
        *(_DWORD *)(v3 + 76) = v49;
        *(_DWORD *)(v5 + 8) = 16190;
LABEL_150:
        if ( !*(_DWORD *)(v5 + 20) )
        {
          *(_QWORD *)(v3 + 16) = v7;
          result = 2i64;
          *(_DWORD *)(v3 + 24) = v6;
          *(_QWORD *)v3 = v10;
          *(_DWORD *)(v3 + 8) = v8;
          *(_DWORD *)(v5 + 72) = v11;
          *(_DWORD *)(v5 + 76) = v12;
          return result;
        }
        v50 = sub_140008CA0(0, 0i64, 0i64);
        v7 = v141;
        v14 = (unsigned int *)(v5 + 112);
        v6 = v145;
        v13 = (_DWORD *)(v5 + 116);
        *(_DWORD *)(v5 + 32) = v50;
        *(_DWORD *)(v3 + 76) = v50;
        *(_DWORD *)(v5 + 8) = 16191;
LABEL_152:
        if ( (unsigned int)(v2 - 5) <= 1 )
          goto LABEL_166;
LABEL_153:
        if ( *(_DWORD *)(v5 + 12) )
        {
          *(_DWORD *)(v5 + 8) = 16206;
          v51 = v12 & 7;
          v11 >>= v51;
          v12 -= v51;
          goto LABEL_144;
        }
        if ( v12 < 3 )
        {
          while ( v8 )
          {
            --v8;
            v11 += LOBYTE(v10->m128i_i64[0]) << v12;
            v10 = (__m128i *)((char *)v10 + 1);
            v12 += 8;
            if ( v12 >= 3 )
              goto LABEL_158;
          }
          goto LABEL_166;
        }
LABEL_158:
        v52 = v11;
        v53 = v11 >> 1;
        *(_DWORD *)(v5 + 12) = v52 & 1;
        if ( v53 & 3 )
        {
          switch ( v53 & 3 )
          {
            case 1u:
              *v14 = 9;
              *(_QWORD *)(v5 + 96) = "`\a";
              *(_QWORD *)(v5 + 104) = &unk_140030F40;
              *v13 = 5;
              *(_DWORD *)(v5 + 8) = 16199;
              if ( v2 == 6 )
              {
                v11 = v53 >> 2;
                v12 -= 3;
                goto LABEL_166;
              }
              break;
            case 2u:
              v11 = v53 >> 2;
              v12 -= 3;
              *(_DWORD *)(v5 + 8) = 16196;
              goto LABEL_144;
            case 3u:
              v11 = v53 >> 2;
              *(_QWORD *)(v3 + 32) = "invalid block type";
              v12 -= 3;
              *(_DWORD *)(v5 + 8) = 16209;
              goto LABEL_144;
          }
        }
        else
        {
          *(_DWORD *)(v5 + 8) = 16193;
        }
        v11 = v53 >> 2;
        v12 -= 3;
        goto LABEL_144;
      case 10:
        goto LABEL_150;
      case 11:
        goto LABEL_152;
      case 12:
        goto LABEL_153;
      case 13:
        v60 = v12 & 7;
        v11 >>= v60;
        v12 -= v60;
        if ( v12 >= 0x20 )
          goto LABEL_182;
        do
        {
          if ( !v8 )
            goto LABEL_166;
          --v8;
          v11 += LOBYTE(v10->m128i_i64[0]) << v12;
          v10 = (__m128i *)((char *)v10 + 1);
          v12 += 8;
        }
        while ( v12 < 0x20 );
LABEL_182:
        if ( (unsigned __int16)v11 == ~v11 >> 16 )
        {
          *(_DWORD *)(v5 + 80) = (unsigned __int16)v11;
          v11 = 0;
          *(_DWORD *)(v5 + 8) = 16194;
          v12 = 0;
          if ( v2 == 6 )
            goto LABEL_166;
LABEL_185:
          *(_DWORD *)(v5 + 8) = 16195;
LABEL_186:
          v61 = *(_DWORD *)(v5 + 80);
          if ( v61 )
          {
            v62 = v8;
            v63 = v6;
            if ( v61 <= v8 )
              v62 = *(_DWORD *)(v5 + 80);
            if ( v62 <= v6 )
              v63 = v62;
            if ( !v63 )
              goto LABEL_166;
            sub_14000CA50(v7, v10, v63);
            v8 -= v63;
            v6 = v145 - v63;
            v7 = (__m128i *)((char *)v141 + v63);
            v145 -= v63;
            v10 = (__m128i *)((char *)v10 + v63);
            v141 = (__m128i *)((char *)v141 + v63);
            *(_DWORD *)(v5 + 80) -= v63;
          }
          else
          {
            *(_DWORD *)(v5 + 8) = 16191;
          }
        }
        else
        {
          *(_QWORD *)(v3 + 32) = "invalid stored block lengths";
          *(_DWORD *)(v5 + 8) = 16209;
        }
        goto LABEL_144;
      case 14:
        goto LABEL_185;
      case 15:
        goto LABEL_186;
      case 16:
        if ( v12 >= 0xE )
          goto LABEL_197;
        do
        {
          if ( !v8 )
            goto LABEL_166;
          --v8;
          v11 += LOBYTE(v10->m128i_i64[0]) << v12;
          v10 = (__m128i *)((char *)v10 + 1);
          v12 += 8;
        }
        while ( v12 < 0xE );
LABEL_197:
        v64 = v11;
        v12 -= 14;
        v65 = v11 >> 5;
        v66 = v65;
        v67 = (v64 & 0x1F) + 257;
        v65 >>= 5;
        *(_DWORD *)(v5 + 124) = v67;
        v68 = v65 & 0xF;
        v11 = v65 >> 4;
        v69 = (v66 & 0x1F) + 1;
        *(_DWORD *)(v5 + 128) = v69;
        *(_DWORD *)(v5 + 120) = v68 + 4;
        if ( v67 > 0x11E || v69 > 0x1E )
        {
          *(_QWORD *)(v3 + 32) = "too many length or distance symbols";
          *(_DWORD *)(v5 + 8) = 16209;
          goto LABEL_144;
        }
        *(_DWORD *)(v5 + 132) = 0;
        *(_DWORD *)(v5 + 8) = 16197;
LABEL_200:
        for ( i = *(unsigned int *)(v5 + 132); (unsigned int)i < *(_DWORD *)(v5 + 120); i = *(unsigned int *)(v5 + 132) )
        {
          for ( ; v12 < 3; v12 += 8 )
          {
            if ( !v8 )
              goto LABEL_166;
            --v8;
            v11 += LOBYTE(v10->m128i_i64[0]) << v12;
            v10 = (__m128i *)((char *)v10 + 1);
          }
          v71 = v11 & 7;
          v11 >>= 3;
          v12 -= 3;
          *(_WORD *)(v5 + 2i64 * (unsigned __int16)word_140030FC0[(*(_DWORD *)(v5 + 132))++] + 144) = v71;
        }
        for ( ; (unsigned int)i < 0x13; *(_DWORD *)(v5 + 132) = i )
        {
          *(_WORD *)(v5 + 2i64 * (unsigned __int16)word_140030FC0[i] + 144) = 0;
          i = (unsigned int)(*(_DWORD *)(v5 + 132) + 1);
        }
        *v14 = 7;
        *(_QWORD *)(v5 + 96) = v5 + 1360;
        *(_QWORD *)(v5 + 136) = v5 + 1360;
        v144 = sub_14000B620(
                 0i64,
                 (unsigned __int16 *)(v5 + 144),
                 19i64,
                 (_DWORD **)(v5 + 136),
                 (unsigned int *)(v5 + 112),
                 (_WORD *)(v5 + 784));
        if ( v144 )
        {
          *(_QWORD *)(v3 + 32) = "invalid code lengths set";
          *(_DWORD *)(v5 + 8) = 16209;
LABEL_143:
          v7 = v141;
          v6 = v145;
          goto LABEL_144;
        }
        *(_DWORD *)(v5 + 132) = 0;
        v14 = (unsigned int *)(v5 + 112);
        *(_DWORD *)(v5 + 8) = 16198;
LABEL_211:
        if ( *(_DWORD *)(v5 + 132) >= (unsigned int)(*(_DWORD *)(v5 + 124) + *(_DWORD *)(v5 + 128)) )
        {
LABEL_239:
          if ( *(_DWORD *)(v5 + 8) == 16209 )
            goto LABEL_143;
          if ( !*(_WORD *)(v5 + 656) )
          {
            *(_QWORD *)(v3 + 32) = "invalid code -- missing end-of-block";
            *(_DWORD *)(v5 + 8) = 16209;
            goto LABEL_143;
          }
          v94 = *(unsigned int *)(v5 + 124);
          *(_QWORD *)(v5 + 136) = v5 + 1360;
          *(_QWORD *)(v5 + 96) = v5 + 1360;
          *v14 = 9;
          v144 = sub_14000B620(
                   1i64,
                   (unsigned __int16 *)(v5 + 144),
                   v94,
                   (_DWORD **)(v5 + 136),
                   v14,
                   (_WORD *)(v5 + 784));
          if ( v144 )
          {
            *(_QWORD *)(v3 + 32) = "invalid literal/lengths set";
            *(_DWORD *)(v5 + 8) = 16209;
            goto LABEL_143;
          }
          v95 = *(unsigned int *)(v5 + 128);
          *(_QWORD *)(v5 + 104) = *(_QWORD *)(v5 + 136);
          v96 = *(unsigned int *)(v5 + 124);
          *(_DWORD *)(v5 + 116) = 6;
          v144 = sub_14000B620(
                   2i64,
                   (unsigned __int16 *)(v5 + 2 * v96 + 144),
                   v95,
                   (_DWORD **)(v5 + 136),
                   (unsigned int *)(v5 + 116),
                   (_WORD *)(v5 + 784));
          v55 = v144;
          if ( v144 )
          {
            *(_QWORD *)(v3 + 32) = "invalid distances set";
            *(_DWORD *)(v5 + 8) = 16209;
            goto LABEL_143;
          }
          v56 = v143;
          *(_DWORD *)(v5 + 8) = 16199;
          if ( v143 == 6 )
          {
            v54 = v142;
            goto LABEL_169;
          }
          v7 = v141;
          v14 = (unsigned int *)(v5 + 112);
          v9 = v142;
          v6 = v145;
LABEL_248:
          *(_DWORD *)(v5 + 8) = 16200;
LABEL_249:
          if ( v8 < 6 || v6 < 0x102 )
          {
            v97 = *(_QWORD *)(v5 + 96);
            v98 = (1 << *v14) - 1;
            *(_DWORD *)(v5 + 7140) = 0;
            v99 = *(_DWORD *)(v97 + 4i64 * (v11 & v98));
            if ( BYTE1(v99) > v12 )
            {
              while ( v8 )
              {
                --v8;
                v11 += LOBYTE(v10->m128i_i64[0]) << v12;
                v10 = (__m128i *)((char *)v10 + 1);
                v12 += 8;
                v99 = *(_DWORD *)(v97 + 4i64 * (v98 & v11));
                if ( (unsigned __int8)(*(_WORD *)(v97 + 4i64 * (v98 & v11)) >> 8) <= v12 )
                  goto LABEL_256;
              }
              goto LABEL_166;
            }
LABEL_256:
            if ( (_BYTE)v99 && !(v99 & 0xF0) )
            {
              v100 = BYTE1(v99);
              v101 = v99 >> 16;
              v102 = 1 << (BYTE1(v99) + v99);
              v99 = *(_DWORD *)(v97 + 4i64 * ((v99 >> 16) + ((v11 & (v102 - 1)) >> SBYTE1(v99))));
              if ( v100 + (unsigned int)BYTE1(v99) > v12 )
              {
                while ( v8 )
                {
                  --v8;
                  v11 += LOBYTE(v10->m128i_i64[0]) << v12;
                  v10 = (__m128i *)((char *)v10 + 1);
                  v12 += 8;
                  v99 = *(_DWORD *)(v97 + 4i64 * (v101 + ((v11 & (v102 - 1)) >> v100)));
                  if ( v100
                     + (unsigned int)(unsigned __int8)(*(_WORD *)(v97 + 4i64 * (v101 + ((v11 & (v102 - 1)) >> v100))) >> 8) <= v12 )
                    goto LABEL_261;
                }
                goto LABEL_166;
              }
LABEL_261:
              *(_DWORD *)(v5 + 7140) = v100;
              v11 >>= v100;
              v12 -= v100;
            }
            *(_DWORD *)(v5 + 7140) += BYTE1(v99);
            v12 -= BYTE1(v99);
            v11 >>= SBYTE1(v99);
            *(_DWORD *)(v5 + 80) = v99 >> 16;
            if ( !(_BYTE)v99 )
            {
              *(_DWORD *)(v5 + 8) = 16205;
              goto LABEL_143;
            }
            if ( v99 & 0x20 )
            {
              *(_DWORD *)(v5 + 7140) = -1;
LABEL_142:
              *(_DWORD *)(v5 + 8) = 16191;
              goto LABEL_143;
            }
            if ( v99 & 0x40 )
            {
              *(_QWORD *)(v3 + 32) = "invalid literal/length code";
              *(_DWORD *)(v5 + 8) = 16209;
              goto LABEL_143;
            }
            *(_DWORD *)(v5 + 8) = 16201;
            *(_DWORD *)(v5 + 88) = v99 & 0xF;
LABEL_269:
            v103 = *(_DWORD *)(v5 + 88);
            if ( v103 )
            {
              if ( v12 < v103 )
              {
                while ( v8 )
                {
                  --v8;
                  v11 += LOBYTE(v10->m128i_i64[0]) << v12;
                  v10 = (__m128i *)((char *)v10 + 1);
                  v12 += 8;
                  if ( v12 >= v103 )
                    goto LABEL_273;
                }
                goto LABEL_166;
              }
LABEL_273:
              v12 -= v103;
              v104 = v11 & ((1 << v103) - 1);
              v11 >>= v103;
              *(_DWORD *)(v5 + 80) += v104;
              *(_DWORD *)(v5 + 7140) += v103;
            }
            v13 = (_DWORD *)(v5 + 116);
            *(_DWORD *)(v5 + 7144) = *(_DWORD *)(v5 + 80);
            *(_DWORD *)(v5 + 8) = 16202;
LABEL_275:
            v105 = *(_QWORD *)(v5 + 104);
            v106 = (1 << *v13) - 1;
            v107 = *(_DWORD *)(v105 + 4i64 * (v11 & v106));
            if ( (unsigned __int8)(*(_WORD *)(v105 + 4i64 * (v11 & v106)) >> 8) > v12 )
            {
              while ( v8 )
              {
                --v8;
                v11 += LOBYTE(v10->m128i_i64[0]) << v12;
                v10 = (__m128i *)((char *)v10 + 1);
                v12 += 8;
                v107 = *(_DWORD *)(v105 + 4i64 * (v106 & v11));
                if ( (unsigned __int8)(*(_WORD *)(v105 + 4i64 * (v106 & v11)) >> 8) <= v12 )
                  goto LABEL_278;
              }
              goto LABEL_166;
            }
LABEL_278:
            if ( !(v107 & 0xF0) )
            {
              v108 = BYTE1(v107);
              v109 = v107 >> 16;
              v110 = 1 << (BYTE1(v107) + v107);
              v107 = *(_DWORD *)(v105 + 4i64 * ((v107 >> 16) + ((v11 & (v110 - 1)) >> SBYTE1(v107))));
              if ( v108 + (unsigned int)BYTE1(v107) > v12 )
              {
                while ( v8 )
                {
                  --v8;
                  v11 += LOBYTE(v10->m128i_i64[0]) << v12;
                  v10 = (__m128i *)((char *)v10 + 1);
                  v12 += 8;
                  v107 = *(_DWORD *)(v105 + 4i64 * (v109 + ((v11 & (v110 - 1)) >> v108)));
                  if ( v108
                     + (unsigned int)(unsigned __int8)(*(_WORD *)(v105 + 4i64 * (v109 + ((v11 & (v110 - 1)) >> v108))) >> 8) <= v12 )
                    goto LABEL_282;
                }
                goto LABEL_166;
              }
LABEL_282:
              v12 -= v108;
              v11 >>= v108;
              *(_DWORD *)(v5 + 7140) += v108;
            }
            v7 = v141;
            v6 = v145;
            *(_DWORD *)(v5 + 7140) += BYTE1(v107);
            v12 -= BYTE1(v107);
            v11 >>= SBYTE1(v107);
            if ( v107 & 0x40 )
            {
              *(_QWORD *)(v3 + 32) = "invalid distance code";
              *(_DWORD *)(v5 + 8) = 16209;
              goto LABEL_144;
            }
            v9 = v142;
            *(_DWORD *)(v5 + 84) = v107 >> 16;
            *(_DWORD *)(v5 + 8) = 16203;
            *(_DWORD *)(v5 + 88) = v107 & 0xF;
LABEL_286:
            v111 = *(_DWORD *)(v5 + 88);
            if ( v111 )
            {
              if ( v12 < v111 )
              {
                while ( v8 )
                {
                  --v8;
                  v11 += LOBYTE(v10->m128i_i64[0]) << v12;
                  v10 = (__m128i *)((char *)v10 + 1);
                  v12 += 8;
                  if ( v12 >= v111 )
                    goto LABEL_290;
                }
                goto LABEL_166;
              }
LABEL_290:
              v12 -= v111;
              v112 = v11 & ((1 << v111) - 1);
              v11 >>= v111;
              *(_DWORD *)(v5 + 84) += v112;
              *(_DWORD *)(v5 + 7140) += v111;
            }
            *(_DWORD *)(v5 + 8) = 16204;
LABEL_292:
            if ( !v6 )
              goto LABEL_166;
            v113 = *(unsigned int *)(v5 + 84);
            if ( (unsigned int)v113 <= v9 - v6 )
            {
              v117 = *(_DWORD *)(v5 + 80);
              v118 = (char *)v7->m128i_i64 - v113;
              v119 = *(_DWORD *)(v5 + 80);
            }
            else
            {
              v114 = v113 - (v9 - v6);
              if ( v114 > *(_DWORD *)(v5 + 56) && *(_DWORD *)(v5 + 7136) )
              {
                *(_QWORD *)(v3 + 32) = "invalid distance too far back";
                *(_DWORD *)(v5 + 8) = 16209;
                goto LABEL_144;
              }
              v115 = *(_DWORD *)(v5 + 60);
              if ( v114 <= v115 )
              {
                v116 = v115 - v114;
              }
              else
              {
                v114 -= v115;
                v116 = *(_DWORD *)(v5 + 52) - v114;
              }
              v117 = *(_DWORD *)(v5 + 80);
              v118 = (char *)(*(_QWORD *)(v5 + 64) + v116);
              v119 = *(_DWORD *)(v5 + 80);
              if ( v114 <= v117 )
                v119 = v114;
            }
            v120 = v6;
            if ( v119 <= v6 )
              v120 = v119;
            v6 -= v120;
            v145 = v6;
            v121 = v118 - (char *)v7;
            *(_DWORD *)(v5 + 80) = v117 - v120;
            do
            {
              LOBYTE(v7->m128i_i64[0]) = *((_BYTE *)v7->m128i_i64 + v121);
              v7 = (__m128i *)((char *)v7 + 1);
              --v120;
            }
            while ( v120 );
            v141 = v7;
            if ( !*(_DWORD *)(v5 + 80) )
              *(_DWORD *)(v5 + 8) = 16200;
          }
          else
          {
            *(_QWORD *)(v3 + 16) = v7;
            *(_DWORD *)(v3 + 24) = v6;
            *(_QWORD *)v3 = v10;
            *(_DWORD *)(v3 + 8) = v8;
            *(_DWORD *)(v5 + 72) = v11;
            *(_DWORD *)(v5 + 76) = v12;
            sub_140009450((unsigned __int8 **)v3, v9);
            v57 = *(_DWORD *)(v5 + 8) == 16191;
            v7 = *(__m128i **)(v3 + 16);
            v6 = *(_DWORD *)(v3 + 24);
            v10 = *(__m128i **)v3;
            v8 = *(_DWORD *)(v3 + 8);
            v11 = *(_DWORD *)(v5 + 72);
            v12 = *(_DWORD *)(v5 + 76);
            v141 = *(__m128i **)(v3 + 16);
            v145 = v6;
            if ( v57 )
              *(_DWORD *)(v5 + 7140) = -1;
          }
LABEL_144:
          if ( (unsigned int)(*(_DWORD *)(v5 + 8) - 16180) > 0x1F )
            return 4294967294i64;
          v9 = v142;
          v2 = v143;
          continue;
        }
        while ( 1 )
        {
          v72 = *(_QWORD *)(v5 + 96);
          v73 = (1 << *v14) - 1;
          v74 = *(_DWORD *)(v72 + 4i64 * (v11 & v73));
          v75 = *(_DWORD *)(v72 + 4i64 * (v11 & v73)) >> 8;
          v76 = (unsigned __int8)(*(_WORD *)(v72 + 4i64 * (v11 & v73)) >> 8);
          v77 = *(_DWORD *)(v72 + 4i64 * (v11 & v73)) >> 16;
          v139 = *(_DWORD *)(v72 + 4i64 * (v11 & v73));
          if ( v76 > v12 )
          {
            do
            {
              if ( !v8 )
                goto LABEL_166;
              --v8;
              v11 += LOBYTE(v10->m128i_i64[0]) << v12;
              v10 = (__m128i *)((char *)v10 + 1);
              v12 += 8;
              v74 = *(_DWORD *)(v72 + 4i64 * (v73 & v11));
              v75 = *(_DWORD *)(v72 + 4i64 * (v73 & v11)) >> 8;
              v78 = (unsigned __int8)(*(_WORD *)(v72 + 4i64 * (v73 & v11)) >> 8);
              v79 = *(_DWORD *)(v72 + 4i64 * (v73 & v11)) >> 16;
              v139 = *(_DWORD *)(v72 + 4i64 * (v73 & v11));
            }
            while ( v78 > v12 );
            LOWORD(v77) = v79;
          }
          if ( (unsigned __int16)v77 < 0x10u )
          {
            v11 >>= v75;
            v12 -= BYTE1(v74);
            *(_WORD *)(v5 + 2i64 * (unsigned int)(*(_DWORD *)(v5 + 132))++ + 144) = HIWORD(v74);
            v80 = *(_DWORD *)(v5 + 132);
            goto LABEL_236;
          }
          if ( (_WORD)v77 == 16 )
          {
            v81 = (unsigned __int8)v75 + 2;
            v82 = BYTE1(v74);
            if ( v12 < v81 )
            {
              while ( v8 )
              {
                --v8;
                v11 += LOBYTE(v10->m128i_i64[0]) << v12;
                v10 = (__m128i *)((char *)v10 + 1);
                v12 += 8;
                if ( v12 >= v81 )
                  goto LABEL_222;
              }
              goto LABEL_166;
            }
LABEL_222:
            v83 = *(_DWORD *)(v5 + 132);
            v11 >>= v82;
            v12 -= v82;
            if ( !v83 )
              goto LABEL_238;
            v12 -= 2;
            v84 = v11 & 3;
            v11 >>= 2;
            v85 = v84 + 3;
            v86 = *(_WORD *)(v5 + 2i64 * (unsigned int)(v83 - 1) + 144);
            goto LABEL_234;
          }
          if ( (_WORD)v77 == 17 )
          {
            v87 = (unsigned __int8)v75 + 3;
            if ( v12 < v87 )
            {
              while ( v8 )
              {
                --v8;
                v11 += LOBYTE(v10->m128i_i64[0]) << v12;
                v10 = (__m128i *)((char *)v10 + 1);
                v12 += 8;
                if ( v12 >= v87 )
                  goto LABEL_228;
              }
              goto LABEL_166;
            }
LABEL_228:
            v88 = v11 >> SBYTE1(v139);
            v89 = v88;
            v11 = v88 >> 3;
            v85 = (v89 & 7) + 3;
            v90 = -3 - BYTE1(v139);
            v86 = 0;
            goto LABEL_233;
          }
          v91 = (unsigned __int8)v75 + 7;
          if ( v12 < v91 )
            break;
LABEL_232:
          v92 = v11 >> SBYTE1(v139);
          v93 = v92;
          v11 = v92 >> 7;
          v85 = (v93 & 0x7F) + 11;
          v90 = -7 - BYTE1(v139);
          v86 = 0;
LABEL_233:
          v12 += v90;
LABEL_234:
          v80 = *(_DWORD *)(v5 + 132);
          if ( v80 + v85 > *(_DWORD *)(v5 + 124) + *(_DWORD *)(v5 + 128) )
          {
LABEL_238:
            *(_QWORD *)(v3 + 32) = "invalid bit length repeat";
            *(_DWORD *)(v5 + 8) = 16209;
            goto LABEL_239;
          }
          do
          {
            *(_WORD *)(v5 + 2i64 * v80 + 144) = v86;
            v80 = *(_DWORD *)(v5 + 132) + 1;
            *(_DWORD *)(v5 + 132) = v80;
            --v85;
          }
          while ( v85 );
LABEL_236:
          if ( v80 >= *(_DWORD *)(v5 + 124) + *(_DWORD *)(v5 + 128) )
            goto LABEL_239;
        }
        while ( v8 )
        {
          --v8;
          v11 += LOBYTE(v10->m128i_i64[0]) << v12;
          v10 = (__m128i *)((char *)v10 + 1);
          v12 += 8;
          if ( v12 >= v91 )
            goto LABEL_232;
        }
LABEL_166:
        v54 = v142;
LABEL_167:
        v55 = v144;
LABEL_168:
        v56 = v143;
LABEL_169:
        *(_QWORD *)(v3 + 16) = v141;
        *(_DWORD *)(v3 + 24) = v145;
        *(_QWORD *)v3 = v10;
        *(_DWORD *)(v3 + 8) = v8;
        v57 = *(_DWORD *)(v5 + 52) == 0;
        *(_DWORD *)(v5 + 72) = v11;
        *(_DWORD *)(v5 + 76) = v12;
        if ( v57
          && (v54 == *(_DWORD *)(v3 + 24) || (v58 = *(_DWORD *)(v5 + 8), v58 >= 16209) || v58 >= 16206 && v56 == 4)
          || !(unsigned int)sub_14000B510(v3, *(_QWORD *)(v3 + 16), v54 - *(_DWORD *)(v3 + 24)) )
        {
          v128 = v54 - *(_DWORD *)(v3 + 24);
          v129 = v140 - *(_DWORD *)(v3 + 8);
          *(_DWORD *)(v3 + 12) += v129;
          *(_DWORD *)(v3 + 28) += v128;
          *(_DWORD *)(v5 + 36) += v128;
          v57 = (*(_BYTE *)(v5 + 16) & 4) == 0;
          v140 = v129;
          if ( !v57 && v128 )
          {
            v130 = *(_DWORD *)(v5 + 32);
            v131 = (char *)(*(_QWORD *)(v3 + 16) - v128);
            if ( *(_DWORD *)(v5 + 24) )
              v132 = sub_140008F90(v130, v131, v128);
            else
              v132 = sub_140008CA0(v130, (unsigned __int8 *)v131, v128);
            v129 = v140;
            *(_DWORD *)(v5 + 32) = v132;
            *(_DWORD *)(v3 + 76) = v132;
          }
          v133 = *(_DWORD *)(v5 + 8);
          if ( v133 == 16199 || v133 == 16194 )
          {
            v135 = 256;
            v134 = 0;
          }
          else
          {
            v134 = 0;
            v135 = 0;
          }
          if ( v133 == 16191 )
            v134 = 128;
          *(_DWORD *)(v3 + 72) = *(_DWORD *)(v5 + 76) + v135 + (*(_DWORD *)(v5 + 12) != 0 ? 0x40 : 0) + v134;
          if ( (!v129 && !v128 || v143 == 4) && !v55 )
            v55 = -5;
          result = v55;
        }
        else
        {
          *(_DWORD *)(v5 + 8) = 16210;
LABEL_176:
          result = 4294967292i64;
        }
        return result;
      case 17:
        goto LABEL_200;
      case 18:
        goto LABEL_211;
      case 19:
        goto LABEL_248;
      case 20:
        goto LABEL_249;
      case 21:
        goto LABEL_269;
      case 22:
        goto LABEL_275;
      case 23:
        goto LABEL_286;
      case 24:
        goto LABEL_292;
      case 25:
        if ( !v6 )
          goto LABEL_166;
        LOBYTE(v7->m128i_i64[0]) = *(_BYTE *)(v5 + 80);
        v7 = (__m128i *)((char *)v7 + 1);
        --v6;
        v141 = v7;
        v145 = v6;
        *(_DWORD *)(v5 + 8) = 16200;
        goto LABEL_144;
      case 26:
        if ( *(_DWORD *)(v5 + 16) )
        {
          for ( ; v12 < 0x20; v12 += 8 )
          {
            if ( !v8 )
              goto LABEL_166;
            --v8;
            v11 += LOBYTE(v10->m128i_i64[0]) << v12;
            v10 = (__m128i *)((char *)v10 + 1);
          }
          v122 = v9 - v6;
          *(_DWORD *)(v3 + 28) += v122;
          *(_DWORD *)(v5 + 36) += v122;
          if ( *(_BYTE *)(v5 + 16) & 4 && (_DWORD)v122 )
          {
            v123 = *(_DWORD *)(v5 + 32);
            v124 = (char *)v7->m128i_i64 - (unsigned int)v122;
            if ( *(_DWORD *)(v5 + 24) )
              v125 = sub_140008F90(v123, v124, v122);
            else
              v125 = sub_140008CA0(v123, (unsigned __int8 *)v124, v122);
            v7 = v141;
            v6 = v145;
            *(_DWORD *)(v5 + 32) = v125;
            *(_DWORD *)(v3 + 76) = v125;
          }
          v54 = v6;
          v142 = v6;
          if ( *(_BYTE *)(v5 + 16) & 4 )
          {
            v126 = v11;
            if ( !*(_DWORD *)(v5 + 24) )
              v126 = (v11 >> 24) + ((v11 >> 8) & 0xFF00) + (((v11 << 16) + (v11 & 0xFF00)) << 8);
            if ( v126 != *(_DWORD *)(v5 + 32) )
            {
              *(_QWORD *)(v3 + 32) = "incorrect data check";
              *(_DWORD *)(v5 + 8) = 16209;
              goto LABEL_144;
            }
          }
          v11 = 0;
          *(_DWORD *)(v5 + 8) = 16207;
          v12 = 0;
        }
        else
        {
          v54 = v142;
          *(_DWORD *)(v5 + 8) = 16207;
        }
LABEL_330:
        v127 = *(_DWORD *)(v5 + 16);
        if ( !v127 || !*(_DWORD *)(v5 + 24) )
          goto LABEL_340;
        for ( ; v12 < 0x20; v12 += 8 )
        {
          if ( !v8 )
            goto LABEL_167;
          --v8;
          v11 += LOBYTE(v10->m128i_i64[0]) << v12;
          v10 = (__m128i *)((char *)v10 + 1);
        }
        if ( !(v127 & 4) || v11 == *(_DWORD *)(v5 + 36) )
        {
          v11 = 0;
          v12 = 0;
LABEL_340:
          *(_DWORD *)(v5 + 8) = 16208;
          v55 = 1;
          goto LABEL_168;
        }
        *(_QWORD *)(v3 + 32) = "incorrect length check";
        *(_DWORD *)(v5 + 8) = 16209;
        goto LABEL_144;
      case 27:
        v54 = v142;
        goto LABEL_330;
      case 28:
        v54 = v142;
        v55 = 1;
        goto LABEL_168;
      case 29:
        v54 = v142;
        v55 = -3;
        goto LABEL_168;
      case 30:
        goto LABEL_176;
      default:
        return 4294967294i64;
    }
  }
}

//----- (000000014000B1E0) ----------------------------------------------------
signed __int64 __fastcall sub_14000B1E0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rax
  signed __int64 result; // rax

  v1 = a1;
  if ( !a1 )
    return 4294967294i64;
  if ( !a1[6] )
    return 4294967294i64;
  if ( !a1[7] )
    return 4294967294i64;
  v2 = a1[5];
  if ( !v2 || *(_QWORD **)v2 != a1 || (unsigned int)(*(_DWORD *)(v2 + 8) - 16180) > 0x1F )
    return 4294967294i64;
  if ( *(_QWORD *)(a1[5] + 64i64) )
  {
    v3 = a1[8];
    v4 = v1[7];
    sub_14002A5B0();
  }
  v5 = v1[5];
  v6 = v1[8];
  v7 = v1[7];
  sub_14002A5B0();
  result = 0i64;
  v1[5] = 0i64;
  return result;
}

//----- (000000014000B260) ----------------------------------------------------
signed __int64 __fastcall sub_14000B260(_QWORD *a1, int a2, _BYTE *a3, int a4)
{
  int v4; // edi
  _QWORD *v5; // rbx
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rbp
  int v12; // esi
  __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rcx
  int v19; // eax
  unsigned int v20; // edi
  __int64 v21; // rcx
  __int64 v22; // rax

  v4 = a2;
  v5 = a1;
  if ( a3 && *a3 == 49 && a4 == 88 )
  {
    if ( !a1 )
      return 4294967294i64;
    v7 = a1[6];
    a1[4] = 0i64;
    if ( v7 )
    {
      v8 = a1[8];
    }
    else
    {
      a1[8] = 0i64;
      a1[6] = sub_14000BBC0;
    }
    if ( !v5[7] )
      v5[7] = sub_14000BBD0;
    v9 = sub_14002A5B0();
    if ( !v9 )
      return 4294967292i64;
    v5[5] = v9;
    *(_QWORD *)v9 = v5;
    *(_QWORD *)(v9 + 64) = 0i64;
    *(_DWORD *)(v9 + 8) = 16180;
    if ( !v5[6] )
      goto LABEL_44;
    if ( !v5[7] )
      goto LABEL_44;
    v10 = v5[5];
    if ( !v10 || *(_QWORD **)v10 != v5 || (unsigned int)(*(_DWORD *)(v10 + 8) - 16180) > 0x1F )
      goto LABEL_44;
    v11 = v5[5];
    if ( v4 >= 0 )
    {
      v12 = ((unsigned int)v4 >> 4) + 5;
      if ( v4 < 48 )
        v4 &= 0xFu;
    }
    else
    {
      if ( v4 < -15 )
        goto LABEL_44;
      v12 = 0;
      v4 = -v4;
    }
    if ( !v4 || (unsigned int)(v4 - 8) <= 7 )
    {
      if ( *(_QWORD *)(v11 + 64) && *(_DWORD *)(v11 + 48) != v4 )
      {
        v13 = v5[8];
        v14 = v5[7];
        sub_14002A5B0();
        *(_QWORD *)(v11 + 64) = 0i64;
      }
      *(_DWORD *)(v11 + 16) = v12;
      *(_DWORD *)(v11 + 48) = v4;
      if ( v5[6] )
      {
        if ( v5[7] )
        {
          v15 = v5[5];
          if ( v15 )
          {
            if ( *(_QWORD **)v15 == v5 && (unsigned int)(*(_DWORD *)(v15 + 8) - 16180) <= 0x1F )
            {
              v16 = v5[5];
              *(_QWORD *)(v16 + 52) = 0i64;
              *(_DWORD *)(v16 + 60) = 0;
              if ( v5[6]
                && v5[7]
                && (v17 = v5[5]) != 0
                && *(_QWORD **)v17 == v5
                && (unsigned int)(*(_DWORD *)(v17 + 8) - 16180) <= 0x1F )
              {
                v18 = v5[5];
                *(_DWORD *)(v18 + 36) = 0;
                *((_DWORD *)v5 + 7) = 0;
                *((_DWORD *)v5 + 3) = 0;
                v5[4] = 0i64;
                v19 = *(_DWORD *)(v18 + 16);
                if ( v19 )
                  *((_DWORD *)v5 + 19) = *(_DWORD *)(v18 + 16) & 1;
                *(_QWORD *)(v18 + 8) = 16180i64;
                *(_QWORD *)(v18 + 136) = v18 + 1360;
                v20 = 0;
                *(_QWORD *)(v18 + 104) = v18 + 1360;
                *(_QWORD *)(v18 + 96) = v18 + 1360;
                *(_DWORD *)(v18 + 20) = 0;
                *(_DWORD *)(v18 + 24) = -1;
                *(_DWORD *)(v18 + 28) = 0x8000;
                *(_QWORD *)(v18 + 40) = 0i64;
                *(_QWORD *)(v18 + 72) = 0i64;
                *(_DWORD *)(v18 + 7136) = 1;
                *(_DWORD *)(v18 + 7140) = -1;
              }
              else
              {
                v20 = -2;
              }
              if ( !v20 )
                return v20;
              goto LABEL_45;
            }
          }
        }
      }
    }
LABEL_44:
    v20 = -2;
LABEL_45:
    v21 = v5[8];
    v22 = v5[7];
    sub_14002A5B0();
    v5[5] = 0i64;
    return v20;
  }
  return 4294967290i64;
}

//----- (000000014000B500) ----------------------------------------------------
signed __int64 __fastcall sub_14000B500(_QWORD *a1, _BYTE *a2, int a3)
{
  return sub_14000B260(a1, 15, a2, a3);
}

//----- (000000014000B510) ----------------------------------------------------
signed __int64 __fastcall sub_14000B510(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rbx
  __int64 v4; // rsi
  __int64 v5; // rbp
  __int64 v6; // rax
  __m128i *v7; // r9
  int v8; // ecx
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rax
  unsigned int v13; // edi
  int v14; // eax
  __int64 v15; // rcx
  unsigned int v16; // edi
  unsigned int v17; // ebp
  int v18; // ecx
  unsigned int v19; // ecx

  v3 = *(_QWORD *)(a1 + 40);
  v4 = a2;
  v5 = a3;
  v6 = a1;
  v7 = *(__m128i **)(v3 + 64);
  if ( !v7 )
  {
    v8 = *(_DWORD *)(v3 + 48);
    v9 = *(_QWORD *)(v6 + 64);
    v10 = *(_QWORD *)(v6 + 48);
    v11 = sub_14002A5B0();
    *(_QWORD *)(v3 + 64) = v11;
    v7 = (__m128i *)v11;
    if ( !v11 )
      return 1i64;
  }
  v13 = *(_DWORD *)(v3 + 52);
  if ( !v13 )
  {
    v13 = 1 << *(_DWORD *)(v3 + 48);
    *(_DWORD *)(v3 + 52) = v13;
    *(_QWORD *)(v3 + 56) = 0i64;
  }
  if ( (unsigned int)v5 < v13 )
  {
    v15 = *(unsigned int *)(v3 + 60);
    v16 = v13 - v15;
    if ( v16 > (unsigned int)v5 )
      v16 = v5;
    sub_14000CA50((__m128i *)((char *)v7 + v15), (const __m128i *)(v4 - v5), v16);
    v17 = v5 - v16;
    if ( v17 )
    {
      sub_14000CA50(*(__m128i **)(v3 + 64), (const __m128i *)(v4 - v17), v17);
      v14 = *(_DWORD *)(v3 + 52);
      *(_DWORD *)(v3 + 60) = v17;
    }
    else
    {
      v18 = v16 + *(_DWORD *)(v3 + 60);
      if ( v18 == *(_DWORD *)(v3 + 52) )
        v18 = 0;
      *(_DWORD *)(v3 + 60) = v18;
      v19 = *(_DWORD *)(v3 + 56);
      if ( v19 >= *(_DWORD *)(v3 + 52) )
        return 0i64;
      v14 = v19 + v16;
    }
  }
  else
  {
    sub_14000CA50(v7, (const __m128i *)(v4 - v13), v13);
    v14 = *(_DWORD *)(v3 + 52);
    *(_DWORD *)(v3 + 60) = 0;
  }
  *(_DWORD *)(v3 + 56) = v14;
  return 0i64;
}

//----- (000000014000B620) ----------------------------------------------------
signed __int64 __fastcall sub_14000B620(__int64 a1, unsigned __int16 *a2, __int64 a3, _DWORD **a4, unsigned int *a5, _WORD *a6)
{
  unsigned int v6; // er10
  _DWORD **v7; // rsi
  unsigned __int16 *v8; // rbp
  int v9; // edi
  unsigned int v10; // ebx
  unsigned __int64 v11; // rax
  unsigned __int16 *v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rax
  unsigned int v15; // edx
  unsigned int v16; // er9
  unsigned int v17; // ecx
  signed __int64 result; // rax
  unsigned int v19; // er11
  __int16 *v20; // rax
  unsigned int v21; // er10
  unsigned int v22; // edx
  int v23; // er8
  __int64 v24; // rcx
  signed __int64 v25; // rdx
  unsigned int v26; // er8
  unsigned __int16 *v27; // rdx
  __int64 v28; // rax
  unsigned int v29; // er13
  _DWORD *v30; // r15
  char v31; // bl
  unsigned int v32; // edi
  unsigned int v33; // er14
  int v34; // er12
  __int64 v35; // rbp
  unsigned int v36; // edx
  unsigned int v37; // ecx
  signed __int64 v38; // rcx
  __int16 v39; // ax
  signed int v40; // er10
  signed int v41; // edx
  __int64 v42; // r8
  unsigned int i; // edx
  char v44; // r8
  signed __int64 v45; // r10
  signed int v46; // eax
  unsigned int v47; // er8
  int v48; // eax
  bool v49; // cf
  bool v50; // zf
  signed __int64 v51; // rdx
  int v52; // [rsp+20h] [rbp-D8h]
  signed int v53; // [rsp+28h] [rbp-D0h]
  int v54; // [rsp+30h] [rbp-C8h]
  unsigned int v55; // [rsp+34h] [rbp-C4h]
  int v56; // [rsp+38h] [rbp-C0h]
  _WORD *v57; // [rsp+40h] [rbp-B8h]
  _WORD *v58; // [rsp+48h] [rbp-B0h]
  _DWORD **v59; // [rsp+58h] [rbp-A0h]
  unsigned __int16 *v60; // [rsp+60h] [rbp-98h]
  __int16 v61; // [rsp+70h] [rbp-88h]
  __int16 v62[15]; // [rsp+72h] [rbp-86h]
  __int16 v63; // [rsp+90h] [rbp-68h]
  __int16 v64; // [rsp+92h] [rbp-66h]
  __int16 v65[14]; // [rsp+94h] [rbp-64h]

  v6 = 0;
  v7 = a4;
  v8 = a2;
  v59 = a4;
  v9 = a1;
  v10 = a3;
  v60 = a2;
  v56 = a1;
  do
  {
    v11 = 2i64 * v6;
    if ( v11 >= 0x20 )
    {
      _report_rangecheckfailure(a1, a2, a3, a4);
      __debugbreak();
      JUMPOUT(*(_QWORD *)sub_14000BBC0);
    }
    ++v6;
    *(__int16 *)((char *)&v61 + v11) = 0;
  }
  while ( v6 <= 0xF );
  if ( (_DWORD)a3 )
  {
    v12 = a2;
    v13 = (unsigned int)a3;
    do
    {
      v14 = *v12;
      ++v12;
      ++*(&v61 + v14);
      --v13;
    }
    while ( v13 );
  }
  v15 = 13;
  v16 = 15;
  while ( !*(&v61 + v16) )
  {
    if ( *(&v61 + v15 + 1) )
    {
      --v16;
      break;
    }
    if ( *(&v61 + v15) )
    {
      v16 -= 2;
      break;
    }
    if ( *(&v61 + v15 - 1) )
    {
      v16 -= 3;
      break;
    }
    if ( *(&v61 + v15 - 2) )
    {
      v16 -= 4;
      break;
    }
    v16 -= 5;
    v15 -= 5;
    if ( v16 < 1 )
      break;
  }
  v17 = v16;
  if ( *a5 <= v16 )
    v17 = *a5;
  if ( !v16 )
  {
    **v7 = 320;
    ++*v7;
    **v7 = 320;
    ++*v7;
    result = 0i64;
    *a5 = 1;
    return result;
  }
  v19 = 1;
  if ( v16 > 1 )
  {
    v20 = v62;
    do
    {
      if ( *v20 )
        break;
      ++v19;
      ++v20;
    }
    while ( v19 < v16 );
  }
  v21 = v19;
  v22 = 1;
  if ( v17 >= v19 )
    v21 = v17;
  v23 = 1;
  v55 = v21;
  do
  {
    v23 = 2 * v23 - (unsigned __int16)*(&v61 + v22);
    if ( v23 < 0 )
      return 0xFFFFFFFFi64;
    ++v22;
  }
  while ( v22 <= 0xF );
  if ( v23 > 0 && (!v9 || v16 != 1) )
    return 0xFFFFFFFFi64;
  v64 = 0;
  v24 = 0i64;
  v25 = 14i64;
  do
  {
    v65[v24] = *(__int16 *)((char *)&v64 + v24 * 2) + v62[v24];
    ++v24;
    --v25;
  }
  while ( v25 );
  v26 = 0;
  if ( v10 )
  {
    v27 = v8;
    do
    {
      v28 = *v27;
      if ( (_WORD)v28 )
      {
        a6[(unsigned __int16)*(&v63 + v28)] = v26;
        ++*(&v63 + *v27);
      }
      ++v26;
      ++v27;
    }
    while ( v26 < v10 );
  }
  v29 = 0;
  v30 = *v7;
  if ( !v9 )
  {
    v36 = 20;
    v57 = a6;
    LODWORD(v35) = 0;
    v58 = a6;
    v32 = 0;
    v53 = 20;
    v33 = 1 << v21;
    v31 = v21;
    v34 = -1;
    v54 = (1 << v21) - 1;
    goto LABEL_54;
  }
  v31 = v21;
  v50 = v9 == 1;
  v32 = 0;
  if ( v50 )
  {
    v53 = 257;
    v58 = &unk_1400311D0;
    v33 = 1 << v21;
    v57 = &unk_140031210;
    LODWORD(v35) = 0;
    v34 = -1;
    v54 = (1 << v21) - 1;
    goto LABEL_50;
  }
  v33 = 1 << v21;
  v58 = &unk_140031250;
  v34 = -1;
  v57 = &unk_140031290;
  v53 = 0;
  v54 = (1 << v21) - 1;
  if ( v56 == 1 )
  {
    LODWORD(v35) = 0;
LABEL_50:
    if ( v33 <= 0x354 )
    {
      v36 = v53;
      goto LABEL_54;
    }
    return 1i64;
  }
  v58 = &unk_140031250;
  v53 = 0;
  v33 = 1 << v21;
  v57 = &unk_140031290;
  v54 = (1 << v21) - 1;
  if ( v56 == 2 )
  {
    v58 = &unk_140031250;
    v57 = &unk_140031290;
    LODWORD(v35) = 0;
    v53 = 0;
    v54 = (1 << v21) - 1;
    if ( (unsigned int)(1 << v21) <= 0x250 )
    {
      v36 = 0;
      goto LABEL_54;
    }
    return 1i64;
  }
  LODWORD(v35) = 0;
  v36 = 0;
  while ( 1 )
  {
LABEL_54:
    BYTE1(v52) = v19 - v29;
    v37 = (unsigned __int16)a6[(unsigned int)v35];
    if ( v37 + 1 >= v36 )
    {
      if ( v37 < v36 )
      {
        LOBYTE(v52) = 96;
        v39 = 0;
      }
      else
      {
        v38 = v37 - v36;
        LOBYTE(v52) = v57[v38];
        v39 = v58[v38];
      }
      HIWORD(v52) = v39;
    }
    else
    {
      LOBYTE(v52) = 0;
      HIWORD(v52) = a6[(unsigned int)v35];
    }
    v40 = 1 << (v19 - v29);
    v41 = 1 << v31;
    LODWORD(v42) = (1 << v31) + (v32 >> v29);
    do
    {
      v42 = (unsigned int)(v42 - v40);
      v30[v42] = v52;
      v41 -= v40;
    }
    while ( v41 );
    for ( i = 1 << (v19 - 1); i & v32; i >>= 1 )
      ;
    if ( i )
      v32 = i + ((i - 1) & v32);
    else
      v32 = 0;
    v35 = (unsigned int)(v35 + 1);
    v50 = (*(&v61 + v19))-- == 1;
    if ( !v50 )
      goto LABEL_70;
    if ( v19 == v16 )
      break;
    v19 = v60[(unsigned __int16)a6[v35]];
LABEL_70:
    v44 = v55;
    v36 = v53;
    if ( v19 > v55 )
    {
      v45 = v32 & v54;
      if ( (_DWORD)v45 != v34 )
      {
        v30 += (unsigned int)(1 << v31);
        if ( !v29 )
          v29 = v55;
        v31 = v19 - v29;
        v46 = 1 << (v19 - v29);
        if ( v19 < v16 )
        {
          v47 = v19;
          do
          {
            v48 = v46 - (unsigned __int16)*(&v61 + v47);
            if ( v48 <= 0 )
              break;
            ++v31;
            ++v47;
            v46 = 2 * v48;
          }
          while ( v47 < v16 );
          v44 = v55;
        }
        v33 += 1 << v31;
        if ( v56 == 1 )
        {
          v49 = v33 < 0x354;
          v50 = v33 == 852;
        }
        else
        {
          if ( v56 != 2 )
            goto LABEL_84;
          v49 = v33 < 0x250;
          v50 = v33 == 592;
        }
        if ( !v49 && !v50 )
          return 1i64;
LABEL_84:
        v51 = v45;
        v34 = v32 & v54;
        LOBYTE((*v59)[v51]) = v31;
        BYTE1((*v59)[v51]) = v44;
        HIWORD((*v59)[v51]) = v30 - *v59;
        v36 = v53;
      }
    }
  }
  if ( v32 )
  {
    LOBYTE(v52) = 64;
    v30[v32] = (unsigned __int16)v52;
  }
  *v59 += v33;
  *a5 = v55;
  return 0i64;
}
// 14000BE04: using guessed type __int64 __fastcall _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD);
// 14000B620: using guessed type __int16 var_86[15];
// 14000B620: using guessed type __int16 var_64[14];

//----- (000000014000BBC0) ----------------------------------------------------
__int64 __fastcall sub_14000BBC0(__int64 a1, int a2, int a3)
{
  return sub_140014FA0((unsigned int)(a3 * a2));
}
// 140014FA0: using guessed type __int64 __fastcall sub_140014FA0(_QWORD);

//----- (000000014000BBD0) ----------------------------------------------------
void __fastcall sub_14000BBD0(__int64 a1, void *a2)
{
  sub_140014F8C(a2);
}

//----- (000000014000BD30) ----------------------------------------------------
__int64 __fastcall sub_14000BD30(DWORD64 a1)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 v3; // [rsp+40h] [rbp+8h]

  v3 = a1;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&v3;
  qword_14003FF50 = retaddr;
  ContextRecord.Rcx = v3;
  dword_14003FF40 = -1073740791;
  dword_14003FF44 = 1;
  dword_14003FF58 = 1;
  unk_14003FF60 = 2i64;
  return _raise_securityfailure(&ExceptionInfo);
}
// 14003FF40: using guessed type int dword_14003FF40;
// 14003FF44: using guessed type int dword_14003FF44;
// 14003FF50: using guessed type __int64 qword_14003FF50;
// 14003FF58: using guessed type int dword_14003FF58;

//----- (000000014000BE18) ----------------------------------------------------
__int64 __fastcall sub_14000BE18(unsigned int a1)
{
  DWORD64 retaddr; // [rsp+28h] [rbp+0h]
  unsigned int v3; // [rsp+30h] [rbp+8h]

  v3 = a1;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(v3);
  capture_current_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&v3;
  qword_14003FF50 = retaddr;
  dword_14003FF40 = -1073740791;
  dword_14003FF44 = 1;
  dword_14003FF58 = 1;
  unk_14003FF60 = v3;
  return _raise_securityfailure(&ExceptionInfo);
}
// 14003FF40: using guessed type int dword_14003FF40;
// 14003FF44: using guessed type int dword_14003FF44;
// 14003FF50: using guessed type __int64 qword_14003FF50;
// 14003FF58: using guessed type int dword_14003FF58;

//----- (000000014000BFA0) ----------------------------------------------------
__int64 __usercall sub_14000BFA0@<rax>(__m256i *a1@<ymm0>)
{
  signed __int32 v1; // eax
  int v2; // ebx
  __int64 v3; // rcx
  int v4; // eax
  __int64 v5; // rcx
  __int64 v6; // rcx
  int v7; // eax
  __int64 result; // rax

  sub_14001921C(2);
  v1 = sub_14000C524();
  sub_14001A048(v1, a1);
  v2 = sub_140006340();
  *sub_14001A2C0() = v2;
  if ( !sub_14000C2A8(1u, a1) )
    goto LABEL_12;
  sub_14000C7DC(v3);
  sub_14000C458((__int64)sub_14000C820, a1);
  v4 = sub_14000C51C();
  if ( (unsigned int)sub_1400194B4(v4, a1) )
    goto LABEL_12;
  sub_14000C52C();
  if ( (unsigned int)sub_14000C568() )
    sub_140019288((__int64)sub_140006340);
  nullsub_1(v5);
  nullsub_1(v6);
  v7 = sub_140006340();
  sub_14001A220(v7, a1);
  if ( sub_14000C540() )
    sub_140019C1C();
  sub_140006340();
  result = sub_14000C714();
  if ( (_DWORD)result )
  {
LABEL_12:
    sub_14000C58C(7u, a1);
    JUMPOUT(*(_QWORD *)&byte_14000C055);
  }
  return result;
}
// 1400035B0: using guessed type __int64 __fastcall nullsub_1(_QWORD);
// 14000C055: using guessed type char byte_14000C055;
// 14000C714: using guessed type __int64 sub_14000C714(void);
// 140019C1C: using guessed type __int64 sub_140019C1C(void);

//----- (000000014000C060) ----------------------------------------------------
__int64 sub_14000C060()
{
  sub_14000C54C();
  return 0i64;
}

//----- (000000014000C070) ----------------------------------------------------
signed __int64 __usercall sub_14000C070@<rax>(__m256i *a1@<ymm0>)
{
  unsigned __int32 v1; // eax

  sub_14000C770();
  v1 = sub_140006340();
  return sub_14001A294(v1, a1);
}

//----- (000000014000C08C) ----------------------------------------------------
signed __int64 __usercall sub_14000C08C@<rax>(UINT a1@<ebx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  char v4; // di
  __int64 *v6; // rax
  __int64 *v7; // rbx
  __int64 v8; // rax
  __int64 *v9; // rax
  __int64 *v10; // rbx

  if ( !sub_14000C25C(1) )
  {
    sub_14000C58C(7u, a3);
    goto LABEL_20;
  }
  v4 = 0;
  LOBYTE(a1) = sub_14000C220();
  if ( dword_1400404B0 == 1 )
  {
LABEL_20:
    sub_14000C58C(7u, a3);
    goto LABEL_21;
  }
  if ( dword_1400404B0 )
  {
    v4 = 1;
  }
  else
  {
    dword_1400404B0 = 1;
    if ( (unsigned int)sub_140019CBC(&unk_14002B470, &unk_14002B4B0) )
      return 255i64;
    sub_140019C78((__int64 *)&unk_14002B458, (__int64 *)&unk_14002B468);
    dword_1400404B0 = 2;
  }
  sub_14000C3CC(a1);
  v6 = (__int64 *)sub_14000C574();
  v7 = v6;
  if ( *v6 && sub_14000C334((__int64)v6) )
  {
    v8 = *v7;
    sub_14002A5B0();
  }
  v9 = (__int64 *)sub_14000C57C();
  v10 = v9;
  if ( *v9 && sub_14000C334((__int64)v9) )
    sub_140019FCC(*v10, a3);
  sub_14000C6D8(a3);
  sub_140019C24();
  a1 = sub_140001000(a2, a3, a4);
  if ( !sub_14000C71C() )
  {
LABEL_21:
    sub_14001A00C(a1);
    sub_140019FC0(a1);
    JUMPOUT(*(_QWORD *)byte_14000C1FD);
  }
  if ( !v4 )
    sub_140019FB0();
  sub_14000C3F0(0, 1, a3);
  return a1;
}
// 1400404B0: using guessed type int dword_1400404B0;

//----- (000000014000C220) ----------------------------------------------------
char sub_14000C220()
{
  signed __int64 v0; // rcx
  signed __int64 v1; // rax

  if ( (unsigned int)sub_14000CA08() )
  {
    v0 = *(_QWORD *)(__readgsqword(0x30u) + 8);
    while ( 1 )
    {
      v1 = _InterlockedCompareExchange(&qword_1400404B8, v0, 0i64);
      if ( !v1 )
        break;
      if ( v0 == v1 )
        return 1;
    }
  }
  return 0;
}
// 1400404B8: using guessed type __int64 qword_1400404B8;

//----- (000000014000C25C) ----------------------------------------------------
char __fastcall sub_14000C25C(int a1)
{
  char v1; // al

  v1 = byte_1400404C0;
  if ( !a1 )
    v1 = 1;
  byte_1400404C0 = v1;
  sub_14000C85C();
  if ( !sub_14000D990() )
    return 0;
  if ( !sub_14001A82C() )
  {
    sub_14000D9B8(0);
    return 0;
  }
  return 1;
}
// 1400404C0: using guessed type char byte_1400404C0;

//----- (000000014000C2A8) ----------------------------------------------------
char __usercall sub_14000C2A8@<al>(unsigned int a1@<ecx>, __m256i *a2@<ymm0>)
{
  unsigned int v2; // ebx
  __m128i v4; // xmm0

  v2 = a1;
  if ( !byte_1400404C1 )
  {
    if ( a1 > 1 )
    {
      sub_14000C58C(5u, a2);
      JUMPOUT(*(_QWORD *)&byte_14000C332);
    }
    if ( !(unsigned int)sub_14000CA08() || v2 )
    {
      v4 = _mm_load_si128((const __m128i *)&xmmword_1400313C0);
      _mm_storeu_si128((__m128i *)&xmmword_1400404C8, v4);
      qword_1400404D8 = -1i64;
      _mm_storeu_si128((__m128i *)&xmmword_1400404E0, v4);
      qword_1400404F0 = -1i64;
    }
    else if ( (unsigned int)sub_14001A664((uintptr_t *)&xmmword_1400404C8)
           || (unsigned int)sub_14001A664((uintptr_t *)&xmmword_1400404E0) )
    {
      return 0;
    }
    byte_1400404C1 = 1;
  }
  return 1;
}
// 14000C332: using guessed type char;
// 1400313C0: using guessed type __int128 xmmword_1400313C0;
// 1400404C1: using guessed type char byte_1400404C1;
// 1400404C8: using guessed type __int128 xmmword_1400404C8;
// 1400404D8: using guessed type __int64 qword_1400404D8;
// 1400404E0: using guessed type __int128 xmmword_1400404E0;
// 1400404F0: using guessed type __int64 qword_1400404F0;

//----- (000000014000C334) ----------------------------------------------------
char __fastcall sub_14000C334(__int64 a1)
{
  unsigned __int64 v1; // r8
  _DWORD *v2; // rdx
  signed __int64 v3; // r9
  unsigned __int64 v4; // rcx

  if ( MEMORY[0x140000000] != 23117
    || *(_DWORD *)(MEMORY[0x14000003C] + 0x140000000i64) != 17744
    || *(_WORD *)(MEMORY[0x14000003C] + 0x140000018i64) != 523 )
  {
    return 0;
  }
  v1 = a1 - 5368709120i64;
  v2 = (_DWORD *)(MEMORY[0x14000003C]
                + 5368709120i64
                + *(unsigned __int16 *)(MEMORY[0x14000003C] + 0x140000014i64)
                + 24i64);
  v3 = (signed __int64)&v2[10 * *(unsigned __int16 *)(MEMORY[0x14000003C] + 0x140000006i64)];
  while ( v2 != (_DWORD *)v3 )
  {
    v4 = (unsigned int)v2[3];
    if ( v1 >= v4 && v1 < (unsigned int)(v4 + v2[2]) )
      goto LABEL_10;
    v2 += 10;
  }
  v2 = 0i64;
LABEL_10:
  if ( !v2 )
    return 0;
  if ( v2[9] >= 0 )
    return 1;
  return 0;
}

//----- (000000014000C3CC) ----------------------------------------------------
_BOOL8 __fastcall sub_14000C3CC(char a1)
{
  char v1; // bl
  _BOOL8 result; // rax

  v1 = a1;
  result = sub_14000CA08();
  _RDX = 0i64;
  if ( (_DWORD)result )
  {
    if ( !v1 )
      __asm { xchg    rdx, cs:qword_1400404B8 }
  }
  return result;
}
// 1400404B8: using guessed type __int64 qword_1400404B8;

//----- (000000014000C3F0) ----------------------------------------------------
char __usercall sub_14000C3F0@<al>(char a1@<dl>, char a2@<cl>, __m256i *a3@<ymm0>)
{
  char v3; // bl

  v3 = a2;
  if ( !byte_1400404C0 || !a1 )
  {
    sub_14001A840(a2, a3);
    sub_14000D9B8(v3);
  }
  return 1;
}
// 1400404C0: using guessed type char byte_1400404C0;

//----- (000000014000C41C) ----------------------------------------------------
__int64 __usercall sub_14000C41C@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rbx
  int v3; // eax
  __int64 v4; // rdx

  v2 = a1;
  if ( (_QWORD)xmmword_1400404C8 == -1i64 )
    v3 = sub_14001A610(a1, a2);
  else
    v3 = sub_14001A68C(a1, (__int64)&xmmword_1400404C8, a2);
  v4 = 0i64;
  if ( !v3 )
    v4 = v2;
  return v4;
}
// 1400404C8: using guessed type __int128 xmmword_1400404C8;

//----- (000000014000C458) ----------------------------------------------------
__int64 __usercall sub_14000C458@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  return (unsigned int)(sub_14000C41C(a1, a2) != 0) - 1;
}

//----- (000000014000C470) ----------------------------------------------------
__int64 sub_14000C470()
{
  uintptr_t v0; // rax
  __int64 result; // rax
  unsigned __int64 v2; // [rsp+30h] [rbp+10h]
  struct _FILETIME SystemTimeAsFileTime; // [rsp+38h] [rbp+18h]
  LARGE_INTEGER PerformanceCount; // [rsp+40h] [rbp+20h]

  v0 = _security_cookie;
  if ( _security_cookie == 47936899621426i64 )
  {
    SystemTimeAsFileTime = 0i64;
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v2 = (unsigned __int64)SystemTimeAsFileTime;
    v2 ^= GetCurrentThreadId();
    v2 ^= GetCurrentProcessId();
    QueryPerformanceCounter(&PerformanceCount);
    v0 = ((unsigned __int64)&v2 ^ v2 ^ PerformanceCount.QuadPart ^ ((unsigned __int64)PerformanceCount.LowPart << 32)) & 0xFFFFFFFFFFFFi64;
    if ( v0 == 47936899621426i64 )
      v0 = 47936899621427i64;
    _security_cookie = v0;
  }
  result = ~v0;
  qword_14003E010 = result;
  return result;
}
// 14003E010: using guessed type __int64 qword_14003E010;

//----- (000000014000C51C) ----------------------------------------------------
signed __int64 sub_14000C51C()
{
  return 1i64;
}

//----- (000000014000C524) ----------------------------------------------------
signed __int64 sub_14000C524()
{
  return 0x4000i64;
}

//----- (000000014000C52C) ----------------------------------------------------
void sub_14000C52C()
{
  InitializeSListHead((PSLIST_HEADER)&unk_140040500);
}

//----- (000000014000C540) ----------------------------------------------------
char sub_14000C540()
{
  return 1;
}

//----- (000000014000C544) ----------------------------------------------------
void *sub_14000C544()
{
  return &unk_140040510;
}

//----- (000000014000C54C) ----------------------------------------------------
_QWORD *sub_14000C54C()
{
  _QWORD *v0; // rax
  _QWORD *result; // rax

  v0 = sub_140001040();
  *v0 |= 0x24ui64;
  result = sub_14000C544();
  *result |= 2ui64;
  return result;
}

//----- (000000014000C568) ----------------------------------------------------
_BOOL8 sub_14000C568()
{
  return dword_14003E024 == 0;
}
// 14003E024: using guessed type int dword_14003E024;

//----- (000000014000C574) ----------------------------------------------------
void *sub_14000C574()
{
  return &unk_140041330;
}

//----- (000000014000C57C) ----------------------------------------------------
void *sub_14000C57C()
{
  return &unk_140041328;
}

//----- (000000014000C584) ----------------------------------------------------
void sub_14000C584()
{
  dword_140040518 = 0;
}
// 140040518: using guessed type int dword_140040518;

//----- (000000014000C58C) ----------------------------------------------------
void __usercall sub_14000C58C(unsigned int a1@<ecx>, __m256i *a2@<ymm0>)
{
  unsigned int v2; // ebx
  DWORD64 v3; // rbx
  struct _RUNTIME_FUNCTION *v4; // rax
  bool v5; // bl
  struct _EXCEPTION_POINTERS ExceptionInfo; // [rsp+40h] [rbp-C0h]
  int v7; // [rsp+50h] [rbp-B0h]
  int v8; // [rsp+54h] [rbp-ACh]
  DWORD64 v9; // [rsp+60h] [rbp-A0h]
  struct _CONTEXT ContextRecord; // [rsp+F0h] [rbp-10h]
  DWORD64 retaddr; // [rsp+5C8h] [rbp+4C8h]
  __int64 v12; // [rsp+5D0h] [rbp+4D0h]
  unsigned __int64 ImageBase; // [rsp+5D8h] [rbp+4D8h]
  unsigned __int64 EstablisherFrame; // [rsp+5E0h] [rbp+4E0h]
  PVOID HandlerData; // [rsp+5E8h] [rbp+4E8h]

  v2 = a1;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(v2);
  sub_14000C584();
  sub_14000D100(0i64, (__int64)&ContextRecord, 0x4D0ui64, a2);
  RtlCaptureContext(&ContextRecord);
  v3 = ContextRecord.Rip;
  v4 = RtlLookupFunctionEntry(ContextRecord.Rip, &ImageBase, 0i64);
  if ( v4 )
    RtlVirtualUnwind(0, ImageBase, v3, v4, &ContextRecord, &HandlerData, &EstablisherFrame, 0i64);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&v12;
  sub_14000D100(0i64, (__int64)&v7, 0x98ui64, a2);
  v9 = retaddr;
  v7 = 1073741845;
  v8 = 1;
  ExceptionInfo.ExceptionRecord = (PEXCEPTION_RECORD)&v7;
  v5 = IsDebuggerPresent() == 1;
  ExceptionInfo.ContextRecord = &ContextRecord;
  SetUnhandledExceptionFilter(0i64);
  if ( !UnhandledExceptionFilter(&ExceptionInfo) && !v5 )
    sub_14000C584();
}

//----- (000000014000C6D8) ----------------------------------------------------
WORD __usercall sub_14000C6D8@<ax>(__m256i *a1@<ymm0>)
{
  WORD result; // ax
  struct _STARTUPINFOW StartupInfo; // [rsp+20h] [rbp-78h]

  sub_14000D100(0i64, (__int64)&StartupInfo, 0x68ui64, a1);
  GetStartupInfoW(&StartupInfo);
  result = 10;
  if ( StartupInfo.dwFlags & 1 )
    result = StartupInfo.wShowWindow;
  return result;
}

//----- (000000014000C71C) ----------------------------------------------------
bool sub_14000C71C()
{
  HMODULE v0; // rax
  char *v1; // rcx
  bool result; // al

  v0 = GetModuleHandleW(0i64);
  if ( v0
    && *(_WORD *)v0 == 23117
    && (v1 = (char *)v0 + *((signed int *)v0 + 15), *(_DWORD *)v1 == 17744)
    && *((_WORD *)v1 + 12) == 523
    && *((_DWORD *)v1 + 33) > 0xEu )
  {
    result = *((_DWORD *)v1 + 62) != 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (000000014000C770) ----------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_14000C770()
{
  return SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)sub_14000C780);
}

//----- (000000014000C780) ----------------------------------------------------
__int64 __usercall sub_14000C780@<rax>(_QWORD *a1@<rcx>, __m256i *a2@<ymm0>)
{
  _DWORD *v2; // rbx
  _QWORD *v3; // rdi
  int v4; // edx
  __int64 v6; // rbx

  v2 = (_DWORD *)*a1;
  v3 = a1;
  if ( *(_DWORD *)*a1 == -529697949 && v2[6] == 4 )
  {
    v4 = v2[8];
    if ( (unsigned int)(v4 - 429065504) <= 2 || v4 == 26820608 )
    {
      *(_QWORD *)sub_14000DB30(a2) = v2;
      v6 = v3[1];
      *(_QWORD *)sub_14000DB44(a2) = v6;
      sub_14001A878(a2);
    }
  }
  return 0i64;
}

//----- (000000014000C7DC) ----------------------------------------------------
__int64 __fastcall sub_14000C7DC(__int64 a1)
{
  __int64 *i; // rbx
  __int64 result; // rax

  for ( i = (__int64 *)&unk_14003AB70; i < (__int64 *)&unk_14003AB70; ++i )
  {
    result = *i;
    if ( *i )
      result = sub_14002A5B0();
  }
  return result;
}

//----- (000000014000C820) ----------------------------------------------------
__int64 __fastcall sub_14000C820(__int64 a1)
{
  __int64 *i; // rbx
  __int64 result; // rax

  for ( i = (__int64 *)&unk_14003AB80; i < (__int64 *)&unk_14003AB80; ++i )
  {
    result = *i;
    if ( *i )
      result = sub_14002A5B0();
  }
  return result;
}

//----- (000000014000C85C) ----------------------------------------------------
__int64 sub_14000C85C()
{
  int v5; // er11
  int v6; // er9
  signed int v7; // esi
  int v9; // er10
  int v14; // edi
  int v15; // eax
  unsigned __int64 v16; // rax
  signed __int64 v17; // rcx
  int v18; // er8
  int v22; // eax
  signed __int64 v24; // [rsp+20h] [rbp+8h]

  _RAX = 0i64;
  __asm { cpuid }
  v5 = 0;
  v6 = _RBX;
  v7 = _RAX;
  _RAX = 1i64;
  v9 = _RCX ^ 0x6C65746E | _RDX ^ 0x49656E69;
  __asm { cpuid }
  v14 = _RCX;
  if ( v6 ^ 0x756E6547 | v9
    || (qword_14003E038 = -1i64, v15 = _RAX & 0xFFF3FF0, qword_14003E030 = 0x8000i64, v15 != 67264)
    && v15 != 132704
    && v15 != 132720
    && ((v16 = (unsigned int)(v15 - 198224), (unsigned int)v16 > 0x20) || (v17 = 4295032833i64, !_bittest64(&v17, v16))) )
  {
    v18 = dword_14004051C;
  }
  else
  {
    v18 = dword_14004051C | 1;
    dword_14004051C |= 1u;
  }
  _RAX = 7i64;
  if ( v7 >= 7 )
  {
    __asm { cpuid }
    v5 = _RBX;
    if ( _bittest((const signed int *)&_RBX, 9u) )
      dword_14004051C = v18 | 2;
  }
  dword_14003E028 = 1;
  dword_14003E02C = 2;
  if ( _bittest(&v14, 0x14u) )
  {
    dword_14003E028 = 2;
    dword_14003E02C = 6;
    if ( _bittest(&v14, 0x1Bu) )
    {
      if ( _bittest(&v14, 0x1Cu) )
      {
        __asm { xgetbv }
        v24 = _RAX | (_RDX << 32);
        if ( (_RAX & 6) == 6 )
        {
          v22 = dword_14003E02C | 8;
          dword_14003E028 = 3;
          dword_14003E02C |= 8u;
          if ( v5 & 0x20 )
          {
            dword_14003E028 = 5;
            dword_14003E02C = v22 | 0x20;
            if ( (v5 & 0xD0030000) == -805109760 && (v24 & 0xE0) == -32 )
            {
              dword_14003E02C |= 0x40u;
              dword_14003E028 = 6;
            }
          }
        }
      }
    }
  }
  return 0i64;
}
// 14003E028: using guessed type int dword_14003E028;
// 14003E02C: using guessed type int dword_14003E02C;
// 14003E030: using guessed type __int64 qword_14003E030;
// 14003E038: using guessed type __int64 qword_14003E038;
// 140040518: using guessed type int dword_140040518;
// 14004051C: using guessed type int dword_14004051C;

//----- (000000014000CA08) ----------------------------------------------------
_BOOL8 sub_14000CA08()
{
  return dword_140041320 != 0;
}
// 140041320: using guessed type int dword_140041320;

//----- (000000014000CA30) ----------------------------------------------------
void __fastcall sub_14000CA30(void *a1, const void *a2, unsigned __int64 a3)
{
  qmemcpy(a1, a2, a3);
}

//----- (000000014000CA50) ----------------------------------------------------
__int64 __fastcall sub_14000CA50(__m128i *_RCX, const __m128i *_RDX, unsigned __int64 _R8)
{
  __int64 result; // rax
  int v4; // ecx
  __int16 v5; // r9
  char v6; // r10
  __int16 v7; // cx
  char v8; // r9
  __int16 v9; // r8
  char v10; // r9
  int v11; // ecx
  __int16 v12; // r9
  char v13; // r8
  int v14; // ecx
  char v15; // r9
  __int16 v16; // cx
  char v17; // cl
  int v18; // ecx
  __int16 v19; // r8
  char v20; // r8
  __m128i v21; // xmm2
  signed __int64 v24; // r9
  signed __int64 v41; // r9
  __m128i v42; // xmm2
  __m128i v43; // xmm3
  __m128i v44; // xmm4
  __m128i v45; // xmm2
  __m128i v46; // xmm3
  __m128i v47; // xmm4
  __m128i *v48; // r11
  const __m128i *v49; // r10
  signed __int64 v50; // rdx
  char *v51; // rcx
  __int128 v52; // xmm0
  signed __int64 v53; // rcx
  unsigned __int64 v54; // r8
  _OWORD *v55; // rax
  __int128 v56; // xmm1
  unsigned __int64 v57; // r9
  __int128 v58; // xmm0
  __int128 v59; // xmm1
  __int128 v60; // xmm1
  __int128 v61; // xmm1
  __int128 v62; // xmm0
  __int128 v63; // xmm1
  unsigned __int64 i; // r9

  result = (__int64)_RCX;
  switch ( _R8 )
  {
    case 0ui64:
      return result;
    case 1ui64:
      LOBYTE(_RCX->m128i_i64[0]) = _RDX->m128i_i64[0];
      return result;
    case 2ui64:
      LOWORD(_RCX->m128i_i64[0]) = _RDX->m128i_i64[0];
      return result;
    case 3ui64:
      v13 = BYTE2(_RDX->m128i_i64[0]);
      LOWORD(_RCX->m128i_i64[0]) = _RDX->m128i_i64[0];
      BYTE2(_RCX->m128i_i64[0]) = v13;
      return result;
    case 4ui64:
      LODWORD(_RCX->m128i_i64[0]) = _RDX->m128i_i64[0];
      return result;
    case 5ui64:
      v20 = BYTE4(_RDX->m128i_i64[0]);
      LODWORD(_RCX->m128i_i64[0]) = _RDX->m128i_i64[0];
      BYTE4(_RCX->m128i_i64[0]) = v20;
      return result;
    case 6ui64:
      v19 = WORD2(_RDX->m128i_i64[0]);
      LODWORD(_RCX->m128i_i64[0]) = _RDX->m128i_i64[0];
      WORD2(_RCX->m128i_i64[0]) = v19;
      return result;
    case 7ui64:
      v9 = WORD2(_RDX->m128i_i64[0]);
      v10 = BYTE6(_RDX->m128i_i64[0]);
      LODWORD(_RCX->m128i_i64[0]) = _RDX->m128i_i64[0];
      WORD2(_RCX->m128i_i64[0]) = v9;
      BYTE6(_RCX->m128i_i64[0]) = v10;
      return result;
    case 8ui64:
      _RCX->m128i_i64[0] = _RDX->m128i_i64[0];
      return result;
    case 9ui64:
      v17 = _RDX->m128i_i64[1];
      *(_QWORD *)result = _RDX->m128i_i64[0];
      *(_BYTE *)(result + 8) = v17;
      return result;
    case 0xAui64:
      v16 = _RDX->m128i_i64[1];
      *(_QWORD *)result = _RDX->m128i_i64[0];
      *(_WORD *)(result + 8) = v16;
      return result;
    case 0xBui64:
      v7 = _RDX->m128i_i64[1];
      v8 = BYTE2(_RDX->m128i_i64[1]);
      *(_QWORD *)result = _RDX->m128i_i64[0];
      *(_WORD *)(result + 8) = v7;
      *(_BYTE *)(result + 10) = v8;
      return result;
    case 0xCui64:
      v18 = _RDX->m128i_i64[1];
      *(_QWORD *)result = _RDX->m128i_i64[0];
      *(_DWORD *)(result + 8) = v18;
      return result;
    case 0xDui64:
      v14 = _RDX->m128i_i64[1];
      v15 = BYTE4(_RDX->m128i_i64[1]);
      *(_QWORD *)result = _RDX->m128i_i64[0];
      *(_DWORD *)(result + 8) = v14;
      *(_BYTE *)(result + 12) = v15;
      return result;
    case 0xEui64:
      v11 = _RDX->m128i_i64[1];
      v12 = WORD2(_RDX->m128i_i64[1]);
      *(_QWORD *)result = _RDX->m128i_i64[0];
      *(_DWORD *)(result + 8) = v11;
      *(_WORD *)(result + 12) = v12;
      return result;
    case 0xFui64:
      v4 = _RDX->m128i_i64[1];
      v5 = WORD2(_RDX->m128i_i64[1]);
      v6 = BYTE6(_RDX->m128i_i64[1]);
      *(_QWORD *)result = _RDX->m128i_i64[0];
      *(_DWORD *)(result + 8) = v4;
      *(_WORD *)(result + 12) = v5;
      *(_BYTE *)(result + 14) = v6;
      return result;
    default:
      if ( _R8 <= 0x20 )
      {
        v21 = _mm_loadu_si128((const __m128i *)((char *)_RDX + _R8 - 16));
        _mm_storeu_si128(_RCX, _mm_loadu_si128(_RDX));
        _mm_storeu_si128((__m128i *)((char *)_RCX + _R8 - 16), v21);
        return result;
      }
      if ( _RDX < _RCX && _RCX < (__m128i *)&_RDX->m128i_i8[_R8] )
      {
        v48 = _RCX;
        v49 = _RDX;
        v50 = (char *)_RDX - (char *)_RCX;
        v51 = (char *)_RCX->m128i_i64 + _R8;
        v52 = *(_OWORD *)&v51[v50 - 16];
        v53 = (signed __int64)(v51 - 16);
        v54 = _R8 - 16;
        if ( v53 & 0xF )
        {
          v55 = (_OWORD *)v53;
          v53 &= 0xFFFFFFFFFFFFFFF0ui64;
          v56 = v52;
          v52 = *(_OWORD *)(v53 + v50);
          *v55 = v56;
          v54 = v53 - (_QWORD)v48;
        }
        v57 = v54 >> 7;
        if ( v54 >> 7 )
        {
          for ( *(_OWORD *)v53 = v52; ; *(_OWORD *)v53 = v63 )
          {
            v58 = *(_OWORD *)(v53 + v50 - 16);
            v59 = *(_OWORD *)(v53 + v50 - 32);
            v53 -= 128i64;
            *(_OWORD *)(v53 + 112) = v58;
            *(_OWORD *)(v53 + 96) = v59;
            v60 = *(_OWORD *)(v53 + v50 + 64);
            --v57;
            *(_OWORD *)(v53 + 80) = *(_OWORD *)(v53 + v50 + 80);
            *(_OWORD *)(v53 + 64) = v60;
            v61 = *(_OWORD *)(v53 + v50 + 32);
            *(_OWORD *)(v53 + 48) = *(_OWORD *)(v53 + v50 + 48);
            *(_OWORD *)(v53 + 32) = v61;
            v62 = *(_OWORD *)(v53 + v50 + 16);
            v63 = *(_OWORD *)(v53 + v50);
            if ( !v57 )
              break;
            *(_OWORD *)(v53 + 16) = v62;
          }
          *(_OWORD *)(v53 + 16) = v62;
          v54 &= 0x7Fu;
          v52 = v63;
        }
        for ( i = v54 >> 4; i; --i )
        {
          *(_OWORD *)v53 = v52;
          v53 -= 16i64;
          v52 = *(_OWORD *)(v53 + v50);
        }
        if ( v54 & 0xF )
          *v48 = *v49;
        *(_OWORD *)v53 = v52;
        result = (__int64)v48;
      }
      else if ( (unsigned int)dword_14003E028 < 3 )
      {
        if ( _R8 > 0x800 )
          JUMPOUT(dword_14004051C & 2, 0, sub_14000CA30);
        if ( _R8 > 0x80 )
        {
          v41 = ((unsigned __int8)_RCX & 0xF) - 16i64;
          _RCX = (__m128i *)((char *)_RCX - v41);
          _RDX = (const __m128i *)((char *)_RDX - v41);
          _R8 += v41;
          if ( _R8 > 0x80 )
          {
            do
            {
              v42 = _mm_loadu_si128(_RDX + 1);
              v43 = _mm_loadu_si128(_RDX + 2);
              v44 = _mm_loadu_si128(_RDX + 3);
              _mm_store_si128(_RCX, _mm_loadu_si128(_RDX));
              _mm_store_si128(_RCX + 1, v42);
              _mm_store_si128(_RCX + 2, v43);
              _mm_store_si128(_RCX + 3, v44);
              v45 = _mm_loadu_si128(_RDX + 5);
              v46 = _mm_loadu_si128(_RDX + 6);
              v47 = _mm_loadu_si128(_RDX + 7);
              _mm_store_si128(_RCX + 4, _mm_loadu_si128(_RDX + 4));
              _mm_store_si128(_RCX + 5, v45);
              _mm_store_si128(_RCX + 6, v46);
              _mm_store_si128(_RCX + 7, v47);
              _RCX += 8;
              _RDX += 8;
              _R8 -= 128i64;
            }
            while ( _R8 >= 0x80 );
          }
        }
        result = ((__int64 (__fastcall *)(__m128i *, const __m128i *))((unsigned int)dword_140045088[((_R8 + 15) & 0xFFFFFFFFFFFFFFF0ui64) >> 4]
                                                                     + 0x140000000i64))(
                   _RCX,
                   _RDX);
      }
      else
      {
        if ( _R8 > 0x2000 && _R8 <= 0x180000 )
          JUMPOUT(dword_14004051C & 2, 0, sub_14000CA30);
        __asm
        {
          vmovdqu ymm0, ymmword ptr [rdx]
          vmovdqu ymm5, ymmword ptr [rdx+r8-20h]
        }
        if ( _R8 <= 0x100 )
          return ((__int64 (__fastcall *)(__m128i *, const __m128i *))((unsigned int)dword_140045040[((_R8 + 31) & 0xFFFFFFFFFFFFFFE0ui64) >> 5]
                                                                     + 0x140000000i64))(
                   _RCX,
                   _RDX);
        v24 = ((unsigned __int8)_RCX & 0x1F) - 32i64;
        _RCX = (__m128i *)((char *)_RCX - v24);
        _RDX = (const __m128i *)((char *)_RDX - v24);
        _R8 += v24;
        if ( _R8 <= 0x100 )
          return ((__int64 (__fastcall *)(__m128i *, const __m128i *))((unsigned int)dword_140045040[((_R8 + 31) & 0xFFFFFFFFFFFFFFE0ui64) >> 5]
                                                                     + 0x140000000i64))(
                   _RCX,
                   _RDX);
        if ( _R8 <= 0x180000 )
        {
          do
          {
            __asm
            {
              vmovdqu ymm1, ymmword ptr [rdx]
              vmovdqu ymm2, ymmword ptr [rdx+20h]
              vmovdqu ymm3, ymmword ptr [rdx+40h]
              vmovdqu ymm4, ymmword ptr [rdx+60h]
              vmovdqa ymmword ptr [rcx], ymm1
              vmovdqa ymmword ptr [rcx+20h], ymm2
              vmovdqa ymmword ptr [rcx+40h], ymm3
              vmovdqa ymmword ptr [rcx+60h], ymm4
              vmovdqu ymm1, ymmword ptr [rdx+80h]
              vmovdqu ymm2, ymmword ptr [rdx+0A0h]
              vmovdqu ymm3, ymmword ptr [rdx+0C0h]
              vmovdqu ymm4, ymmword ptr [rdx+0E0h]
              vmovdqa ymmword ptr [rcx+80h], ymm1
              vmovdqa ymmword ptr [rcx+0A0h], ymm2
              vmovdqa ymmword ptr [rcx+0C0h], ymm3
              vmovdqa ymmword ptr [rcx+0E0h], ymm4
            }
            _RCX += 16;
            _RDX += 16;
            _R8 -= 256i64;
          }
          while ( _R8 >= 0x100 );
          return ((__int64 (__fastcall *)(_QWORD, _QWORD))((unsigned int)dword_140045040[((_R8 + 31) & 0xFFFFFFFFFFFFFFE0ui64) >> 5]
                                                         + 0x140000000i64))(
                   _RCX,
                   _RDX);
        }
        do
        {
          __asm
          {
            vmovdqu ymm1, ymmword ptr [rdx]
            vmovdqu ymm2, ymmword ptr [rdx+20h]
            vmovdqu ymm3, ymmword ptr [rdx+40h]
            vmovdqu ymm4, ymmword ptr [rdx+60h]
            vmovntdq ymmword ptr [rcx], ymm1
            vmovntdq ymmword ptr [rcx+20h], ymm2
            vmovntdq ymmword ptr [rcx+40h], ymm3
            vmovntdq ymmword ptr [rcx+60h], ymm4
            vmovdqu ymm1, ymmword ptr [rdx+80h]
            vmovdqu ymm2, ymmword ptr [rdx+0A0h]
            vmovdqu ymm3, ymmword ptr [rdx+0C0h]
            vmovdqu ymm4, ymmword ptr [rdx+0E0h]
            vmovntdq ymmword ptr [rcx+80h], ymm1
            vmovntdq ymmword ptr [rcx+0A0h], ymm2
            vmovntdq ymmword ptr [rcx+0C0h], ymm3
            vmovntdq ymmword ptr [rcx+0E0h], ymm4
          }
          _RCX += 16;
          _RDX += 16;
          _R8 -= 256i64;
        }
        while ( _R8 >= 0x100 );
        result = ((__int64 (__fastcall *)(__m128i *, const __m128i *))((unsigned int)dword_140045064[((_R8 + 31) & 0xFFFFFFFFFFFFFFE0ui64) >> 5]
                                                                     + 0x140000000i64))(
                   _RCX,
                   _RDX);
      }
      return result;
  }
}
// 14003E028: using guessed type int dword_14003E028;
// 14004051C: using guessed type int dword_14004051C;

//----- (000000014000D0E0) ----------------------------------------------------
__int64 __fastcall sub_14000D0E0(void *a1, char a2, unsigned __int64 a3, __int64 a4)
{
  memset(a1, a2, a3);
  return a4;
}

//----- (000000014000D100) ----------------------------------------------------
__int64 __usercall sub_14000D100@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, unsigned __int64 a3@<r8>, __m256i _YMM0@<ymm0>)
{
  __int64 result; // rax
  signed __int64 v5; // r11
  __m128i *v6; // rcx
  __m128i v7; // xmm0
  signed __int64 v9; // r9
  signed __int64 v11; // rdx
  unsigned __int64 v12; // r8
  signed __int64 v13; // r9
  __m128i *v14; // rcx
  signed __int64 v15; // rdx
  unsigned __int64 v16; // r8

  result = a2;
  a1 = (unsigned __int8)a1;
  v5 = 72340172838076673i64 * (unsigned __int8)a1;
  v6 = (__m128i *)(a3 + a2);
  switch ( a3 )
  {
    case 0ui64:
      return result;
    case 1ui64:
      goto LABEL_5;
    case 2ui64:
      goto LABEL_8;
    case 3ui64:
      goto LABEL_4;
    case 4ui64:
      goto LABEL_12;
    case 5ui64:
      goto LABEL_10;
    case 6ui64:
      goto LABEL_7;
    case 7ui64:
      goto LABEL_3;
    case 8ui64:
      v6[-1].m128i_i64[1] = v5;
      return result;
    case 9ui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 7) = v5;
      v6[-1].m128i_i8[15] = a1;
      return result;
    case 0xAui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 6) = v5;
      v6[-1].m128i_i16[7] = v5;
      return result;
    case 0xBui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 5) = v5;
      *(__int16 *)((char *)&v6[-1].m128i_i16[6] + 1) = v5;
      v6[-1].m128i_i8[15] = a1;
      return result;
    case 0xCui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 4) = v5;
LABEL_12:
      v6[-1].m128i_i32[3] = v5;
      return result;
    case 0xDui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 3) = v5;
LABEL_10:
      *(__int32 *)((char *)&v6[-1].m128i_i32[2] + 3) = v5;
      v6[-1].m128i_i8[15] = v5;
      return result;
    case 0xEui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 2) = v5;
LABEL_7:
      *(__int32 *)((char *)&v6[-1].m128i_i32[2] + 2) = v5;
LABEL_8:
      v6[-1].m128i_i16[7] = v5;
      return result;
    case 0xFui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 1) = v5;
LABEL_3:
      *(__int32 *)((char *)&v6[-1].m128i_i32[2] + 1) = v5;
LABEL_4:
      *(__int16 *)((char *)&v6[-1].m128i_i16[6] + 1) = v5;
LABEL_5:
      v6[-1].m128i_i8[15] = v5;
      return result;
    default:
      v7 = _mm_unpacklo_epi64((__m128i)(unsigned __int64)v5, (__m128i)(unsigned __int64)v5);
      if ( a3 <= 0x20 )
      {
        _mm_storeu_si128(v6, v7);
        _mm_storeu_si128((__m128i *)((char *)v6 + a3 - 16), v7);
        return result;
      }
      if ( (unsigned int)dword_14003E028 < 3 )
      {
        if ( a3 > qword_14003E030 )
          JUMPOUT(dword_14004051C & 2, 0, sub_14000D0E0);
        v13 = ((unsigned __int8)v6 & 0xF) - 16i64;
        v14 = (__m128i *)((char *)v6 - v13);
        v15 = a1 - v13;
        v16 = v13 + a3;
        if ( v16 > 0x80 )
        {
          do
          {
            _mm_store_si128(v14, v7);
            _mm_store_si128(v14 + 1, v7);
            _mm_store_si128(v14 + 2, v7);
            _mm_store_si128(v14 + 3, v7);
            _mm_store_si128(v14 + 4, v7);
            _mm_store_si128(v14 + 5, v7);
            _mm_store_si128(v14 + 6, v7);
            _mm_store_si128(v14 + 7, v7);
            v14 += 8;
            v16 -= 128i64;
          }
          while ( v16 >= 0x80 );
        }
        result = ((__int64 (__fastcall *)(__m128i *, signed __int64))((unsigned int)dword_140045138[((v16 + 15) & 0xFFFFFFFFFFFFFFF0ui64) >> 4]
                                                                    + 0x140000000i64))(
                   v14,
                   v15);
      }
      else
      {
        if ( a3 > qword_14003E030 && a3 <= qword_14003E038 )
          JUMPOUT(dword_14004051C & 2, 0, sub_14000D0E0);
        __asm { vinsertf128 ymm0, ymm0, xmm0, 1 }
        v9 = ((unsigned __int8)v6 & 0x1F) - 32i64;
        _RCX = (char *)v6->m128i_i64 - v9;
        v11 = a1 - v9;
        v12 = v9 + a3;
        if ( v12 <= 0x100 )
          return ((__int64 (__fastcall *)(char *, signed __int64))((unsigned int)dword_1400450F0[((v12 + 31) & 0xFFFFFFFFFFFFFFE0ui64) >> 5]
                                                                 + 0x140000000i64))(
                   _RCX,
                   v11);
        if ( v12 <= qword_14003E038 )
        {
          do
          {
            __asm
            {
              vmovdqa ymmword ptr [rcx], ymm0
              vmovdqa ymmword ptr [rcx+20h], ymm0
              vmovdqa ymmword ptr [rcx+40h], ymm0
              vmovdqa ymmword ptr [rcx+60h], ymm0
              vmovdqa ymmword ptr [rcx+80h], ymm0
              vmovdqa ymmword ptr [rcx+0A0h], ymm0
              vmovdqa ymmword ptr [rcx+0C0h], ymm0
              vmovdqa ymmword ptr [rcx+0E0h], ymm0
            }
            _RCX += 256;
            v12 -= 256i64;
          }
          while ( v12 >= 0x100 );
          return ((__int64 (__fastcall *)(char *, signed __int64))((unsigned int)dword_1400450F0[((v12 + 31) & 0xFFFFFFFFFFFFFFE0ui64) >> 5]
                                                                 + 0x140000000i64))(
                   _RCX,
                   v11);
        }
        do
        {
          __asm
          {
            vmovntdq ymmword ptr [rcx], ymm0
            vmovntdq ymmword ptr [rcx+20h], ymm0
            vmovntdq ymmword ptr [rcx+40h], ymm0
            vmovntdq ymmword ptr [rcx+60h], ymm0
            vmovntdq ymmword ptr [rcx+80h], ymm0
            vmovntdq ymmword ptr [rcx+0A0h], ymm0
            vmovntdq ymmword ptr [rcx+0C0h], ymm0
            vmovntdq ymmword ptr [rcx+0E0h], ymm0
          }
          _RCX += 256;
          v12 -= 256i64;
        }
        while ( v12 >= 0x100 );
        result = ((__int64 (__fastcall *)(char *, signed __int64))((unsigned int)dword_140045114[((v12 + 31) & 0xFFFFFFFFFFFFFFE0ui64) >> 5]
                                                                 + 0x140000000i64))(
                   _RCX,
                   v11);
      }
      return result;
  }
}
// 14003E028: using guessed type int dword_14003E028;
// 14003E030: using guessed type __int64 qword_14003E030;
// 14003E038: using guessed type __int64 qword_14003E038;
// 14004051C: using guessed type int dword_14004051C;

//----- (000000014000D488) ----------------------------------------------------
_BYTE *__fastcall sub_14000D488(__int64 a1, unsigned __int8 a2)
{
  __m128i *v2; // r8
  int v3; // er10
  _BYTE *v4; // r9
  __m128i v5; // xmm2
  __int64 v6; // rdx
  _BYTE *v7; // rdx

  v2 = (__m128i *)(a1 & 0xFFFFFFFFFFFFFFF0ui64);
  v3 = a2 | (a2 << 8);
  v4 = 0i64;
  v5 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_cvtsi32_si128(v3), 0), 0);
  for ( LODWORD(v6) = (-1 << (a1 & 0xF)) & _mm_movemask_epi8(
                                             _mm_or_si128(
                                               _mm_cmpeq_epi8(v5, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFF0ui64)),
                                               _mm_cmpeq_epi8((__m128i)0i64, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFF0ui64))));
        !(_DWORD)v6;
        LODWORD(v6) = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v5, *v2), _mm_cmpeq_epi8((__m128i)0i64, *v2))) )
  {
    ++v2;
  }
  _BitScanForward((unsigned int *)&v6, v6);
  v7 = (char *)v2->m128i_i64 + v6;
  if ( *v7 == (_BYTE)v3 )
    v4 = v7;
  return v4;
}

//----- (000000014000D508) ----------------------------------------------------
__m128i *__fastcall sub_14000D508(__m128i *a1, int a2)
{
  __m128i *v2; // r9
  __m128i *v3; // r8
  __m128i *v4; // rdx
  __int64 v5; // rax
  __m128i *result; // rax
  __m128i *v7; // r11
  __m128i v8; // xmm2
  int v9; // edx
  int i; // ebx
  __int64 v11; // rcx
  __m128i *v12; // rcx
  int v13; // edx
  __int64 v14; // rcx
  __m128i *v15; // rcx
  __m128i v16; // xmm0
  unsigned __int8 v17; // zf
  int v18; // ecx

  v2 = 0i64;
  v3 = a1;
  if ( a2 )
  {
    if ( dword_14003E028 >= 2 )
    {
      while ( (unsigned __int8)v3 & 0xF )
      {
        if ( SLOBYTE(v3->m128i_i64[0]) == a2 )
          v2 = v3;
        if ( !LOBYTE(v3->m128i_i64[0]) )
          goto LABEL_12;
        v3 = (__m128i *)((char *)v3 + 1);
      }
      v16 = _mm_cvtsi32_si128((unsigned __int8)a2);
      while ( 1 )
      {
        v18 = _mm_cmpistri(v16, *v3, 64);
        v17 = _mm_cmpistrz(v16, *v3, 64);
        if ( _mm_cmpistrc(v16, *v3, 64) )
        {
          v2 = (__m128i *)((char *)v3 + v18);
          v17 = _mm_cmpistrz(v16, *v3, 64);
        }
        if ( v17 )
          break;
        ++v3;
      }
    }
    else
    {
      v7 = (__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0ui64);
      v8 = _mm_shuffle_epi32(
             _mm_shufflelo_epi16(_mm_cvtsi32_si128((unsigned __int8)a2 | ((unsigned int)(unsigned __int8)a2 << 8)), 0),
             0);
      v9 = (-1 << ((unsigned __int8)a1 & 0xF)) & _mm_movemask_epi8(
                                                   _mm_cmpeq_epi8(
                                                     v8,
                                                     *(__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0ui64)));
      for ( i = (-1 << ((unsigned __int8)a1 & 0xF)) & _mm_movemask_epi8(
                                                        _mm_cmpeq_epi8(
                                                          (__m128i)0i64,
                                                          *(__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0ui64)));
            !i;
            v9 = _mm_movemask_epi8(_mm_cmpeq_epi8(v8, *v7)) )
      {
        _BitScanReverse((unsigned int *)&v11, v9);
        v12 = (__m128i *)((char *)v7 + v11);
        if ( v9 )
          v2 = v12;
        ++v7;
        i = _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0i64, *v7));
      }
      v13 = ((i & -i) - 1) & v9;
      _BitScanReverse((unsigned int *)&v14, v13);
      v15 = (__m128i *)((char *)v7 + v14);
      if ( v13 )
        v2 = v15;
    }
LABEL_12:
    result = v2;
  }
  else
  {
    v4 = (__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0ui64);
    for ( LODWORD(v5) = (-1 << ((unsigned __int8)a1 & 0xF)) & _mm_movemask_epi8(
                                                                _mm_cmpeq_epi8(
                                                                  (__m128i)0i64,
                                                                  *(__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0ui64)));
          !(_DWORD)v5;
          LODWORD(v5) = _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0i64, *v4)) )
    {
      ++v4;
    }
    _BitScanForward((unsigned int *)&v5, v5);
    result = (__m128i *)((char *)v4 + v5);
  }
  return result;
}
// 14003E028: using guessed type int dword_14003E028;

//----- (000000014000D644) ----------------------------------------------------
const __m128i *__fastcall sub_14000D644(const __m128i *a1, unsigned __int16 a2)
{
  const __m128i *v2; // r8
  _WORD *v3; // r9
  __m128i v4; // xmm2
  __m128i v5; // xmm0
  unsigned int v6; // eax
  signed __int64 v7; // rax
  __int64 v8; // rcx
  _WORD *v9; // r8

  v2 = a1;
  v3 = 0i64;
  v4 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_cvtsi32_si128(a2), 0), 0);
  while ( ((unsigned __int16)v2 & 0xFFFu) > 0xFF0ui64 )
  {
    if ( LOWORD(v2->m128i_i64[0]) == a2 )
      return v2;
    if ( !LOWORD(v2->m128i_i64[0]) )
      return 0i64;
    v7 = 2i64;
LABEL_8:
    v2 = (const __m128i *)((char *)v2 + v7);
  }
  v5 = _mm_loadu_si128(v2);
  v6 = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi16((__m128i)0i64, v5), _mm_cmpeq_epi16(v5, v4)));
  if ( !v6 )
  {
    v7 = 16i64;
    goto LABEL_8;
  }
  _BitScanForward((unsigned int *)&v8, v6);
  v9 = (_WORD *)((char *)v2->m128i_i64 + v8);
  if ( *v9 == a2 )
    v3 = v9;
  return (const __m128i *)v3;
}

//----- (000000014000D6D0) ----------------------------------------------------
__int64 __fastcall sub_14000D6D0(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rdx
  bool v4; // cf
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // r9

  v3 = a2 - (_QWORD)a1;
  if ( a3 < 8 )
    goto LABEL_6;
  for ( ; (unsigned __int8)a1 & 7; --a3 )
  {
    v4 = *(_BYTE *)a1 < *((_BYTE *)a1 + v3);
    if ( *(_BYTE *)a1 != *((_BYTE *)a1 + v3) )
      return -v4 - ((unsigned int)v4 - 1);
    a1 = (unsigned __int64 *)((char *)a1 + 1);
  }
  if ( !(a3 >> 3) )
  {
LABEL_6:
    if ( !a3 )
      return 0i64;
    while ( 1 )
    {
      v4 = *(_BYTE *)a1 < *((_BYTE *)a1 + v3);
      if ( *(_BYTE *)a1 != *((_BYTE *)a1 + v3) )
        break;
      a1 = (unsigned __int64 *)((char *)a1 + 1);
      if ( !--a3 )
        return 0i64;
    }
    return -v4 - ((unsigned int)v4 - 1);
  }
  v6 = a3 >> 5;
  if ( a3 >> 5 )
  {
    while ( 1 )
    {
      v7 = *a1;
      if ( *a1 != *(unsigned __int64 *)((char *)a1 + v3) )
        break;
      v7 = a1[1];
      if ( v7 != *(unsigned __int64 *)((char *)a1 + v3 + 8) )
        goto LABEL_24;
      v7 = a1[2];
      if ( v7 != *(unsigned __int64 *)((char *)a1 + v3 + 16) )
        goto LABEL_23;
      v7 = a1[3];
      if ( v7 != *(unsigned __int64 *)((char *)a1 + v3 + 24) )
      {
        ++a1;
LABEL_23:
        ++a1;
LABEL_24:
        ++a1;
        break;
      }
      a1 += 4;
      if ( !--v6 )
      {
        a3 &= 0x1Fu;
        goto LABEL_18;
      }
    }
  }
  else
  {
LABEL_18:
    v8 = a3 >> 3;
    if ( !(a3 >> 3) )
      goto LABEL_6;
    while ( 1 )
    {
      v7 = *a1;
      if ( *a1 != *(unsigned __int64 *)((char *)a1 + v3) )
        break;
      ++a1;
      if ( !--v8 )
      {
        a3 &= 7u;
        goto LABEL_6;
      }
    }
  }
  v4 = _byteswap_uint64(v7) < _byteswap_uint64(*(unsigned __int64 *)((char *)a1 + v3));
  return -v4 - ((unsigned int)v4 - 1);
}

//----- (000000014000D798) ----------------------------------------------------
__int64 __fastcall sub_14000D798(PEXCEPTION_RECORD ExceptionRecord, PVOID TargetFrame, __int64 a3, __int64 a4)
{
  PEXCEPTION_RECORD v4; // rbp
  __int64 v5; // r15
  __int64 v6; // rsi
  PVOID v7; // r13
  __int64 v8; // r12
  unsigned int *v9; // rbx
  unsigned __int64 v10; // r14
  unsigned int v11; // edi
  int v12; // eax
  __int64 v13; // rcx
  unsigned __int64 v15; // rsi
  unsigned int v16; // er9
  __int64 v17; // rax
  unsigned int v18; // edx
  PEXCEPTION_RECORD v19; // [rsp+30h] [rbp-38h]
  __int64 v20; // [rsp+38h] [rbp-30h]

  v4 = ExceptionRecord;
  v5 = a4;
  v6 = a3;
  v7 = TargetFrame;
  sub_14000DBB4(a3);
  v8 = *(_QWORD *)(v5 + 8);
  v9 = *(unsigned int **)(v5 + 56);
  v10 = *(_QWORD *)v5 - v8;
  v11 = *(_DWORD *)(v5 + 72);
  if ( v4->ExceptionFlags & 0x66 )
  {
    v15 = *(_QWORD *)(v5 + 32) - v8;
    while ( 1 )
    {
      v18 = *v9;
      if ( v11 >= *v9 )
        break;
      if ( v10 >= v9[4 * v11 + 1] && v10 < v9[4 * v11 + 2] )
      {
        if ( v4->ExceptionFlags & 0x20 )
        {
          v16 = 0;
          if ( v18 )
          {
            do
            {
              if ( v15 >= v9[4 * v16 + 1]
                && v15 < v9[4 * v16 + 2]
                && v9[4 * v16 + 4] == v9[4 * v11 + 4]
                && v9[4 * v16 + 3] == v9[4 * v11 + 3] )
              {
                break;
              }
              ++v16;
            }
            while ( v16 < v18 );
          }
          if ( v16 != v18 )
            return 1i64;
        }
        v17 = v9[4 * v11 + 4];
        if ( (_DWORD)v17 )
        {
          if ( v15 == v17 && v4->ExceptionFlags & 0x20 )
            return 1i64;
        }
        else
        {
          *(_DWORD *)(v5 + 72) = v11 + 1;
          ((void (__fastcall *)(signed __int64, PVOID))(v8 + v9[4 * v11 + 3]))(2i64 * v11, v7);
        }
      }
      ++v11;
    }
  }
  else
  {
    v19 = v4;
    v20 = v6;
    while ( v11 < *v9 )
    {
      if ( v10 >= v9[4 * v11 + 1] && v10 < v9[4 * v11 + 2] && v9[4 * v11 + 4] )
      {
        if ( v9[4 * v11 + 3] == 1 )
          goto LABEL_38;
        v12 = ((__int64 (__fastcall *)(PEXCEPTION_RECORD *, PVOID))(v8 + v9[4 * v11 + 3]))(&v19, v7);
        if ( v12 < 0 )
          return 0i64;
        if ( v12 > 0 )
        {
LABEL_38:
          if ( v4->ExceptionCode == -529697949 && sub_14000DA00 )
          {
            if ( (unsigned int)sub_14002A360((__int64)&off_1400313D0) )
              sub_14000DA00((__int64)v4);
          }
          v13 = v9[4 * v11 + 4];
          sub_14000DB80();
          RtlUnwindEx(
            v7,
            (PVOID)(v8 + v9[4 * v11 + 4]),
            v4,
            (PVOID)v4->ExceptionCode,
            *(PCONTEXT *)(v5 + 40),
            *(PUNWIND_HISTORY_TABLE *)(v5 + 64));
          nullsub_2();
        }
      }
      ++v11;
    }
  }
  return 1i64;
}
// 14000DBB0: using guessed type __int64 nullsub_2(void);
// 1400313D0: using guessed type __int64 (__fastcall *off_1400313D0)();

//----- (000000014000D990) ----------------------------------------------------
char sub_14000D990()
{
  if ( !sub_14000DD58() )
    return 0;
  if ( !sub_14000DCEC() )
  {
    sub_14000DDA0();
    return 0;
  }
  return 1;
}

//----- (000000014000D9B8) ----------------------------------------------------
char __fastcall sub_14000D9B8(char a1)
{
  if ( !a1 )
  {
    sub_14000DD34();
    sub_14000DDA0();
  }
  return 1;
}

//----- (000000014000D9D4) ----------------------------------------------------
__int64 __fastcall sub_14000D9D4(__int64 a1, __int64 a2)
{
  char *v2; // rax
  __int64 v3; // rdx
  char v4; // cl

  if ( a1 == a2 )
    return 0i64;
  v2 = (char *)(a1 + 9);
  v3 = a2 - a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
      break;
    ++v2;
    if ( !v4 )
      return 0i64;
  }
  return -((unsigned __int8)*v2 < (unsigned __int8)v2[v3]) | 1u;
}

//----- (000000014000DA00) ----------------------------------------------------
void __fastcall sub_14000DA00(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // rax

  if ( a1 )
  {
    if ( *(_DWORD *)a1 == -529697949
      && *(_DWORD *)(a1 + 24) == 4
      && (unsigned int)(*(_DWORD *)(a1 + 32) - 429065504) <= 2 )
    {
      v1 = *(_QWORD *)(a1 + 48);
      if ( v1 )
      {
        v2 = *(signed int *)(v1 + 4);
        if ( (_DWORD)v2 )
        {
          sub_14000DA70(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 56) + v2);
        }
        else if ( *(_BYTE *)v1 & 0x10 )
        {
          v3 = **(_QWORD **)(a1 + 40);
          if ( v3 )
          {
            v4 = *(_QWORD *)(*(_QWORD *)v3 + 16i64);
            sub_14002A5B0();
          }
        }
      }
    }
  }
}
// 14000DA70: using guessed type __int64 __fastcall sub_14000DA70(_QWORD, _QWORD);

//----- (000000014000DA74) ----------------------------------------------------
signed __int64 __usercall sub_14000DA74@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rbx
  _QWORD *i; // rdx

  v2 = a1;
  for ( i = (_QWORD *)*((_QWORD *)sub_14000DC10(a2) + 11); ; i = (_QWORD *)i[1] )
  {
    if ( !i )
      return 1i64;
    if ( *i == v2 )
      break;
  }
  return 0i64;
}

//----- (000000014000DAA4) ----------------------------------------------------
__int64 __fastcall sub_14000DAA4(__int64 a1, signed int *a2)
{
  __int64 result; // rax

  result = a1 + *a2;
  if ( a2[1] >= 0 )
    result += a2[1] + (signed __int64)*(signed int *)(a2[2] + *(_QWORD *)(a2[1] + a1));
  return result;
}

//----- (000000014000DAC8) ----------------------------------------------------
__int64 __usercall sub_14000DAC8@<rax>(_DWORD **a1@<rcx>, __m256i *a2@<ymm0>)
{
  _DWORD *v2; // rdi
  _DWORD **v3; // rbx
  _DWORD *v4; // rax
  _DWORD *v6; // rbx

  v2 = *a1;
  v3 = a1;
  if ( **a1 == -532462766 || *v2 == -532459699 )
  {
    if ( *((_DWORD *)sub_14000DC10(a2) + 12) > 0 )
    {
      v4 = sub_14000DC10(a2);
      --v4[12];
    }
  }
  else if ( *v2 == -529697949 )
  {
    *((_QWORD *)sub_14000DC10(a2) + 4) = v2;
    v6 = v3[1];
    *((_QWORD *)sub_14000DC10(a2) + 5) = v6;
    sub_14001A878(a2);
  }
  return 0i64;
}

//----- (000000014000DB30) ----------------------------------------------------
char *__usercall sub_14000DB30@<rax>(__m256i *a1@<ymm0>)
{
  return (char *)sub_14000DC10(a1) + 32;
}

//----- (000000014000DB44) ----------------------------------------------------
char *__usercall sub_14000DB44@<rax>(__m256i *a1@<ymm0>)
{
  return (char *)sub_14000DC10(a1) + 40;
}

//----- (000000014000DB80) ----------------------------------------------------
void sub_14000DB80()
{
  ;
}

//----- (000000014000DBB4) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_14000DBB4(__int64 a1))()
{
  __int64 (__fastcall *result)(); // rax
  unsigned __int64 v2; // rcx

  result = _guard_check_icall_fptr[0];
  if ( (__int64 (__fastcall *)(_QWORD))_guard_check_icall_fptr[0] != nullsub_1 )
  {
    result = (__int64 (__fastcall *)())__readgsqword(0x30u);
    v2 = *(_QWORD *)(a1 + 152);
    if ( v2 < *((_QWORD *)result + 2) || v2 > *((_QWORD *)result + 1) )
      __fastfail(0xDu);
  }
  return result;
}
// 1400035B0: using guessed type __int64 __fastcall nullsub_1(_QWORD);
// 14002B420: using guessed type __int64 (__fastcall *_guard_check_icall_fptr[5])();

//----- (000000014000DBF0) ----------------------------------------------------
void __fastcall sub_14000DBF0(void *a1)
{
  if ( a1 )
  {
    if ( a1 != &unk_140040530 )
      sub_140014F8C(a1);
  }
}

//----- (000000014000DC10) ----------------------------------------------------
LPVOID __usercall sub_14000DC10@<rax>(__m256i *a1@<ymm0>)
{
  LPVOID result; // rax

  result = sub_14000DC2C();
  if ( !result )
    sub_14001A9AC(a1);
  return result;
}

//----- (000000014000DC2C) ----------------------------------------------------
LPVOID sub_14000DC2C()
{
  DWORD v1; // edi
  LPVOID v2; // rax
  LPVOID v3; // rsi
  _DWORD *v4; // rax
  DWORD v5; // ecx
  _DWORD *v6; // rbx
  _DWORD *v7; // rax

  if ( dwTlsIndex == -1 )
    return 0i64;
  v1 = GetLastError();
  v2 = sub_14000DFB8(dwTlsIndex);
  v3 = 0i64;
  if ( v2 != (LPVOID)-1i64 )
  {
    if ( v2 )
    {
      v3 = v2;
      goto LABEL_13;
    }
    if ( !sub_14000E000(dwTlsIndex, (LPVOID)0xFFFFFFFFFFFFFFFFi64) )
      goto LABEL_13;
    v4 = (_DWORD *)sub_140014F84(1i64, 128i64);
    v5 = dwTlsIndex;
    v6 = v4;
    if ( v4 )
    {
      if ( sub_14000E000(dwTlsIndex, v4) )
      {
        v7 = v6;
        v6[30] = -2;
        v6 = 0i64;
        v3 = v7;
LABEL_12:
        sub_140014F8C(v6);
        goto LABEL_13;
      }
      v5 = dwTlsIndex;
    }
    sub_14000E000(v5, 0i64);
    goto LABEL_12;
  }
LABEL_13:
  SetLastError(v1);
  return v3;
}
// 140014F84: using guessed type __int64 __fastcall sub_140014F84(_QWORD, _QWORD);

//----- (000000014000DCEC) ----------------------------------------------------
char sub_14000DCEC()
{
  int v0; // eax

  v0 = sub_14000DF28();
  dwTlsIndex = v0;
  if ( v0 != -1 )
  {
    if ( sub_14000E000(v0, &unk_140040530) )
    {
      dword_1400405A8 = -2;
      return 1;
    }
    sub_14000DD34();
  }
  return 0;
}
// 1400405A8: using guessed type int dword_1400405A8;

//----- (000000014000DD34) ----------------------------------------------------
char sub_14000DD34()
{
  if ( dwTlsIndex != -1 )
  {
    sub_14000DF70(dwTlsIndex);
    dwTlsIndex = -1;
  }
  return 1;
}

//----- (000000014000DD58) ----------------------------------------------------
char sub_14000DD58()
{
  __int64 v0; // rbx

  v0 = 0i64;
  while ( sub_14000E054((LPCRITICAL_SECTION)&unk_1400405B0 + v0, 0xFA0u) )
  {
    ++dword_1400405D8;
    v0 = (unsigned int)(v0 + 1);
    if ( (unsigned int)v0 >= 1 )
      return 1;
  }
  sub_14000DDA0();
  return 0;
}
// 1400405D8: using guessed type int dword_1400405D8;

//----- (000000014000DDA0) ----------------------------------------------------
char sub_14000DDA0()
{
  int v0; // ebx

  v0 = dword_1400405D8;
  while ( v0 )
  {
    DeleteCriticalSection((LPCRITICAL_SECTION)&unk_1400405B0 + (unsigned int)--v0);
    --dword_1400405D8;
  }
  return 1;
}
// 1400405D8: using guessed type int dword_1400405D8;

//----- (000000014000DDD8) ----------------------------------------------------
FARPROC __fastcall sub_14000DDD8(unsigned int a1, const CHAR *a2, unsigned int *a3, unsigned int *a4)
{
  unsigned int *v7; // r12
  unsigned int *v8; // rbp
  const CHAR *v9; // r13
  FARPROC result; // rax
  bool i; // zf
  HMODULE v13; // rbx
  wchar_t *v14; // r15

  _RDI = a1;
  _R15 = 5368709120i64;
  _R14 = -1i64;
  v7 = a4;
  v8 = a3;
  v9 = a2;
  result = (FARPROC)qword_140040660[a1];
  if ( result != (FARPROC)-1i64 )
  {
    if ( result )
      return result;
    for ( i = a3 == a4; !i; i = v8 == v7 )
    {
      _RSI = *v8;
      v13 = (HMODULE)qword_140040648[_RSI];
      if ( v13 )
      {
        if ( v13 != (HMODULE)-1i64 )
          goto LABEL_16;
      }
      else
      {
        v14 = off_1400321B8[_RSI];
        v13 = LoadLibraryExW(off_1400321B8[_RSI], 0i64, 0x800u);
        if ( v13
          || GetLastError() == 87
          && (unsigned int)sub_14001AA04(v14, L"api-ms-", 7i64)
          && (v13 = LoadLibraryExW(v14, 0i64, 0)) != 0i64 )
        {
          _RAX = v13;
          _R15 = 5368709120i64;
          __asm { xchg    rax, rva qword_140040648[r15+rsi*8] }
          if ( _RAX )
            FreeLibrary(v13);
LABEL_16:
          result = GetProcAddress(v13, v9);
          if ( result )
          {
            _RCX = result;
            __asm { xchg    rcx, rva qword_140040660[r15+rdi*8] }
            return result;
          }
          break;
        }
        _RAX = -1i64;
        _R15 = 5368709120i64;
        __asm { xchg    rax, rva qword_140040648[r15+rsi*8] }
      }
      ++v8;
    }
    __asm { xchg    r14, rva qword_140040660[r15+rdi*8] }
  }
  return 0i64;
}
// 1400321B8: using guessed type wchar_t *off_1400321B8[3];
// 140032268: using guessed type wchar_t aApiMs[8];
// 140040648: using guessed type __int64 qword_140040648[];

//----- (000000014000DF28) ----------------------------------------------------
int sub_14000DF28()
{
  int result; // eax

  if ( sub_14000DDD8(0, "FlsAlloc", (unsigned int *)&unk_140032278, (unsigned int *)"FlsAlloc") )
    result = sub_14002A5B0();
  else
    result = TlsAlloc();
  return result;
}

//----- (000000014000DF70) ----------------------------------------------------
int __fastcall sub_14000DF70(DWORD a1)
{
  DWORD v1; // ebx
  int result; // eax

  v1 = a1;
  if ( sub_14000DDD8(1u, "FlsFree", (unsigned int *)&unk_140032290, (unsigned int *)"FlsFree") )
    result = sub_14002A5B0();
  else
    result = TlsFree(v1);
  return result;
}

//----- (000000014000DFB8) ----------------------------------------------------
LPVOID __fastcall sub_14000DFB8(DWORD a1)
{
  DWORD v1; // ebx
  LPVOID result; // rax

  v1 = a1;
  if ( sub_14000DDD8(2u, "FlsGetValue", (unsigned int *)&unk_1400322A0, (unsigned int *)"FlsGetValue") )
    result = (LPVOID)sub_14002A5B0();
  else
    result = TlsGetValue(v1);
  return result;
}

//----- (000000014000E000) ----------------------------------------------------
int __fastcall sub_14000E000(DWORD dwTlsIndex, LPVOID lpTlsValue)
{
  void *v2; // rbx
  DWORD v3; // edi
  int result; // eax

  v2 = lpTlsValue;
  v3 = dwTlsIndex;
  if ( sub_14000DDD8(3u, "FlsSetValue", (unsigned int *)&unk_1400322B8, (unsigned int *)"FlsSetValue") )
    result = sub_14002A5B0();
  else
    result = TlsSetValue(v3, v2);
  return result;
}

//----- (000000014000E054) ----------------------------------------------------
int __fastcall sub_14000E054(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
{
  DWORD v2; // ebx
  struct _RTL_CRITICAL_SECTION *v3; // rdi
  int result; // eax

  v2 = dwSpinCount;
  v3 = lpCriticalSection;
  if ( sub_14000DDD8(
         4u,
         "InitializeCriticalSectionEx",
         (unsigned int *)&unk_1400322D0,
         (unsigned int *)"InitializeCriticalSectionEx") )
  {
    result = sub_14002A5B0();
  }
  else
  {
    result = InitializeCriticalSectionAndSpinCount(v3, v2);
  }
  return result;
}

//----- (000000014000E0B8) ----------------------------------------------------
__int64 __usercall sub_14000E0B8@<rax>(unsigned int *a1@<rcx>, __m256i *a2@<ymm0>)
{
  unsigned int *v2; // rbx
  _QWORD *v3; // rax
  __int64 v4; // rcx
  __int64 v5; // rax

  v2 = a1;
  v3 = sub_14000DC10(a2);
  v4 = *v2;
  v5 = v3[2];
  sub_14002A5B0();
  return 0i64;
}

//----- (000000014000E10C) ----------------------------------------------------
signed __int64 __usercall sub_14000E10C@<rax>(int a1@<edx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  int v3; // edi
  int v4; // esi
  bool v5; // zf
  __int64 v6; // rbp
  signed __int64 result; // rax

  v3 = *(_DWORD *)(a2 + 12);
  v4 = a1;
  v5 = v3 == 0;
  v6 = a2;
  while ( !v5 )
  {
    result = *((_QWORD *)sub_14000DC10(a3) + 12) + 20i64 * (unsigned int)--v3 + *(signed int *)(v6 + 16);
    if ( v4 > *(_DWORD *)(result + 4) && v4 <= *(_DWORD *)(result + 8) )
      return result;
    v5 = v3 == 0;
  }
  return 0i64;
}

//----- (000000014000E170) ----------------------------------------------------
bool __usercall sub_14000E170@<al>(__int64 a1@<rdx>, unsigned __int64 *a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rbx
  int v4; // eax

  v3 = a1;
  v4 = sub_14000E71C(a2, a1, a3);
  return sub_14000E10C(v4, v3, a3) != 0;
}

//----- (000000014000E19C) ----------------------------------------------------
__int64 __usercall sub_14000E19C@<rax>(unsigned __int64 *a1@<rdx>, _QWORD *a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  __int64 v4; // rbx
  unsigned __int64 *v5; // rdi
  __int64 *v6; // rsi
  int v7; // eax
  signed __int64 v8; // rax
  int v9; // er9
  char v11; // [rsp+48h] [rbp+20h]

  v4 = a3;
  v5 = a1;
  v6 = sub_14000E200(a1, a2, a3, &v11, a4);
  v7 = sub_14000E71C(v5, v4, a4);
  v8 = sub_14000E10C(v7, v4, a4);
  if ( v8 )
    v9 = *(_DWORD *)(v8 + 4);
  else
    v9 = -1;
  return sub_14000F904(v5, v6, v4, v9, a4);
}

//----- (000000014000E200) ----------------------------------------------------
_QWORD *__usercall sub_14000E200@<rax>(unsigned __int64 *a1@<rdx>, _QWORD *a2@<rcx>, __int64 a3@<r8>, _QWORD *a4@<r9>, __m256i *a5@<ymm0>)
{
  int v5; // esi
  _QWORD *v6; // r12
  _QWORD *v7; // rdi
  __int64 v8; // r14
  DWORD64 *v9; // r15
  int v10; // ebp
  _DWORD *v11; // rbx
  PRUNTIME_FUNCTION v12; // rax
  __int64 v13; // rcx
  unsigned __int64 v14; // r8
  unsigned int v15; // er9
  _DWORD *v16; // rdx
  unsigned __int64 ImageBase; // [rsp+50h] [rbp+8h]

  v5 = *(_DWORD *)(a3 + 12);
  v6 = a2;
  v7 = a4;
  v8 = a3;
  v9 = a1;
  v10 = sub_14000E71C(a1, a3, a5);
  *v7 = *v6;
  while ( v5 )
  {
    v11 = (_DWORD *)(v9[1] + *(signed int *)(v8 + 16) + 20i64 * (unsigned int)--v5);
    if ( v10 > v11[1] && v10 <= v11[2] )
    {
      v12 = RtlLookupFunctionEntry(*v9, &ImageBase, 0i64);
      v13 = 0i64;
      v14 = ImageBase + (signed int)v11[4];
      v15 = v11[3];
      if ( v15 )
      {
        v16 = (_DWORD *)(v14 + 12);
        do
        {
          if ( *v16 == (unsigned __int64)v12->BeginAddress )
            break;
          v13 = (unsigned int)(v13 + 1);
          v16 += 5;
        }
        while ( (unsigned int)v13 < v15 );
      }
      if ( (unsigned int)v13 < v15 )
      {
        *v7 = *(_QWORD *)(*(signed int *)(v14 + 20 * v13 + 16) + *v6);
        return v7;
      }
    }
  }
  return v7;
}

//----- (000000014000E2CC) ----------------------------------------------------
__m128i *__usercall sub_14000E2CC@<rax>(__int64 a1@<rdx>, __m128i *a2@<rcx>, int a3@<r8d>, unsigned __int64 *a4@<r9>, __m256i *a5@<ymm0>, __int64 a6)
{
  __int64 v6; // r12
  __m128i *v7; // rbp
  unsigned __int64 *v8; // rdi
  int v9; // er15
  unsigned int v10; // er14
  int v11; // eax
  int v12; // er10
  int v13; // esi
  unsigned __int64 v14; // r11
  __int64 v15; // rbx
  signed int v16; // er9
  signed int v17; // er13
  unsigned int v18; // edx
  __int64 v19; // r8
  signed __int64 v20; // rax
  unsigned int v21; // er8
  signed __int64 v22; // rdx
  _DWORD *v23; // rcx
  signed int v24; // eax
  signed int v25; // eax
  __m128i *result; // rax
  __m128i v27; // [rsp+20h] [rbp-48h]
  __m128i v28; // [rsp+30h] [rbp-38h]

  v6 = a1;
  v7 = a2;
  v8 = a4;
  v9 = a3;
  v10 = *(_DWORD *)(a6 + 12);
  v11 = sub_14000E71C(a4, a6, a5);
  v12 = 0;
  v13 = v11;
  if ( !v10 )
    sub_14001A9AC(a5);
  v14 = v8[1];
  v15 = *(signed int *)(a6 + 16);
  v16 = -1;
  v17 = -1;
  v18 = v10;
  do
  {
    v19 = v18 - 1;
    v20 = v14 + 20 * v19;
    if ( v13 > *(_DWORD *)(v20 + v15 + 4) && v13 <= *(_DWORD *)(v20 + v15 + 8) )
      break;
    --v18;
  }
  while ( (_DWORD)v19 );
  v21 = 0;
  if ( v18 )
    v22 = v14 + v15 + 20i64 * (v18 - 1);
  else
    v22 = 0i64;
  v23 = (_DWORD *)(v14 + v15);
  do
  {
    if ( (!v22 || *v23 > *(_DWORD *)(v22 + 4) && v23[1] <= *(_DWORD *)(v22 + 8)) && v9 >= *v23 && v9 <= v23[1] )
    {
      v24 = v21;
      v17 = v21;
      if ( v16 != -1 )
        v24 = v16;
      v16 = v24;
    }
    ++v21;
    v23 += 5;
  }
  while ( v21 < v10 );
  v27.m128i_i64[0] = v6;
  v25 = 0;
  v28.m128i_i64[0] = v6;
  if ( v16 != -1 )
    v25 = v16;
  v27.m128i_i32[2] = v25;
  if ( v16 != -1 )
    v12 = v17 + 1;
  result = v7;
  v28.m128i_i32[2] = v12;
  _mm_storeu_si128(v7, v27);
  _mm_storeu_si128(v7 + 1, v28);
  return result;
}

//----- (000000014000E40C) ----------------------------------------------------
void __fastcall sub_14000E40C(void **a1, ULONG_PTR a2, ULONG_PTR a3, ULONG_PTR a4, ULONG_PTR a5, ULONG_PTR a6, int a7, int a8, __int64 a9, __int64 a10, unsigned __int8 a11)
{
  __int128 v11; // xmm1
  __int128 v12; // xmm0
  __int128 v13; // xmm1
  __int128 v14; // xmm0
  __int128 v15; // xmm1
  __int128 v16; // xmm0
  __int128 v17; // xmm1
  ULONG_PTR v18; // rax
  void *v19; // rcx
  struct _UNWIND_HISTORY_TABLE *HistoryTable; // ST28_8
  _CONTEXT *ContextRecord; // rax
  void *v22; // rdx
  EXCEPTION_RECORD ExceptionRecord; // [rsp+30h] [rbp-91h]

  v11 = *(_OWORD *)&asc_140032300[16];
  *(_OWORD *)&ExceptionRecord.ExceptionCode = *(_OWORD *)")";
  v12 = *(_OWORD *)&asc_140032300[32];
  *(_OWORD *)&ExceptionRecord.ExceptionAddress = v11;
  v13 = *(_OWORD *)&asc_140032300[48];
  *(_OWORD *)ExceptionRecord.ExceptionInformation = v12;
  v14 = *(_OWORD *)&asc_140032300[64];
  *(_OWORD *)&ExceptionRecord.ExceptionInformation[2] = v13;
  v15 = *(_OWORD *)&asc_140032300[80];
  *(_OWORD *)&ExceptionRecord.ExceptionInformation[4] = v14;
  v16 = *(_OWORD *)&asc_140032300[96];
  *(_OWORD *)&ExceptionRecord.ExceptionInformation[6] = v15;
  v17 = *(_OWORD *)&asc_140032300[128];
  *(_OWORD *)&ExceptionRecord.ExceptionInformation[8] = v16;
  v18 = *(_QWORD *)&asc_140032300[144];
  *(_OWORD *)&ExceptionRecord.ExceptionInformation[10] = *(_OWORD *)&asc_140032300[112];
  *(_OWORD *)&ExceptionRecord.ExceptionInformation[12] = v17;
  ExceptionRecord.ExceptionInformation[14] = v18;
  v19 = *a1;
  ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR)sub_14000F690;
  ExceptionRecord.ExceptionInformation[2] = a5;
  ExceptionRecord.ExceptionInformation[3] = a7;
  ExceptionRecord.ExceptionInformation[5] = a6;
  ExceptionRecord.ExceptionInformation[7] = a11;
  HistoryTable = *(struct _UNWIND_HISTORY_TABLE **)(a10 + 64);
  ContextRecord = *(_CONTEXT **)(a10 + 40);
  ExceptionRecord.ExceptionInformation[1] = a4;
  ExceptionRecord.ExceptionInformation[4] = a3;
  ExceptionRecord.ExceptionInformation[6] = a2;
  v22 = *(void **)a10;
  ExceptionRecord.ExceptionInformation[8] = 429065504i64;
  RtlUnwindEx(v19, v22, &ExceptionRecord, 0i64, ContextRecord, HistoryTable);
}

//----- (000000014000E510) ----------------------------------------------------
_QWORD *__usercall sub_14000E510@<rax>(__int64 a1@<rdx>, _QWORD *a2@<rcx>, __m256i *a3@<ymm0>)
{
  _QWORD *v3; // rbx
  __int64 v4; // rcx

  v3 = a2;
  *a2 = a1;
  if ( (unsigned __int64)a2 >= *((_QWORD *)sub_14000DC10(a3) + 11) )
    v4 = 0i64;
  else
    v4 = *((_QWORD *)sub_14000DC10(a3) + 11);
  v3[1] = v4;
  *((_QWORD *)sub_14000DC10(a3) + 11) = v3;
  return v3;
}

//----- (000000014000E54C) ----------------------------------------------------
_QWORD *__usercall sub_14000E54C@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rdi
  __int64 v3; // rdx
  __int64 v4; // rbx
  _QWORD *result; // rax

  v2 = a1;
  if ( a1 != *((_QWORD *)sub_14000DC10(a2) + 11) || (v3 = *((_QWORD *)sub_14000DC10(a2) + 11)) == 0 )
LABEL_7:
    sub_14001A9AC(a2);
  while ( 1 )
  {
    v4 = *(_QWORD *)(v3 + 8);
    if ( v2 == v3 )
      break;
    v3 = *(_QWORD *)(v3 + 8);
    if ( !v4 )
      goto LABEL_7;
  }
  result = sub_14000DC10(a2);
  result[11] = v4;
  return result;
}

//----- (000000014000E5A0) ----------------------------------------------------
__int64 __usercall sub_14000E5A0@<rax>(__m256i *a1@<ymm0>)
{
  return *((_QWORD *)sub_14000DC10(a1) + 12);
}

//----- (000000014000E5B4) ----------------------------------------------------
__int64 __usercall sub_14000E5B4@<rax>(__m256i *a1@<ymm0>)
{
  return *((_QWORD *)sub_14000DC10(a1) + 13);
}

//----- (000000014000E5C8) ----------------------------------------------------
_QWORD *__usercall sub_14000E5C8@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rbx
  _QWORD *result; // rax

  v2 = a1;
  result = sub_14000DC10(a2);
  result[12] = v2;
  return result;
}

//----- (000000014000E5E0) ----------------------------------------------------
_QWORD *__usercall sub_14000E5E0@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rbx
  _QWORD *result; // rax

  v2 = a1;
  result = sub_14000DC10(a2);
  result[13] = v2;
  return result;
}

//----- (000000014000E5F8) ----------------------------------------------------
__int64 __usercall sub_14000E5F8@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  __int64 v5; // rbx
  __int64 v6; // rdi
  int v7; // esi
  __int64 v8; // rbp
  __int64 v9; // rbx
  _BYTE *v10; // rax
  __int64 v12; // [rsp+50h] [rbp+8h]

  v5 = *(_QWORD *)(a4 + 8);
  v6 = a4;
  v7 = a3;
  v12 = a1;
  v8 = a2;
  *((_QWORD *)sub_14000DC10(a5) + 12) = v5;
  v9 = *(_QWORD *)(v8 + 56);
  *((_QWORD *)sub_14000DC10(a5) + 13) = v9;
  v10 = sub_14000DC10(a5);
  return sub_14000F58C(v8, (unsigned __int64)&v12, v7, v6, v10[96] + (unsigned __int8)**(_DWORD **)(v6 + 56));
}
// 14000F58C: using guessed type __int64 __fastcall sub_14000F58C(__int64, _DWORD, _DWORD, __int64, char);

//----- (000000014000E680) ----------------------------------------------------
signed __int64 __usercall sub_14000E680@<rax>(unsigned __int64 *a1@<rdx>, _QWORD *a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  signed __int64 result; // rax

  result = *(unsigned int *)(*(signed int *)(a3 + 28) + *a2);
  if ( (_DWORD)result == -2 )
    result = sub_14000E724((__int64)a1, a3, *a1, a4);
  return result;
}

//----- (000000014000E6A8) ----------------------------------------------------
__int64 __usercall sub_14000E6A8@<rax>(unsigned __int64 *a1@<rdx>, _QWORD *a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  __int64 v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v8; // [rsp+40h] [rbp+18h]

  v4 = a3;
  v5 = *sub_14000E200(a1, a2, a3, &v8, a4);
  v6 = *(signed int *)(v4 + 28);
  v8 = v5;
  return *(unsigned int *)(v6 + v5 + 4);
}

//----- (000000014000E6D4) ----------------------------------------------------
__int64 __fastcall sub_14000E6D4(__int64 *a1, __int64 a2, int a3)
{
  __int64 result; // rax

  result = *a1;
  *(_DWORD *)(*(signed int *)(a2 + 28) + *a1) = a3;
  return result;
}

//----- (000000014000E6E0) ----------------------------------------------------
__int64 __usercall sub_14000E6E0@<rax>(unsigned __int64 *a1@<rdx>, _QWORD *a2@<rcx>, __int64 a3@<r8>, int a4@<r9d>, __m256i *a5@<ymm0>)
{
  int v5; // edi
  __int64 v6; // rbx
  __int64 v7; // rcx
  __int64 result; // rax
  __int64 v9; // [rsp+40h] [rbp+18h]

  v5 = a4;
  v6 = a3;
  v7 = *sub_14000E200(a1, a2, a3, &v9, a5);
  result = *(signed int *)(v6 + 28);
  v9 = v7;
  if ( v5 > *(_DWORD *)(result + v7 + 4) )
    *(_DWORD *)(result + v7 + 4) = v5;
  return result;
}

//----- (000000014000E71C) ----------------------------------------------------
signed __int64 __usercall sub_14000E71C@<rax>(unsigned __int64 *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  return sub_14000E724((__int64)a1, a2, *a1, a3);
}

//----- (000000014000E724) ----------------------------------------------------
signed __int64 __usercall sub_14000E724@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, unsigned __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // r11
  __int64 v6; // r10
  unsigned int v7; // er8
  __int64 v8; // r9
  signed __int64 result; // rax

  v4 = a3;
  if ( !a2 || (v5 = *(signed int *)(a2 + 24), v6 = *(_QWORD *)(a1 + 8), !(v6 + v5)) )
    sub_14001A9AC(a4);
  v7 = *(_DWORD *)(a2 + 20);
  v8 = 0i64;
  if ( !v7 )
    goto LABEL_13;
  do
  {
    if ( v4 < v6 + *(signed int *)(v5 + 8 * v8 + v6) )
      break;
    v8 = (unsigned int)(v8 + 1);
  }
  while ( (unsigned int)v8 < v7 );
  if ( (_DWORD)v8 )
    result = *(unsigned int *)(v6 + 8i64 * (unsigned int)(v8 - 1) + v5 + 4);
  else
LABEL_13:
    result = 0xFFFFFFFFi64;
  return result;
}

//----- (000000014000E78C) ----------------------------------------------------
__int64 __usercall sub_14000E78C@<rax>(__m128i *a1@<rdx>, __int64 a2@<rcx>, _DWORD *a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  __int64 v5; // r14
  _DWORD *v6; // rbx
  __m128i *v7; // rsi
  __int64 v8; // r13
  unsigned int v9; // edi
  __int64 v10; // r15
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rax
  __int64 v14; // rcx
  const __m128i *v15; // rdx
  __int64 v16; // rbx
  __int64 v17; // rcx
  unsigned __int64 v18; // rbx
  const __m128i *v19; // rax
  __int64 v20; // rcx

  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = a2;
  v9 = 0;
  if ( a3[1] )
  {
    v10 = (signed int)a3[1];
    v11 = v10 + sub_14000E5A0(a5);
  }
  else
  {
    v11 = 0i64;
    LODWORD(v10) = 0;
  }
  if ( v11 )
  {
    v12 = (_DWORD)v10 ? (signed int)v6[1] + sub_14000E5A0(a5) : 0i64;
    if ( *(_BYTE *)(v12 + 16) && (v6[2] || *v6 < 0) )
    {
      if ( *v6 >= 0 )
        v7 = (__m128i *)(v7->m128i_i64[0] + (signed int)v6[2]);
      if ( *(_BYTE *)v6 < 0 && *(_BYTE *)v5 & 0x10 && qword_140040520 )
      {
        v13 = sub_14002A5B0();
        if ( !v13 || !v7 )
          sub_14001A9AC(a5);
        v7->m128i_i64[0] = v13;
        v14 = v13;
      }
      else if ( *(_BYTE *)v6 & 8 )
      {
        v14 = *(_QWORD *)(v8 + 40);
        if ( !v14 || !v7 )
          sub_14001A9AC(a5);
        v7->m128i_i64[0] = v14;
      }
      else
      {
        if ( !(*(_BYTE *)v5 & 1) )
        {
          if ( *(_DWORD *)(v5 + 24) )
          {
            v16 = *(signed int *)(v5 + 24);
            v17 = v16 + sub_14000E5B4(a5);
          }
          else
          {
            v17 = 0i64;
            LODWORD(v16) = 0;
          }
          if ( v17 )
          {
            if ( !*(_QWORD *)(v8 + 40)
              || !v7
              || (!(_DWORD)v16 ? (v20 = 0i64) : (v20 = *(signed int *)(v5 + 24) + sub_14000E5B4(a5)), !v20) )
            {
              sub_14001A9AC(a5);
            }
            v9 = ((*(_BYTE *)v5 & 4) != 0) + 1;
          }
          else
          {
            if ( !*(_QWORD *)(v8 + 40) || !v7 )
              sub_14001A9AC(a5);
            v18 = *(signed int *)(v5 + 20);
            v19 = (const __m128i *)sub_14000DAA4(*(_QWORD *)(v8 + 40), (signed int *)(v5 + 8));
            sub_14000CA50(v7, v19, v18);
          }
          return v9;
        }
        v15 = *(const __m128i **)(v8 + 40);
        if ( !v15 || !v7 )
          sub_14001A9AC(a5);
        sub_14000CA50(v7, v15, *(signed int *)(v5 + 20));
        if ( *(_DWORD *)(v5 + 20) != 8 || !v7->m128i_i64[0] )
          return v9;
        v14 = v7->m128i_i64[0];
      }
      v7->m128i_i64[0] = sub_14000DAA4(v14, (signed int *)(v5 + 8));
      return v9;
    }
  }
  return 0i64;
}
// 140040520: using guessed type __int64 qword_140040520;

//----- (000000014000E98C) ----------------------------------------------------
__int64 __usercall sub_14000E98C@<rax>(__m128i *a1@<rdx>, __int64 a2@<rcx>, _DWORD *a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  __int64 v5; // rdi
  __int64 v6; // r14
  __int64 (__fastcall *v7)(__int64, __int64); // rbx
  __int64 v8; // rsi
  __int64 result; // rax
  __int64 v10; // r14
  __int64 v11; // r14

  v5 = a4;
  v6 = a2;
  v7 = 0i64;
  if ( *a3 >= 0 )
    v8 = a1->m128i_i64[0] + (signed int)a3[2];
  else
    v8 = (__int64)a1;
  result = (unsigned int)sub_14000E78C(a1, a2, a3, a4, a5) - 1;
  if ( (_DWORD)result )
  {
    if ( (_DWORD)result == 1 )
    {
      v10 = sub_14000DAA4(*(_QWORD *)(v6 + 40), (signed int *)(v5 + 8));
      if ( *(_DWORD *)(v5 + 24) )
        v7 = (__int64 (__fastcall *)(__int64, __int64))(sub_14000E5B4(a5) + *(signed int *)(v5 + 24));
      result = sub_14000FCAC(v8, (__int64 (__fastcall *)(__int64, __int64, _QWORD))v7, v10, 1u);
    }
  }
  else
  {
    v11 = sub_14000DAA4(*(_QWORD *)(v6 + 40), (signed int *)(v5 + 8));
    if ( *(_DWORD *)(v5 + 24) )
      v7 = (__int64 (__fastcall *)(__int64, __int64))(sub_14000E5B4(a5) + *(signed int *)(v5 + 24));
    result = sub_14000FCA0(v8, v7, v11);
  }
  return result;
}

//----- (000000014000EA4C) ----------------------------------------------------
void __usercall sub_14000EA4C(void **a1@<rdx>, ULONG_PTR a2@<rcx>, ULONG_PTR a3@<r8>, unsigned __int64 *a4@<r9>, __m256i *a5@<ymm0>, int a6, int a7, int a8, int a9, int a10, int a11, char a12, unsigned __int8 a13)
{
  ULONG_PTR v13; // r13
  __int64 v14; // r15
  void **v15; // r12
  ULONG_PTR v16; // rbp
  __m128i *v17; // rax
  ULONG_PTR v18; // r14
  __int64 v19; // rsi
  int v20; // ebx
  int v21; // edi
  __int64 v22; // rax
  __int64 v23; // [rsp+A8h] [rbp+10h]
  ULONG_PTR v24; // [rsp+B0h] [rbp+18h]

  v24 = a3;
  v13 = *(_QWORD *)&a6;
  v14 = (__int64)a4;
  v15 = a1;
  v16 = a2;
  v17 = (__m128i *)sub_14000E200(a4, a1, *(__int64 *)&a6, &v23, a5);
  v18 = (ULONG_PTR)v17;
  v19 = *(_QWORD *)&a7;
  if ( *(_QWORD *)&a8 )
    sub_14000E98C(v17, v16, *(_DWORD **)&a7, *(__int64 *)&a8, a5);
  v20 = *(_DWORD *)(*(_QWORD *)&a9 + 8i64);
  v21 = **(_DWORD **)&a9;
  v22 = sub_14000E5A0(a5);
  sub_14000E40C(v15, v16, v24, v18, *(signed int *)(v19 + 12) + v22, v13, v21, v20, v19, v14, a13);
}

//----- (000000014000EB20) ----------------------------------------------------
_QWORD *__usercall sub_14000EB20@<rax>(void **a1@<rdx>, ULONG_PTR a2@<rcx>, ULONG_PTR a3@<r8>, unsigned __int64 *a4@<r9>, __m256i *a5@<ymm0>, _DWORD *a6, __int64 a7, int a8, __int64 a9)
{
  void **v9; // r12
  ULONG_PTR v10; // rbx
  unsigned __int64 *v11; // rsi
  signed int v12; // eax
  int v13; // er14
  _QWORD *result; // rax
  _DWORD *v15; // r15
  __m128i v16; // xmm0
  __int64 v17; // r9
  unsigned int v18; // er13
  __int64 v19; // rax
  signed __int64 v20; // r8
  __m128i v21; // xmm0
  __int64 v22; // rcx
  unsigned int v23; // er12
  __int64 v24; // rdx
  unsigned __int64 v25; // r15
  __int64 v26; // rax
  _BYTE *v27; // r8
  _DWORD *v28; // rdx
  _QWORD *v29; // rax
  char v30; // [rsp+60h] [rbp-A0h]
  int v31; // [rsp+64h] [rbp-9Ch]
  ULONG_PTR v32; // [rsp+68h] [rbp-98h]
  signed int *v33; // [rsp+70h] [rbp-90h]
  void **v34; // [rsp+78h] [rbp-88h]
  __int64 v35; // [rsp+80h] [rbp-80h]
  __int64 v36; // [rsp+88h] [rbp-78h]
  __int64 v37; // [rsp+90h] [rbp-70h]
  __int64 v38; // [rsp+98h] [rbp-68h]
  __m128i v39; // [rsp+A0h] [rbp-60h]
  int v40; // [rsp+B0h] [rbp-50h]
  _DWORD *v41; // [rsp+B8h] [rbp-48h]
  unsigned __int64 v42; // [rsp+C0h] [rbp-40h]
  __int128 v43; // [rsp+C8h] [rbp-38h]
  __m128i v44; // [rsp+D8h] [rbp-28h]
  unsigned int v45; // [rsp+F0h] [rbp-10h]
  __int128 v46; // [rsp+F8h] [rbp-8h]
  int v47; // [rsp+108h] [rbp+8h]

  v9 = a1;
  v32 = a3;
  v10 = a2;
  v34 = a1;
  v38 = a9;
  v30 = 0;
  v11 = a4;
  v12 = sub_14000FA90(a4, a1, (__int64)a6, a5);
  v13 = v12;
  if ( v12 < -1 || v12 >= a6[1] )
    goto LABEL_54;
  if ( *(_DWORD *)v10 == -529697949
    && *(_DWORD *)(v10 + 24) == 4
    && (unsigned int)(*(_DWORD *)(v10 + 32) - 429065504) <= 2
    && !*(_QWORD *)(v10 + 48) )
  {
    result = sub_14000DC10(a5);
    if ( !result[4] )
      return result;
    v10 = *((_QWORD *)sub_14000DC10(a5) + 4);
    v30 = 1;
    v32 = *((_QWORD *)sub_14000DC10(a5) + 5);
    sub_14000E5E0(*(_QWORD *)(v10 + 56), a5);
    if ( *(_DWORD *)v10 == -529697949
      && *(_DWORD *)(v10 + 24) == 4
      && (unsigned int)(*(_DWORD *)(v10 + 32) - 429065504) <= 2
      && !*(_QWORD *)(v10 + 48) )
    {
      goto LABEL_54;
    }
    if ( *((_QWORD *)sub_14000DC10(a5) + 7) )
    {
      v15 = (_DWORD *)*((_QWORD *)sub_14000DC10(a5) + 7);
      *((_QWORD *)sub_14000DC10(a5) + 7) = 0i64;
      if ( !sub_14000FB28(v15, v10, a5) )
      {
        if ( sub_14000FC18(v15, a5) )
        {
          sub_14000DA00(v10);
          sub_14000F5D0(&v46);
          sub_14000FEA0(&v46, &_TI2_AVbad_exception_std__);
          __debugbreak();
        }
        sub_14001A878(a5);
      }
    }
  }
  v42 = v11[1];
  v41 = a6;
  if ( *(_DWORD *)v10 != -529697949
    || *(_DWORD *)(v10 + 24) != 4
    || (unsigned int)(*(_DWORD *)(v10 + 32) - 429065504) > 2 )
  {
    if ( a6[3] )
    {
      if ( (_BYTE)a7 )
        goto LABEL_54;
      sub_14000EFF8((unsigned int *)v10, v11, a5);
    }
  }
  else
  {
    if ( a6[3] )
    {
      sub_14000E2CC((__int64)&v41, &v44, v13, v11, a5, (__int64)a6);
      v16 = v44;
      _mm_storeu_si128((__m128i *)&v43, v44);
      if ( _mm_cvtsi128_si32(_mm_srli_si128(v16, 8)) < v45 )
      {
        v17 = v44.m128i_i64[0];
        v18 = DWORD2(v43);
        v35 = v44.m128i_i64[0];
        do
        {
          v19 = *(_QWORD *)(v17 + 8);
          v20 = *(signed int *)(*(_QWORD *)v43 + 16i64) + 20i64 * v18;
          v21 = *(__m128i *)(v20 + v19);
          v22 = *(signed int *)(v20 + v19 + 16);
          v40 = *(_DWORD *)(v20 + v19 + 16);
          v39 = v21;
          if ( _mm_cvtsi128_si32(v21) <= v13 && v13 <= v39.m128i_i32[1] )
          {
            v23 = 0;
            v24 = v11[1] + v22;
            v25 = (unsigned __int64)v39.m128i_i64[1] >> 32;
            v37 = v11[1] + v22;
            if ( v39.m128i_i32[3] )
            {
              while ( 1 )
              {
                v46 = *(_OWORD *)(v24 + 20i64 * v23);
                v47 = *(_DWORD *)(v24 + 20i64 * v23 + 16);
                v33 = (signed int *)(*(signed int *)(*(_QWORD *)(v10 + 48) + 12i64) + sub_14000E5B4(a5) + 4);
                v31 = *(_DWORD *)(sub_14000E5B4(a5) + *(signed int *)(*(_QWORD *)(v10 + 48) + 12i64));
                if ( v31 > 0 )
                  break;
LABEL_28:
                if ( ++v23 == (_DWORD)v25 )
                {
                  v9 = v34;
                  goto LABEL_33;
                }
                v24 = v37;
              }
              while ( 1 )
              {
                v26 = sub_14000E5B4(a5);
                v27 = *(_BYTE **)(v10 + 48);
                v36 = *v33 + v26;
                if ( (unsigned int)sub_14000F214(v36, (__int64)&v46, v27, a5) )
                  break;
                ++v33;
                if ( --v31 <= 0 )
                  goto LABEL_28;
              }
              v9 = v34;
              sub_14000EA4C(
                v34,
                v10,
                v32,
                v11,
                a5,
                (int)a6,
                (unsigned __int64)&v46,
                v36,
                (unsigned __int64)&v39,
                a8,
                v38,
                v30,
                a7);
LABEL_33:
              v17 = v35;
            }
            else
            {
              v9 = v34;
            }
          }
          ++v18;
        }
        while ( v18 < v45 );
      }
    }
    if ( (*a6 & 0x1FFFFFFFu) >= 0x19930521
      && (a6[8] && (signed int)a6[8] + sub_14000E5A0(a5) || (a6[9] >> 2) & 1 && !sub_14000E170((__int64)a6, v11, a5)) )
    {
      if ( (a6[9] >> 2) & 1 )
      {
        *((_QWORD *)sub_14000DC10(a5) + 4) = v10;
        *((_QWORD *)sub_14000DC10(a5) + 5) = v32;
        sub_14001A878(a5);
      }
      if ( a6[8] )
        v28 = (_DWORD *)((signed int)a6[8] + sub_14000E5A0(a5));
      else
        v28 = 0i64;
      if ( !sub_14000FB28(v28, v10, a5) )
      {
        v29 = sub_14000E200(v11, v9, (__int64)a6, &v36, a5);
        sub_14000E40C(v9, v10, v32, (ULONG_PTR)v29, 0i64, (ULONG_PTR)a6, -1, -1, 0i64, (__int64)v11, a7);
      }
    }
  }
  result = sub_14000DC10(a5);
  if ( result[7] )
LABEL_54:
    sub_14001A9AC(a5);
  return result;
}
// 14003CD60: using guessed type int _TI2_AVbad_exception_std__;

//----- (000000014000EFF8) ----------------------------------------------------
void __usercall sub_14000EFF8(unsigned int *a1@<rcx>, unsigned __int64 *a2@<r9>, __m256i *a3@<ymm0>)
{
  unsigned __int64 *v3; // rsi
  unsigned int *v4; // r14
  int v5; // er12
  int v6; // edi
  PVOID v7; // rbx
  int v8; // er13
  __m128i v9; // xmm0
  __int64 v10; // r9
  unsigned int v11; // er15
  __int64 v12; // rax
  signed __int64 v13; // r8
  __m128i v14; // xmm0
  __int64 v15; // rdx
  signed __int64 v16; // rbx
  __int64 v17; // r13
  __int64 v18; // rax
  __int64 v19; // [rsp+28h] [rbp-59h]
  __int64 v20; // [rsp+30h] [rbp-51h]
  __int128 v21; // [rsp+38h] [rbp-49h]
  __m128i v22; // [rsp+48h] [rbp-39h]
  int v23; // [rsp+58h] [rbp-29h]
  __m128i v24; // [rsp+60h] [rbp-21h]
  unsigned int v25; // [rsp+78h] [rbp-9h]
  __int64 v26; // [rsp+C8h] [rbp+47h]
  void **v27; // [rsp+D0h] [rbp+4Fh]
  ULONG_PTR v28; // [rsp+D8h] [rbp+57h]
  __int64 v29; // [rsp+E8h] [rbp+67h]
  int vars0; // [rsp+F0h] [rbp+6Fh]
  void *retaddr; // [rsp+F8h] [rbp+77h]
  __int64 v32; // [rsp+100h] [rbp+7Fh]

  v3 = a2;
  v4 = a1;
  if ( *a1 != -2147483645 )
  {
    v5 = vars0;
    v6 = v29;
    if ( *((_QWORD *)sub_14000DC10(a3) + 2)
      && (v7 = EncodePointer(0i64), *((PVOID *)sub_14000DC10(a3) + 2) != v7)
      && *v4 != -532459699 )
    {
      v8 = (signed int)retaddr;
      if ( *v4 != -532462766 )
      {
        LODWORD(v21) = vars0;
        v20 = v32;
        LODWORD(v19) = (_DWORD)retaddr;
        if ( (unsigned int)sub_14000E0B8(v4, a3) )
          return;
      }
    }
    else
    {
      v8 = (signed int)retaddr;
    }
    v20 = v3[1];
    v19 = v29;
    if ( !*(_DWORD *)(v29 + 12) )
      sub_14001A9AC(a3);
    LODWORD(v19) = v8;
    sub_14000E2CC((__int64)&v19, &v24, vars0, v3, a3, v29);
    v9 = v24;
    _mm_storeu_si128((__m128i *)&v21, v24);
    if ( _mm_cvtsi128_si32(_mm_srli_si128(v9, 8)) < v25 )
    {
      v10 = v24.m128i_i64[0];
      v11 = DWORD2(v21);
      v26 = v24.m128i_i64[0];
      do
      {
        v12 = *(_QWORD *)(v10 + 8);
        v13 = *(signed int *)(*(_QWORD *)v21 + 16i64) + 20i64 * v11;
        v14 = *(__m128i *)(v13 + v12);
        v15 = *(signed int *)(v13 + v12 + 16);
        v23 = *(_DWORD *)(v13 + v12 + 16);
        v22 = v14;
        if ( _mm_cvtsi128_si32(v14) <= v5 && v5 <= v22.m128i_i32[1] )
        {
          v16 = v15 + 20 * ((unsigned __int64)v22.m128i_i64[1] >> 32) + v3[1] - 20;
          if ( *(_DWORD *)(v16 + 4) )
          {
            v17 = *(signed int *)(v16 + 4);
            if ( v17 + sub_14000E5A0(a3) )
            {
              v18 = (_DWORD)v17 ? *(signed int *)(v16 + 4) + sub_14000E5A0(a3) : 0i64;
              if ( *(_BYTE *)(v18 + 16) )
                goto LABEL_23;
            }
            v8 = (signed int)retaddr;
          }
          if ( !(*(_BYTE *)v16 & 0x40) )
            sub_14000EA4C(v27, (ULONG_PTR)v4, v28, v3, a3, v6, v16, 0, (unsigned __int64)&v22, v8, v32, 1, 0);
        }
LABEL_23:
        v8 = (signed int)retaddr;
        ++v11;
        v10 = v26;
      }
      while ( v11 < v25 );
    }
  }
}

//----- (000000014000F214) ----------------------------------------------------
signed __int64 __usercall sub_14000F214@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, _BYTE *a3@<r8>, __m256i *a4@<ymm0>)
{
  unsigned int v4; // ebx
  _BYTE *v5; // r14
  __int64 v6; // rbp
  __int64 v7; // rdi
  __int64 v8; // rsi
  __int64 v9; // rsi
  __int64 v10; // rcx
  __int64 v11; // rsi
  __int64 v12; // rsi
  __int64 v13; // r8
  unsigned __int8 *v14; // rax
  signed __int64 v15; // r8
  int v16; // edx
  int v17; // ecx

  v4 = 0;
  v5 = a3;
  v6 = a1;
  v7 = a2;
  if ( !*(_DWORD *)(a2 + 4) )
    return 1i64;
  v8 = *(signed int *)(a2 + 4);
  if ( !(v8 + sub_14000E5A0(a4)) )
    return 1i64;
  if ( (_DWORD)v8 )
  {
    v9 = *(signed int *)(v7 + 4);
    v10 = v9 + sub_14000E5A0(a4);
  }
  else
  {
    v10 = 0i64;
    LODWORD(v9) = 0;
  }
  if ( !*(_BYTE *)(v10 + 16) || *(_BYTE *)v7 < 0 && *(_BYTE *)v6 & 0x10 )
    return 1i64;
  if ( (_DWORD)v9 )
    v11 = *(signed int *)(v7 + 4) + sub_14000E5A0(a4);
  else
    v11 = 0i64;
  if ( v11 != *(signed int *)(v6 + 4) + sub_14000E5B4(a4) )
  {
    v12 = *(_DWORD *)(v7 + 4) ? *(signed int *)(v7 + 4) + sub_14000E5A0(a4) : 0i64;
    v13 = sub_14000E5B4(a4) + *(signed int *)(v6 + 4) + 16i64;
    v14 = (unsigned __int8 *)(v12 + 16);
    v15 = v13 - (v12 + 16);
    do
    {
      v16 = v14[v15];
      v17 = *v14 - v16;
      if ( *v14 != v16 )
        break;
      ++v14;
    }
    while ( v16 );
    if ( v17 )
      return 0i64;
  }
  if ( (!(*(_BYTE *)v6 & 2) || *(_BYTE *)v7 & 8)
    && (!(*v5 & 1) || *(_BYTE *)v7 & 1)
    && (!(*v5 & 4) || *(_BYTE *)v7 & 4)
    && (!(*v5 & 2) || *(_BYTE *)v7 & 2) )
  {
    v4 = 1;
  }
  return v4;
}

//----- (000000014000F354) ----------------------------------------------------
__int64 __usercall sub_14000F354@<rax>(__int64 *a1@<rdx>, ULONG_PTR a2@<rcx>, __int64 a3@<r8>, unsigned __int64 *a4@<r9>, __m256i *a5@<ymm0>, __int64 a6, int a7, __int64 a8, char a9)
{
  ULONG_PTR v9; // rdi
  unsigned __int64 *v10; // rsi
  ULONG_PTR v11; // r14
  __int64 *v12; // rbp
  signed int v13; // eax
  int v14; // er9
  __int64 *v15; // rcx
  __int64 v17; // [rsp+28h] [rbp-30h]

  v9 = a2;
  v10 = a4;
  v11 = a3;
  v12 = a1;
  sub_14000DBB4(a3);
  if ( *((_DWORD *)sub_14000DC10(a5) + 16) || *(_DWORD *)v9 == -529697949 )
    goto LABEL_9;
  if ( *(_DWORD *)v9 != -2147483607 )
    goto LABEL_6;
  if ( *(_DWORD *)(v9 + 24) == 15 )
  {
    if ( *(_QWORD *)(v9 + 96) == 429065504i64 )
      goto LABEL_9;
LABEL_6:
    if ( *(_DWORD *)v9 == -2147483610 )
      goto LABEL_9;
  }
  if ( (*(_DWORD *)a6 & 0x1FFFFFFFu) >= 0x19930522 && *(_BYTE *)(a6 + 36) & 1 )
    return 1i64;
LABEL_9:
  if ( *(_BYTE *)(v9 + 4) & 0x66 )
  {
    if ( !*(_DWORD *)(a6 + 4) || a7 )
      return 1i64;
    if ( *(_BYTE *)(v9 + 4) & 0x20 )
    {
      if ( *(_DWORD *)v9 == -2147483610 )
      {
        v13 = sub_14000E724((__int64)v10, a6, v10[4], a5);
        if ( v13 >= -1 && v13 < *(_DWORD *)(a6 + 4) )
        {
          v14 = v13;
          v15 = v12;
LABEL_17:
          sub_14000F904(v10, v15, a6, v14, a5);
          return 1i64;
        }
        goto LABEL_38;
      }
      if ( *(_DWORD *)v9 == -2147483607 )
      {
        v14 = *(_DWORD *)(v9 + 56);
        if ( v14 >= -1 && v14 < *(_DWORD *)(a6 + 4) )
        {
          v15 = *(__int64 **)(v9 + 40);
          goto LABEL_17;
        }
LABEL_38:
        sub_14001A9AC(a5);
      }
    }
    sub_14000E19C(v10, v12, a6, a5);
    return 1i64;
  }
  if ( *(_DWORD *)(a6 + 12)
    || (*(_DWORD *)a6 & 0x1FFFFFFFu) >= 0x19930521
    && *(_DWORD *)(a6 + 32)
    && *(signed int *)(a6 + 32) + sub_14000E5A0(a5)
    || (*(_DWORD *)a6 & 0x1FFFFFFFu) >= 0x19930522 && (*(_DWORD *)(a6 + 36) >> 2) & 1 )
  {
    if ( *(_DWORD *)v9 == -529697949
      && *(_DWORD *)(v9 + 24) >= 3u
      && *(_DWORD *)(v9 + 32) > 0x19930522u
      && *(_DWORD *)(*(_QWORD *)(v9 + 48) + 8i64)
      && *(signed int *)(*(_QWORD *)(v9 + 48) + 8i64) + sub_14000E5B4(a5) )
    {
      return sub_14002A5B0();
    }
    LOBYTE(v17) = a9;
    sub_14000EB20((void **)v12, v9, v11, v10, a5, (_DWORD *)a6, v17, a7, a8);
  }
  return 1i64;
}

//----- (000000014000F594) ----------------------------------------------------
_QWORD *__usercall sub_14000F594@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  _QWORD *v3; // rbx

  v3 = (_QWORD *)a2;
  *(_QWORD *)a2 = &std::exception::`vftable';
  *(_OWORD *)(a2 + 8) = 0i64;
  sub_14000FDE8(a2 + 8, a1 + 8, a3);
  *v3 = &std::bad_exception::`vftable';
  return v3;
}
// 1400323A0: using guessed type void *std::exception::`vftable';
// 1400323D0: using guessed type void *std::bad_exception::`vftable';

//----- (000000014000F5D0) ----------------------------------------------------
_QWORD *__fastcall sub_14000F5D0(_QWORD *a1)
{
  a1[2] = 0i64;
  a1[1] = "bad exception";
  *a1 = &std::bad_exception::`vftable';
  return a1;
}
// 1400323D0: using guessed type void *std::bad_exception::`vftable';

//----- (000000014000F5F0) ----------------------------------------------------
__int64 __usercall sub_14000F5F0@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rbx

  v3 = a2;
  *(_QWORD *)a2 = &std::exception::`vftable';
  *(_OWORD *)(a2 + 8) = 0i64;
  sub_14000FDE8(a2 + 8, a1 + 8, a3);
  return v3;
}
// 1400323A0: using guessed type void *std::exception::`vftable';

//----- (000000014000F624) ----------------------------------------------------
void __fastcall sub_14000F624(_QWORD *a1)
{
  *a1 = &std::exception::`vftable';
  sub_14000FE78((__int64)(a1 + 1));
}
// 1400323A0: using guessed type void *std::exception::`vftable';

//----- (000000014000F640) ----------------------------------------------------
_QWORD *__fastcall sub_14000F640(_QWORD *a1, char a2)
{
  _QWORD *v2; // rdi
  char v3; // bl

  v2 = a1;
  *a1 = &std::exception::`vftable';
  v3 = a2;
  sub_14000FE78((__int64)(a1 + 1));
  if ( v3 & 1 )
    sub_14002A40C(v2, 24i64);
  return v2;
}
// 14002A40C: using guessed type __int64 __fastcall sub_14002A40C(_QWORD, _QWORD);
// 1400323A0: using guessed type void *std::exception::`vftable';

//----- (000000014000F690) ----------------------------------------------------
__int64 __usercall sub_14000F690@<rax>(_QWORD *a1@<rcx>, __m256i *a2@<ymm0>)
{
  _QWORD *v2; // rdi
  __int64 v3; // r13
  __int64 v4; // rsi
  __int64 v5; // rbx
  __int64 *v6; // r14
  _QWORD *v7; // rax
  _QWORD *v8; // r12
  __int64 v9; // rax
  __int64 v10; // rbx
  __int64 v12; // [rsp+30h] [rbp-78h]
  __int64 v13; // [rsp+48h] [rbp-60h]
  char v14; // [rsp+60h] [rbp-48h]
  __int64 v15; // [rsp+C0h] [rbp+18h]
  __int64 v16; // [rsp+C8h] [rbp+20h]

  v2 = a1;
  v3 = *((_QWORD *)sub_14000DC10(a2) + 5);
  v15 = *((_QWORD *)sub_14000DC10(a2) + 4);
  v4 = v2[10];
  v12 = v2[9];
  v5 = v2[8];
  v13 = v2[6];
  v6 = (__int64 *)v2[5];
  sub_14000DBB4(v2[8]);
  *((_QWORD *)sub_14000DC10(a2) + 4) = v4;
  *((_QWORD *)sub_14000DC10(a2) + 5) = v5;
  v7 = sub_14000DC10(a2);
  v8 = sub_14000E510(*(_QWORD *)(v7[4] + 40i64), &v14, a2);
  if ( v2[11] )
    v16 = *((_QWORD *)sub_14000DC10(a2) + 14);
  sub_14000FCF0(v13, v6);
  v10 = v9;
  sub_14000E54C((__int64)v8, a2);
  if ( *(_DWORD *)v4 == -529697949
    && *(_DWORD *)(v4 + 24) == 4
    && (unsigned int)(*(_DWORD *)(v4 + 32) - 429065504) <= 2
    && (unsigned int)sub_14000DA74(*(_QWORD *)(v4 + 40), a2) )
  {
    sub_14000DA00(v4);
  }
  *((_QWORD *)sub_14000DC10(a2) + 4) = v15;
  *((_QWORD *)sub_14000DC10(a2) + 5) = v3;
  *(_QWORD *)(*(signed int *)(v12 + 28) + *v6) = -2i64;
  return v10;
}

//----- (000000014000F87C) ----------------------------------------------------
signed __int64 __usercall sub_14000F87C@<rax>(__int64 a1@<rdx>, __int64 *a2@<rcx>, signed int *a3@<r8>, __m256i *a4@<ymm0>)
{
  __int64 v4; // r9
  signed int *v5; // rbx
  signed int v6; // ecx
  signed __int64 result; // rax

  v4 = *a2;
  v5 = a3;
  *a3 = 0;
  if ( *(_DWORD *)v4 != -529697949 )
    return 0i64;
  if ( *(_DWORD *)(v4 + 24) == 4 && (unsigned int)(*(_DWORD *)(v4 + 32) - 429065504) <= 2 )
  {
    v6 = *a3;
    if ( *(_QWORD *)(v4 + 40) == *(_QWORD *)(a1 + 40) )
      v6 = 1;
    *a3 = v6;
  }
  if ( *(_DWORD *)v4 != -529697949
    || *(_DWORD *)(v4 + 24) != 4
    || (unsigned int)(*(_DWORD *)(v4 + 32) - 429065504) > 2
    || *(_QWORD *)(v4 + 48) )
  {
    return 0i64;
  }
  *((_DWORD *)sub_14000DC10(a4) + 16) = 1;
  result = 1i64;
  *v5 = 1;
  return result;
}

//----- (000000014000F904) ----------------------------------------------------
__int64 __usercall sub_14000F904@<rax>(unsigned __int64 *a1@<rdx>, __int64 *a2@<rcx>, __int64 a3@<r8>, int a4@<r9d>, __m256i *a5@<ymm0>)
{
  int v5; // er12
  __int64 v6; // rsi
  unsigned __int64 *v7; // rbx
  __int64 *v8; // r15
  __int64 v9; // r13
  int v10; // edi
  _DWORD *v11; // rax
  __int64 v12; // r14
  __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rbx
  __int64 v16; // rax
  _DWORD *v17; // rax

  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = a2;
  v9 = sub_14000E5A0(a5);
  v10 = sub_14000E680(v7, v8, v6, a5);
  v11 = sub_14000DC10(a5);
  ++v11[12];
  while ( v10 != -1 && v10 > v5 )
  {
    if ( v10 <= -1 || v10 >= *(_DWORD *)(v6 + 4) )
      sub_14001A9AC(a5);
    v12 = v10;
    v10 = *(_DWORD *)(*(signed int *)(v6 + 8) + sub_14000E5A0(a5) + 8i64 * v10);
    if ( *(_DWORD *)(*(signed int *)(v6 + 8) + sub_14000E5A0(a5) + 8 * v12 + 4) )
    {
      v13 = *(signed int *)(*(signed int *)(v6 + 8) + sub_14000E5A0(a5) + 8 * v12 + 4);
      v14 = v13 + sub_14000E5A0(a5);
    }
    else
    {
      v14 = 0i64;
    }
    if ( v14 )
    {
      sub_14000E6D4(v8, v6, v10);
      if ( *(_DWORD *)(*(signed int *)(v6 + 8) + sub_14000E5A0(a5) + 8 * v12 + 4) )
      {
        v15 = *(signed int *)(*(signed int *)(v6 + 8) + sub_14000E5A0(a5) + 8 * v12 + 4);
        v16 = v15 + sub_14000E5A0(a5);
      }
      else
      {
        v16 = 0i64;
      }
      sub_14000FCF0(v16, v8);
      sub_14000E5C8(v9, a5);
    }
  }
  if ( *((_DWORD *)sub_14000DC10(a5) + 12) > 0 )
  {
    v17 = sub_14000DC10(a5);
    --v17[12];
  }
  if ( v10 != -1 && v10 > v5 )
    sub_14001A9AC(a5);
  return sub_14000E6D4(v8, v6, v10);
}

//----- (000000014000FA90) ----------------------------------------------------
__int64 __usercall sub_14000FA90@<rax>(unsigned __int64 *a1@<rdx>, _QWORD *a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  _QWORD *v4; // rbp
  __int64 v5; // rdi
  unsigned __int64 *v6; // rsi
  int v7; // ebx
  char v9; // [rsp+48h] [rbp+20h]

  v4 = a2;
  v5 = a3;
  v6 = a1;
  v7 = sub_14000E71C(a1, a3, a4);
  sub_14000E200(v6, v4, v5, &v9, a4);
  if ( v7 <= (signed int)sub_14000E6A8(v6, v4, v5, a4) )
  {
    v7 = sub_14000E6A8(v6, v4, v5, a4);
  }
  else
  {
    sub_14000E6D4((__int64 *)&v9, v5, v7);
    sub_14000E6E0(v6, v4, v5, v7, a4);
  }
  return (unsigned int)v7;
}

//----- (000000014000FB28) ----------------------------------------------------
char __usercall sub_14000FB28@<al>(_DWORD *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  _DWORD *v3; // rbp
  __int64 v4; // r13
  char v5; // r15
  int v6; // esi
  signed int *v7; // r12
  int v8; // er14
  __int64 v9; // rax
  _BYTE *v10; // rbx
  __int64 v11; // rdi
  __int64 v12; // rax

  v3 = a1;
  v4 = a2;
  if ( !a1 )
    sub_14001A9AC(a3);
  v5 = 0;
  v6 = 0;
  if ( *a1 > 0 )
  {
    do
    {
      v7 = (signed int *)(sub_14000E5B4(a3) + *(signed int *)(*(_QWORD *)(v4 + 48) + 12i64) + 4i64);
      v8 = *(_DWORD *)(sub_14000E5B4(a3) + *(signed int *)(*(_QWORD *)(v4 + 48) + 12i64));
      if ( v8 > 0 )
      {
        while ( 1 )
        {
          v9 = sub_14000E5B4(a3);
          v10 = *(_BYTE **)(v4 + 48);
          v11 = *v7 + v9;
          v12 = sub_14000E5A0(a3);
          if ( (unsigned int)sub_14000F214(v11, v12 + 20i64 * v6 + (signed int)v3[1], v10, a3) )
            break;
          --v8;
          ++v7;
          if ( v8 <= 0 )
            goto LABEL_8;
        }
        v5 = 1;
      }
LABEL_8:
      ++v6;
    }
    while ( v6 < *v3 );
  }
  return v5;
}

//----- (000000014000FC18) ----------------------------------------------------
char __usercall sub_14000FC18@<al>(_DWORD *a1@<rcx>, __m256i *a2@<ymm0>)
{
  int v2; // ebp
  _DWORD *v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rbx
  __int64 v6; // rax

  v2 = 0;
  v3 = a1;
  if ( *a1 <= 0 )
    return 0;
  v4 = 0i64;
  while ( 1 )
  {
    if ( *(_DWORD *)((signed int)v3[1] + v4 + sub_14000E5A0(a2) + 4) )
    {
      v5 = *(signed int *)((signed int)v3[1] + v4 + sub_14000E5A0(a2) + 4);
      v6 = v5 + sub_14000E5A0(a2);
    }
    else
    {
      v6 = 0i64;
    }
    if ( !(unsigned int)sub_14000D9D4(v6 + 8, (__int64)&qword_14003EC20) )
      break;
    ++v2;
    v4 += 20i64;
    if ( v2 >= *v3 )
      return 0;
  }
  return 1;
}
// 14003EC20: using guessed type __int64 qword_14003EC20;

//----- (000000014000FCA0) ----------------------------------------------------
__int64 __fastcall sub_14000FCA0(__int64 a1, __int64 (__fastcall *a2)(__int64, __int64), __int64 a3)
{
  return a2(a1, a3);
}

//----- (000000014000FCAC) ----------------------------------------------------
__int64 __fastcall sub_14000FCAC(__int64 a1, __int64 (__fastcall *a2)(__int64, __int64, _QWORD), __int64 a3, unsigned int a4)
{
  return a2(a1, a3, a4);
}

//----- (000000014000FCC0) ----------------------------------------------------
const char *__fastcall sub_14000FCC0(__int64 a1)
{
  const char *result; // rax

  result = "Unknown exception";
  if ( *(_QWORD *)(a1 + 8) )
    result = *(const char **)(a1 + 8);
  return result;
}

//----- (000000014000FCF0) ----------------------------------------------------
void __fastcall sub_14000FCF0(__int64 a1, __int64 *a2)
{
  __int64 v2; // rdx
  void (*v3)(void); // rax
  __int64 v4; // rdx
  __int64 *v5; // [rsp+38h] [rbp+10h]

  v5 = a2;
  v2 = *a2;
  sub_14000DB80();
  v3();
  nullsub_2();
  v4 = *v5;
  sub_14000DB80();
}
// 14000DBB0: using guessed type __int64 nullsub_2(void);

//----- (000000014000FD40) ----------------------------------------------------
__int64 __fastcall sub_14000FD40(__int64 a1, __int64 *a2)
{
  __int64 v2; // rdx
  void (*v3)(void); // rax

  v2 = *a2;
  sub_14000DB80();
  v3();
  return nullsub_2();
}
// 14000DBB0: using guessed type __int64 nullsub_2(void);

//----- (000000014000FD70) ----------------------------------------------------
void __fastcall sub_14000FD70(__int64 a1, __int64 *a2)
{
  __int64 v2; // rdx

  v2 = *a2;
  sub_14000DB80();
}

//----- (000000014000FDA0) ----------------------------------------------------
void __fastcall sub_14000FDA0(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall *v3)(__int64); // rax
  __int64 v4; // [rsp+40h] [rbp+18h]

  v4 = a3;
  sub_14000DB80();
  v3(v4);
  nullsub_2();
  sub_14000DB80();
}
// 14000DBB0: using guessed type __int64 nullsub_2(void);

//----- (000000014000FDE8) ----------------------------------------------------
void __usercall sub_14000FDE8(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // r14
  __int64 *v4; // rsi
  signed __int64 v5; // rdi
  _BYTE *v6; // rax
  void *v7; // rbx

  v3 = a1;
  v4 = (__int64 *)a2;
  if ( *(_BYTE *)(a2 + 8) && *(_QWORD *)a2 )
  {
    v5 = -1i64;
    do
      ++v5;
    while ( *(_BYTE *)(*(_QWORD *)a2 + v5) );
    v6 = (_BYTE *)sub_140014FA0(v5 + 1);
    v7 = v6;
    if ( v6 )
    {
      sub_14001A94C(v5 + 1, v6, *v4, a3);
      *(_BYTE *)(v3 + 8) = 1;
      *(_QWORD *)v3 = v7;
      v7 = 0i64;
    }
    sub_140014F8C(v7);
  }
  else
  {
    *(_QWORD *)a1 = *(_QWORD *)a2;
    *(_BYTE *)(a1 + 8) = 0;
  }
}
// 140014FA0: using guessed type __int64 __fastcall sub_140014FA0(_QWORD);

//----- (000000014000FE78) ----------------------------------------------------
void __fastcall sub_14000FE78(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  if ( *(_BYTE *)(a1 + 8) )
    sub_140014F8C(*(LPVOID *)a1);
  *(_QWORD *)v1 = 0i64;
  *(_BYTE *)(v1 + 8) = 0;
}

//----- (000000014000FEA0) ----------------------------------------------------
void __fastcall sub_14000FEA0(_QWORD *a1, _BYTE *a2)
{
  _BYTE *v2; // rbx
  _QWORD *v3; // rsi
  ULONG_PTR v4; // rdi
  signed __int64 v5; // rcx
  __int64 v6; // rax
  PVOID v7; // rax
  PVOID BaseOfImage; // [rsp+20h] [rbp-38h]
  ULONG_PTR Arguments; // [rsp+28h] [rbp-30h]
  _QWORD *v10; // [rsp+30h] [rbp-28h]
  _BYTE *v11; // [rsp+38h] [rbp-20h]
  PVOID v12; // [rsp+40h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  v4 = 429065504i64;
  if ( a2 && *a2 & 0x10 )
  {
    v5 = *a1 - 8i64;
    v2 = *(_BYTE **)(*(_QWORD *)v5 + 48i64);
    v6 = *(_QWORD *)(*(_QWORD *)v5 + 64i64);
    sub_14002A5B0();
  }
  v7 = RtlPcToFileHeader(v2, &BaseOfImage);
  BaseOfImage = v7;
  if ( v2 && (*v2 & 8 || !v7) )
    v4 = 26820608i64;
  Arguments = v4;
  v10 = v3;
  v11 = v2;
  v12 = v7;
  RaiseException(0xE06D7363, 1u, 4u, &Arguments);
}

//----- (000000014000FF40) ----------------------------------------------------
char sub_14000FF40()
{
  qword_1400406B0 = (__int64)GetCommandLineA();
  qword_1400406B8 = (__int64)GetCommandLineW();
  return 1;
}
// 1400406B0: using guessed type __int64 qword_1400406B0;
// 1400406B8: using guessed type __int64 qword_1400406B8;

//----- (000000014000FF68) ----------------------------------------------------
int *sub_14000FF68()
{
  return &dword_140040698;
}
// 140040698: using guessed type int dword_140040698;

//----- (000000014000FF70) ----------------------------------------------------
LPVOID *sub_14000FF70()
{
  return &qword_1400406A8;
}

//----- (000000014000FF78) ----------------------------------------------------
signed __int64 __usercall sub_14000FF78@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  unsigned int v6; // edi

  v3 = a1;
  v4 = a2;
  if ( !a2 )
  {
    *(_BYTE *)(a1 + 48) = 1;
    *(_DWORD *)(a1 + 44) = 22;
    sub_14001ACE8(0i64, a3, 0i64, (signed __int64 *)a1);
    return 0xFFFFFFFFi64;
  }
  if ( (*(_DWORD *)(a2 + 20) >> 12) & 1 )
  {
    sub_14001B154(a2);
    return 0xFFFFFFFFi64;
  }
  sub_1400151DC(a2);
  v6 = sub_14000FFF4(v3, v4, a3);
  sub_1400151E8(v4);
  return v6;
}

//----- (000000014000FFF4) ----------------------------------------------------
signed __int64 __usercall sub_14000FFF4@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  signed __int64 result; // rax
  unsigned int v6; // esi
  signed int v7; // eax
  void *v8; // rcx

  v3 = a1;
  v4 = a2;
  if ( a2 )
  {
    v6 = -1;
    if ( (*(_DWORD *)(a2 + 20) >> 13) & 1 )
    {
      v6 = sub_140017568(a1, a2, a3);
      sub_14001B25C(v4);
      v7 = sub_14001A924(v4, a3);
      if ( (signed int)sub_14001AED0(v3, v7, a3) >= 0 )
      {
        v8 = *(void **)(v4 + 40);
        if ( v8 )
        {
          sub_14001AE1C(v8);
          *(_QWORD *)(v4 + 40) = 0i64;
        }
      }
      else
      {
        v6 = -1;
      }
    }
    sub_14001B154(v4);
    result = v6;
  }
  else
  {
    *(_BYTE *)(a1 + 48) = 1;
    *(_DWORD *)(a1 + 44) = 22;
    sub_14001ACE8(0i64, a3, 0i64, (signed __int64 *)a1);
    result = 0xFFFFFFFFi64;
  }
  return result;
}

//----- (000000014001009C) ----------------------------------------------------
signed __int64 __usercall sub_14001009C@<rax>(signed __int64 *a1@<rcx>, __m256i *a2@<ymm0>)
{
  signed __int64 *v2; // rdi
  DWORD v3; // eax
  bool v4; // zf
  __int64 v5; // rdx
  signed __int64 v6; // rax
  DWORD v7; // ecx
  signed __int64 v8; // rbx
  DWORD dwErrCode; // [rsp+30h] [rbp+8h]

  v2 = a1;
  if ( !*a1 )
  {
    v3 = GetLastError();
    v4 = *((_BYTE *)v2 + 16) == 0;
    dwErrCode = v3;
    if ( v4 )
    {
      v2[1] = 0i64;
      v5 = 0i64;
      *((_BYTE *)v2 + 16) = 1;
    }
    else
    {
      v5 = v2[1];
    }
    v6 = sub_14001B860((__int64)&dwErrCode, v5);
    v7 = dwErrCode;
    v8 = v6;
    *v2 = v6;
    SetLastError(v7);
    if ( !v8 )
      sub_14001A9AC(a2);
  }
  return *v2;
}

//----- (0000000140010104) ----------------------------------------------------
__int64 __usercall sub_140010104@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  unsigned int v2; // edi
  int v3; // ebx
  int v4; // ebx
  __int64 v6; // [rsp+20h] [rbp-40h]
  char v7; // [rsp+30h] [rbp-30h]
  __int128 v8; // [rsp+38h] [rbp-28h]
  char v9; // [rsp+48h] [rbp-18h]
  int v10; // [rsp+4Ch] [rbp-14h]
  char v11; // [rsp+50h] [rbp-10h]
  int v12; // [rsp+54h] [rbp-Ch]
  char v13; // [rsp+58h] [rbp-8h]

  v6 = 0i64;
  v7 = 0;
  v9 = 0;
  v11 = 0;
  v13 = 0;
  if ( !dword_140040924 )
  {
    v9 = 1;
    _mm_storeu_si128((__m128i *)&v8, off_14003E2C8);
  }
  v2 = sub_14000FFF4((__int64)&v6, a1, a2);
  if ( v9 == 2 )
    *(_DWORD *)(v6 + 936) &= 0xFFFFFFFD;
  if ( v11 )
  {
    v3 = v10;
    *(_DWORD *)(sub_14001009C(&v6, a2) + 32) = v3;
  }
  if ( v13 )
  {
    v4 = v12;
    *(_DWORD *)(sub_14001009C(&v6, a2) + 36) = v4;
  }
  return v2;
}
// 140040924: using guessed type int dword_140040924;

//----- (000000014001019C) ----------------------------------------------------
__int64 __usercall sub_14001019C@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  unsigned int v2; // edi
  int v3; // ebx
  int v4; // ebx
  __int64 v6; // [rsp+20h] [rbp-40h]
  char v7; // [rsp+30h] [rbp-30h]
  __int128 v8; // [rsp+38h] [rbp-28h]
  char v9; // [rsp+48h] [rbp-18h]
  int v10; // [rsp+4Ch] [rbp-14h]
  char v11; // [rsp+50h] [rbp-10h]
  int v12; // [rsp+54h] [rbp-Ch]
  char v13; // [rsp+58h] [rbp-8h]

  v6 = 0i64;
  v7 = 0;
  v9 = 0;
  v11 = 0;
  v13 = 0;
  if ( !dword_140040924 )
  {
    v9 = 1;
    _mm_storeu_si128((__m128i *)&v8, off_14003E2C8);
  }
  v2 = sub_14000FF78((__int64)&v6, a1, a2);
  if ( v9 == 2 )
    *(_DWORD *)(v6 + 936) &= 0xFFFFFFFD;
  if ( v11 )
  {
    v3 = v10;
    *(_DWORD *)(sub_14001009C(&v6, a2) + 32) = v3;
  }
  if ( v13 )
  {
    v4 = v12;
    *(_DWORD *)(sub_14001009C(&v6, a2) + 36) = v4;
  }
  return v2;
}
// 140040924: using guessed type int dword_140040924;

//----- (0000000140010234) ----------------------------------------------------
__int64 __usercall sub_140010234@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  if ( a1 )
    return (*(_DWORD *)(a1 + 20) >> 3) & 1;
  *(_DWORD *)sub_140015334() = 22;
  sub_14001ADB4(a2);
  return 0i64;
}

//----- (0000000140010260) ----------------------------------------------------
__int64 __usercall sub_140010260@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  if ( a1 )
    return (*(_DWORD *)(a1 + 20) >> 4) & 1;
  *(_DWORD *)sub_140015334() = 22;
  sub_14001ADB4(a2);
  return 0i64;
}

//----- (000000014001028C) ----------------------------------------------------
unsigned __int64 __usercall sub_14001028C@<rax>(unsigned __int64 a1@<rdx>, __int64 a2@<rcx>, unsigned __int64 a3@<r8>, unsigned __int64 a4@<r9>, __m256i *a5@<ymm0>, __int64 a6)
{
  __int64 v6; // rbx
  unsigned __int64 v7; // r14
  unsigned __int64 v8; // rsi
  __int64 v9; // r12
  unsigned int v11; // ecx
  unsigned __int64 v12; // rdi
  __m128i *v13; // r10
  unsigned __int64 v14; // rbp
  unsigned __int64 v15; // r13
  unsigned __int64 v16; // r15
  const __m128i *v17; // rdx
  unsigned int v18; // er15
  __int64 v19; // rax
  signed int v20; // eax
  int v21; // eax
  int v22; // eax
  WCHAR *v23; // [rsp+20h] [rbp-48h]
  unsigned __int64 v24; // [rsp+88h] [rbp+20h]
  unsigned int v25; // [rsp+90h] [rbp+28h]

  v24 = a4;
  v6 = a6;
  v7 = a3;
  v8 = a1;
  v9 = a2;
  if ( !a3 || !a4 )
    return 0i64;
  if ( !a2 )
    goto LABEL_55;
  if ( !a6 || a4 > 0xFFFFFFFFFFFFFFFFui64 / a3 )
  {
    if ( a1 != -1i64 )
    {
      sub_14000D100(0i64, a2, a1, a5);
      a4 = v24;
    }
    if ( !a6 || a4 > 0xFFFFFFFFFFFFFFFFui64 / v7 )
    {
LABEL_55:
      *(_DWORD *)sub_140015334() = 22;
      goto LABEL_5;
    }
  }
  if ( *(_DWORD *)(a6 + 20) & 0x4C0 )
    v11 = *(_DWORD *)(a6 + 32);
  else
    v11 = 4096;
  v25 = v11;
  v12 = a4 * v7;
  v13 = (__m128i *)v9;
  v23 = (WCHAR *)v9;
  v14 = a4 * v7;
  v15 = v8;
  if ( !(a4 * v7) )
    return a4;
  while ( 1 )
  {
    if ( *(_DWORD *)(v6 + 20) & 0x4C0 )
    {
      v16 = *(signed int *)(v6 + 16);
      if ( (_DWORD)v16 )
      {
        if ( (v16 & 0x80000000) != 0i64 )
          goto LABEL_50;
        if ( v14 < v16 )
          v16 = (unsigned int)v14;
        if ( v16 > v15 )
          goto LABEL_47;
        v17 = *(const __m128i **)v6;
        if ( !v16 )
          goto LABEL_31;
        if ( v13 )
        {
          if ( v17 )
          {
            sub_14000CA50(v13, v17, (unsigned int)v16);
LABEL_30:
            v13 = (__m128i *)v23;
LABEL_31:
            *(_DWORD *)(v6 + 16) -= v16;
            v14 -= v16;
            *(_QWORD *)v6 += v16;
            v11 = v25;
            v15 -= v16;
            goto LABEL_44;
          }
          sub_14000D100(0i64, (__int64)v13, v15, a5);
        }
        *(_DWORD *)sub_140015334() = 22;
        sub_14001ADB4(a5);
        goto LABEL_30;
      }
    }
    if ( v14 < v11 )
      break;
    v18 = v14;
    if ( v14 > 0x7FFFFFFF )
      v18 = 0x7FFFFFFF;
    if ( v11 )
      v18 -= v18 % v11;
    if ( v18 > v15 )
      goto LABEL_47;
    v19 = *(_QWORD *)(v6 + 8);
    *(_DWORD *)(v6 + 16) = 0;
    *(_QWORD *)v6 = v19;
    v20 = sub_14001A924(v6, a5);
    v21 = sub_14001BF2C(v23, v20, v18, a5);
    if ( !v21 )
    {
      _InterlockedOr((volatile signed __int32 *)(v6 + 20), 8u);
      return (v12 - v14) / v7;
    }
    if ( v21 < 0 )
    {
LABEL_50:
      _InterlockedOr((volatile signed __int32 *)(v6 + 20), 0x10u);
      return (v12 - v14) / v7;
    }
    v11 = v25;
    v13 = (__m128i *)v23;
    v16 = v21;
    v14 -= v21;
    v15 -= v21;
LABEL_44:
    v13 = (__m128i *)((char *)v13 + v16);
    v23 = (WCHAR *)v13;
    if ( !v14 )
      return v24;
  }
  v22 = sub_14001C37C(v6, a5);
  if ( v22 == -1 )
    return (v12 - v14) / v7;
  if ( v15 )
  {
    v13 = (__m128i *)v23;
    --v14;
    --v15;
    v16 = 1i64;
    *(_BYTE *)v23 = v22;
    v11 = *(_DWORD *)(v6 + 32);
    v25 = *(_DWORD *)(v6 + 32);
    goto LABEL_44;
  }
LABEL_47:
  if ( v8 != -1i64 )
    sub_14000D100(0i64, v9, v8, a5);
  *(_DWORD *)sub_140015334() = 34;
LABEL_5:
  sub_14001ADB4(a5);
  return 0i64;
}

//----- (00000001400104EC) ----------------------------------------------------
unsigned __int64 __usercall sub_1400104EC@<rax>(unsigned __int64 a1@<rdx>, __int64 a2@<rcx>, unsigned __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  return sub_14001050C(0xFFFFFFFFFFFFFFFFui64, a2, a1, a3, a5, a4);
}

//----- (000000014001050C) ----------------------------------------------------
unsigned __int64 __usercall sub_14001050C@<rax>(unsigned __int64 a1@<rdx>, __int64 a2@<rcx>, unsigned __int64 a3@<r8>, unsigned __int64 a4@<r9>, __m256i *a5@<ymm0>, __int64 a6)
{
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // r15
  unsigned __int64 v8; // rdi
  __int64 v9; // r14
  unsigned __int64 v11; // rdi

  v6 = a4;
  v7 = a3;
  v8 = a1;
  v9 = a2;
  if ( !a3 || !a4 )
    return 0i64;
  if ( !a6 )
  {
    if ( a1 != -1i64 )
      sub_14000D100(0i64, a2, a1, a5);
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
    return 0i64;
  }
  sub_1400151DC(a6);
  v11 = sub_14001028C(v8, v9, v7, v6, a5, a6);
  sub_1400151E8(a6);
  return v11;
}

//----- (00000001400105B4) ----------------------------------------------------
signed __int64 __usercall sub_1400105B4@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, unsigned int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  __int64 v5; // rdi
  int v6; // esi
  __int64 v7; // r14
  __int64 v8; // rbx
  signed __int64 result; // rax
  unsigned int v10; // edi

  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = a2;
  if ( a2 && a3 <= 2 )
  {
    sub_1400151DC(a2);
    v10 = sub_140010738(v7, v8, v6, v5, a5);
    sub_1400151E8(v8);
    result = v10;
  }
  else
  {
    *(_BYTE *)(a4 + 48) = 1;
    *(_DWORD *)(a4 + 44) = 22;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)a4);
    result = 0xFFFFFFFFi64;
  }
  return result;
}

//----- (0000000140010650) ----------------------------------------------------
char __usercall sub_140010650@<al>(__int64 a1@<rdx>, _DWORD *a2@<rcx>, int a3@<r8d>, __m256i *a4@<ymm0>)
{
  signed __int64 v4; // rdi
  _DWORD *v5; // rbx
  __int64 v6; // r10
  __int64 v7; // rcx
  __int64 v8; // r9
  LARGE_INTEGER v9; // rcx
  __int64 v10; // rdx
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdi
  unsigned __int64 v13; // rdx
  __int64 v14; // rdx
  char result; // al

  v4 = a1;
  v5 = a2;
  if ( a3 == 2 )
    return 0;
  if ( !(a2[5] & 0x4C0) )
    return 0;
  if ( a2[5] & 6 )
    return 0;
  if ( a2[4] <= 0 )
    return 0;
  v6 = (signed int)a2[6];
  v7 = a2[6] & 0x3F;
  v8 = qword_140040970[v6 >> 6];
  if ( *(_BYTE *)(v8 + 72 * v7 + 56) < 0 || *(_BYTE *)(v8 + 72 * v7 + 57) )
    return 0;
  if ( !a3 )
  {
    v9 = sub_14001C754(0i64, v6, 1u, a4);
    if ( v9.QuadPart < 0 )
      return 0;
    v10 = v4;
    v11 = v9.QuadPart - (signed int)v5[4];
    v12 = (unsigned __int64)v4 >> 63;
    v13 = v10 - v11;
    if ( (_DWORD)v12 != v11 >> 63 && (_DWORD)v12 != v13 >> 63 )
      return 0;
    v4 = v13;
  }
  if ( *((_QWORD *)v5 + 1) - *(_QWORD *)v5 <= v4 )
  {
    v14 = (signed int)v5[4];
    if ( v4 <= v14 )
    {
      *(_QWORD *)v5 += v4;
      result = 1;
      v5[4] = v14 - v4;
      return result;
    }
  }
  return 0;
}

//----- (0000000140010738) ----------------------------------------------------
signed __int64 __usercall sub_140010738@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  __int64 v5; // rdi
  unsigned int v6; // ebp
  __int64 v7; // r14
  __int64 v8; // rbx
  signed __int64 result; // rax
  int v10; // esi

  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = a2;
  if ( (*(_DWORD *)(a2 + 20) >> 13) & 1 )
  {
    _InterlockedAnd((volatile signed __int32 *)(a2 + 20), 0xFFFFFFF7);
    v10 = 0;
    if ( sub_140010650(a1, (_DWORD *)a2, a3, a5) )
    {
      result = 0i64;
    }
    else
    {
      if ( v6 == 1 )
      {
        v7 += sub_14001901C(v8, v5);
        v6 = 0;
      }
      sub_140017568(v5, v8, a5);
      *(_QWORD *)v8 = *(_QWORD *)(v8 + 8);
      *(_DWORD *)(v8 + 16) = 0;
      if ( (*(_DWORD *)(v8 + 20) >> 2) & 1 )
      {
        _InterlockedAnd((volatile signed __int32 *)(v8 + 20), 0xFFFFFFFC);
      }
      else if ( (*(_BYTE *)(v8 + 20) & 0x41) == 65 && !((*(_WORD *)(v8 + 20) >> 8) & 1) )
      {
        *(_DWORD *)(v8 + 32) = 512;
      }
      LOBYTE(v10) = sub_14001C7F0(*(unsigned int *)(v8 + 24), v7, v6) != -1;
      result = (unsigned int)(v10 - 1);
    }
  }
  else
  {
    *(_BYTE *)(a4 + 48) = 1;
    result = 0xFFFFFFFFi64;
    *(_DWORD *)(a4 + 44) = 22;
  }
  return result;
}
// 14001901C: using guessed type __int64 __fastcall sub_14001901C(_QWORD, _QWORD);
// 14001C7F0: using guessed type __int64 __fastcall sub_14001C7F0(_QWORD, _QWORD, _QWORD);

//----- (0000000140010824) ----------------------------------------------------
__int64 __usercall sub_140010824@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, unsigned int a3@<r8d>, __m256i *a4@<ymm0>)
{
  unsigned int v4; // edi
  int v5; // ebx
  int v6; // ebx
  __int64 v8; // [rsp+20h] [rbp-40h]
  char v9; // [rsp+30h] [rbp-30h]
  __int128 v10; // [rsp+38h] [rbp-28h]
  char v11; // [rsp+48h] [rbp-18h]
  int v12; // [rsp+4Ch] [rbp-14h]
  char v13; // [rsp+50h] [rbp-10h]
  int v14; // [rsp+54h] [rbp-Ch]
  char v15; // [rsp+58h] [rbp-8h]

  v8 = 0i64;
  v9 = 0;
  v11 = 0;
  v13 = 0;
  v15 = 0;
  if ( !dword_140040924 )
  {
    v11 = 1;
    _mm_storeu_si128((__m128i *)&v10, off_14003E2C8);
  }
  v4 = sub_1400105B4(a1, a2, a3, (__int64)&v8, a4);
  if ( v11 == 2 )
    *(_DWORD *)(v8 + 936) &= 0xFFFFFFFD;
  if ( v13 )
  {
    v5 = v12;
    *(_DWORD *)(sub_14001009C(&v8, a4) + 32) = v5;
  }
  if ( v15 )
  {
    v6 = v14;
    *(_DWORD *)(sub_14001009C(&v8, a4) + 36) = v6;
  }
  return v4;
}
// 140040924: using guessed type int dword_140040924;

//----- (00000001400108BC) ----------------------------------------------------
unsigned __int64 __usercall sub_1400108BC@<rax>(__int64 *a1@<rdx>, char ***a2@<r8>, __int64 *a3@<r9>, __m256i *a4@<ymm0>)
{
  __int64 *v4; // rbx
  char ***v5; // rdi
  unsigned __int64 v6; // rdi

  v4 = a3;
  v5 = a2;
  sub_1400151DC(*a1);
  v6 = sub_1400108FC(v5, a4);
  sub_1400151E8(*v4);
  return v6;
}

//----- (00000001400108FC) ----------------------------------------------------
unsigned __int64 __usercall sub_1400108FC@<rax>(char ***a1@<rcx>, __m256i *a2@<ymm0>)
{
  char ***v2; // rbx
  __int64 v3; // rsi
  __int64 v4; // rbp
  char v5; // di
  unsigned __int64 v6; // rbx

  v2 = a1;
  v3 = (__int64)a1[1];
  v4 = (__int64)**a1;
  v5 = sub_14001D9C4(**a1, a2);
  v6 = sub_140010A18(
         (unsigned __int64)*v2[3],
         (__m128i *)*v2[2],
         (unsigned __int64)*v2[4],
         (__int64)**v2,
         a2,
         (__int64)v2[1]);
  sub_14001DA8C(v4, v5, v3, a2);
  return v6;
}

//----- (000000014001097C) ----------------------------------------------------
unsigned __int64 __usercall sub_14001097C@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>, __int64 a6)
{
  __int64 v6; // rax
  signed __int64 *v7; // ST28_8
  __int64 v9; // [rsp+38h] [rbp-38h]
  __int64 v10; // [rsp+40h] [rbp-30h]
  __int64 *v11; // [rsp+48h] [rbp-28h]
  __int64 v12; // [rsp+50h] [rbp-20h]
  __int64 *v13; // [rsp+58h] [rbp-18h]
  __int64 *v14; // [rsp+60h] [rbp-10h]
  __int64 *v15; // [rsp+68h] [rbp-8h]
  __int64 v16; // [rsp+80h] [rbp+10h]
  __int64 v17; // [rsp+88h] [rbp+18h]
  __int64 v18; // [rsp+90h] [rbp+20h]
  __int64 v19; // [rsp+98h] [rbp+28h]

  v19 = a4;
  v18 = a3;
  v17 = a1;
  v16 = a2;
  if ( !a1 || !a3 )
    return 0i64;
  if ( !a4 )
  {
    v6 = a6;
    v7 = (signed __int64 *)a6;
    *(_BYTE *)(a6 + 48) = 1;
    *(_DWORD *)(v6 + 44) = 22;
    sub_14001ACE8(0i64, a5, 0i64, v7);
    return 0i64;
  }
  v9 = a4;
  v11 = &v19;
  v12 = a6;
  v10 = a4;
  v13 = &v16;
  v14 = &v17;
  v15 = &v18;
  return sub_1400108BC(&v10, (char ***)&v11, &v9, a5);
}

//----- (0000000140010A18) ----------------------------------------------------
unsigned __int64 __usercall sub_140010A18@<rax>(unsigned __int64 a1@<rdx>, __m128i *a2@<rcx>, unsigned __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>, __int64 a6)
{
  __int64 v6; // rbx
  unsigned __int64 v7; // r12
  unsigned __int64 v8; // rbp
  __m128i *v9; // r13
  __int64 v10; // rax
  unsigned int v12; // er15
  unsigned __int64 v13; // rdi
  unsigned __int64 v14; // rsi
  bool i; // zf
  int v16; // eax
  unsigned __int64 v17; // r14
  unsigned __int64 v18; // rax
  unsigned int v19; // er14
  int v20; // eax
  unsigned int v21; // eax
  unsigned int v22; // ecx
  signed __int64 *v23; // [rsp+28h] [rbp-30h]
  unsigned int v24; // [rsp+68h] [rbp+10h]

  v6 = a4;
  v7 = a3;
  v8 = a1;
  v9 = a2;
  if ( !a1 || !a3 )
    return 0i64;
  if ( !a4 )
    goto LABEL_44;
  if ( !a2 )
  {
    v10 = a6;
    v23 = (signed __int64 *)a6;
    goto LABEL_5;
  }
  if ( a3 > 0xFFFFFFFFFFFFFFFFui64 / a1 )
  {
LABEL_44:
    v10 = a6;
    v23 = (signed __int64 *)a6;
LABEL_5:
    *(_BYTE *)(v10 + 48) = 1;
    *(_DWORD *)(v10 + 44) = 22;
    sub_14001ACE8(0i64, a5, 0i64, v23);
    return 0i64;
  }
  if ( *(_DWORD *)(a4 + 20) & 0x4C0 )
    v12 = *(_DWORD *)(a4 + 32);
  else
    v12 = 4096;
  v13 = a3 * a1;
  v14 = a3 * a1;
  for ( i = a3 * a1 == 0; !i; i = v14 == 0 )
  {
    if ( *(_DWORD *)(v6 + 20) & 0xC0 && (v16 = *(_DWORD *)(v6 + 16)) != 0 )
    {
      if ( v16 < 0 )
        goto LABEL_34;
      if ( *(_DWORD *)(v6 + 20) & 1 )
        return (v13 - v14) / v8;
      v17 = v14;
      if ( v14 >= *(signed int *)(v6 + 16) )
        v17 = *(signed int *)(v6 + 16);
      sub_14000CA50(*(__m128i **)v6, v9, v17);
      *(_DWORD *)(v6 + 16) -= v17;
      v14 -= v17;
      *(_QWORD *)v6 += v17;
    }
    else if ( v14 < v12 )
    {
      if ( (unsigned int)sub_14001D8AC(v6, v9->m128i_i64[0], a6, a5) == -1 )
        return (v13 - v14) / v8;
      v12 = *(_DWORD *)(v6 + 32);
      --v14;
      if ( (signed int)v12 <= 0 )
        v12 = 1;
      v17 = 1i64;
    }
    else
    {
      if ( *(_DWORD *)(v6 + 20) & 0xC0 && (unsigned int)sub_140017568(a6, v6, a5) )
        return (v13 - v14) / v8;
      v18 = v14;
      if ( v12 )
        v18 = v14 - v14 % v12;
      v19 = -2;
      if ( v18 < 0xFFFFFFFE )
        v19 = v18;
      v24 = v19;
      v20 = sub_14001A924(v6, a5);
      v21 = sub_14001D310((unsigned __int16 *)v9, v20, v19, a6, a5);
      if ( v21 == -1 )
        goto LABEL_34;
      v22 = v21;
      if ( v21 > v19 )
        v22 = v19;
      v17 = v22;
      v14 -= v22;
      if ( v21 < v24 )
      {
LABEL_34:
        _InterlockedOr((volatile signed __int32 *)(v6 + 20), 0x10u);
        return (v13 - v14) / v8;
      }
    }
    v9 = (__m128i *)((char *)v9 + v17);
  }
  return v7;
}

//----- (0000000140010C2C) ----------------------------------------------------
unsigned __int64 __usercall sub_140010C2C@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  unsigned __int64 v5; // rdi
  int v6; // ebx
  int v7; // ebx
  __int64 v9; // [rsp+30h] [rbp-40h]
  char v10; // [rsp+40h] [rbp-30h]
  __int128 v11; // [rsp+48h] [rbp-28h]
  char v12; // [rsp+58h] [rbp-18h]
  int v13; // [rsp+5Ch] [rbp-14h]
  char v14; // [rsp+60h] [rbp-10h]
  int v15; // [rsp+64h] [rbp-Ch]
  char v16; // [rsp+68h] [rbp-8h]

  v9 = 0i64;
  v10 = 0;
  v12 = 0;
  v14 = 0;
  v16 = 0;
  if ( !dword_140040924 )
  {
    v12 = 1;
    _mm_storeu_si128((__m128i *)&v11, off_14003E2C8);
  }
  v5 = sub_14001097C(a1, a2, a3, a4, a5, (__int64)&v9);
  if ( v12 == 2 )
    *(_DWORD *)(v9 + 936) &= 0xFFFFFFFD;
  if ( v14 )
  {
    v6 = v13;
    *(_DWORD *)(sub_14001009C(&v9, a5) + 32) = v6;
  }
  if ( v16 )
  {
    v7 = v15;
    *(_DWORD *)(sub_14001009C(&v9, a5) + 36) = v7;
  }
  return v5;
}
// 140040924: using guessed type int dword_140040924;

//----- (0000000140010CD0) ----------------------------------------------------
char __fastcall sub_140010CD0(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  char result; // al
  char v5; // di
  unsigned __int64 v6; // rsi
  LPVOID v7; // rbx

  v3 = a1;
  if ( a2 <= 0x7FFFFFFFFFFFFFFFi64 )
  {
    v5 = 0;
    v6 = 2 * a2;
    if ( (*(_QWORD *)(a1 + 1032) || v6 > 0x400) && v6 > *(_QWORD *)(a1 + 1024) )
    {
      v7 = sub_14001DACC(2 * a2);
      if ( v7 )
      {
        sub_14001AE1C(*(LPVOID *)(v3 + 1032));
        *(_QWORD *)(v3 + 1032) = v7;
        v5 = 1;
        *(_QWORD *)(v3 + 1024) = v6;
      }
      sub_14001AE1C(0i64);
      result = v5;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    *(_BYTE *)(a3 + 48) = 1;
    result = 0;
    *(_DWORD *)(a3 + 44) = 12;
  }
  return result;
}

//----- (0000000140010D78) ----------------------------------------------------
char __fastcall sub_140010D78(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  char result; // al
  char v5; // di
  unsigned __int64 v6; // rsi
  LPVOID v7; // rbx

  v3 = a1;
  if ( a2 <= 0x3FFFFFFFFFFFFFFFi64 )
  {
    v5 = 0;
    v6 = 4 * a2;
    if ( (*(_QWORD *)(a1 + 1032) || v6 > 0x400) && v6 > *(_QWORD *)(a1 + 1024) )
    {
      v7 = sub_14001DACC(4 * a2);
      if ( v7 )
      {
        sub_14001AE1C(*(LPVOID *)(v3 + 1032));
        *(_QWORD *)(v3 + 1032) = v7;
        v5 = 1;
        *(_QWORD *)(v3 + 1024) = v6;
      }
      sub_14001AE1C(0i64);
      result = v5;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    *(_BYTE *)(a3 + 48) = 1;
    result = 0;
    *(_DWORD *)(a3 + 44) = 12;
  }
  return result;
}

//----- (0000000140010E24) ----------------------------------------------------
bool __fastcall sub_140010E24(char a1, __int16 a2, int a3)
{
  __int64 v3; // rcx
  bool result; // al

  if ( a3 == 2 )
    return 0;
  if ( a3 == 3 || a3 == 12 || a3 == 13 )
    return 1;
  v3 = a1 & 4;
  result = (_DWORD)v3 != 0;
  if ( (a2 - 99) & 0xFFEF )
    result = v3 == 0;
  return result;
}

//----- (0000000140010E64) ----------------------------------------------------
signed __int64 __usercall sub_140010E64@<rax>(char **a1@<rdx>, __int64 a2@<rcx>, signed int a3@<r8d>, unsigned __int8 a4@<r9b>, __m256i *a5@<ymm0>)
{
  char *v5; // r12
  unsigned int v6; // ebp
  char **v7; // rbx
  __int64 v8; // r13
  char **v9; // rcx
  char v10; // si
  char *v11; // rcx
  unsigned int v12; // er14
  int v13; // edi
  int v14; // eax
  char v15; // dl
  signed int v16; // eax
  signed int v17; // eax
  char *v18; // r8
  unsigned int v19; // er9
  unsigned int v20; // ecx
  unsigned int v21; // edx
  BOOL v22; // ecx
  bool v23; // cf
  bool v24; // zf
  char **v25; // rax
  signed __int64 result; // rax
  signed int v27; // eax
  signed int v28; // ecx
  int v29; // edi
  char **v30; // rdx
  char **v31; // rax

  v5 = *a1;
  v6 = a3;
  v7 = a1;
  v8 = a2;
  if ( !*a1 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
    goto LABEL_6;
  }
  if ( a3 && (unsigned int)(a3 - 2) > 0x22 )
  {
    *(_BYTE *)(a2 + 48) = 1;
    *(_DWORD *)(a2 + 44) = 22;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)a2);
LABEL_6:
    v9 = (char **)v7[1];
    if ( v9 )
      *v9 = *v7;
    return 0i64;
  }
  v10 = *v5;
  v11 = v5 + 1;
  v12 = 0;
  *a1 = v5 + 1;
  v13 = a4 | 2;
  if ( v10 != 45 )
    v13 = a4;
  if ( v10 == 45 || v10 == 43 )
  {
    v10 = *v11;
    v11 = v5 + 2;
    *a1 = v5 + 2;
  }
  if ( !(a3 & 0xFFFFFFEF) )
  {
    if ( (unsigned __int8)(v10 - 48) > 9u )
    {
      if ( (unsigned __int8)(v10 - 97) > 0x19u )
      {
        if ( (unsigned __int8)(v10 - 65) > 0x19u )
          goto LABEL_28;
        v14 = v10 - 55;
      }
      else
      {
        v14 = v10 - 87;
      }
    }
    else
    {
      v14 = v10 - 48;
    }
    if ( !v14 )
    {
      v15 = *v11;
      *v7 = v11 + 1;
      if ( (v15 - 88) & 0xDF )
      {
        *v7 = v11;
        v16 = 8;
        if ( a3 )
          v16 = a3;
        v6 = v16;
        if ( v15 && *v11 != v15 )
        {
          *(_DWORD *)sub_140015334() = 22;
          sub_14001ADB4(a5);
        }
        goto LABEL_32;
      }
      v10 = v11[1];
      *v7 = v11 + 2;
      v17 = 16;
      goto LABEL_29;
    }
LABEL_28:
    v17 = 10;
LABEL_29:
    if ( a3 )
      v17 = a3;
    v6 = v17;
  }
LABEL_32:
  v18 = *v7;
  v19 = 0xFFFFFFFF / v6;
  while ( 1 )
  {
    if ( (unsigned __int8)(v10 - 48) > 9u )
    {
      if ( (unsigned __int8)(v10 - 97) > 0x19u )
        v20 = (unsigned __int8)(v10 - 65) > 0x19u ? -1 : v10 - 55;
      else
        v20 = v10 - 87;
    }
    else
    {
      v20 = v10 - 48;
    }
    if ( v20 >= v6 )
      break;
    v10 = *v18;
    v21 = v6 * v12 + v20;
    v22 = v21 < v6 * v12;
    v23 = v12 < v19;
    v24 = v12 == v19;
    v12 = v21;
    v13 |= 4 * (!v23 && !v24 || v22) | 8;
    *v7 = ++v18;
  }
  *v7 = v18 - 1;
  if ( v10 && *(v18 - 1) != v10 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
  }
  if ( !(v13 & 8) )
  {
    v25 = (char **)v7[1];
    *v7 = v5;
    if ( v25 )
      *v25 = v5;
    return 0i64;
  }
  if ( v13 & 4 )
  {
    v27 = 1;
    v28 = v13;
    goto LABEL_57;
  }
  if ( !(v13 & 1) )
  {
    if ( !(v13 & 2) )
      goto LABEL_68;
    goto LABEL_67;
  }
  if ( !(v13 & 2) )
  {
    if ( v12 <= 0x7FFFFFFF )
    {
LABEL_68:
      v31 = (char **)v7[1];
      if ( v31 )
        *v31 = *v7;
      return v12;
    }
    goto LABEL_56;
  }
  if ( v12 <= 0x80000000 )
  {
LABEL_67:
    v12 = -v12;
    goto LABEL_68;
  }
LABEL_56:
  v28 = 1;
  v27 = v13;
LABEL_57:
  v29 = v13 & 2;
  *(_BYTE *)(v8 + 48) = 1;
  *(_DWORD *)(v8 + 44) = 34;
  if ( !(v28 & v27) )
  {
    v12 = -1;
    goto LABEL_68;
  }
  v30 = (char **)v7[1];
  if ( v29 )
  {
    if ( v30 )
      *v30 = *v7;
    result = 0x80000000i64;
  }
  else
  {
    if ( v30 )
      *v30 = *v7;
    result = 0x7FFFFFFFi64;
  }
  return result;
}

//----- (0000000140011118) ----------------------------------------------------
signed __int64 __usercall sub_140011118@<rax>(__int16 **a1@<rdx>, __int64 a2@<rcx>, unsigned int a3@<r8d>, unsigned __int8 a4@<r9b>, __m256i *a5@<ymm0>)
{
  unsigned __int16 *v5; // r12
  unsigned int v6; // er15
  unsigned __int16 **v7; // rdi
  unsigned __int16 **v8; // rcx
  unsigned __int16 v9; // bx
  unsigned int v10; // er14
  int v11; // esi
  signed int v12; // ecx
  int v13; // eax
  int v14; // ecx
  unsigned int v15; // eax
  bool v16; // cf
  bool v17; // zf
  unsigned int v18; // eax
  __int16 *v19; // rcx
  __int16 v20; // dx
  unsigned __int16 *v21; // r8
  signed int v22; // eax
  signed int v23; // eax
  unsigned int v24; // er9
  unsigned int v25; // ecx
  signed int v26; // eax
  int v27; // ecx
  unsigned __int16 *v28; // r8
  unsigned int v29; // edx
  BOOL v30; // ecx
  unsigned __int16 **v31; // rax
  signed __int64 result; // rax
  signed int v33; // eax
  signed int v34; // ecx
  unsigned __int16 **v35; // rdx
  unsigned __int16 **v36; // rdx
  unsigned __int16 *v37; // [rsp+98h] [rbp-40h]
  __int64 v38; // [rsp+E0h] [rbp+8h]

  v38 = a2;
  v5 = (unsigned __int16 *)*a1;
  v37 = (unsigned __int16 *)*a1;
  v6 = a3;
  v7 = (unsigned __int16 **)a1;
  if ( !*a1 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
    goto LABEL_6;
  }
  if ( a3 && a3 - 2 > 0x22 )
  {
    *(_BYTE *)(a2 + 48) = 1;
    *(_DWORD *)(a2 + 44) = 22;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)a2);
LABEL_6:
    v8 = (unsigned __int16 **)v7[1];
    if ( v8 )
      *v8 = *v7;
    return 0i64;
  }
  v9 = *v5;
  v10 = 0;
  *a1 = (__int16 *)(v5 + 1);
  v11 = a4 | 2;
  if ( v9 != 45 )
    v11 = a4;
  if ( !((v9 - 43) & 0xFFFD) )
  {
    v9 = v5[1];
    *a1 = (__int16 *)(v5 + 2);
  }
  v12 = 48;
  if ( a3 & 0xFFFFFFEF )
    goto LABEL_73;
  if ( v9 >= 0x30u )
  {
    if ( v9 < 0x3Au )
    {
LABEL_15:
      v13 = v9 - v12;
      goto LABEL_55;
    }
    if ( v9 >= 0xFF10u )
    {
      if ( v9 < 0xFF1Au )
      {
        v13 = v9 - 65296;
LABEL_55:
        if ( v13 != -1 )
          goto LABEL_61;
        goto LABEL_56;
      }
    }
    else if ( v9 >= 0x660u )
    {
      if ( v9 < 0x66Au )
      {
        v13 = v9 - 1632;
        goto LABEL_55;
      }
      if ( v9 >= 0x6F0u )
      {
        if ( v9 < 0x6FAu )
        {
          v13 = v9 - 1776;
          goto LABEL_55;
        }
        if ( v9 >= 0x966u )
        {
          if ( v9 < 0x970u )
          {
            v13 = v9 - 2406;
            goto LABEL_55;
          }
          if ( v9 >= 0x9E6u )
          {
            if ( v9 < 0x9F0u )
            {
              v13 = v9 - 2534;
              goto LABEL_55;
            }
            v12 = 2662;
            if ( v9 >= 0xA66u )
            {
              if ( v9 < 0xA70u )
                goto LABEL_15;
              v12 = 2790;
              if ( v9 >= 0xAE6u )
              {
                if ( v9 < 0xAF0u )
                  goto LABEL_15;
                v12 = 2918;
                if ( v9 >= 0xB66u )
                {
                  if ( v9 < 0xB70u )
                    goto LABEL_15;
                  v12 = 3174;
                  if ( v9 >= 0xC66u )
                  {
                    if ( v9 < 0xC70u )
                      goto LABEL_15;
                    v12 = 3302;
                    if ( v9 >= 0xCE6u )
                    {
                      if ( v9 < 0xCF0u )
                        goto LABEL_15;
                      v12 = 3430;
                      if ( v9 >= 0xD66u )
                      {
                        if ( v9 < 0xD70u )
                          goto LABEL_15;
                        v12 = 3664;
                        if ( v9 >= 0xE50u )
                        {
                          if ( v9 < 0xE5Au )
                            goto LABEL_15;
                          v12 = 3792;
                          if ( v9 >= 0xED0u )
                          {
                            if ( v9 < 0xEDAu )
                              goto LABEL_15;
                            v12 = 3872;
                            if ( v9 >= 0xF20u )
                            {
                              if ( v9 < 0xF2Au )
                                goto LABEL_15;
                              v12 = 4160;
                              if ( v9 >= 0x1040u )
                              {
                                if ( v9 < 0x104Au )
                                  goto LABEL_15;
                                v12 = 6112;
                                if ( v9 >= 0x17E0u )
                                {
                                  if ( v9 < 0x17EAu )
                                    goto LABEL_15;
                                  v12 = 6160;
                                  if ( (unsigned __int16)(v9 - 6160) <= 9u )
                                    goto LABEL_15;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_56:
  v14 = v9;
  v15 = v9 - 65;
  v16 = v15 < 0x19;
  v17 = v15 == 25;
  v18 = v9 - 97;
  if ( !v16 && !v17 && v18 > 0x19 )
    goto LABEL_69;
  if ( v18 <= 0x19 )
    v14 = v9 - 32;
  v13 = v14 - 55;
LABEL_61:
  if ( v13 )
  {
LABEL_69:
    v23 = 10;
    goto LABEL_70;
  }
  v19 = *a1;
  v20 = **a1;
  v21 = *v7 + 1;
  *v7 = v21;
  if ( !((v20 - 88) & 0xFFDF) )
  {
    v9 = *v21;
    *v7 = v21 + 1;
    v23 = 16;
LABEL_70:
    if ( v6 )
      v23 = v6;
    v6 = v23;
    goto LABEL_73;
  }
  *v7 = (unsigned __int16 *)v19;
  v22 = 8;
  if ( v6 )
    v22 = v6;
  v6 = v22;
  if ( v20 && *v19 != v20 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
  }
LABEL_73:
  v24 = 0xFFFFFFFF / v6;
  while ( 1 )
  {
    if ( v9 >= 0x30u )
    {
      if ( v9 < 0x3Au )
      {
        v25 = v9 - 48;
        goto LABEL_114;
      }
      if ( v9 >= 0xFF10u )
      {
        if ( v9 < 0xFF1Au )
        {
          v25 = v9 - 65296;
LABEL_114:
          if ( v25 != -1 )
            goto LABEL_123;
          goto LABEL_115;
        }
      }
      else if ( v9 >= 0x660u )
      {
        if ( v9 < 0x66Au )
        {
          v25 = v9 - 1632;
          goto LABEL_114;
        }
        v26 = 1776;
        if ( v9 >= 0x6F0u )
        {
          if ( v9 < 0x6FAu )
            goto LABEL_83;
          v26 = 2406;
          if ( v9 >= 0x966u )
          {
            if ( v9 < 0x970u )
              goto LABEL_83;
            v26 = 2534;
            if ( v9 >= 0x9E6u )
            {
              if ( v9 < 0x9F0u )
                goto LABEL_83;
              v26 = 2662;
              if ( v9 >= 0xA66u )
              {
                if ( v9 < 0xA70u )
                  goto LABEL_83;
                v26 = 2790;
                if ( v9 >= 0xAE6u )
                {
                  if ( v9 < 0xAF0u )
                    goto LABEL_83;
                  v26 = 2918;
                  if ( v9 >= 0xB66u )
                  {
                    if ( v9 < 0xB70u )
                      goto LABEL_83;
                    v26 = 3174;
                    if ( v9 >= 0xC66u )
                    {
                      if ( v9 < 0xC70u )
                        goto LABEL_83;
                      v26 = 3302;
                      if ( v9 >= 0xCE6u )
                      {
                        if ( v9 < 0xCF0u )
                          goto LABEL_83;
                        v26 = 3430;
                        if ( v9 >= 0xD66u )
                        {
                          if ( v9 < 0xD70u )
                            goto LABEL_83;
                          v26 = 3664;
                          if ( v9 >= 0xE50u )
                          {
                            if ( v9 < 0xE5Au )
                              goto LABEL_83;
                            v26 = 3792;
                            if ( v9 >= 0xED0u )
                            {
                              if ( v9 < 0xEDAu )
                                goto LABEL_83;
                              v26 = 3872;
                              if ( v9 >= 0xF20u )
                              {
                                if ( v9 < 0xF2Au )
                                  goto LABEL_83;
                                v26 = 4160;
                                if ( v9 >= 0x1040u )
                                {
                                  if ( v9 < 0x104Au )
                                    goto LABEL_83;
                                  v26 = 6112;
                                  if ( v9 >= 0x17E0u )
                                  {
                                    if ( v9 < 0x17EAu )
                                    {
LABEL_83:
                                      v25 = v9 - v26;
                                      goto LABEL_114;
                                    }
                                    if ( (unsigned __int16)(v9 - 6160) <= 9u )
                                    {
                                      v25 = v9 - 6160;
                                      goto LABEL_114;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_115:
    if ( ((v27 = v9, v9 < 0x41u) || v9 > 0x5Au) && (v9 < 0x61u || v9 > 0x7Au) )
    {
      v25 = -1;
    }
    else
    {
      if ( (unsigned __int16)(v9 - 97) <= 0x19u )
        v27 = v9 - 32;
      v25 = v27 - 55;
    }
LABEL_123:
    v28 = *v7;
    if ( v25 >= v6 )
      break;
    v9 = *v28;
    v29 = v6 * v10 + v25;
    v30 = v29 < v6 * v10;
    v16 = v10 < v24;
    v17 = v10 == v24;
    v10 = v29;
    *v7 = v28 + 1;
    v11 |= 4 * (!v16 && !v17 || v30) | 8;
  }
  *v7 = v28 - 1;
  if ( v9 && *(v28 - 1) != v9 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
  }
  if ( v11 & 8 )
  {
    if ( v11 & 4 )
    {
      v33 = 1;
      v34 = v11;
LABEL_140:
      *(_BYTE *)(v38 + 48) = 1;
      *(_DWORD *)(v38 + 44) = 34;
      if ( v34 & v33 )
      {
        v35 = (unsigned __int16 **)v7[1];
        if ( v11 & 2 )
        {
          if ( v35 )
            *v35 = *v7;
          result = 0x80000000i64;
        }
        else
        {
          if ( v35 )
            *v35 = *v7;
          result = 0x7FFFFFFFi64;
        }
        return result;
      }
      v10 = -1;
LABEL_151:
      v36 = (unsigned __int16 **)v7[1];
      if ( v36 )
        *v36 = *v7;
      return v10;
    }
    if ( v11 & 1 )
    {
      if ( !(v11 & 2) )
      {
        if ( v10 <= 0x7FFFFFFF )
          goto LABEL_151;
        goto LABEL_139;
      }
      if ( v10 > 0x80000000 )
      {
LABEL_139:
        v34 = 1;
        v33 = v11;
        goto LABEL_140;
      }
    }
    else if ( !(v11 & 2) )
    {
      goto LABEL_151;
    }
    v10 = -v10;
    goto LABEL_151;
  }
  v31 = (unsigned __int16 **)v7[1];
  *v7 = v37;
  if ( v31 )
    *v31 = v37;
  return 0i64;
}

//----- (0000000140011890) ----------------------------------------------------
char __usercall sub_140011890@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  signed int v2; // er8
  __int64 v3; // rbx
  int v4; // er8
  int v5; // er8
  int v6; // er8
  unsigned int v7; // edx
  signed __int64 v8; // rdi
  signed __int64 *v9; // rcx
  signed __int64 v10; // rsi
  unsigned __int16 *v11; // rcx
  unsigned __int8 *v12; // rcx
  int v13; // er8
  int v14; // er8
  __int64 v15; // rax
  unsigned int *v17; // rcx
  __int64 v18; // r8

  v2 = *(_DWORD *)(a1 + 52);
  v3 = a1;
  if ( v2 > 5 )
  {
    v13 = v2 - 6;
    if ( v13 )
    {
      v14 = v13 - 1;
      if ( v14 )
      {
        v5 = v14 - 2;
        if ( v5 )
          goto LABEL_6;
      }
    }
  }
  else if ( v2 != 5 )
  {
    if ( !v2 )
      goto LABEL_25;
    v4 = v2 - 1;
    if ( !v4 )
    {
      v7 = *(_DWORD *)(a1 + 40);
      v8 = 1i64;
      v12 = *(unsigned __int8 **)(a1 + 24);
      *(_QWORD *)(v3 + 24) = v12 + 8;
      if ( (v7 >> 4) & 1 )
        v10 = (char)*v12;
      else
        v10 = *v12;
      goto LABEL_9;
    }
    v5 = v4 - 1;
    if ( !v5 )
    {
      v7 = *(_DWORD *)(a1 + 40);
      v8 = 2i64;
      v11 = *(unsigned __int16 **)(a1 + 24);
      *(_QWORD *)(v3 + 24) = v11 + 4;
      if ( (v7 >> 4) & 1 )
        v10 = (signed __int16)*v11;
      else
        v10 = *v11;
      goto LABEL_9;
    }
LABEL_6:
    v6 = v5 - 1;
    if ( v6 )
    {
      if ( v6 != 1 )
      {
        v15 = *(_QWORD *)(a1 + 8);
        *(_BYTE *)(v15 + 48) = 1;
        *(_DWORD *)(v15 + 44) = 22;
        sub_14001ACE8(0i64, a2, 0i64, *(signed __int64 **)(a1 + 8));
        return 0;
      }
      goto LABEL_8;
    }
LABEL_25:
    v7 = *(_DWORD *)(a1 + 40);
    v8 = 4i64;
    v17 = *(unsigned int **)(a1 + 24);
    *(_QWORD *)(v3 + 24) = v17 + 2;
    if ( (v7 >> 4) & 1 )
      v10 = (signed int)*v17;
    else
      v10 = *v17;
    goto LABEL_9;
  }
LABEL_8:
  v7 = *(_DWORD *)(a1 + 40);
  v8 = 8i64;
  v9 = *(signed __int64 **)(a1 + 24);
  *(_QWORD *)(v3 + 24) = v9 + 1;
  v10 = *v9;
LABEL_9:
  if ( (v7 >> 4) & 1 && v10 < 0 )
  {
    v10 = -v10;
    v7 |= 0x40u;
    *(_DWORD *)(v3 + 40) = v7;
  }
  if ( *(_DWORD *)(v3 + 48) >= 0 )
  {
    v18 = *(_QWORD *)(v3 + 8);
    *(_DWORD *)(v3 + 40) = v7 & 0xFFFFFFF7;
    sub_140010CD0(v3 + 80, *(signed int *)(v3 + 48), v18);
  }
  else
  {
    *(_DWORD *)(v3 + 48) = 1;
  }
  if ( !v10 )
    *(_DWORD *)(v3 + 40) &= 0xFFFFFFDF;
  *(_BYTE *)(v3 + 76) = 0;
  if ( v8 == 8 )
    sub_140012844(v3, v10);
  else
    sub_1400124C0(v3, v10);
  if ( (*(_DWORD *)(v3 + 40) >> 7) & 1 && (!*(_DWORD *)(v3 + 72) || **(_BYTE **)(v3 + 64) != 48) )
  {
    *(_BYTE *)--*(_QWORD *)(v3 + 64) = 48;
    ++*(_DWORD *)(v3 + 72);
  }
  return 1;
}

//----- (0000000140011A94) ----------------------------------------------------
char __usercall sub_140011A94@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  signed int v2; // er8
  __int64 v3; // rbx
  int v4; // er8
  int v5; // er8
  int v6; // er8
  unsigned int v7; // edx
  signed __int64 v8; // rdi
  signed __int64 *v9; // rcx
  signed __int64 v10; // rsi
  unsigned __int16 *v11; // rcx
  unsigned __int8 *v12; // rcx
  int v13; // er8
  int v14; // er8
  __int64 v15; // rax
  unsigned int *v17; // rcx
  __int64 v18; // r8

  v2 = *(_DWORD *)(a1 + 52);
  v3 = a1;
  if ( v2 > 5 )
  {
    v13 = v2 - 6;
    if ( v13 )
    {
      v14 = v13 - 1;
      if ( v14 )
      {
        v5 = v14 - 2;
        if ( v5 )
          goto LABEL_6;
      }
    }
  }
  else if ( v2 != 5 )
  {
    if ( !v2 )
      goto LABEL_25;
    v4 = v2 - 1;
    if ( !v4 )
    {
      v7 = *(_DWORD *)(a1 + 40);
      v8 = 1i64;
      v12 = *(unsigned __int8 **)(a1 + 24);
      *(_QWORD *)(v3 + 24) = v12 + 8;
      if ( (v7 >> 4) & 1 )
        v10 = (char)*v12;
      else
        v10 = *v12;
      goto LABEL_9;
    }
    v5 = v4 - 1;
    if ( !v5 )
    {
      v7 = *(_DWORD *)(a1 + 40);
      v8 = 2i64;
      v11 = *(unsigned __int16 **)(a1 + 24);
      *(_QWORD *)(v3 + 24) = v11 + 4;
      if ( (v7 >> 4) & 1 )
        v10 = (signed __int16)*v11;
      else
        v10 = *v11;
      goto LABEL_9;
    }
LABEL_6:
    v6 = v5 - 1;
    if ( v6 )
    {
      if ( v6 != 1 )
      {
        v15 = *(_QWORD *)(a1 + 8);
        *(_BYTE *)(v15 + 48) = 1;
        *(_DWORD *)(v15 + 44) = 22;
        sub_14001ACE8(0i64, a2, 0i64, *(signed __int64 **)(a1 + 8));
        return 0;
      }
      goto LABEL_8;
    }
LABEL_25:
    v7 = *(_DWORD *)(a1 + 40);
    v8 = 4i64;
    v17 = *(unsigned int **)(a1 + 24);
    *(_QWORD *)(v3 + 24) = v17 + 2;
    if ( (v7 >> 4) & 1 )
      v10 = (signed int)*v17;
    else
      v10 = *v17;
    goto LABEL_9;
  }
LABEL_8:
  v7 = *(_DWORD *)(a1 + 40);
  v8 = 8i64;
  v9 = *(signed __int64 **)(a1 + 24);
  *(_QWORD *)(v3 + 24) = v9 + 1;
  v10 = *v9;
LABEL_9:
  if ( (v7 >> 4) & 1 && v10 < 0 )
  {
    v10 = -v10;
    v7 |= 0x40u;
    *(_DWORD *)(v3 + 40) = v7;
  }
  if ( *(_DWORD *)(v3 + 48) >= 0 )
  {
    v18 = *(_QWORD *)(v3 + 8);
    *(_DWORD *)(v3 + 40) = v7 & 0xFFFFFFF7;
    sub_140010D78(v3 + 80, *(signed int *)(v3 + 48), v18);
  }
  else
  {
    *(_DWORD *)(v3 + 48) = 1;
  }
  if ( !v10 )
    *(_DWORD *)(v3 + 40) &= 0xFFFFFFDF;
  *(_BYTE *)(v3 + 76) = 1;
  if ( v8 == 8 )
    sub_1400128B4(v3, v10);
  else
    sub_140012530(v3, v10);
  if ( (*(_DWORD *)(v3 + 40) >> 7) & 1 && (!*(_DWORD *)(v3 + 72) || **(_WORD **)(v3 + 64) != 48) )
  {
    *(_QWORD *)(v3 + 64) -= 2i64;
    **(_WORD **)(v3 + 64) = 48;
    ++*(_DWORD *)(v3 + 72);
  }
  return 1;
}

//----- (0000000140011CA0) ----------------------------------------------------
char __usercall sub_140011CA0@<al>(char a1@<dl>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  signed int v3; // er8
  char v4; // bp
  __int64 v5; // rbx
  int v6; // er8
  int v7; // er8
  int v8; // er8
  unsigned int v9; // edx
  signed __int64 v10; // rdi
  signed __int64 *v11; // rcx
  signed __int64 v12; // rsi
  unsigned __int16 *v13; // rcx
  unsigned __int8 *v14; // rcx
  int v15; // er8
  int v16; // er8
  __int64 v17; // rax
  unsigned int *v19; // rcx
  __int64 v20; // r8

  v3 = *(_DWORD *)(a2 + 52);
  v4 = a1;
  v5 = a2;
  if ( v3 > 5 )
  {
    v15 = v3 - 6;
    if ( v15 )
    {
      v16 = v15 - 1;
      if ( v16 )
      {
        v7 = v16 - 2;
        if ( v7 )
          goto LABEL_6;
      }
    }
  }
  else if ( v3 != 5 )
  {
    if ( !v3 )
      goto LABEL_25;
    v6 = v3 - 1;
    if ( !v6 )
    {
      v9 = *(_DWORD *)(a2 + 40);
      v10 = 1i64;
      v14 = *(unsigned __int8 **)(a2 + 24);
      *(_QWORD *)(v5 + 24) = v14 + 8;
      if ( (v9 >> 4) & 1 )
        v12 = (char)*v14;
      else
        v12 = *v14;
      goto LABEL_9;
    }
    v7 = v6 - 1;
    if ( !v7 )
    {
      v9 = *(_DWORD *)(a2 + 40);
      v10 = 2i64;
      v13 = *(unsigned __int16 **)(a2 + 24);
      *(_QWORD *)(v5 + 24) = v13 + 4;
      if ( (v9 >> 4) & 1 )
        v12 = (signed __int16)*v13;
      else
        v12 = *v13;
      goto LABEL_9;
    }
LABEL_6:
    v8 = v7 - 1;
    if ( v8 )
    {
      if ( v8 != 1 )
      {
        v17 = *(_QWORD *)(a2 + 8);
        *(_BYTE *)(v17 + 48) = 1;
        *(_DWORD *)(v17 + 44) = 22;
        sub_14001ACE8(0i64, a3, 0i64, *(signed __int64 **)(a2 + 8));
        return 0;
      }
      goto LABEL_8;
    }
LABEL_25:
    v9 = *(_DWORD *)(a2 + 40);
    v10 = 4i64;
    v19 = *(unsigned int **)(a2 + 24);
    *(_QWORD *)(v5 + 24) = v19 + 2;
    if ( (v9 >> 4) & 1 )
      v12 = (signed int)*v19;
    else
      v12 = *v19;
    goto LABEL_9;
  }
LABEL_8:
  v9 = *(_DWORD *)(a2 + 40);
  v10 = 8i64;
  v11 = *(signed __int64 **)(a2 + 24);
  *(_QWORD *)(v5 + 24) = v11 + 1;
  v12 = *v11;
LABEL_9:
  if ( (v9 >> 4) & 1 && v12 < 0 )
  {
    v12 = -v12;
    v9 |= 0x40u;
    *(_DWORD *)(v5 + 40) = v9;
  }
  if ( *(_DWORD *)(v5 + 48) >= 0 )
  {
    v20 = *(_QWORD *)(v5 + 8);
    *(_DWORD *)(v5 + 40) = v9 & 0xFFFFFFF7;
    sub_140010CD0(v5 + 80, *(signed int *)(v5 + 48), v20);
  }
  else
  {
    *(_DWORD *)(v5 + 48) = 1;
  }
  if ( !v12 )
    *(_DWORD *)(v5 + 40) &= 0xFFFFFFDF;
  *(_BYTE *)(v5 + 76) = 0;
  if ( v10 == 8 )
    sub_14001293C(v5, v12, v4);
  else
    sub_1400125B4(v5, v12, v4);
  if ( (*(_DWORD *)(v5 + 40) >> 7) & 1 && (!*(_DWORD *)(v5 + 72) || **(_BYTE **)(v5 + 64) != 48) )
  {
    *(_BYTE *)--*(_QWORD *)(v5 + 64) = 48;
    ++*(_DWORD *)(v5 + 72);
  }
  return 1;
}

//----- (0000000140011EA4) ----------------------------------------------------
char __usercall sub_140011EA4@<al>(char a1@<dl>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  signed int v3; // er8
  char v4; // bp
  __int64 v5; // rbx
  int v6; // er8
  int v7; // er8
  int v8; // er8
  unsigned int v9; // edx
  signed __int64 v10; // rdi
  signed __int64 *v11; // rcx
  signed __int64 v12; // rsi
  unsigned __int16 *v13; // rcx
  unsigned __int8 *v14; // rcx
  int v15; // er8
  int v16; // er8
  __int64 v17; // rax
  unsigned int *v19; // rcx
  __int64 v20; // r8

  v3 = *(_DWORD *)(a2 + 52);
  v4 = a1;
  v5 = a2;
  if ( v3 > 5 )
  {
    v15 = v3 - 6;
    if ( v15 )
    {
      v16 = v15 - 1;
      if ( v16 )
      {
        v7 = v16 - 2;
        if ( v7 )
          goto LABEL_6;
      }
    }
  }
  else if ( v3 != 5 )
  {
    if ( !v3 )
      goto LABEL_25;
    v6 = v3 - 1;
    if ( !v6 )
    {
      v9 = *(_DWORD *)(a2 + 40);
      v10 = 1i64;
      v14 = *(unsigned __int8 **)(a2 + 24);
      *(_QWORD *)(v5 + 24) = v14 + 8;
      if ( (v9 >> 4) & 1 )
        v12 = (char)*v14;
      else
        v12 = *v14;
      goto LABEL_9;
    }
    v7 = v6 - 1;
    if ( !v7 )
    {
      v9 = *(_DWORD *)(a2 + 40);
      v10 = 2i64;
      v13 = *(unsigned __int16 **)(a2 + 24);
      *(_QWORD *)(v5 + 24) = v13 + 4;
      if ( (v9 >> 4) & 1 )
        v12 = (signed __int16)*v13;
      else
        v12 = *v13;
      goto LABEL_9;
    }
LABEL_6:
    v8 = v7 - 1;
    if ( v8 )
    {
      if ( v8 != 1 )
      {
        v17 = *(_QWORD *)(a2 + 8);
        *(_BYTE *)(v17 + 48) = 1;
        *(_DWORD *)(v17 + 44) = 22;
        sub_14001ACE8(0i64, a3, 0i64, *(signed __int64 **)(a2 + 8));
        return 0;
      }
      goto LABEL_8;
    }
LABEL_25:
    v9 = *(_DWORD *)(a2 + 40);
    v10 = 4i64;
    v19 = *(unsigned int **)(a2 + 24);
    *(_QWORD *)(v5 + 24) = v19 + 2;
    if ( (v9 >> 4) & 1 )
      v12 = (signed int)*v19;
    else
      v12 = *v19;
    goto LABEL_9;
  }
LABEL_8:
  v9 = *(_DWORD *)(a2 + 40);
  v10 = 8i64;
  v11 = *(signed __int64 **)(a2 + 24);
  *(_QWORD *)(v5 + 24) = v11 + 1;
  v12 = *v11;
LABEL_9:
  if ( (v9 >> 4) & 1 && v12 < 0 )
  {
    v12 = -v12;
    v9 |= 0x40u;
    *(_DWORD *)(v5 + 40) = v9;
  }
  if ( *(_DWORD *)(v5 + 48) >= 0 )
  {
    v20 = *(_QWORD *)(v5 + 8);
    *(_DWORD *)(v5 + 40) = v9 & 0xFFFFFFF7;
    sub_140010D78(v5 + 80, *(signed int *)(v5 + 48), v20);
  }
  else
  {
    *(_DWORD *)(v5 + 48) = 1;
  }
  if ( !v12 )
    *(_DWORD *)(v5 + 40) &= 0xFFFFFFDF;
  *(_BYTE *)(v5 + 76) = 1;
  if ( v10 == 8 )
    sub_1400129EC(v5, v12, v4);
  else
    sub_140012660(v5, v12, v4);
  if ( (*(_DWORD *)(v5 + 40) >> 7) & 1 && (!*(_DWORD *)(v5 + 72) || **(_WORD **)(v5 + 64) != 48) )
  {
    *(_QWORD *)(v5 + 64) -= 2i64;
    **(_WORD **)(v5 + 64) = 48;
    ++*(_DWORD *)(v5 + 72);
  }
  return 1;
}

//----- (00000001400120B0) ----------------------------------------------------
char __usercall sub_1400120B0@<al>(char a1@<dl>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  signed int v3; // er8
  char v4; // bp
  __int64 v5; // rbx
  int v6; // er8
  int v7; // er8
  int v8; // er8
  unsigned int v9; // edx
  signed __int64 v10; // rdi
  signed __int64 *v11; // rcx
  signed __int64 v12; // rsi
  unsigned __int16 *v13; // rcx
  unsigned __int8 *v14; // rcx
  int v15; // er8
  int v16; // er8
  __int64 v17; // rax
  unsigned int *v19; // rcx
  __int64 v20; // r8

  v3 = *(_DWORD *)(a2 + 52);
  v4 = a1;
  v5 = a2;
  if ( v3 > 5 )
  {
    v15 = v3 - 6;
    if ( v15 )
    {
      v16 = v15 - 1;
      if ( v16 )
      {
        v7 = v16 - 2;
        if ( v7 )
          goto LABEL_6;
      }
    }
  }
  else if ( v3 != 5 )
  {
    if ( !v3 )
      goto LABEL_25;
    v6 = v3 - 1;
    if ( !v6 )
    {
      v9 = *(_DWORD *)(a2 + 40);
      v10 = 1i64;
      v14 = *(unsigned __int8 **)(a2 + 24);
      *(_QWORD *)(v5 + 24) = v14 + 8;
      if ( (v9 >> 4) & 1 )
        v12 = (char)*v14;
      else
        v12 = *v14;
      goto LABEL_9;
    }
    v7 = v6 - 1;
    if ( !v7 )
    {
      v9 = *(_DWORD *)(a2 + 40);
      v10 = 2i64;
      v13 = *(unsigned __int16 **)(a2 + 24);
      *(_QWORD *)(v5 + 24) = v13 + 4;
      if ( (v9 >> 4) & 1 )
        v12 = (signed __int16)*v13;
      else
        v12 = *v13;
      goto LABEL_9;
    }
LABEL_6:
    v8 = v7 - 1;
    if ( v8 )
    {
      if ( v8 != 1 )
      {
        v17 = *(_QWORD *)(a2 + 8);
        *(_BYTE *)(v17 + 48) = 1;
        *(_DWORD *)(v17 + 44) = 22;
        sub_14001ACE8(0i64, a3, 0i64, *(signed __int64 **)(a2 + 8));
        return 0;
      }
      goto LABEL_8;
    }
LABEL_25:
    v9 = *(_DWORD *)(a2 + 40);
    v10 = 4i64;
    v19 = *(unsigned int **)(a2 + 24);
    *(_QWORD *)(v5 + 24) = v19 + 2;
    if ( (v9 >> 4) & 1 )
      v12 = (signed int)*v19;
    else
      v12 = *v19;
    goto LABEL_9;
  }
LABEL_8:
  v9 = *(_DWORD *)(a2 + 40);
  v10 = 8i64;
  v11 = *(signed __int64 **)(a2 + 24);
  *(_QWORD *)(v5 + 24) = v11 + 1;
  v12 = *v11;
LABEL_9:
  if ( (v9 >> 4) & 1 && v12 < 0 )
  {
    v12 = -v12;
    v9 |= 0x40u;
    *(_DWORD *)(v5 + 40) = v9;
  }
  if ( *(_DWORD *)(v5 + 48) >= 0 )
  {
    v20 = *(_QWORD *)(v5 + 8);
    *(_DWORD *)(v5 + 40) = v9 & 0xFFFFFFF7;
    sub_140010CD0(v5 + 80, *(signed int *)(v5 + 48), v20);
  }
  else
  {
    *(_DWORD *)(v5 + 48) = 1;
  }
  if ( !v12 )
    *(_DWORD *)(v5 + 40) &= 0xFFFFFFDF;
  *(_BYTE *)(v5 + 76) = 0;
  if ( v10 == 8 )
    sub_140012AB0(v5, v12, v4);
  else
    sub_140012720(v5, v12, v4);
  if ( (*(_DWORD *)(v5 + 40) >> 7) & 1 && (!*(_DWORD *)(v5 + 72) || **(_BYTE **)(v5 + 64) != 48) )
  {
    *(_BYTE *)--*(_QWORD *)(v5 + 64) = 48;
    ++*(_DWORD *)(v5 + 72);
  }
  return 1;
}

//----- (00000001400122B4) ----------------------------------------------------
char __usercall sub_1400122B4@<al>(char a1@<dl>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  signed int v3; // er8
  char v4; // bp
  __int64 v5; // rbx
  int v6; // er8
  int v7; // er8
  int v8; // er8
  unsigned int v9; // edx
  signed __int64 v10; // rdi
  signed __int64 *v11; // rcx
  signed __int64 v12; // rsi
  unsigned __int16 *v13; // rcx
  unsigned __int8 *v14; // rcx
  int v15; // er8
  int v16; // er8
  __int64 v17; // rax
  unsigned int *v19; // rcx
  __int64 v20; // r8

  v3 = *(_DWORD *)(a2 + 52);
  v4 = a1;
  v5 = a2;
  if ( v3 > 5 )
  {
    v15 = v3 - 6;
    if ( v15 )
    {
      v16 = v15 - 1;
      if ( v16 )
      {
        v7 = v16 - 2;
        if ( v7 )
          goto LABEL_6;
      }
    }
  }
  else if ( v3 != 5 )
  {
    if ( !v3 )
      goto LABEL_25;
    v6 = v3 - 1;
    if ( !v6 )
    {
      v9 = *(_DWORD *)(a2 + 40);
      v10 = 1i64;
      v14 = *(unsigned __int8 **)(a2 + 24);
      *(_QWORD *)(v5 + 24) = v14 + 8;
      if ( (v9 >> 4) & 1 )
        v12 = (char)*v14;
      else
        v12 = *v14;
      goto LABEL_9;
    }
    v7 = v6 - 1;
    if ( !v7 )
    {
      v9 = *(_DWORD *)(a2 + 40);
      v10 = 2i64;
      v13 = *(unsigned __int16 **)(a2 + 24);
      *(_QWORD *)(v5 + 24) = v13 + 4;
      if ( (v9 >> 4) & 1 )
        v12 = (signed __int16)*v13;
      else
        v12 = *v13;
      goto LABEL_9;
    }
LABEL_6:
    v8 = v7 - 1;
    if ( v8 )
    {
      if ( v8 != 1 )
      {
        v17 = *(_QWORD *)(a2 + 8);
        *(_BYTE *)(v17 + 48) = 1;
        *(_DWORD *)(v17 + 44) = 22;
        sub_14001ACE8(0i64, a3, 0i64, *(signed __int64 **)(a2 + 8));
        return 0;
      }
      goto LABEL_8;
    }
LABEL_25:
    v9 = *(_DWORD *)(a2 + 40);
    v10 = 4i64;
    v19 = *(unsigned int **)(a2 + 24);
    *(_QWORD *)(v5 + 24) = v19 + 2;
    if ( (v9 >> 4) & 1 )
      v12 = (signed int)*v19;
    else
      v12 = *v19;
    goto LABEL_9;
  }
LABEL_8:
  v9 = *(_DWORD *)(a2 + 40);
  v10 = 8i64;
  v11 = *(signed __int64 **)(a2 + 24);
  *(_QWORD *)(v5 + 24) = v11 + 1;
  v12 = *v11;
LABEL_9:
  if ( (v9 >> 4) & 1 && v12 < 0 )
  {
    v12 = -v12;
    v9 |= 0x40u;
    *(_DWORD *)(v5 + 40) = v9;
  }
  if ( *(_DWORD *)(v5 + 48) >= 0 )
  {
    v20 = *(_QWORD *)(v5 + 8);
    *(_DWORD *)(v5 + 40) = v9 & 0xFFFFFFF7;
    sub_140010D78(v5 + 80, *(signed int *)(v5 + 48), v20);
  }
  else
  {
    *(_DWORD *)(v5 + 48) = 1;
  }
  if ( !v12 )
    *(_DWORD *)(v5 + 40) &= 0xFFFFFFDF;
  *(_BYTE *)(v5 + 76) = 1;
  if ( v10 == 8 )
    sub_140012B34(v5, v12, v4);
  else
    sub_1400127A4(v5, v12, v4);
  if ( (*(_DWORD *)(v5 + 40) >> 7) & 1 && (!*(_DWORD *)(v5 + 72) || **(_WORD **)(v5 + 64) != 48) )
  {
    *(_QWORD *)(v5 + 64) -= 2i64;
    **(_WORD **)(v5 + 64) = 48;
    ++*(_DWORD *)(v5 + 72);
  }
  return 1;
}

//----- (00000001400124C0) ----------------------------------------------------
signed __int64 __fastcall sub_1400124C0(__int64 a1, unsigned int a2)
{
  signed __int64 v2; // r8
  unsigned int v3; // er9
  signed __int64 v4; // rax
  signed __int64 v5; // rdx
  _BYTE *i; // r8
  int v7; // eax
  char v8; // al
  signed __int64 result; // rax

  v2 = a1 + 80;
  v3 = a2;
  if ( *(_QWORD *)(a1 + 1112) )
  {
    v2 = *(_QWORD *)(a1 + 1112);
    v4 = *(_QWORD *)(a1 + 1104) >> 1;
  }
  else
  {
    v4 = 512i64;
  }
  v5 = v4 + v2 - 1;
  *(_QWORD *)(a1 + 64) = v5;
  for ( i = (_BYTE *)(v4 + v2 - 1); ; i = *(_BYTE **)(a1 + 64) )
  {
    v7 = *(_DWORD *)(a1 + 48);
    if ( v7 <= 0 && !v3 )
      break;
    *(_DWORD *)(a1 + 48) = v7 - 1;
    v8 = v3 & 7;
    v3 >>= 3;
    *i = v8 + 48;
    --*(_QWORD *)(a1 + 64);
  }
  result = (signed __int64)(i + 1);
  *(_DWORD *)(a1 + 72) = v5 - *(_DWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = i + 1;
  return result;
}

//----- (0000000140012530) ----------------------------------------------------
signed __int64 __fastcall sub_140012530(__int64 a1, unsigned int a2)
{
  signed __int64 v2; // rax
  __int64 v3; // r8
  signed __int64 v4; // rcx
  signed __int64 v5; // rax
  signed __int64 v6; // rcx
  signed __int64 v7; // rax
  _WORD *i; // r11
  int v9; // er10
  char v10; // r9
  signed __int64 v11; // rcx
  signed __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 1112);
  v3 = a1;
  v4 = a1 + 80;
  if ( v2 )
  {
    v4 = v2;
    v5 = *(_QWORD *)(v3 + 1104) >> 2;
  }
  else
  {
    v5 = 256i64;
  }
  v6 = v4 + 2 * v5 - 2;
  *(_QWORD *)(v3 + 64) = v6;
  v7 = v6;
  for ( i = (_WORD *)v6; ; i = *(_WORD **)(v3 + 64) )
  {
    v9 = *(_DWORD *)(v3 + 48);
    v10 = a2;
    if ( v9 <= 0 && !a2 )
      break;
    a2 >>= 3;
    *(_DWORD *)(v3 + 48) = v9 - 1;
    *i = (v10 & 7) + 48;
    *(_QWORD *)(v3 + 64) -= 2i64;
    v7 = *(_QWORD *)(v3 + 64);
  }
  v11 = v6 - v7;
  result = v7 + 2;
  *(_DWORD *)(v3 + 72) = v11 >> 1;
  *(_QWORD *)(v3 + 64) = result;
  return result;
}

//----- (00000001400125B4) ----------------------------------------------------
signed __int64 __fastcall sub_1400125B4(__int64 a1, unsigned int a2, char a3)
{
  signed __int64 v3; // rax
  __int64 v4; // r9
  signed __int64 v5; // rcx
  char v6; // bl
  unsigned int v7; // er11
  signed __int64 v8; // rax
  signed __int64 v9; // r8
  _BYTE *i; // r10
  int v11; // eax
  unsigned int v12; // edx
  char v13; // r11
  char v14; // al
  char v15; // cl
  signed __int64 result; // rax

  v3 = *(_QWORD *)(a1 + 1112);
  v4 = a1;
  v5 = a1 + 80;
  v6 = a3;
  v7 = a2;
  if ( v3 )
  {
    v5 = v3;
    v8 = *(_QWORD *)(v4 + 1104) >> 1;
  }
  else
  {
    v8 = 512i64;
  }
  v9 = v8 + v5 - 1;
  *(_QWORD *)(v4 + 64) = v9;
  for ( i = (_BYTE *)(v8 + v5 - 1); ; i = *(_BYTE **)(v4 + 64) )
  {
    v11 = *(_DWORD *)(v4 + 48);
    if ( v11 <= 0 && !v7 )
      break;
    *(_DWORD *)(v4 + 48) = v11 - 1;
    v12 = v7 / 0xA;
    v13 = v7 % 0xA + 48;
    v14 = v13;
    v15 = v13;
    v7 = v12;
    if ( v14 > 57 )
      v14 = v15 + 32 * (v6 ^ 1) + 7;
    *i = v14;
    --*(_QWORD *)(v4 + 64);
  }
  result = (signed __int64)(i + 1);
  *(_DWORD *)(v4 + 72) = v9 - *(_DWORD *)(v4 + 64);
  *(_QWORD *)(v4 + 64) = i + 1;
  return result;
}

//----- (0000000140012660) ----------------------------------------------------
signed __int64 __fastcall sub_140012660(__int64 a1, unsigned int a2, char a3)
{
  signed __int64 v3; // rax
  __int64 v4; // r9
  signed __int64 v5; // rcx
  char v6; // bl
  unsigned int v7; // er10
  signed __int64 v8; // rax
  signed __int64 v9; // r8
  signed __int64 v10; // rax
  _WORD *i; // r11
  int v12; // ecx
  unsigned __int16 v13; // cx
  signed __int64 v14; // r8
  signed __int64 result; // rax

  v3 = *(_QWORD *)(a1 + 1112);
  v4 = a1;
  v5 = a1 + 80;
  v6 = a3;
  v7 = a2;
  if ( v3 )
  {
    v5 = v3;
    v8 = *(_QWORD *)(v4 + 1104) >> 2;
  }
  else
  {
    v8 = 256i64;
  }
  v9 = v5 + 2 * (v8 - 1);
  *(_QWORD *)(v4 + 64) = v9;
  v10 = v5 + 2 * (v8 - 1);
  for ( i = (_WORD *)v9; ; i = *(_WORD **)(v4 + 64) )
  {
    v12 = *(_DWORD *)(v4 + 48);
    if ( v12 <= 0 && !v7 )
      break;
    *(_DWORD *)(v4 + 48) = v12 - 1;
    v13 = v7 % 0xA + 48;
    v7 /= 0xAu;
    if ( v13 > 0x39u )
      LOBYTE(v13) = v13 + 32 * (v6 ^ 1) + 7;
    *i = (char)v13;
    *(_QWORD *)(v4 + 64) -= 2i64;
    v10 = *(_QWORD *)(v4 + 64);
  }
  v14 = (v9 - v10) >> 1;
  result = v10 + 2;
  *(_DWORD *)(v4 + 72) = v14;
  *(_QWORD *)(v4 + 64) = result;
  return result;
}

//----- (0000000140012720) ----------------------------------------------------
signed __int64 __fastcall sub_140012720(__int64 a1, unsigned int a2, char a3)
{
  signed __int64 v3; // r9
  char v4; // r11
  unsigned int v5; // er10
  signed __int64 v6; // rax
  signed __int64 v7; // rdx
  unsigned __int8 *i; // r8
  int v9; // eax
  char v10; // al
  unsigned __int8 v11; // al
  signed __int64 result; // rax

  v3 = a1 + 80;
  v4 = a3;
  v5 = a2;
  if ( *(_QWORD *)(a1 + 1112) )
  {
    v3 = *(_QWORD *)(a1 + 1112);
    v6 = *(_QWORD *)(a1 + 1104) >> 1;
  }
  else
  {
    v6 = 512i64;
  }
  v7 = v6 + v3 - 1;
  *(_QWORD *)(a1 + 64) = v7;
  for ( i = (unsigned __int8 *)(v6 + v3 - 1); ; i = *(unsigned __int8 **)(a1 + 64) )
  {
    v9 = *(_DWORD *)(a1 + 48);
    if ( v9 <= 0 && !v5 )
      break;
    *(_DWORD *)(a1 + 48) = v9 - 1;
    v10 = v5 & 0xF;
    v5 >>= 4;
    v11 = v10 + 48;
    if ( v11 > 0x39u )
      v11 += 32 * (v4 ^ 1) + 7;
    *i = v11;
    --*(_QWORD *)(a1 + 64);
  }
  result = (signed __int64)(i + 1);
  *(_DWORD *)(a1 + 72) = v7 - *(_DWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = i + 1;
  return result;
}

//----- (00000001400127A4) ----------------------------------------------------
signed __int64 __fastcall sub_1400127A4(__int64 a1, unsigned int a2, char a3)
{
  signed __int64 v3; // r9
  char v4; // r11
  unsigned int v5; // er10
  signed __int64 v6; // rax
  signed __int64 v7; // rdx
  signed __int64 v8; // rax
  _WORD *i; // r9
  int v10; // er8
  int v11; // eax
  __int16 v12; // r8
  unsigned __int16 v13; // r8
  signed __int64 v14; // rdx
  signed __int64 result; // rax

  v3 = a1 + 80;
  v4 = a3;
  v5 = a2;
  if ( *(_QWORD *)(a1 + 1112) )
  {
    v3 = *(_QWORD *)(a1 + 1112);
    v6 = *(_QWORD *)(a1 + 1104) >> 2;
  }
  else
  {
    v6 = 256i64;
  }
  v7 = v3 + 2 * (v6 - 1);
  *(_QWORD *)(a1 + 64) = v7;
  v8 = v3 + 2 * (v6 - 1);
  for ( i = (_WORD *)v7; ; i = *(_WORD **)(a1 + 64) )
  {
    v10 = *(_DWORD *)(a1 + 48);
    if ( v10 <= 0 && !v5 )
      break;
    v11 = v10 - 1;
    v12 = v5 & 0xF;
    v5 >>= 4;
    v13 = v12 + 48;
    *(_DWORD *)(a1 + 48) = v11;
    if ( v13 > 0x39u )
      v13 = (unsigned __int8)(v13 + 32 * (v4 ^ 1) + 7);
    *i = v13;
    *(_QWORD *)(a1 + 64) -= 2i64;
    v8 = *(_QWORD *)(a1 + 64);
  }
  v14 = v7 - v8;
  result = v8 + 2;
  *(_DWORD *)(a1 + 72) = v14 >> 1;
  *(_QWORD *)(a1 + 64) = result;
  return result;
}

//----- (0000000140012844) ----------------------------------------------------
signed __int64 __fastcall sub_140012844(__int64 a1, unsigned __int64 a2)
{
  signed __int64 v2; // r8
  unsigned __int64 v3; // r9
  signed __int64 v4; // rax
  signed __int64 v5; // rdx
  _BYTE *i; // r8
  int v7; // eax
  char v8; // al
  signed __int64 result; // rax

  v2 = a1 + 80;
  v3 = a2;
  if ( *(_QWORD *)(a1 + 1112) )
  {
    v2 = *(_QWORD *)(a1 + 1112);
    v4 = *(_QWORD *)(a1 + 1104) >> 1;
  }
  else
  {
    v4 = 512i64;
  }
  v5 = v4 + v2 - 1;
  *(_QWORD *)(a1 + 64) = v5;
  for ( i = (_BYTE *)(v4 + v2 - 1); ; i = *(_BYTE **)(a1 + 64) )
  {
    v7 = *(_DWORD *)(a1 + 48);
    if ( v7 <= 0 && !v3 )
      break;
    *(_DWORD *)(a1 + 48) = v7 - 1;
    v8 = v3 & 7;
    v3 >>= 3;
    *i = v8 + 48;
    --*(_QWORD *)(a1 + 64);
  }
  result = (signed __int64)(i + 1);
  *(_DWORD *)(a1 + 72) = v5 - *(_DWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = i + 1;
  return result;
}

//----- (00000001400128B4) ----------------------------------------------------
signed __int64 __fastcall sub_1400128B4(__int64 a1, unsigned __int64 a2)
{
  signed __int64 v2; // rax
  __int64 v3; // r8
  signed __int64 v4; // rcx
  signed __int64 v5; // rax
  signed __int64 v6; // rcx
  signed __int64 v7; // rax
  _WORD *i; // r11
  int v9; // er10
  char v10; // r9
  signed __int64 v11; // rcx
  signed __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 1112);
  v3 = a1;
  v4 = a1 + 80;
  if ( v2 )
  {
    v4 = v2;
    v5 = *(_QWORD *)(v3 + 1104) >> 2;
  }
  else
  {
    v5 = 256i64;
  }
  v6 = v4 + 2 * v5 - 2;
  *(_QWORD *)(v3 + 64) = v6;
  v7 = v6;
  for ( i = (_WORD *)v6; ; i = *(_WORD **)(v3 + 64) )
  {
    v9 = *(_DWORD *)(v3 + 48);
    v10 = a2;
    if ( v9 <= 0 && !a2 )
      break;
    a2 >>= 3;
    *(_DWORD *)(v3 + 48) = v9 - 1;
    *i = (v10 & 7) + 48;
    *(_QWORD *)(v3 + 64) -= 2i64;
    v7 = *(_QWORD *)(v3 + 64);
  }
  v11 = v6 - v7;
  result = v7 + 2;
  *(_DWORD *)(v3 + 72) = v11 >> 1;
  *(_QWORD *)(v3 + 64) = result;
  return result;
}

//----- (000000014001293C) ----------------------------------------------------
signed __int64 __fastcall sub_14001293C(__int64 a1, unsigned __int64 a2, char a3)
{
  signed __int64 v3; // rax
  __int64 v4; // r9
  signed __int64 v5; // rcx
  char v6; // bl
  unsigned __int64 v7; // r11
  signed __int64 v8; // rax
  signed __int64 v9; // r8
  _BYTE *i; // r10
  int v11; // eax
  unsigned __int64 v12; // rdx
  char v13; // r11
  char v14; // al
  char v15; // cl
  signed __int64 result; // rax

  v3 = *(_QWORD *)(a1 + 1112);
  v4 = a1;
  v5 = a1 + 80;
  v6 = a3;
  v7 = a2;
  if ( v3 )
  {
    v5 = v3;
    v8 = *(_QWORD *)(v4 + 1104) >> 1;
  }
  else
  {
    v8 = 512i64;
  }
  v9 = v8 + v5 - 1;
  *(_QWORD *)(v4 + 64) = v9;
  for ( i = (_BYTE *)(v8 + v5 - 1); ; i = *(_BYTE **)(v4 + 64) )
  {
    v11 = *(_DWORD *)(v4 + 48);
    if ( v11 <= 0 && !v7 )
      break;
    *(_DWORD *)(v4 + 48) = v11 - 1;
    v12 = (unsigned __int64)(v7 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
    v13 = v7 - 10 * v12 + 48;
    v14 = v13;
    v15 = v13;
    v7 = v12;
    if ( v14 > 57 )
      v14 = v15 + 32 * (v6 ^ 1) + 7;
    *i = v14;
    --*(_QWORD *)(v4 + 64);
  }
  result = (signed __int64)(i + 1);
  *(_DWORD *)(v4 + 72) = v9 - *(_DWORD *)(v4 + 64);
  *(_QWORD *)(v4 + 64) = i + 1;
  return result;
}

//----- (00000001400129EC) ----------------------------------------------------
signed __int64 __fastcall sub_1400129EC(__int64 a1, unsigned __int64 a2, char a3)
{
  signed __int64 v3; // rax
  __int64 v4; // r9
  signed __int64 v5; // rcx
  char v6; // bl
  unsigned __int64 v7; // r10
  signed __int64 v8; // rax
  signed __int64 v9; // r8
  signed __int64 v10; // rax
  _WORD *i; // r11
  int v12; // ecx
  unsigned __int16 v13; // cx
  signed __int64 v14; // r8
  signed __int64 result; // rax

  v3 = *(_QWORD *)(a1 + 1112);
  v4 = a1;
  v5 = a1 + 80;
  v6 = a3;
  v7 = a2;
  if ( v3 )
  {
    v5 = v3;
    v8 = *(_QWORD *)(v4 + 1104) >> 2;
  }
  else
  {
    v8 = 256i64;
  }
  v9 = v5 + 2 * (v8 - 1);
  *(_QWORD *)(v4 + 64) = v9;
  v10 = v5 + 2 * (v8 - 1);
  for ( i = (_WORD *)v9; ; i = *(_WORD **)(v4 + 64) )
  {
    v12 = *(_DWORD *)(v4 + 48);
    if ( v12 <= 0 && !v7 )
      break;
    *(_DWORD *)(v4 + 48) = v12 - 1;
    v13 = v7 - 10 * ((unsigned __int64)(v7 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3) + 48;
    v7 = (unsigned __int64)(v7 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
    if ( v13 > 0x39u )
      LOBYTE(v13) = v13 + 32 * (v6 ^ 1) + 7;
    *i = (char)v13;
    *(_QWORD *)(v4 + 64) -= 2i64;
    v10 = *(_QWORD *)(v4 + 64);
  }
  v14 = (v9 - v10) >> 1;
  result = v10 + 2;
  *(_DWORD *)(v4 + 72) = v14;
  *(_QWORD *)(v4 + 64) = result;
  return result;
}

//----- (0000000140012AB0) ----------------------------------------------------
signed __int64 __fastcall sub_140012AB0(__int64 a1, unsigned __int64 a2, char a3)
{
  signed __int64 v3; // r9
  char v4; // r11
  unsigned __int64 v5; // r10
  signed __int64 v6; // rax
  signed __int64 v7; // rdx
  unsigned __int8 *i; // r8
  int v9; // eax
  char v10; // al
  unsigned __int8 v11; // al
  signed __int64 result; // rax

  v3 = a1 + 80;
  v4 = a3;
  v5 = a2;
  if ( *(_QWORD *)(a1 + 1112) )
  {
    v3 = *(_QWORD *)(a1 + 1112);
    v6 = *(_QWORD *)(a1 + 1104) >> 1;
  }
  else
  {
    v6 = 512i64;
  }
  v7 = v6 + v3 - 1;
  *(_QWORD *)(a1 + 64) = v7;
  for ( i = (unsigned __int8 *)(v6 + v3 - 1); ; i = *(unsigned __int8 **)(a1 + 64) )
  {
    v9 = *(_DWORD *)(a1 + 48);
    if ( v9 <= 0 && !v5 )
      break;
    *(_DWORD *)(a1 + 48) = v9 - 1;
    v10 = v5 & 0xF;
    v5 >>= 4;
    v11 = v10 + 48;
    if ( v11 > 0x39u )
      v11 += 32 * (v4 ^ 1) + 7;
    *i = v11;
    --*(_QWORD *)(a1 + 64);
  }
  result = (signed __int64)(i + 1);
  *(_DWORD *)(a1 + 72) = v7 - *(_DWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = i + 1;
  return result;
}

//----- (0000000140012B34) ----------------------------------------------------
signed __int64 __fastcall sub_140012B34(__int64 a1, unsigned __int64 a2, char a3)
{
  signed __int64 v3; // r9
  char v4; // r11
  unsigned __int64 v5; // r10
  signed __int64 v6; // rax
  signed __int64 v7; // rdx
  signed __int64 v8; // rax
  _WORD *i; // r9
  int v10; // er8
  int v11; // eax
  __int16 v12; // r8
  unsigned __int16 v13; // r8
  signed __int64 v14; // rdx
  signed __int64 result; // rax

  v3 = a1 + 80;
  v4 = a3;
  v5 = a2;
  if ( *(_QWORD *)(a1 + 1112) )
  {
    v3 = *(_QWORD *)(a1 + 1112);
    v6 = *(_QWORD *)(a1 + 1104) >> 2;
  }
  else
  {
    v6 = 256i64;
  }
  v7 = v3 + 2 * (v6 - 1);
  *(_QWORD *)(a1 + 64) = v7;
  v8 = v3 + 2 * (v6 - 1);
  for ( i = (_WORD *)v7; ; i = *(_WORD **)(a1 + 64) )
  {
    v10 = *(_DWORD *)(a1 + 48);
    if ( v10 <= 0 && !v5 )
      break;
    v11 = v10 - 1;
    v12 = v5 & 0xF;
    v5 >>= 4;
    v13 = v12 + 48;
    *(_DWORD *)(a1 + 48) = v11;
    if ( v13 > 0x39u )
      v13 = (unsigned __int8)(v13 + 32 * (v4 ^ 1) + 7);
    *i = v13;
    *(_QWORD *)(a1 + 64) -= 2i64;
    v8 = *(_QWORD *)(a1 + 64);
  }
  v14 = v7 - v8;
  result = v8 + 2;
  *(_DWORD *)(a1 + 72) = v14 >> 1;
  *(_QWORD *)(a1 + 64) = result;
  return result;
}

//----- (0000000140012BD4) ----------------------------------------------------
char __fastcall sub_140012BD4(char *a1, __int64 a2)
{
  char v2; // r9
  char result; // al
  char v4; // dl
  _BYTE *v5; // rcx
  _BYTE *v6; // r8
  _BYTE *v7; // rdx
  signed __int64 v8; // r8

  v2 = ***(_BYTE ***)(*(_QWORD *)a2 + 248i64);
  result = *a1;
  if ( *a1 )
  {
    v4 = *a1;
    do
    {
      result = v4;
      if ( v4 == v2 )
        break;
      result = *++a1;
      v4 = *a1;
    }
    while ( *a1 );
  }
  v5 = a1 + 1;
  if ( result )
  {
    while ( *v5 && (*v5 - 69) & 0xDF )
      ++v5;
    v6 = v5;
    do
      --v5;
    while ( *v5 == 48 );
    v7 = v5 - 1;
    if ( *v5 != v2 )
      v7 = v5;
    v8 = v6 - v7;
    do
    {
      result = (v7++)[v8];
      *v7 = result;
    }
    while ( result );
  }
  return result;
}

//----- (0000000140012C40) ----------------------------------------------------
char __usercall sub_140012C40@<al>(_DWORD *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rbp
  __int64 v4; // rsi
  signed __int64 v5; // rax
  __int64 v6; // rbx
  char v7; // cl
  __int64 v8; // rax
  char result; // al
  __int64 v10; // [rsp+20h] [rbp-18h]
  unsigned __int64 *v11; // [rsp+28h] [rbp-10h]
  unsigned __int64 v12; // [rsp+40h] [rbp+8h]

  v3 = *(_QWORD *)(a2 + 8);
  v4 = a2;
  v5 = *(_QWORD *)(a2 + 16) - 1i64;
  v11 = &v12;
  v6 = *(_QWORD *)(v3 + 44);
  v12 = v5;
  v10 = v5;
  *a1 = sub_140010E64((char **)&v10, v3, 10, 1u, a3);
  v7 = 0;
  v8 = *(_QWORD *)(v4 + 8);
  if ( (!*(_BYTE *)(v8 + 48) || *(_DWORD *)(v8 + 44) != 34) && v12 >= *(_QWORD *)(v4 + 16) )
  {
    *(_QWORD *)(v4 + 16) = v12;
    v7 = 1;
  }
  result = v7;
  *(_QWORD *)(v3 + 44) = v6;
  return result;
}

//----- (0000000140012CD0) ----------------------------------------------------
char __usercall sub_140012CD0@<al>(_DWORD *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rbp
  __int64 v4; // rsi
  signed __int64 v5; // rax
  __int64 v6; // rbx
  char v7; // cl
  __int64 v8; // rax
  char result; // al
  __int64 v10; // [rsp+20h] [rbp-18h]
  unsigned __int64 *v11; // [rsp+28h] [rbp-10h]
  unsigned __int64 v12; // [rsp+40h] [rbp+8h]

  v3 = *(_QWORD *)(a2 + 8);
  v4 = a2;
  v5 = *(_QWORD *)(a2 + 16) - 2i64;
  v11 = &v12;
  v6 = *(_QWORD *)(v3 + 44);
  v12 = v5;
  v10 = v5;
  *a1 = sub_140011118((__int16 **)&v10, v3, 0xAu, 1u, a3);
  v7 = 0;
  v8 = *(_QWORD *)(v4 + 8);
  if ( (!*(_BYTE *)(v8 + 48) || *(_DWORD *)(v8 + 44) != 34) && v12 >= *(_QWORD *)(v4 + 16) )
  {
    *(_QWORD *)(v4 + 16) = v12;
    v7 = 1;
  }
  result = v7;
  *(_QWORD *)(v3 + 44) = v6;
  return result;
}

//----- (0000000140012D60) ----------------------------------------------------
signed __int64 __usercall sub_140012D60@<rax>(_QWORD *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __int64 v4; // rax
  __int64 v5; // rbx
  char *v6; // rcx
  int v8; // eax
  char v9; // r8
  unsigned __int8 v10; // cl
  unsigned __int64 v11; // rax
  char v12; // al
  _DWORD *v13; // rdx
  signed int *v14; // rcx
  signed int v15; // ecx
  int *v16; // rcx
  int v17; // eax
  __int64 v18; // rdi
  __int64 v19; // r8
  __int64 v20; // rcx
  _BYTE *v21; // rax
  __int64 v22; // rcx
  char *v23; // rax
  __int64 v24; // rax
  __int64 v25; // rax

  v4 = a1[1];
  v5 = (__int64)a1;
  if ( !a1[140] )
  {
    *(_BYTE *)(v4 + 48) = 1;
    *(_DWORD *)(v4 + 44) = 22;
LABEL_69:
    sub_14001ACE8(0i64, a3, 0i64, (signed __int64 *)v4);
    return 0xFFFFFFFFi64;
  }
  v6 = (char *)a1[2];
  if ( !v6 )
  {
    *(_BYTE *)(v4 + 48) = 1;
    *(_DWORD *)(v4 + 44) = 22;
    sub_14001ACE8(0i64, a3, 0i64, *(signed __int64 **)(v5 + 8));
    return 0xFFFFFFFFi64;
  }
  v8 = *(_DWORD *)(v5 + 1128) + 1;
  *(_DWORD *)(v5 + 1128) = v8;
  if ( v8 == 2 )
    return *(unsigned int *)(v5 + 32);
  while ( 2 )
  {
    *(_DWORD *)(v5 + 72) = 0;
    *(_BYTE *)(v5 + 36) = 0;
    v9 = *v6++;
    while ( 1 )
    {
      *(_QWORD *)(v5 + 16) = v6;
      *(_BYTE *)(v5 + 57) = v9;
      if ( !v9 || *(_DWORD *)(v5 + 32) < 0 )
        break;
      if ( (unsigned __int8)(v9 - 32) > 0x5Au )
        v10 = 0;
      else
        v10 = byte_1400323F0[2 * ((v9 - 32) & 0x7F) + 1];
      v11 = byte_1400323F0[2 * ((*(unsigned __int8 *)(v5 + 36) + 8 * v10) & 0x7F)];
      *(_BYTE *)(v5 + 36) = v11;
      if ( (unsigned __int8)v11 >= 8u )
        goto LABEL_68;
      if ( (_BYTE)v11 )
      {
        if ( (_DWORD)v11 == 1 )
        {
          *(_QWORD *)(v5 + 40) = 0i64;
          *(_BYTE *)(v5 + 56) = 0;
          *(_DWORD *)(v5 + 48) = -1;
          *(_DWORD *)(v5 + 52) = 0;
          *(_BYTE *)(v5 + 76) = 0;
          goto LABEL_62;
        }
        if ( (_DWORD)v11 == 2 )
        {
          switch ( v9 )
          {
            case 32:
              *(_DWORD *)(v5 + 40) |= 2u;
              break;
            case 35:
              *(_DWORD *)(v5 + 40) |= 0x20u;
              break;
            case 43:
              *(_DWORD *)(v5 + 40) |= 1u;
              break;
            case 45:
              *(_DWORD *)(v5 + 40) |= 4u;
              break;
            case 48:
              *(_DWORD *)(v5 + 40) |= 8u;
              break;
          }
          goto LABEL_62;
        }
        if ( (_DWORD)v11 == 3 )
        {
          if ( v9 != 42 )
          {
            v13 = (_DWORD *)(v5 + 44);
            goto LABEL_24;
          }
          v16 = *(int **)(v5 + 24);
          *(_QWORD *)(v5 + 24) = v16 + 2;
          v17 = *v16;
          *(_DWORD *)(v5 + 44) = *v16;
          if ( v17 < 0 )
          {
            *(_DWORD *)(v5 + 40) |= 4u;
            *(_DWORD *)(v5 + 44) = -v17;
          }
        }
        else
        {
          if ( (_DWORD)v11 == 4 )
          {
            *(_DWORD *)(v5 + 48) = 0;
            goto LABEL_62;
          }
          if ( (_DWORD)v11 != 5 )
          {
            if ( (_DWORD)v11 == 6 )
            {
              v12 = sub_1400133B8(v11, v5, a2, a3, a4);
            }
            else
            {
              if ( (_DWORD)v11 != 7 )
                return 0xFFFFFFFFi64;
              v12 = sub_1400136F0(v5, a2, a3, a4);
            }
LABEL_34:
            if ( !v12 )
              return 0xFFFFFFFFi64;
            goto LABEL_62;
          }
          if ( v9 != 42 )
          {
            v13 = (_DWORD *)(v5 + 48);
LABEL_24:
            v12 = sub_140012C40(v13, v5, a3);
            goto LABEL_34;
          }
          v14 = *(signed int **)(v5 + 24);
          *(_QWORD *)(v5 + 24) = v14 + 2;
          v15 = *v14;
          if ( v15 < 0 )
            v15 = -1;
          *(_DWORD *)(v5 + 48) = v15;
        }
        v12 = 1;
        goto LABEL_34;
      }
      v18 = *(_QWORD *)(v5 + 8);
      *(_BYTE *)(v5 + 76) = 0;
      if ( !*(_BYTE *)(v18 + 40) )
        sub_140014910((signed __int64 *)v18, a3);
      v19 = *(char *)(v5 + 57);
      if ( (signed int)v19 >= -1 && *(_WORD *)(**(_QWORD **)(v18 + 24) + 2 * v19) < 0 )
      {
        v20 = *(_QWORD *)(v5 + 1120);
        if ( *(_QWORD *)(v20 + 16) == *(_QWORD *)(v20 + 8) )
        {
          if ( *(_BYTE *)(v20 + 24) )
            ++*(_DWORD *)(v5 + 32);
          else
            *(_DWORD *)(v5 + 32) = -1;
        }
        else
        {
          ++*(_DWORD *)(v5 + 32);
          ++*(_QWORD *)(v20 + 16);
          *(_BYTE *)(**(_QWORD **)(v5 + 1120))++ = v19;
        }
        v21 = *(_BYTE **)(v5 + 16);
        LOBYTE(v19) = *v21;
        *(_QWORD *)(v5 + 16) = v21 + 1;
        *(_BYTE *)(v5 + 57) = v19;
        if ( !(_BYTE)v19 )
        {
          v24 = *(_QWORD *)(v5 + 8);
          *(_BYTE *)(v24 + 48) = 1;
          *(_DWORD *)(v24 + 44) = 22;
          sub_14001ACE8(0i64, a3, 0i64, *(signed __int64 **)(v5 + 8));
LABEL_68:
          v25 = *(_QWORD *)(v5 + 8);
          *(_BYTE *)(v25 + 48) = 1;
          *(_DWORD *)(v25 + 44) = 22;
          v4 = *(_QWORD *)(v5 + 8);
          goto LABEL_69;
        }
      }
      v22 = *(_QWORD *)(v5 + 1120);
      if ( *(_QWORD *)(v22 + 16) == *(_QWORD *)(v22 + 8) )
      {
        if ( *(_BYTE *)(v22 + 24) )
          ++*(_DWORD *)(v5 + 32);
        else
          *(_DWORD *)(v5 + 32) = -1;
      }
      else
      {
        ++*(_DWORD *)(v5 + 32);
        ++*(_QWORD *)(v22 + 16);
        *(_BYTE *)(**(_QWORD **)(v5 + 1120))++ = v19;
      }
LABEL_62:
      v23 = *(char **)(v5 + 16);
      v9 = *v23;
      v6 = v23 + 1;
    }
    if ( ++*(_DWORD *)(v5 + 1128) != 2 )
      continue;
    return *(unsigned int *)(v5 + 32);
  }
}

//----- (00000001400130E0) ----------------------------------------------------
signed __int64 __usercall sub_1400130E0@<rax>(_QWORD *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __int64 v4; // rax
  __int64 v5; // rbx
  __int16 *v6; // rcx
  int v8; // eax
  __int16 v9; // r8
  int v10; // er9
  unsigned __int8 v11; // cl
  int v12; // eax
  char v13; // al
  _DWORD *v14; // rdx
  signed int *v15; // rcx
  signed int v16; // ecx
  int *v17; // rcx
  int v18; // eax
  __int64 v19; // rcx
  __int16 *v20; // rax
  __int64 v21; // rax

  v4 = a1[1];
  v5 = (__int64)a1;
  if ( !a1[140] )
  {
    *(_BYTE *)(v4 + 48) = 1;
    *(_DWORD *)(v4 + 44) = 22;
LABEL_58:
    sub_14001ACE8(0i64, a3, 0i64, (signed __int64 *)v4);
    return 0xFFFFFFFFi64;
  }
  v6 = (__int16 *)a1[2];
  if ( !v6 )
  {
    *(_BYTE *)(v4 + 48) = 1;
    *(_DWORD *)(v4 + 44) = 22;
    sub_14001ACE8(0i64, a3, 0i64, *(signed __int64 **)(v5 + 8));
    return 0xFFFFFFFFi64;
  }
  v8 = *(_DWORD *)(v5 + 1128) + 1;
  *(_DWORD *)(v5 + 1128) = v8;
  if ( v8 == 2 )
    return *(unsigned int *)(v5 + 32);
  while ( 2 )
  {
    *(_DWORD *)(v5 + 72) = 0;
    *(_BYTE *)(v5 + 36) = 0;
    v9 = *v6;
    for ( ++v6; ; v6 = v20 + 1 )
    {
      *(_QWORD *)(v5 + 16) = v6;
      *(_WORD *)(v5 + 58) = v9;
      if ( !v9 )
        break;
      v10 = *(_DWORD *)(v5 + 32);
      if ( v10 < 0 )
        break;
      if ( (unsigned __int16)(v9 - 32) > 0x5Au )
        v11 = 0;
      else
        v11 = byte_1400323F0[2 * (((_BYTE)v9 - 32) & 0x7F) + 1];
      v12 = byte_1400323F0[2 * ((*(unsigned __int8 *)(v5 + 36) + 8 * v11) & 0x7F)];
      *(_BYTE *)(v5 + 36) = v12;
      if ( (unsigned __int8)v12 >= 8u )
      {
        v21 = *(_QWORD *)(v5 + 8);
        *(_BYTE *)(v21 + 48) = 1;
        *(_DWORD *)(v21 + 44) = 22;
        v4 = *(_QWORD *)(v5 + 8);
        goto LABEL_58;
      }
      if ( !(_BYTE)v12 )
      {
        *(_BYTE *)(v5 + 76) = 1;
        v19 = *(_QWORD *)(v5 + 1120);
        if ( *(_QWORD *)(v19 + 16) == *(_QWORD *)(v19 + 8) )
        {
          if ( *(_BYTE *)(v19 + 24) )
            *(_DWORD *)(v5 + 32) = v10 + 1;
          else
            *(_DWORD *)(v5 + 32) = -1;
        }
        else
        {
          *(_DWORD *)(v5 + 32) = v10 + 1;
          ++*(_QWORD *)(v19 + 16);
          ***(_WORD ***)(v5 + 1120) = v9;
          **(_QWORD **)(v5 + 1120) += 2i64;
        }
        goto LABEL_52;
      }
      switch ( v12 )
      {
        case 1:
          *(_QWORD *)(v5 + 40) = 0i64;
          *(_BYTE *)(v5 + 56) = 0;
          *(_DWORD *)(v5 + 48) = -1;
          *(_DWORD *)(v5 + 52) = 0;
          *(_BYTE *)(v5 + 76) = 0;
          goto LABEL_52;
        case 2:
          switch ( v9 )
          {
            case 32:
              *(_DWORD *)(v5 + 40) |= 2u;
              break;
            case 35:
              *(_DWORD *)(v5 + 40) |= 0x20u;
              break;
            case 43:
              *(_DWORD *)(v5 + 40) |= 1u;
              break;
            case 45:
              *(_DWORD *)(v5 + 40) |= 4u;
              break;
            case 48:
              *(_DWORD *)(v5 + 40) |= 8u;
              break;
          }
          goto LABEL_52;
        case 3:
          if ( v9 != 42 )
          {
            v14 = (_DWORD *)(v5 + 44);
            goto LABEL_24;
          }
          v17 = *(int **)(v5 + 24);
          *(_QWORD *)(v5 + 24) = v17 + 2;
          v18 = *v17;
          *(_DWORD *)(v5 + 44) = *v17;
          if ( v18 < 0 )
          {
            *(_DWORD *)(v5 + 40) |= 4u;
            *(_DWORD *)(v5 + 44) = -v18;
          }
          goto LABEL_33;
        case 4:
          *(_DWORD *)(v5 + 48) = 0;
          goto LABEL_52;
        case 5:
          if ( v9 != 42 )
          {
            v14 = (_DWORD *)(v5 + 48);
LABEL_24:
            v13 = sub_140012CD0(v14, v5, a3);
            break;
          }
          v15 = *(signed int **)(v5 + 24);
          *(_QWORD *)(v5 + 24) = v15 + 2;
          v16 = *v15;
          if ( v16 < 0 )
            v16 = -1;
          *(_DWORD *)(v5 + 48) = v16;
LABEL_33:
          v13 = 1;
          break;
        case 6:
          v13 = sub_140013540(v5, a2, a3, a4);
          break;
        case 7:
          v13 = sub_140013AF4(v5, a2, a3, a4);
          break;
        default:
          return 0xFFFFFFFFi64;
      }
      if ( !v13 )
        return 0xFFFFFFFFi64;
LABEL_52:
      v20 = *(__int16 **)(v5 + 16);
      v9 = *v20;
    }
    if ( ++*(_DWORD *)(v5 + 1128) != 2 )
      continue;
    return *(unsigned int *)(v5 + 32);
  }
}

//----- (00000001400133B8) ----------------------------------------------------
char __usercall sub_1400133B8@<al>(unsigned __int64 a1@<rax>, __int64 a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  char v5; // al
  __int64 v7; // rax
  _BYTE *v8; // rax
  signed int v9; // eax
  _BYTE *v10; // rax
  char *v11; // r8
  char v12; // al
  signed __int64 v13; // rdx

  v5 = *(_BYTE *)(a2 + 57);
  if ( v5 == 70 )
  {
    if ( !(*(_BYTE *)a2 & 8) )
    {
      *(_BYTE *)(a2 + 36) = 7;
      return sub_1400136F0(a2, a3, a4, a5);
    }
    return 1;
  }
  if ( v5 == 78 )
  {
    if ( !(*(_BYTE *)a2 & 8) )
    {
      *(_BYTE *)(a2 + 36) = 8;
LABEL_7:
      v7 = *(_QWORD *)(a2 + 8);
      *(_BYTE *)(v7 + 48) = 1;
      *(_DWORD *)(v7 + 44) = 22;
      sub_14001ACE8(0i64, a4, 0i64, *(signed __int64 **)(a2 + 8));
      return 0;
    }
  }
  else
  {
    if ( *(_DWORD *)(a2 + 52) )
      goto LABEL_7;
    switch ( v5 )
    {
      case 73:
        v11 = *(char **)(a2 + 16);
        v12 = *v11;
        if ( *v11 != 51 || v11[1] != 50 )
        {
          if ( v12 == 54 )
          {
            if ( v11[1] == 52 )
            {
              *(_DWORD *)(a2 + 52) = 11;
              *(_QWORD *)(a2 + 16) = v11 + 2;
            }
          }
          else
          {
            LOBYTE(a1) = v12 - 88;
            if ( (unsigned __int8)a1 <= 0x20u )
            {
              v13 = 4840361985i64;
              if ( _bittest64(&v13, a1) )
                *(_DWORD *)(a2 + 52) = 9;
            }
          }
        }
        else
        {
          *(_DWORD *)(a2 + 52) = 10;
          *(_QWORD *)(a2 + 16) = v11 + 2;
        }
        return 1;
      case 76:
        *(_DWORD *)(a2 + 52) = 8;
        return 1;
      case 84:
        *(_DWORD *)(a2 + 52) = 13;
        return 1;
      case 104:
        v10 = *(_BYTE **)(a2 + 16);
        if ( *v10 == 104 )
        {
          *(_QWORD *)(a2 + 16) = v10 + 1;
          v9 = 1;
        }
        else
        {
          v9 = 2;
        }
        break;
      case 106:
        *(_DWORD *)(a2 + 52) = 5;
        return 1;
      case 108:
        v8 = *(_BYTE **)(a2 + 16);
        if ( *v8 == 108 )
        {
          *(_QWORD *)(a2 + 16) = v8 + 1;
          v9 = 4;
        }
        else
        {
          v9 = 3;
        }
        break;
      default:
        switch ( v5 )
        {
          case 116:
            *(_DWORD *)(a2 + 52) = 7;
            break;
          case 119:
            *(_DWORD *)(a2 + 52) = 12;
            break;
          case 122:
            *(_DWORD *)(a2 + 52) = 6;
            break;
        }
        return 1;
    }
    *(_DWORD *)(a2 + 52) = v9;
  }
  return 1;
}

//----- (0000000140013540) ----------------------------------------------------
char __usercall sub_140013540@<al>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __int16 v4; // ax
  __int64 v6; // rax
  _WORD *v7; // rax
  signed int v8; // eax
  _WORD *v9; // rax
  unsigned __int16 *v10; // r8
  unsigned __int64 v11; // rax
  signed __int64 v12; // rdx

  v4 = *(_WORD *)(a1 + 58);
  if ( v4 == 70 )
  {
    if ( !(*(_BYTE *)a1 & 8) )
    {
      *(_BYTE *)(a1 + 36) = 7;
      return sub_140013AF4(a1, a2, a3, a4);
    }
    return 1;
  }
  if ( v4 == 78 )
  {
    if ( !(*(_BYTE *)a1 & 8) )
    {
      *(_BYTE *)(a1 + 36) = 8;
LABEL_7:
      v6 = *(_QWORD *)(a1 + 8);
      *(_BYTE *)(v6 + 48) = 1;
      *(_DWORD *)(v6 + 44) = 22;
      sub_14001ACE8(0i64, a3, 0i64, *(signed __int64 **)(a1 + 8));
      return 0;
    }
  }
  else
  {
    if ( *(_DWORD *)(a1 + 52) )
      goto LABEL_7;
    switch ( v4 )
    {
      case 73:
        v10 = *(unsigned __int16 **)(a1 + 16);
        v11 = *v10;
        if ( (_WORD)v11 != 51 || v10[1] != 50 )
        {
          if ( (_WORD)v11 == 54 )
          {
            if ( v10[1] == 52 )
            {
              *(_DWORD *)(a1 + 52) = 11;
              *(_QWORD *)(a1 + 16) = v10 + 2;
            }
          }
          else
          {
            LOWORD(v11) = v11 - 88;
            if ( (unsigned __int16)v11 <= 0x20u )
            {
              v12 = 4840361985i64;
              if ( _bittest64(&v12, v11) )
                *(_DWORD *)(a1 + 52) = 9;
            }
          }
        }
        else
        {
          *(_DWORD *)(a1 + 52) = 10;
          *(_QWORD *)(a1 + 16) = v10 + 2;
        }
        return 1;
      case 76:
        *(_DWORD *)(a1 + 52) = 8;
        return 1;
      case 84:
        *(_DWORD *)(a1 + 52) = 13;
        return 1;
      case 104:
        v9 = *(_WORD **)(a1 + 16);
        if ( *v9 == 104 )
        {
          *(_QWORD *)(a1 + 16) = v9 + 1;
          v8 = 1;
        }
        else
        {
          v8 = 2;
        }
        break;
      case 106:
        *(_DWORD *)(a1 + 52) = 5;
        return 1;
      case 108:
        v7 = *(_WORD **)(a1 + 16);
        if ( *v7 == 108 )
        {
          *(_QWORD *)(a1 + 16) = v7 + 1;
          v8 = 4;
        }
        else
        {
          v8 = 3;
        }
        break;
      default:
        switch ( v4 )
        {
          case 116:
            *(_DWORD *)(a1 + 52) = 7;
            break;
          case 119:
            *(_DWORD *)(a1 + 52) = 12;
            break;
          case 122:
            *(_DWORD *)(a1 + 52) = 6;
            break;
        }
        return 1;
    }
    *(_DWORD *)(a1 + 52) = v8;
  }
  return 1;
}

//----- (00000001400136F0) ----------------------------------------------------
char __usercall sub_1400136F0@<al>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  char v4; // di
  __int64 v5; // rbx
  signed int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  char v11; // al
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  char v16; // dl
  unsigned int v18; // ecx
  signed __int64 v19; // rdx
  char v20; // r8
  bool v21; // r9
  int v22; // esi
  int v23; // er9
  int v24; // er8
  __int64 v25; // rcx
  int v26; // er8
  int *v27; // rdi
  __int64 v28; // ST20_8
  signed __int64 v29; // r14
  int v30; // er8
  int v31; // edx
  _QWORD *v32; // rcx
  int v33; // edx
  unsigned __int16 *v34; // r12
  int v35; // er15
  __int64 v36; // rax
  unsigned __int16 v37; // r9
  __int64 v38; // ST20_8
  __int64 v39; // ST20_8
  int v40; // ecx
  int i; // er8
  __int64 v42; // rdx
  int v43; // ecx
  int v44; // [rsp+30h] [rbp-20h]
  char v45; // [rsp+34h] [rbp-1Ch]

  v4 = 120;
  v5 = a1;
  v6 = *(char *)(a1 + 57);
  if ( v6 <= 100 )
  {
    if ( v6 != 100 )
    {
      if ( v6 <= 83 )
      {
        if ( v6 != 83 )
        {
          v7 = v6 - 65;
          if ( v7 )
          {
            v8 = v7 - 2;
            if ( v8 )
            {
              v9 = v8 - 2;
              if ( v9 )
              {
                v10 = v9 - 1;
                if ( v10 )
                {
                  if ( v10 != 1 )
                    return 0;
                }
              }
              goto LABEL_10;
            }
            goto LABEL_15;
          }
LABEL_10:
          v11 = sub_140014054(v5, a3);
          goto LABEL_39;
        }
        goto LABEL_35;
      }
      if ( v6 != 88 )
      {
        switch ( v6 )
        {
          case 90:
            v11 = sub_140013F58(v5);
            goto LABEL_39;
          case 97:
            goto LABEL_10;
          case 99:
LABEL_15:
            v11 = sub_140014510(v5, a3);
            goto LABEL_39;
        }
        return 0;
      }
      goto LABEL_37;
    }
    goto LABEL_25;
  }
  if ( v6 > 111 )
  {
    if ( v6 == 112 )
    {
      *(_DWORD *)(v5 + 48) = 16;
      *(_DWORD *)(v5 + 52) = 11;
LABEL_37:
      v16 = 1;
LABEL_38:
      v11 = sub_1400120B0(v16, v5, a3);
      goto LABEL_39;
    }
    if ( v6 == 115 )
    {
LABEL_35:
      v11 = sub_140014760(v5, a2, a4);
      goto LABEL_39;
    }
    if ( v6 != 117 )
    {
      if ( v6 != 120 )
        return 0;
      v16 = 0;
      goto LABEL_38;
    }
LABEL_26:
    v11 = sub_140011CA0(0, v5, a3);
    goto LABEL_39;
  }
  if ( v6 != 111 )
  {
    v12 = v6 - 101;
    if ( !v12 )
      goto LABEL_10;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_10;
    v14 = v13 - 1;
    if ( !v14 )
      goto LABEL_10;
    v15 = v14 - 2;
    if ( v15 )
    {
      if ( v15 == 5 )
      {
        v11 = sub_1400146A8(v5, a3);
        goto LABEL_39;
      }
      return 0;
    }
LABEL_25:
    *(_DWORD *)(v5 + 40) |= 0x10u;
    goto LABEL_26;
  }
  if ( (*(_DWORD *)(v5 + 40) >> 5) & 1 )
    *(_DWORD *)(v5 + 40) |= 0x80u;
  v11 = sub_140011890(v5, a3);
LABEL_39:
  if ( !v11 )
    return 0;
  if ( !*(_BYTE *)(v5 + 56) )
  {
    v18 = *(_DWORD *)(v5 + 40);
    LOWORD(v44) = 0;
    v19 = 0i64;
    BYTE2(v44) = 0;
    if ( !((v18 >> 4) & 1) )
      goto LABEL_50;
    if ( (v18 >> 6) & 1 )
    {
      LOBYTE(v44) = 45;
    }
    else if ( v18 & 1 )
    {
      LOBYTE(v44) = 43;
    }
    else
    {
      if ( !((v18 >> 1) & 1) )
        goto LABEL_50;
      LOBYTE(v44) = 32;
    }
    v19 = 1i64;
LABEL_50:
    v20 = *(_BYTE *)(v5 + 57);
    v21 = !((v20 - 88) & 0xDF) && (v18 >> 5) & 1;
    if ( v21 || !((v20 - 65) & 0xDF) )
    {
      *((_BYTE *)&v44 + v19) = 48;
      if ( v20 == 88 || v20 == 65 )
        v4 = 88;
      *((_BYTE *)&v44 + v19 + 1) = v4;
      LODWORD(v19) = v19 + 2;
    }
    v22 = *(_DWORD *)(v5 + 44) - v19 - *(_DWORD *)(v5 + 72);
    if ( !(v18 & 0xC) )
    {
      v23 = 0;
      if ( v22 > 0 )
      {
        v24 = *(_DWORD *)(v5 + 32);
        do
        {
          v25 = *(_QWORD *)(v5 + 1120);
          if ( *(_QWORD *)(v25 + 16) == *(_QWORD *)(v25 + 8) )
          {
            if ( *(_BYTE *)(v25 + 24) )
              v26 = v24 + 1;
            else
              v26 = -1;
            *(_DWORD *)(v5 + 32) = v26;
          }
          else
          {
            *(_DWORD *)(v5 + 32) = v24 + 1;
            ++*(_QWORD *)(v25 + 16);
            *(_BYTE *)(**(_QWORD **)(v5 + 1120))++ = 32;
          }
          v24 = *(_DWORD *)(v5 + 32);
          if ( v24 == -1 )
            break;
          ++v23;
        }
        while ( v23 < v22 );
      }
    }
    v27 = (int *)(v5 + 32);
    v28 = *(_QWORD *)(v5 + 8);
    v29 = v5 + 1120;
    sub_140014988((_QWORD *)(v5 + 1120), (const __m128i *)&v44, v19, (_DWORD *)(v5 + 32));
    if ( (*(_DWORD *)(v5 + 40) >> 3) & 1 )
    {
      if ( !((*(_DWORD *)(v5 + 40) >> 2) & 1) )
      {
        v30 = 0;
        if ( v22 > 0 )
        {
          v31 = *v27;
          do
          {
            v32 = *(_QWORD **)v29;
            if ( *(_QWORD *)(*(_QWORD *)v29 + 16i64) == *(_QWORD *)(*(_QWORD *)v29 + 8i64) )
            {
              if ( *((_BYTE *)v32 + 24) )
                v33 = v31 + 1;
              else
                v33 = -1;
              *v27 = v33;
            }
            else
            {
              *v27 = v31 + 1;
              ++v32[2];
              *(_BYTE *)(**(_QWORD **)v29)++ = 48;
            }
            v31 = *v27;
            if ( *v27 == -1 )
              break;
            ++v30;
          }
          while ( v30 < v22 );
        }
      }
    }
    if ( *(_BYTE *)(v5 + 76) && *(_DWORD *)(v5 + 72) > 0 )
    {
      v34 = *(unsigned __int16 **)(v5 + 64);
      v35 = 0;
      while ( 1 )
      {
        v36 = *(_QWORD *)(v5 + 8);
        v37 = *v34;
        v44 = 0;
        ++v34;
        if ( (unsigned int)sub_14001ED28(&v45, &v44, 6ui64, v37, a3, v36) || !v44 )
          break;
        v38 = *(_QWORD *)(v5 + 8);
        sub_140014988((_QWORD *)(v5 + 1120), (const __m128i *)&v45, v44, (_DWORD *)(v5 + 32));
        if ( ++v35 == *(_DWORD *)(v5 + 72) )
          goto LABEL_92;
      }
      *v27 = -1;
    }
    else
    {
      v39 = *(_QWORD *)(v5 + 8);
      sub_140014988((_QWORD *)(v5 + 1120), *(const __m128i **)(v5 + 64), *(_DWORD *)(v5 + 72), (_DWORD *)(v5 + 32));
    }
LABEL_92:
    v40 = *v27;
    if ( *v27 >= 0 )
    {
      if ( (*(_DWORD *)(v5 + 40) >> 2) & 1 )
      {
        for ( i = 0; i < v22; ++i )
        {
          v42 = *(_QWORD *)v29;
          if ( *(_QWORD *)(*(_QWORD *)v29 + 16i64) == *(_QWORD *)(*(_QWORD *)v29 + 8i64) )
          {
            if ( *(_BYTE *)(v42 + 24) )
              v43 = v40 + 1;
            else
              v43 = -1;
            *v27 = v43;
          }
          else
          {
            *v27 = v40 + 1;
            ++*(_QWORD *)(v42 + 16);
            *(_BYTE *)(**(_QWORD **)v29)++ = 32;
          }
          v40 = *v27;
          if ( *v27 == -1 )
            break;
        }
      }
    }
  }
  return 1;
}

//----- (0000000140013AF4) ----------------------------------------------------
char __usercall sub_140013AF4@<al>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  signed __int16 v4; // di
  __int64 v5; // rbx
  unsigned int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  char v11; // al
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  char v16; // dl
  unsigned int v18; // ecx
  signed __int64 v19; // rdx
  signed __int16 v20; // ax
  __int16 v21; // r8
  char v22; // r9
  int v23; // esi
  int v24; // er9
  int v25; // er8
  __int64 v26; // rcx
  int v27; // er8
  int *v28; // rdi
  __int64 v29; // ST20_8
  signed __int64 v30; // r14
  int v31; // er8
  int v32; // edx
  _QWORD *v33; // rcx
  int v34; // edx
  __int64 v35; // rbp
  int v36; // er15
  CHAR *v37; // r12
  __int64 v38; // rax
  __int64 v39; // r9
  int v40; // eax
  __int64 v41; // rcx
  __int16 v42; // r8
  int v43; // ecx
  int i; // er8
  __int64 v45; // rdx
  int v46; // ecx
  __int64 v47; // ST20_8
  __int16 v48; // [rsp+30h] [rbp-48h]
  int v49; // [rsp+34h] [rbp-44h]
  __int16 v50; // [rsp+38h] [rbp-40h]

  v4 = 120;
  v5 = a1;
  v6 = *(unsigned __int16 *)(a1 + 58);
  if ( v6 <= 0x64 )
  {
    if ( v6 != 100 )
    {
      if ( v6 <= 0x53 )
      {
        if ( v6 != 83 )
        {
          v7 = v6 - 65;
          if ( v7 )
          {
            v8 = v7 - 2;
            if ( v8 )
            {
              v9 = v8 - 2;
              if ( v9 )
              {
                v10 = v9 - 1;
                if ( v10 )
                {
                  if ( v10 != 1 )
                    return 0;
                }
              }
              goto LABEL_10;
            }
            goto LABEL_15;
          }
LABEL_10:
          v11 = sub_1400142A8(v5, a3);
          goto LABEL_39;
        }
        goto LABEL_35;
      }
      if ( v6 != 88 )
      {
        switch ( v6 )
        {
          case 0x5Au:
            v11 = sub_140013FD4(v5);
            goto LABEL_39;
          case 0x61u:
            goto LABEL_10;
          case 0x63u:
LABEL_15:
            v11 = sub_1400145E4(v5, a3);
            goto LABEL_39;
        }
        return 0;
      }
      goto LABEL_37;
    }
    goto LABEL_25;
  }
  if ( v6 > 0x6F )
  {
    if ( v6 == 112 )
    {
      *(_DWORD *)(v5 + 48) = 16;
      *(_DWORD *)(v5 + 52) = 11;
LABEL_37:
      v16 = 1;
LABEL_38:
      v11 = sub_1400122B4(v16, v5, a3);
      goto LABEL_39;
    }
    if ( v6 == 115 )
    {
LABEL_35:
      v11 = sub_1400147FC(v5, a2, a3, a4);
      goto LABEL_39;
    }
    if ( v6 != 117 )
    {
      if ( v6 != 120 )
        return 0;
      v16 = 0;
      goto LABEL_38;
    }
LABEL_26:
    v11 = sub_140011EA4(0, v5, a3);
    goto LABEL_39;
  }
  if ( v6 != 111 )
  {
    v12 = v6 - 101;
    if ( !v12 )
      goto LABEL_10;
    v13 = v12 - 1;
    if ( !v13 )
      goto LABEL_10;
    v14 = v13 - 1;
    if ( !v14 )
      goto LABEL_10;
    v15 = v14 - 2;
    if ( v15 )
    {
      if ( v15 == 5 )
      {
        v11 = sub_1400146A8(v5, a3);
        goto LABEL_39;
      }
      return 0;
    }
LABEL_25:
    *(_DWORD *)(v5 + 40) |= 0x10u;
    goto LABEL_26;
  }
  if ( (*(_DWORD *)(v5 + 40) >> 5) & 1 )
    *(_DWORD *)(v5 + 40) |= 0x80u;
  v11 = sub_140011A94(v5, a3);
LABEL_39:
  if ( !v11 )
    return 0;
  if ( !*(_BYTE *)(v5 + 56) )
  {
    v18 = *(_DWORD *)(v5 + 40);
    v49 = 0;
    v19 = 0i64;
    v50 = 0;
    if ( !((v18 >> 4) & 1) )
      goto LABEL_51;
    if ( (v18 >> 6) & 1 )
    {
      v20 = 45;
    }
    else
    {
      if ( !(v18 & 1) )
      {
        if ( !((v18 >> 1) & 1) )
          goto LABEL_51;
        LOWORD(v49) = 32;
LABEL_50:
        v19 = 1i64;
LABEL_51:
        v21 = *(_WORD *)(v5 + 58);
        if ( (v21 - 88) & 0xFFDF || (v22 = 1, !((v18 >> 5) & 1)) )
          v22 = 0;
        if ( v22 || ((v21 - 65) & 0xFFDF) == 0 )
        {
          *((_WORD *)&v49 + v19) = 48;
          if ( v21 == 88 || v21 == 65 )
            v4 = 88;
          *((_WORD *)&v49 + v19 + 1) = v4;
          LODWORD(v19) = v19 + 2;
        }
        v23 = *(_DWORD *)(v5 + 44) - v19 - *(_DWORD *)(v5 + 72);
        if ( !(v18 & 0xC) )
        {
          v24 = 0;
          if ( v23 > 0 )
          {
            v25 = *(_DWORD *)(v5 + 32);
            do
            {
              v26 = *(_QWORD *)(v5 + 1120);
              if ( *(_QWORD *)(v26 + 16) == *(_QWORD *)(v26 + 8) )
              {
                if ( *(_BYTE *)(v26 + 24) )
                  v27 = v25 + 1;
                else
                  v27 = -1;
                *(_DWORD *)(v5 + 32) = v27;
              }
              else
              {
                *(_DWORD *)(v5 + 32) = v25 + 1;
                ++*(_QWORD *)(v26 + 16);
                ***(_WORD ***)(v5 + 1120) = 32;
                **(_QWORD **)(v5 + 1120) += 2i64;
              }
              v25 = *(_DWORD *)(v5 + 32);
              if ( v25 == -1 )
                break;
              ++v24;
            }
            while ( v24 < v23 );
          }
        }
        v28 = (int *)(v5 + 32);
        v29 = *(_QWORD *)(v5 + 8);
        v30 = v5 + 1120;
        sub_140014A2C((_QWORD *)(v5 + 1120), (const __m128i *)&v49, v19, (_DWORD *)(v5 + 32));
        if ( (*(_DWORD *)(v5 + 40) >> 3) & 1 )
        {
          if ( !((*(_DWORD *)(v5 + 40) >> 2) & 1) )
          {
            v31 = 0;
            if ( v23 > 0 )
            {
              v32 = *v28;
              do
              {
                v33 = *(_QWORD **)v30;
                if ( *(_QWORD *)(*(_QWORD *)v30 + 16i64) == *(_QWORD *)(*(_QWORD *)v30 + 8i64) )
                {
                  if ( *((_BYTE *)v33 + 24) )
                    v34 = v32 + 1;
                  else
                    v34 = -1;
                  *v28 = v34;
                }
                else
                {
                  *v28 = v32 + 1;
                  ++v33[2];
                  ***(_WORD ***)v30 = 48;
                  **(_QWORD **)v30 += 2i64;
                }
                v32 = *v28;
                if ( *v28 == -1 )
                  break;
                ++v31;
              }
              while ( v31 < v23 );
            }
          }
        }
        if ( *(_BYTE *)(v5 + 76) || *(_DWORD *)(v5 + 72) <= 0 )
        {
          v47 = *(_QWORD *)(v5 + 8);
          sub_140014A2C((_QWORD *)(v5 + 1120), *(const __m128i **)(v5 + 64), *(_DWORD *)(v5 + 72), (_DWORD *)(v5 + 32));
        }
        else
        {
          v35 = *(_QWORD *)(v5 + 8);
          if ( !*(_BYTE *)(v35 + 40) )
            sub_140014910(*(signed __int64 **)(v5 + 8), a3);
          v36 = 0;
          v37 = *(CHAR **)(v5 + 64);
          if ( *(_DWORD *)(v5 + 72) )
          {
            while ( 1 )
            {
              v38 = *(_QWORD *)(v35 + 24);
              v39 = *(_QWORD *)(v5 + 8);
              v48 = 0;
              v40 = sub_14001EED8(v37, (WCHAR *)&v48, *(signed int *)(v38 + 8), v39, a3);
              if ( v40 <= 0 )
                break;
              v41 = *(_QWORD *)v30;
              v42 = v48;
              if ( *(_QWORD *)(*(_QWORD *)v30 + 16i64) == *(_QWORD *)(*(_QWORD *)v30 + 8i64) )
              {
                if ( *(_BYTE *)(v41 + 24) )
                  ++*v28;
                else
                  *v28 = -1;
              }
              else
              {
                ++*v28;
                ++*(_QWORD *)(v41 + 16);
                ***(_WORD ***)v30 = v42;
                **(_QWORD **)v30 += 2i64;
              }
              v37 += v40;
              if ( ++v36 == *(_DWORD *)(v5 + 72) )
                goto LABEL_95;
            }
            *v28 = -1;
          }
        }
LABEL_95:
        v43 = *v28;
        if ( *v28 >= 0 )
        {
          if ( (*(_DWORD *)(v5 + 40) >> 2) & 1 )
          {
            for ( i = 0; i < v23; ++i )
            {
              v45 = *(_QWORD *)v30;
              if ( *(_QWORD *)(*(_QWORD *)v30 + 16i64) == *(_QWORD *)(*(_QWORD *)v30 + 8i64) )
              {
                if ( *(_BYTE *)(v45 + 24) )
                  v46 = v43 + 1;
                else
                  v46 = -1;
                *v28 = v46;
              }
              else
              {
                *v28 = v43 + 1;
                ++*(_QWORD *)(v45 + 16);
                ***(_WORD ***)v30 = 32;
                **(_QWORD **)v30 += 2i64;
              }
              v43 = *v28;
              if ( *v28 == -1 )
                break;
            }
          }
        }
        return 1;
      }
      v20 = 43;
    }
    LOWORD(v49) = v20;
    goto LABEL_50;
  }
  return 1;
}

//----- (0000000140013F58) ----------------------------------------------------
char __fastcall sub_140013F58(__int64 a1)
{
  unsigned __int16 **v1; // rdx
  unsigned __int16 *v2; // r9
  __int64 v3; // r10
  bool v4; // al
  bool v5; // zf
  unsigned int v6; // eax

  v1 = *(unsigned __int16 ***)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v1 + 1;
  v2 = *v1;
  if ( !*v1 || (v3 = *((_QWORD *)v2 + 1)) == 0 )
  {
    v6 = 6;
    *(_QWORD *)(a1 + 64) = "(null)";
    goto LABEL_13;
  }
  if ( *(_DWORD *)(a1 + 52) != 2 )
  {
    if ( *(_DWORD *)(a1 + 52) == 3 || *(_DWORD *)(a1 + 52) == 12 )
    {
      v4 = 1;
      goto LABEL_10;
    }
    if ( *(_DWORD *)(a1 + 52) != 13 )
    {
      v4 = ((*(_BYTE *)(a1 + 57) - 99) & 0xEF) != 0;
      goto LABEL_10;
    }
  }
  v4 = 0;
LABEL_10:
  *(_QWORD *)(a1 + 64) = v3;
  v5 = v4 == 0;
  v6 = *v2;
  if ( v5 )
  {
LABEL_13:
    *(_BYTE *)(a1 + 76) = 0;
    goto LABEL_14;
  }
  *(_BYTE *)(a1 + 76) = 1;
  v6 >>= 1;
LABEL_14:
  *(_DWORD *)(a1 + 72) = v6;
  return 1;
}

//----- (0000000140013FD4) ----------------------------------------------------
char __fastcall sub_140013FD4(__int64 a1)
{
  unsigned __int16 **v1; // rdx
  __int64 v2; // rbx
  unsigned __int16 *v3; // rdi
  __int64 v4; // rsi
  bool v5; // al
  bool v6; // zf
  unsigned int v7; // eax

  v1 = *(unsigned __int16 ***)(a1 + 24);
  v2 = a1;
  *(_QWORD *)(a1 + 24) = v1 + 1;
  v3 = *v1;
  if ( !*v1 || (v4 = *((_QWORD *)v3 + 1)) == 0 )
  {
    v7 = 6;
    *(_QWORD *)(a1 + 64) = "(null)";
    goto LABEL_6;
  }
  v5 = sub_140010E24(*(_QWORD *)a1, *(_WORD *)(a1 + 58), *(_DWORD *)(a1 + 52));
  *(_QWORD *)(v2 + 64) = v4;
  v6 = v5 == 0;
  v7 = *v3;
  if ( v6 )
  {
LABEL_6:
    *(_BYTE *)(v2 + 76) = 0;
    goto LABEL_7;
  }
  *(_BYTE *)(v2 + 76) = 1;
  v7 >>= 1;
LABEL_7:
  *(_DWORD *)(v2 + 72) = v7;
  return 1;
}

//----- (0000000140014054) ----------------------------------------------------
char __usercall sub_140014054@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rbx
  signed int v3; // eax
  signed __int64 v4; // rdi
  char v5; // al
  unsigned __int64 v6; // r8
  __int64 v7; // rax
  int v8; // edx
  signed __int64 v9; // rax
  __int64 *v10; // rcx
  signed __int64 v11; // r10
  __int64 v12; // r11
  unsigned __int64 v13; // rsi
  int v14; // ebp
  _BYTE *v15; // r9
  __int64 v16; // rcx
  unsigned __int64 v17; // r9
  unsigned __int64 v18; // rax
  __int64 v19; // rdi
  unsigned __int8 *v20; // rcx
  _QWORD *v21; // r9
  __int64 v22; // r8
  __int64 v23; // rdx
  bool v24; // zf
  _BYTE *v25; // rdx
  char *v26; // rdx
  char v27; // al
  char v28; // cl
  __int64 v29; // rdi
  char *v30; // rcx
  char v31; // al
  signed __int64 v32; // rdx
  signed __int64 v33; // rdx
  char result; // al
  __int64 v35; // [rsp+28h] [rbp-30h]
  __int64 v36; // [rsp+40h] [rbp-18h]
  __int64 v37; // [rsp+60h] [rbp+8h]

  *(_DWORD *)(a1 + 40) |= 0x10u;
  v2 = a1;
  v3 = *(_DWORD *)(a1 + 48);
  if ( v3 >= 0 )
  {
    if ( !v3 && (*(_BYTE *)(a1 + 57) == 103 || *(_BYTE *)(a1 + 57) == 71) )
    {
      *(_DWORD *)(a1 + 48) = 1;
      v3 = 1;
    }
  }
  else
  {
    v3 = ((*(_BYTE *)(a1 + 57) - 65) & 0xDF) != 0 ? 6 : 13;
    *(_DWORD *)(a1 + 48) = v3;
  }
  v4 = a1 + 80;
  v5 = sub_140010CD0(a1 + 80, v3 + 349, *(_QWORD *)(a1 + 8));
  v6 = 512i64;
  if ( v5 )
  {
    v8 = *(_DWORD *)(v2 + 48);
  }
  else
  {
    if ( *(_QWORD *)(v2 + 1112) )
      v7 = *(_QWORD *)(v2 + 1104) >> 1;
    else
      LODWORD(v7) = 512;
    v8 = v7 - 349;
    *(_DWORD *)(v2 + 48) = v7 - 349;
  }
  v9 = *(_QWORD *)(v4 + 1032);
  if ( !v9 )
    v9 = v4;
  *(_QWORD *)(v2 + 64) = v9;
  v10 = *(__int64 **)(v2 + 24);
  v37 = 0i64;
  *(_QWORD *)(v2 + 24) = v10 + 1;
  v11 = *(_QWORD *)(v2 + 1112);
  v12 = *(_QWORD *)(v2 + 8);
  v13 = *(_QWORD *)v2;
  v14 = *(char *)(v2 + 57);
  v37 = *v10;
  if ( v11 )
  {
    v17 = *(_QWORD *)(v4 + 1024);
    v4 = v11;
    v15 = (_BYTE *)(v11 + (v17 >> 1));
    v16 = *(_QWORD *)(v2 + 1104) >> 1;
    v6 = *(_QWORD *)(v2 + 1104) >> 1;
  }
  else
  {
    v15 = (_BYTE *)(v4 + 512);
    v16 = 512i64;
  }
  LODWORD(v36) = 1;
  LODWORD(v35) = v14;
  sub_14001EA40((_BYTE *)v4, (unsigned __int64 *)&v37, v6, v15, a2, v16, v35, v8, v13, v36, v12);
  v18 = (unsigned int)(*(_DWORD *)(v2 + 40) >> 5);
  if ( v18 & 1 && !*(_DWORD *)(v2 + 48) )
  {
    v19 = *(_QWORD *)(v2 + 8);
    if ( !*(_BYTE *)(v19 + 40) )
      sub_140014910(*(signed __int64 **)(v2 + 8), a2);
    v20 = *(unsigned __int8 **)(v2 + 64);
    v21 = *(_QWORD **)(v19 + 24);
    v22 = *v20;
    v23 = v21[34];
    if ( *(_BYTE *)(v22 + v23) != 101 )
    {
      do
        v22 = *++v20;
      while ( *(_BYTE *)(*v21 + 2 * v22) & 4 );
    }
    v24 = *(_BYTE *)((unsigned __int8)v22 + v23) == 120;
    if ( *(_BYTE *)((unsigned __int8)v22 + v23) == 120 )
      LOBYTE(v22) = v20[2];
    v18 = v21[31];
    v25 = v20 + 2;
    if ( !v24 )
      v25 = v20;
    *v25 = **(_BYTE **)v18;
    v26 = v25 + 1;
    do
    {
      v27 = *v26;
      v28 = v22;
      *v26++ = v22;
      LOBYTE(v22) = v27;
    }
    while ( v28 );
  }
  if ( !((*(_BYTE *)(v2 + 57) - 71) & 0xDF) )
  {
    v18 = (unsigned int)(*(_DWORD *)(v2 + 40) >> 5);
    if ( !(v18 & 1) )
    {
      v29 = *(_QWORD *)(v2 + 8);
      if ( !*(_BYTE *)(v29 + 40) )
        sub_140014910(*(signed __int64 **)(v2 + 8), a2);
      sub_140012BD4(*(char **)(v2 + 64), v29 + 24);
    }
  }
  v30 = *(char **)(v2 + 64);
  v31 = *v30;
  if ( *v30 == 45 )
  {
    *(_DWORD *)(v2 + 40) |= 0x40u;
    *(_QWORD *)(v2 + 64) = ++v30;
    v31 = *v30;
  }
  LOBYTE(v18) = v31 - 73;
  if ( (unsigned __int8)v18 <= 0x25u )
  {
    v32 = 141733920801i64;
    if ( _bittest64(&v32, v18) )
    {
      *(_DWORD *)(v2 + 40) &= 0xFFFFFFF7;
      *(_BYTE *)(v2 + 57) = 115;
    }
  }
  v33 = -1i64;
  do
    ++v33;
  while ( v30[v33] );
  result = 1;
  *(_DWORD *)(v2 + 72) = v33;
  return result;
}

//----- (00000001400142A8) ----------------------------------------------------
char __usercall sub_1400142A8@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rbx
  signed int v3; // eax
  signed __int64 v4; // rdi
  char v5; // al
  unsigned __int64 v6; // r8
  __int64 v7; // rax
  int v8; // edx
  signed __int64 v9; // rax
  __int64 *v10; // rcx
  signed __int64 v11; // r10
  __int64 v12; // r11
  unsigned __int64 v13; // rsi
  int v14; // ebp
  _BYTE *v15; // r9
  __int64 v16; // rcx
  unsigned __int64 v17; // r9
  __int64 v18; // rdi
  unsigned __int8 *v19; // rcx
  __int64 v20; // r9
  __int64 v21; // r8
  __int64 v22; // rdx
  bool v23; // zf
  _BYTE *v24; // rdx
  char *v25; // rdx
  char v26; // al
  char v27; // cl
  unsigned __int64 v28; // rax
  __int64 v29; // rdi
  char *v30; // rcx
  char v31; // al
  signed __int64 v32; // rdx
  signed __int64 v33; // rdx
  __int64 v35; // [rsp+28h] [rbp-40h]
  __int64 v36; // [rsp+40h] [rbp-28h]
  __int64 v37; // [rsp+70h] [rbp+8h]

  *(_DWORD *)(a1 + 40) |= 0x10u;
  v2 = a1;
  v3 = *(_DWORD *)(a1 + 48);
  if ( v3 >= 0 )
  {
    if ( !v3 && (*(_WORD *)(a1 + 58) == 103 || *(_WORD *)(a1 + 58) == 71) )
    {
      *(_DWORD *)(a1 + 48) = 1;
      v3 = 1;
    }
  }
  else
  {
    v3 = ((*(_WORD *)(a1 + 58) - 65) & 0xFFDF) != 0 ? 6 : 13;
    *(_DWORD *)(a1 + 48) = v3;
  }
  v4 = a1 + 80;
  v5 = sub_140010CD0(a1 + 80, v3 + 349, *(_QWORD *)(a1 + 8));
  v6 = 512i64;
  if ( v5 )
  {
    v8 = *(_DWORD *)(v2 + 48);
  }
  else
  {
    if ( *(_QWORD *)(v2 + 1112) )
      v7 = *(_QWORD *)(v2 + 1104) >> 1;
    else
      LODWORD(v7) = 512;
    v8 = v7 - 349;
    *(_DWORD *)(v2 + 48) = v7 - 349;
  }
  v9 = *(_QWORD *)(v4 + 1032);
  if ( !v9 )
    v9 = v4;
  *(_QWORD *)(v2 + 64) = v9;
  v10 = *(__int64 **)(v2 + 24);
  v37 = 0i64;
  *(_QWORD *)(v2 + 24) = v10 + 1;
  v11 = *(_QWORD *)(v2 + 1112);
  v12 = *(_QWORD *)(v2 + 8);
  v13 = *(_QWORD *)v2;
  v14 = *(char *)(v2 + 58);
  v37 = *v10;
  if ( v11 )
  {
    v17 = *(_QWORD *)(v4 + 1024);
    v4 = v11;
    v15 = (_BYTE *)(v11 + (v17 >> 1));
    v16 = *(_QWORD *)(v2 + 1104) >> 1;
    v6 = *(_QWORD *)(v2 + 1104) >> 1;
  }
  else
  {
    v15 = (_BYTE *)(v4 + 512);
    v16 = 512i64;
  }
  LODWORD(v36) = 1;
  LODWORD(v35) = v14;
  sub_14001EA40((_BYTE *)v4, (unsigned __int64 *)&v37, v6, v15, a2, v16, v35, v8, v13, v36, v12);
  if ( (*(_DWORD *)(v2 + 40) >> 5) & 1 && !*(_DWORD *)(v2 + 48) )
  {
    v18 = *(_QWORD *)(v2 + 8);
    if ( !*(_BYTE *)(v18 + 40) )
      sub_140014910(*(signed __int64 **)(v2 + 8), a2);
    v19 = *(unsigned __int8 **)(v2 + 64);
    v20 = *(_QWORD *)(v18 + 24);
    v21 = *v19;
    v22 = *(_QWORD *)(v20 + 272);
    if ( *(_BYTE *)(v21 + v22) != 101 )
    {
      do
        v21 = *++v19;
      while ( *(_BYTE *)(*(_QWORD *)v20 + 2 * v21) & 4 );
    }
    v23 = *(_BYTE *)((unsigned __int8)v21 + v22) == 120;
    if ( *(_BYTE *)((unsigned __int8)v21 + v22) == 120 )
      LOBYTE(v21) = v19[2];
    v24 = v19 + 2;
    if ( !v23 )
      v24 = v19;
    *v24 = ***(_BYTE ***)(v20 + 248);
    v25 = v24 + 1;
    do
    {
      v26 = *v25;
      v27 = v21;
      *v25++ = v21;
      LOBYTE(v21) = v26;
    }
    while ( v27 );
  }
  v28 = *(unsigned __int16 *)(v2 + 58);
  LOWORD(v28) = v28 - 71;
  if ( !(v28 & 0xFFDF) )
  {
    v28 = (unsigned int)(*(_DWORD *)(v2 + 40) >> 5);
    if ( !(v28 & 1) )
    {
      v29 = *(_QWORD *)(v2 + 8);
      if ( !*(_BYTE *)(v29 + 40) )
        sub_140014910(*(signed __int64 **)(v2 + 8), a2);
      sub_140012BD4(*(char **)(v2 + 64), v29 + 24);
    }
  }
  v30 = *(char **)(v2 + 64);
  v31 = *v30;
  if ( *v30 == 45 )
  {
    *(_DWORD *)(v2 + 40) |= 0x40u;
    *(_QWORD *)(v2 + 64) = ++v30;
    v31 = *v30;
  }
  LOBYTE(v28) = v31 - 73;
  if ( (unsigned __int8)v28 <= 0x25u )
  {
    v32 = 141733920801i64;
    if ( _bittest64(&v32, v28) )
    {
      *(_DWORD *)(v2 + 40) &= 0xFFFFFFF7;
      *(_WORD *)(v2 + 58) = 115;
    }
  }
  v33 = -1i64;
  do
    ++v33;
  while ( v30[v33] );
  *(_DWORD *)(v2 + 72) = v33;
  return 1;
}

//----- (0000000140014510) ----------------------------------------------------
char __usercall sub_140014510@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  char v2; // dl
  __int64 v3; // rbx
  int v4; // ecx
  int v5; // ecx
  unsigned __int16 *v6; // rcx
  CHAR *v7; // rdx
  unsigned __int64 v8; // r8
  signed __int64 v9; // rdi
  _BYTE *v10; // rcx
  _BYTE *v11; // rdx
  signed __int64 v12; // rcx
  char result; // al

  v2 = *(_BYTE *)(a1 + 57);
  v3 = a1;
  v4 = *(_DWORD *)(a1 + 52) - 2;
  if ( v4 && ((v5 = v4 - 1) == 0 || v5 == 9 || *(_DWORD *)(v3 + 52) != 13 && (v2 - 99) & 0xEF) )
  {
    v6 = *(unsigned __int16 **)(v3 + 24);
    *(_QWORD *)(v3 + 24) = v6 + 4;
    v7 = *(CHAR **)(v3 + 1112);
    if ( v7 )
    {
      v9 = v3 + 80;
      v8 = *(_QWORD *)(v3 + 1104) >> 1;
    }
    else
    {
      v7 = (CHAR *)(v3 + 80);
      v8 = 512i64;
      v9 = v3 + 80;
    }
    if ( (unsigned int)sub_14001ED28(v7, (int *)(v3 + 72), v8, *v6, a2, *(_QWORD *)(v3 + 8)) )
      *(_BYTE *)(v3 + 56) = 1;
  }
  else
  {
    v10 = *(_BYTE **)(v3 + 24);
    v9 = v3 + 80;
    v11 = *(_BYTE **)(v3 + 1112);
    if ( !v11 )
      v11 = (_BYTE *)(v3 + 80);
    *(_QWORD *)(v3 + 24) = v10 + 8;
    *v11 = *v10;
    *(_DWORD *)(v3 + 72) = 1;
  }
  v12 = *(_QWORD *)(v9 + 1032);
  result = 1;
  if ( !v12 )
    v12 = v9;
  *(_QWORD *)(v3 + 64) = v12;
  return result;
}

//----- (00000001400145E4) ----------------------------------------------------
char __usercall sub_1400145E4@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rbx
  __int16 *v3; // rdx
  __int16 v4; // si
  __int64 v5; // rsi
  signed __int64 v6; // rdi
  WCHAR *v7; // rcx
  _WORD *v8; // rcx
  signed __int64 v9; // rcx
  char result; // al
  char v11; // [rsp+30h] [rbp+8h]
  char v12; // [rsp+31h] [rbp+9h]

  *(_BYTE *)(a1 + 76) = 1;
  v2 = a1;
  v3 = *(__int16 **)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v3 + 4;
  v4 = *v3;
  if ( sub_140010E24(*(_QWORD *)a1, *(_WORD *)(a1 + 58), *(_DWORD *)(a1 + 52)) )
  {
    v6 = v2 + 80;
    v8 = *(_WORD **)(v2 + 1112);
    if ( !v8 )
      v8 = (_WORD *)(v2 + 80);
    *v8 = v4;
  }
  else
  {
    v11 = v4;
    v5 = *(_QWORD *)(v2 + 8);
    v12 = 0;
    if ( !*(_BYTE *)(v5 + 40) )
      sub_140014910((signed __int64 *)v5, a2);
    v6 = v2 + 80;
    v7 = *(WCHAR **)(v2 + 1112);
    if ( !v7 )
      v7 = (WCHAR *)(v2 + 80);
    if ( (sub_14001EED8(&v11, v7, *(signed int *)(*(_QWORD *)(v5 + 24) + 8i64), v5, a2) & 0x80000000) != 0i64 )
      *(_BYTE *)(v2 + 56) = 1;
  }
  v9 = *(_QWORD *)(v6 + 1032);
  result = 1;
  *(_DWORD *)(v2 + 72) = 1;
  if ( !v9 )
    v9 = v6;
  *(_QWORD *)(v2 + 64) = v9;
  return result;
}

//----- (00000001400146A8) ----------------------------------------------------
char __usercall sub_1400146A8@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  _QWORD **v2; // rdx
  __int64 v3; // rbx
  _QWORD *v4; // rdi
  __int64 v5; // rax
  signed int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx

  v2 = *(_QWORD ***)(a1 + 24);
  v3 = a1;
  *(_QWORD *)(a1 + 24) = v2 + 1;
  v4 = *v2;
  if ( !(unsigned int)sub_14001F050() )
    goto LABEL_2;
  v7 = *(_DWORD *)(v3 + 52);
  if ( v7 > 5 )
  {
    v10 = v7 - 6;
    if ( v10 )
    {
      v11 = v10 - 1;
      if ( v11 )
      {
        v9 = v11 - 2;
        if ( v9 )
          goto LABEL_13;
      }
    }
LABEL_15:
    *v4 = *(signed int *)(v3 + 32);
    goto LABEL_16;
  }
  if ( v7 == 5 )
    goto LABEL_15;
  if ( !v7 )
    goto LABEL_18;
  v8 = v7 - 1;
  if ( !v8 )
  {
    *(_BYTE *)v4 = *(_BYTE *)(v3 + 32);
    goto LABEL_16;
  }
  v9 = v8 - 1;
  if ( v9 )
  {
LABEL_13:
    v12 = v9 - 1;
    if ( v12 )
    {
      if ( v12 != 1 )
      {
LABEL_2:
        v5 = *(_QWORD *)(v3 + 8);
        *(_BYTE *)(v5 + 48) = 1;
        *(_DWORD *)(v5 + 44) = 22;
        sub_14001ACE8(0i64, a2, 0i64, *(signed __int64 **)(v3 + 8));
        return 0;
      }
      goto LABEL_15;
    }
LABEL_18:
    *(_DWORD *)v4 = *(_DWORD *)(v3 + 32);
    goto LABEL_16;
  }
  *(_WORD *)v4 = *(_WORD *)(v3 + 32);
LABEL_16:
  *(_BYTE *)(v3 + 56) = 1;
  return 1;
}

//----- (0000000140014760) ----------------------------------------------------
char __usercall sub_140014760@<al>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm1>)
{
  __m128i **v3; // rdx
  __int64 v4; // rbx
  __m128i *v5; // rcx
  signed int v6; // er8
  int v7; // edx
  char v8; // r9
  int v9; // edx
  int v10; // edx
  int v11; // eax

  v3 = *(__m128i ***)(a1 + 24);
  v4 = a1;
  *(_QWORD *)(a1 + 24) = v3 + 1;
  v5 = *v3;
  v6 = *(_DWORD *)(v4 + 48);
  v7 = *(_DWORD *)(v4 + 52);
  v8 = *(_BYTE *)(v4 + 57);
  if ( v6 == -1 )
    v6 = 0x7FFFFFFF;
  *(_QWORD *)(v4 + 64) = v5;
  v9 = v7 - 2;
  if ( v9 && ((v10 = v9 - 1) == 0 || v10 == 9 || *(_DWORD *)(v4 + 52) != 13 && (v8 - 99) & 0xEF) )
  {
    if ( !v5 )
    {
      v5 = (__m128i *)L"(null)";
      *(_QWORD *)(v4 + 64) = L"(null)";
    }
    *(_BYTE *)(v4 + 76) = 1;
    v11 = sub_14001DC7C(v6, v5, a2, a3);
  }
  else
  {
    if ( !v5 )
    {
      v5 = (__m128i *)"(null)";
      *(_QWORD *)(v4 + 64) = "(null)";
    }
    v11 = (unsigned __int64)sub_14001DB2C(v6, v5, a2, a3);
  }
  *(_DWORD *)(v4 + 72) = v11;
  return 1;
}
// 1400324F0: using guessed type wchar_t aNull_0[7];

//----- (00000001400147FC) ----------------------------------------------------
char __usercall sub_1400147FC@<al>(__int64 a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __m128i **v4; // rdx
  __int64 v5; // rbx
  int v6; // esi
  __m128i *v7; // rdi
  int v8; // er8
  __int16 v9; // dx
  int v10; // eax
  const char *v11; // rcx

  v4 = *(__m128i ***)(a1 + 24);
  v5 = a1;
  *(_QWORD *)(a1 + 24) = v4 + 1;
  v6 = *(_DWORD *)(a1 + 48);
  v7 = *v4;
  v8 = *(_DWORD *)(a1 + 52);
  if ( v6 == -1 )
    v6 = 0x7FFFFFFF;
  v9 = *(_WORD *)(a1 + 58);
  *(_QWORD *)(a1 + 64) = v7;
  if ( sub_140010E24(*(_QWORD *)a1, v9, v8) )
  {
    if ( !v7 )
    {
      v7 = (__m128i *)L"(null)";
      *(_QWORD *)(v5 + 64) = L"(null)";
    }
    *(_BYTE *)(v5 + 76) = 1;
    v10 = sub_14001DC7C(v6, v7, a2, a4);
  }
  else
  {
    v11 = "(null)";
    if ( v7 )
      v11 = (const char *)v7;
    *(_QWORD *)(v5 + 64) = v11;
    v10 = sub_140014898(v6, v5, a3);
  }
  *(_DWORD *)(v5 + 72) = v10;
  return 1;
}
// 1400324F0: using guessed type wchar_t aNull_0[7];

//----- (0000000140014898) ----------------------------------------------------
__int64 __usercall sub_140014898@<rax>(int a1@<edx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rbx
  int v4; // esi
  __int64 v5; // rdi
  _BYTE *v6; // r9
  unsigned int v7; // er10
  int v8; // er8
  signed __int64 v9; // rcx

  v3 = *(_QWORD *)(a2 + 8);
  v4 = a1;
  v5 = a2;
  if ( !*(_BYTE *)(v3 + 40) )
    sub_140014910(*(signed __int64 **)(a2 + 8), a3);
  v6 = *(_BYTE **)(v5 + 64);
  v7 = 0;
  if ( v4 > 0 )
  {
    do
    {
      if ( !*v6 )
        break;
      v8 = *(unsigned __int16 *)(**(_QWORD **)(v3 + 24) + 2i64 * (unsigned __int8)*v6);
      v9 = (signed __int64)(v6 + 1);
      if ( !_bittest(&v8, 0xFu) )
        v9 = (signed __int64)v6;
      ++v7;
      v6 = (_BYTE *)(v9 + 1);
    }
    while ( (signed int)v7 < v4 );
  }
  return v7;
}

//----- (0000000140014910) ----------------------------------------------------
__int64 __usercall sub_140014910@<rax>(signed __int64 *a1@<rcx>, __m256i *a2@<ymm0>)
{
  signed __int64 *v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rsi
  __int64 result; // rax

  v2 = a1;
  v3 = sub_14001009C(a1, a2);
  v4 = v3;
  v2[3] = *(_QWORD *)(v3 + 144);
  v2[4] = *(_QWORD *)(v3 + 136);
  sub_14001DE88(v2 + 3, v3, v2[1], a2);
  sub_14001DEF4(v2 + 4, v4, v2[1], a2);
  result = *(unsigned int *)(v4 + 936);
  if ( !(result & 2) )
  {
    result = (unsigned int)result | 2;
    *(_DWORD *)(v4 + 936) = result;
    *((_BYTE *)v2 + 40) = 2;
  }
  return result;
}

//----- (0000000140014988) ----------------------------------------------------
void __fastcall sub_140014988(_QWORD *a1, const __m128i *a2, int a3, _DWORD *a4)
{
  _QWORD *v4; // r14
  __int64 v5; // rdi
  __int64 v6; // rcx
  _DWORD *v7; // rbx
  __int64 v8; // rax
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rsi
  __m128i *v11; // rcx

  if ( a3 )
  {
    v4 = a1;
    v5 = a3;
    v6 = *a1;
    v7 = a4;
    v8 = *(_QWORD *)(v6 + 8);
    if ( *(_QWORD *)(v6 + 16) == v8 )
    {
      if ( *(_BYTE *)(v6 + 24) )
        *a4 += v5;
      else
        *a4 = -1;
    }
    else
    {
      v9 = v8 - *(_QWORD *)(v6 + 16);
      v10 = a3;
      v11 = *(__m128i **)v6;
      if ( v9 < a3 )
        v10 = v9;
      sub_14000CA50(v11, a2, v10);
      *(_QWORD *)*v4 += v10;
      *(_QWORD *)(*v4 + 16i64) += v10;
      if ( *(_BYTE *)(*v4 + 24i64) )
      {
        *v7 += v5;
      }
      else if ( v10 == v5 )
      {
        *v7 += v10;
      }
      else
      {
        *v7 = -1;
      }
    }
  }
}

//----- (0000000140014A2C) ----------------------------------------------------
void __fastcall sub_140014A2C(_QWORD *a1, const __m128i *a2, int a3, _DWORD *a4)
{
  _QWORD *v4; // r15
  __int64 v5; // rsi
  __int64 v6; // rcx
  _DWORD *v7; // rdi
  __int64 v8; // rax
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // r14
  __m128i *v11; // rcx

  if ( a3 )
  {
    v4 = a1;
    v5 = a3;
    v6 = *a1;
    v7 = a4;
    v8 = *(_QWORD *)(v6 + 8);
    if ( *(_QWORD *)(v6 + 16) == v8 )
    {
      if ( *(_BYTE *)(v6 + 24) )
        *a4 += v5;
      else
        *a4 = -1;
    }
    else
    {
      v9 = v8 - *(_QWORD *)(v6 + 16);
      v10 = a3;
      v11 = *(__m128i **)v6;
      if ( v9 < a3 )
        v10 = v9;
      sub_14000CA50(v11, a2, 2 * v10);
      *(_QWORD *)*v4 += 2 * v10;
      *(_QWORD *)(*v4 + 16i64) += v10;
      if ( *(_BYTE *)(*v4 + 24i64) )
      {
        *v7 += v5;
      }
      else if ( v10 == v5 )
      {
        *v7 += v10;
      }
      else
      {
        *v7 = -1;
      }
    }
  }
}

//----- (0000000140014AD4) ----------------------------------------------------
__int64 __usercall sub_140014AD4@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>, __m128i *a8, __int64 a9)
{
  unsigned __int64 v9; // rbx
  _BYTE *v10; // rsi
  char v11; // r15
  __m128i v12; // xmm0
  unsigned __int64 v13; // rdi
  int v14; // eax
  __int64 v15; // rax
  void *v16; // rcx
  int v17; // ebx
  int v18; // ebx
  __int64 v20; // [rsp+30h] [rbp-D0h]
  __int64 v21; // [rsp+38h] [rbp-C8h]
  __int64 v22; // [rsp+40h] [rbp-C0h]
  char v23; // [rsp+48h] [rbp-B8h]
  int v24; // [rsp+49h] [rbp-B7h]
  __int16 v25; // [rsp+4Dh] [rbp-B3h]
  char v26; // [rsp+4Fh] [rbp-B1h]
  __int64 v27; // [rsp+50h] [rbp-B0h]
  char v28; // [rsp+60h] [rbp-A0h]
  __int128 v29; // [rsp+68h] [rbp-98h]
  char v30; // [rsp+78h] [rbp-88h]
  int v31; // [rsp+7Ch] [rbp-84h]
  char v32; // [rsp+80h] [rbp-80h]
  int v33; // [rsp+84h] [rbp-7Ch]
  char v34; // [rsp+88h] [rbp-78h]
  __int64 v35; // [rsp+90h] [rbp-70h]
  __int64 *v36; // [rsp+98h] [rbp-68h]
  __int64 v37; // [rsp+A0h] [rbp-60h]
  __int64 v38; // [rsp+A8h] [rbp-58h]
  int v39; // [rsp+B0h] [rbp-50h]
  char v40; // [rsp+B4h] [rbp-4Ch]
  __int64 v41; // [rsp+B8h] [rbp-48h]
  int v42; // [rsp+C0h] [rbp-40h]
  __int16 v43; // [rsp+C8h] [rbp-38h]
  int v44; // [rsp+D8h] [rbp-28h]
  char v45; // [rsp+DCh] [rbp-24h]
  LPVOID lpMem[2]; // [rsp+4E0h] [rbp+3E0h]
  __int64 *v47; // [rsp+4F0h] [rbp+3F0h]
  int v48; // [rsp+4F8h] [rbp+3F8h]

  v27 = 0i64;
  v9 = a3;
  v28 = 0;
  v10 = (_BYTE *)a1;
  v30 = 0;
  v11 = a2;
  v32 = 0;
  v34 = 0;
  if ( a8 )
  {
    v12 = *a8;
LABEL_5:
    v30 = 1;
    _mm_storeu_si128((__m128i *)&v29, v12);
    goto LABEL_6;
  }
  if ( !dword_140040924 )
  {
    v12 = (__m128i)off_14003E2C8;
    goto LABEL_5;
  }
LABEL_6:
  if ( !a4 || a3 && !a1 )
  {
    v32 = 1;
    v31 = 22;
    sub_14001ACE8(0i64, a6, 0i64, &v27);
LABEL_8:
    LODWORD(v13) = -1;
    goto LABEL_34;
  }
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v20 = a1;
  v21 = a3;
  v22 = 0i64;
  if ( a2 & 2 || (v23 = 0, !a1) )
    v23 = 1;
  v39 = 0;
  v36 = &v27;
  v40 = 0;
  v47 = &v20;
  v38 = a9;
  v41 = 0i64;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  _mm_store_si128((__m128i *)lpMem, (__m128i)0i64);
  v35 = a2;
  v37 = a4;
  v48 = 0;
  v14 = sub_140012D60(&v35, a5, a6, a7);
  v13 = v14;
  if ( !v10 )
    goto LABEL_33;
  if ( v11 & 1 )
  {
    if ( !v9 && v14 )
      goto LABEL_18;
    v15 = v22;
    if ( v22 == v9 )
    {
      if ( (v13 & 0x80000000) == 0i64 && v13 > v9 )
        goto LABEL_18;
      goto LABEL_33;
    }
    goto LABEL_32;
  }
  if ( !(v11 & 2) )
  {
    if ( !v9 )
    {
LABEL_18:
      sub_14001AE1C(lpMem[1]);
      goto LABEL_8;
    }
    v15 = v22;
    if ( v22 == v9 )
    {
      v16 = lpMem[1];
      v10[v9 - 1] = 0;
      sub_14001AE1C(v16);
      LODWORD(v13) = -2;
      goto LABEL_34;
    }
    goto LABEL_32;
  }
  if ( v9 )
  {
    if ( v14 < 0 )
    {
      *v10 = 0;
      goto LABEL_33;
    }
    v15 = v22;
    if ( v22 == v9 )
    {
      v10[v9 - 1] = 0;
      goto LABEL_33;
    }
LABEL_32:
    v10[v15] = 0;
  }
LABEL_33:
  sub_14001AE1C(lpMem[1]);
LABEL_34:
  if ( v30 == 2 )
    *(_DWORD *)(v27 + 936) &= 0xFFFFFFFD;
  if ( v32 )
  {
    v17 = v31;
    *(_DWORD *)(sub_14001009C(&v27, a6) + 32) = v17;
  }
  if ( v34 )
  {
    v18 = v33;
    *(_DWORD *)(sub_14001009C(&v27, a6) + 36) = v18;
  }
  return (unsigned int)v13;
}
// 140040924: using guessed type int dword_140040924;

//----- (0000000140014D28) ----------------------------------------------------
__int64 __usercall sub_140014D28@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>, __m128i *a8, __int64 a9)
{
  unsigned __int64 v9; // rbx
  _WORD *v10; // rsi
  char v11; // r15
  __m128i v12; // xmm0
  unsigned __int64 v13; // rdi
  int v14; // eax
  __int64 v15; // rax
  void *v16; // rcx
  int v17; // ebx
  int v18; // ebx
  __int64 v20; // [rsp+30h] [rbp-D0h]
  __int64 v21; // [rsp+38h] [rbp-C8h]
  __int64 v22; // [rsp+40h] [rbp-C0h]
  char v23; // [rsp+48h] [rbp-B8h]
  int v24; // [rsp+49h] [rbp-B7h]
  __int16 v25; // [rsp+4Dh] [rbp-B3h]
  char v26; // [rsp+4Fh] [rbp-B1h]
  __int64 v27; // [rsp+50h] [rbp-B0h]
  char v28; // [rsp+60h] [rbp-A0h]
  __int128 v29; // [rsp+68h] [rbp-98h]
  char v30; // [rsp+78h] [rbp-88h]
  int v31; // [rsp+7Ch] [rbp-84h]
  char v32; // [rsp+80h] [rbp-80h]
  int v33; // [rsp+84h] [rbp-7Ch]
  char v34; // [rsp+88h] [rbp-78h]
  __int64 v35; // [rsp+90h] [rbp-70h]
  __int64 *v36; // [rsp+98h] [rbp-68h]
  __int64 v37; // [rsp+A0h] [rbp-60h]
  __int64 v38; // [rsp+A8h] [rbp-58h]
  int v39; // [rsp+B0h] [rbp-50h]
  char v40; // [rsp+B4h] [rbp-4Ch]
  __int64 v41; // [rsp+B8h] [rbp-48h]
  int v42; // [rsp+C0h] [rbp-40h]
  char v43; // [rsp+C8h] [rbp-38h]
  __int16 v44; // [rsp+CAh] [rbp-36h]
  int v45; // [rsp+D8h] [rbp-28h]
  char v46; // [rsp+DCh] [rbp-24h]
  LPVOID lpMem[2]; // [rsp+4E0h] [rbp+3E0h]
  __int64 *v48; // [rsp+4F0h] [rbp+3F0h]
  int v49; // [rsp+4F8h] [rbp+3F8h]

  v27 = 0i64;
  v9 = a3;
  v28 = 0;
  v10 = (_WORD *)a1;
  v30 = 0;
  v11 = a2;
  v32 = 0;
  v34 = 0;
  if ( a8 )
  {
    v12 = *a8;
LABEL_5:
    v30 = 1;
    _mm_storeu_si128((__m128i *)&v29, v12);
    goto LABEL_6;
  }
  if ( !dword_140040924 )
  {
    v12 = (__m128i)off_14003E2C8;
    goto LABEL_5;
  }
LABEL_6:
  if ( !a4 || a3 && !a1 )
  {
    v32 = 1;
    v31 = 22;
    sub_14001ACE8(0i64, a6, 0i64, &v27);
LABEL_8:
    LODWORD(v13) = -1;
    goto LABEL_34;
  }
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v20 = a1;
  v21 = a3;
  v22 = 0i64;
  if ( a2 & 2 || (v23 = 0, !a1) )
    v23 = 1;
  v39 = 0;
  v36 = &v27;
  v40 = 0;
  v48 = &v20;
  v38 = a9;
  v41 = 0i64;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  _mm_store_si128((__m128i *)lpMem, (__m128i)0i64);
  v35 = a2;
  v37 = a4;
  v49 = 0;
  v14 = sub_1400130E0(&v35, a5, a6, a7);
  v13 = v14;
  if ( !v10 )
    goto LABEL_33;
  if ( v11 & 1 )
  {
    if ( !v9 && v14 )
      goto LABEL_18;
    v15 = v22;
    if ( v22 == v9 )
    {
      if ( (v13 & 0x80000000) == 0i64 && v13 > v9 )
        goto LABEL_18;
      goto LABEL_33;
    }
    goto LABEL_32;
  }
  if ( !(v11 & 2) )
  {
    if ( !v9 )
    {
LABEL_18:
      sub_14001AE1C(lpMem[1]);
      goto LABEL_8;
    }
    v15 = v22;
    if ( v22 == v9 )
    {
      v16 = lpMem[1];
      v10[v9 - 1] = 0;
      sub_14001AE1C(v16);
      LODWORD(v13) = -2;
      goto LABEL_34;
    }
    goto LABEL_32;
  }
  if ( v9 )
  {
    if ( v14 < 0 )
    {
      *v10 = 0;
      goto LABEL_33;
    }
    v15 = v22;
    if ( v22 == v9 )
    {
      v10[v9 - 1] = 0;
      goto LABEL_33;
    }
LABEL_32:
    v10[v15] = 0;
  }
LABEL_33:
  sub_14001AE1C(lpMem[1]);
LABEL_34:
  if ( v30 == 2 )
    *(_DWORD *)(v27 + 936) &= 0xFFFFFFFD;
  if ( v32 )
  {
    v17 = v31;
    *(_DWORD *)(sub_14001009C(&v27, a6) + 32) = v17;
  }
  if ( v34 )
  {
    v18 = v33;
    *(_DWORD *)(sub_14001009C(&v27, a6) + 36) = v18;
  }
  return (unsigned int)v13;
}
// 140040924: using guessed type int dword_140040924;

//----- (0000000140014F8C) ----------------------------------------------------
void __fastcall sub_140014F8C(LPVOID lpMem)
{
  sub_14001AE1C(lpMem);
}

//----- (0000000140014FC0) ----------------------------------------------------
signed __int64 __fastcall sub_140014FC0(_QWORD *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rdx
  unsigned __int8 v4; // al
  __int64 v5; // rax
  bool v6; // cf

  v3 = a2 - (_QWORD)a1;
  if ( !a3 )
    return 0i64;
  if ( (unsigned __int8)a1 & 7 )
    goto LABEL_3;
LABEL_7:
  while ( (((_WORD)v3 + (_WORD)a1) & 0xFFFu) <= 0xFF8 )
  {
    v5 = *a1;
    if ( *a1 != *(_QWORD *)((char *)a1 + v3) )
      break;
    ++a1;
    v6 = a3 < 8;
    a3 -= 8i64;
    if ( v6 || a3 == 0 || (v5 - 72340172838076673i64) & ~v5 & 0x8080808080808080ui64 )
      return 0i64;
  }
LABEL_3:
  while ( 1 )
  {
    v4 = *(_BYTE *)a1;
    if ( *(_BYTE *)a1 != *((_BYTE *)a1 + v3) )
      return -(signed __int64)(v4 < *((_BYTE *)a1 + v3)) | 1;
    a1 = (_QWORD *)((char *)a1 + 1);
    if ( !--a3 || !v4 )
      return 0i64;
    if ( !((unsigned __int8)a1 & 7) )
      goto LABEL_7;
  }
}

//----- (0000000140015040) ----------------------------------------------------
signed __int64 sub_140015040()
{
  signed int v0; // eax
  __int64 v1; // rbx
  signed __int64 v2; // rdi
  __int64 v4; // rbp
  _DWORD *v5; // rsi
  char *v6; // r14

  v0 = dword_1400406C0;
  v1 = 0i64;
  v2 = 3i64;
  if ( dword_1400406C0 )
  {
    if ( dword_1400406C0 < 3 )
      v0 = 3;
  }
  else
  {
    v0 = 512;
  }
  dword_1400406C0 = v0;
  lpMem = sub_14001F068(v0, 8ui64);
  sub_14001AE1C(0i64);
  if ( !lpMem )
  {
    dword_1400406C0 = 3;
    lpMem = sub_14001F068(3ui64, 8ui64);
    sub_14001AE1C(0i64);
    if ( !lpMem )
      return 0xFFFFFFFFi64;
  }
  v4 = 0i64;
  v5 = &unk_14003E068;
  v6 = (char *)&unk_14003E050;
  do
  {
    sub_14001F444((LPCRITICAL_SECTION)(v6 + 48), 0xFA0u);
    *(_QWORD *)((char *)lpMem + v1) = v6;
    if ( *(_QWORD *)(qword_140040970[v4 >> 6] + 72 * (v4 & 0x3F) + 40) >= 0xFFFFFFFFFFFFFFFEui64
      || *(_QWORD *)(qword_140040970[v4 >> 6] + 72 * (v4 & 0x3F) + 40) == 0i64 )
    {
      *v5 = -2;
    }
    ++v4;
    v6 += 88;
    v1 += 8i64;
    v5 += 22;
    --v2;
  }
  while ( v2 );
  return 0i64;
}
// 1400406C0: using guessed type int dword_1400406C0;
// 1400406D0: using guessed type int dword_1400406D0;

//----- (0000000140015160) ----------------------------------------------------
char *__fastcall sub_140015160(unsigned int a1)
{
  return (char *)&unk_14003E050 + 88 * a1;
}

//----- (0000000140015180) ----------------------------------------------------
void __usercall sub_140015180(__m256i *a1@<ymm0>)
{
  __int64 v1; // rbx

  sub_1400176C8(a1);
  sub_14001F674(a1);
  v1 = 0i64;
  do
  {
    sub_14001B25C(*(_QWORD *)((char *)lpMem + v1));
    DeleteCriticalSection((LPCRITICAL_SECTION)(*(_QWORD *)((char *)lpMem + v1) + 48i64));
    v1 += 8i64;
  }
  while ( v1 != 24 );
  sub_14001AE1C(lpMem);
  lpMem = 0i64;
}

//----- (00000001400151DC) ----------------------------------------------------
void __fastcall sub_1400151DC(__int64 a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
}

//----- (00000001400151E8) ----------------------------------------------------
void __fastcall sub_1400151E8(__int64 a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
}

//----- (00000001400151F4) ----------------------------------------------------
char *__fastcall sub_1400151F4(unsigned __int64 a1)
{
  unsigned __int64 v1; // rbx
  char **v2; // rax
  char *result; // rax
  char **v4; // rbx

  v1 = a1;
  if ( a1 > 0x8D || *(signed int *)sub_14001F730() < a1 && v1 < 0x64 )
  {
    v4 = sub_14001F728();
    result = v4[*(signed int *)sub_14001F730()];
  }
  else
  {
    if ( v1 > *(signed int *)sub_14001F730() )
    {
      v1 -= 100i64;
      v2 = off_140033780;
    }
    else
    {
      v2 = sub_14001F728();
    }
    result = v2[v1];
  }
  return result;
}
// 140033780: using guessed type char *off_140033780[86];

//----- (0000000140015260) ----------------------------------------------------
signed __int64 __fastcall sub_140015260(int a1)
{
  __int64 v1; // rax
  unsigned int *v2; // rdx
  signed __int64 result; // rax

  v1 = 0i64;
  v2 = dword_140032510;
  do
  {
    if ( a1 == *v2 )
      return dword_140032510[2 * v1 + 1];
    v1 = (unsigned int)(v1 + 1);
    v2 += 2;
  }
  while ( (unsigned int)v1 < 0x2D );
  if ( (unsigned int)(a1 - 19) <= 0x11 )
    return 13i64;
  result = 22i64;
  if ( (unsigned int)(a1 - 188) <= 0xE )
    result = 8i64;
  return result;
}

//----- (00000001400152A8) ----------------------------------------------------
__int64 __fastcall sub_1400152A8(int a1)
{
  int v1; // ebx
  __int64 v2; // rax
  int *v3; // rax
  int v4; // ebx
  __int64 result; // rax
  _DWORD *v6; // rcx

  v1 = a1;
  v2 = sub_14001B798();
  if ( v2 )
    v3 = (int *)(v2 + 36);
  else
    v3 = (int *)&unk_14003E15C;
  *v3 = v1;
  v4 = sub_140015260(v1);
  result = sub_14001B798();
  v6 = &unk_14003E158;
  if ( result )
    v6 = (_DWORD *)(result + 32);
  *v6 = v4;
  return result;
}

//----- (00000001400152F0) ----------------------------------------------------
signed __int64 __fastcall sub_1400152F0(int a1, __int64 a2)
{
  __int64 v2; // rbx
  signed __int64 result; // rax

  v2 = a2;
  *(_BYTE *)(a2 + 56) = 1;
  *(_DWORD *)(a2 + 52) = a1;
  result = sub_140015260(a1);
  *(_DWORD *)(v2 + 44) = result;
  *(_BYTE *)(v2 + 48) = 1;
  return result;
}

//----- (0000000140015314) ----------------------------------------------------
void *sub_140015314()
{
  __int64 v0; // rax
  void *result; // rax

  v0 = sub_14001B798();
  if ( v0 )
    result = (void *)(v0 + 36);
  else
    result = &unk_14003E15C;
  return result;
}

//----- (0000000140015334) ----------------------------------------------------
void *sub_140015334()
{
  __int64 v0; // rax
  void *result; // rax

  v0 = sub_14001B798();
  if ( v0 )
    result = (void *)(v0 + 32);
  else
    result = &unk_14003E158;
  return result;
}

//----- (0000000140015354) ----------------------------------------------------
const char *__usercall sub_140015354@<rax>(int a1@<ecx>, __m256i *a2@<ymm0>)
{
  unsigned __int64 v2; // rsi
  __int64 v3; // rax
  __int64 v4; // rbx
  _BYTE *v6; // rdi
  char *v7; // rax

  v2 = a1;
  v3 = sub_14001B798();
  v4 = v3;
  if ( !v3 )
    return "Visual C++ CRT: Not enough memory to complete call to strerror.";
  if ( !*(_QWORD *)(v3 + 120) )
  {
    *(_QWORD *)(v3 + 120) = sub_14001F068(0x86ui64, 1ui64);
    sub_14001AE1C(0i64);
  }
  v6 = *(_BYTE **)(v4 + 120);
  if ( !v6 )
    return "Visual C++ CRT: Not enough memory to complete call to strerror.";
  v7 = sub_1400151F4(v2);
  if ( (unsigned int)sub_14001F738(134i64, v6, (__int64)v7, 133i64, a2) )
  {
    sub_14001ADD4(a2);
    JUMPOUT(*(_QWORD *)&byte_1400153F0);
  }
  return *(const char **)(v4 + 120);
}
// 1400153F0: using guessed type char;

//----- (00000001400153F4) ----------------------------------------------------
__int64 __fastcall sub_1400153F4(const CHAR *a1, __int64 a2, __int64 a3, UINT a4)
{
  UINT v4; // ebp
  __int64 v5; // rbx
  const CHAR *v6; // rdi
  LPVOID v7; // rax
  __int64 result; // rax
  int v9; // eax
  unsigned __int64 v10; // rsi
  int v11; // eax
  unsigned __int64 v12; // rdx
  LPVOID v13; // rax
  __int64 v14; // rax

  v4 = a4;
  v5 = a2;
  v6 = a1;
  if ( !a1 )
  {
    if ( *(_BYTE *)(a2 + 40) )
    {
      sub_14001AE1C(*(LPVOID *)(a2 + 16));
      *(_BYTE *)(v5 + 40) = 0;
    }
    *(_QWORD *)(v5 + 16) = 0i64;
    *(_QWORD *)(v5 + 24) = 0i64;
    goto LABEL_5;
  }
  if ( *a1 )
  {
    v9 = sub_14001FB10(a4, 9, a1, -1, 0i64, 0);
    v10 = v9;
    if ( v9 )
    {
      v12 = *(_QWORD *)(v5 + 24);
      if ( v9 > v12 )
      {
        if ( *(_BYTE *)(v5 + 40) )
        {
          sub_14001AE1C(*(LPVOID *)(v5 + 16));
          *(_BYTE *)(v5 + 40) = 0;
        }
        v13 = sub_14001DACC(2 * v10);
        *(_QWORD *)(v5 + 16) = v13;
        v12 = 0i64;
        result = v13 == 0i64 ? 0xC : 0;
        if ( !(_DWORD)result )
          v12 = v10;
        *(_BYTE *)(v5 + 40) = (_DWORD)result == 0;
        *(_QWORD *)(v5 + 24) = v12;
        if ( (_DWORD)result )
          return result;
      }
      v14 = sub_14001FB10(v4, 9, v6, -1, *(WCHAR **)(v5 + 16), v12);
      if ( (_DWORD)v14 )
      {
        *(_QWORD *)(v5 + 32) = v14 - 1;
        goto LABEL_22;
      }
    }
    v11 = GetLastError();
    sub_1400152A8(v11);
    return *(unsigned int *)sub_140015334();
  }
  if ( *(_QWORD *)(a2 + 24) )
    goto LABEL_25;
  if ( *(_BYTE *)(a2 + 40) )
  {
    sub_14001AE1C(*(LPVOID *)(a2 + 16));
    *(_BYTE *)(v5 + 40) = 0;
  }
  v7 = sub_14001DACC(2ui64);
  *(_QWORD *)(v5 + 16) = v7;
  result = v7 == 0i64 ? 0xC : 0;
  *(_BYTE *)(v5 + 40) = (_DWORD)result == 0;
  *(_QWORD *)(v5 + 24) = (_DWORD)result == 0;
  if ( !(_DWORD)result )
  {
LABEL_25:
    **(_WORD **)(v5 + 16) = 0;
LABEL_5:
    *(_QWORD *)(v5 + 32) = 0i64;
LABEL_22:
    result = 0i64;
  }
  return result;
}

//----- (0000000140015570) ----------------------------------------------------
signed __int64 __usercall sub_140015570@<rax>(__m128i *lpRootPathName@<rcx>, _OWORD *a2@<rdx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  __int64 v5; // rdi
  __m128i *v6; // rsi
  HANDLE v7; // rax
  void *v8; // rbx
  __int16 v10; // ax
  int v11; // eax
  __int64 v12; // rax
  int v13; // [rsp+58h] [rbp+10h]

  v5 = (__int64)a2;
  v6 = lpRootPathName;
  if ( !a2 || (*a2 = 0i64, a2[1] = 0i64, a2[2] = 0i64, !lpRootPathName) )
  {
    *(_DWORD *)sub_140015314() = 0;
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a4);
    return 0xFFFFFFFFi64;
  }
  v7 = CreateFileW((LPCWSTR)lpRootPathName, 0x80u, 7u, 0i64, 3u, 0x2000000u, 0i64);
  v8 = v7;
  if ( v7 == (HANDLE)-1i64 )
  {
    if ( sub_140015BE8((LPCWSTR)v6, a4) )
    {
      v10 = sub_1400159A8(v6, 0x10u, a3, a4, a5);
      v13 = 0;
      *(_WORD *)(v5 + 6) = v10;
      *(_WORD *)(v5 + 8) = 1;
      if ( sub_140015AE4(&v13, (unsigned __int16 *)v6, a4) )
      {
        v11 = v13 - 1;
        *(_DWORD *)(v5 + 16) = v13 - 1;
        *(_DWORD *)v5 = v11;
        v12 = sub_14001FE30(1980, 1, 1, 0, 0);
        *(_QWORD *)(v5 + 32) = v12;
        *(_QWORD *)(v5 + 24) = v12;
        *(_QWORD *)(v5 + 40) = v12;
        return 0i64;
      }
    }
    else
    {
      sub_1400152A8(2);
    }
    *(_OWORD *)v5 = 0i64;
    *(_OWORD *)(v5 + 16) = 0i64;
    *(_OWORD *)(v5 + 32) = 0i64;
    return 0xFFFFFFFFi64;
  }
  if ( !sub_1400156C4(-1, v6, v7, v5, a3, a4, a5) )
  {
    *(_OWORD *)v5 = 0i64;
    *(_OWORD *)(v5 + 16) = 0i64;
    *(_OWORD *)(v5 + 32) = 0i64;
    CloseHandle(v8);
    return 0xFFFFFFFFi64;
  }
  CloseHandle(v8);
  return 0i64;
}
// 14001FE30: using guessed type __int64 __fastcall sub_14001FE30(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000001400156C4) ----------------------------------------------------
char __usercall sub_1400156C4@<al>(int a1@<edx>, __m128i *a2@<rcx>, void *a3@<r8>, __int64 a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>)
{
  __m128i *v7; // rdi
  __int64 v8; // rbx
  void *v9; // rsi
  int v10; // er14
  DWORD v11; // ecx
  DWORD v12; // eax
  __int16 v13; // ax
  FILETIME v14; // rcx
  __int64 v15; // rax
  FILETIME v16; // rcx
  __int64 v17; // rax
  __int64 v18; // rdx
  FILETIME v19; // rcx
  int v21; // eax
  signed __int16 v22; // ax
  DWORD TotalBytesAvail; // [rsp+30h] [rbp-50h]
  struct _BY_HANDLE_FILE_INFORMATION FileInformation; // [rsp+38h] [rbp-48h]

  v7 = a2;
  v8 = a4;
  v9 = a3;
  v10 = a1;
  v11 = GetFileType(a3) & 0xFFFF7FFF;
  if ( v11 != 1 )
  {
    if ( v11 - 2 <= 1 )
    {
      *(_WORD *)(v8 + 8) = 1;
      v22 = 4096;
      *(_DWORD *)(v8 + 16) = v10;
      *(_DWORD *)v8 = v10;
      if ( v11 == 2 )
        v22 = 0x2000;
      *(_WORD *)(v8 + 6) = v22;
      if ( v11 != 2 && PeekNamedPipe(v9, 0i64, 0, 0i64, &TotalBytesAvail, 0i64) )
        *(_DWORD *)(v8 + 20) = TotalBytesAvail;
      return 1;
    }
    if ( !v11 )
    {
      *(_DWORD *)sub_140015334() = 9;
      return 0;
    }
    goto LABEL_14;
  }
  *(_WORD *)(v8 + 8) = 1;
  if ( v7 )
  {
    TotalBytesAvail = 0;
    if ( !sub_140015AE4((int *)&TotalBytesAvail, (unsigned __int16 *)v7, a6) )
      return 0;
    v12 = TotalBytesAvail - 1;
    *(_DWORD *)(v8 + 16) = TotalBytesAvail - 1;
    *(_DWORD *)v8 = v12;
  }
  *(_OWORD *)&FileInformation.dwFileAttributes = 0i64;
  FileInformation.nFileIndexLow = 0;
  *(_OWORD *)&FileInformation.ftLastAccessTime.dwHighDateTime = 0i64;
  *(_OWORD *)&FileInformation.nFileSizeHigh = 0i64;
  if ( !GetFileInformationByHandle(v9, &FileInformation) )
  {
LABEL_14:
    v21 = GetLastError();
    sub_1400152A8(v21);
    return 0;
  }
  v13 = sub_1400159A8(v7, FileInformation.dwFileAttributes, a5, a6, a7);
  v14 = FileInformation.ftLastWriteTime;
  *(_WORD *)(v8 + 6) = v13;
  v15 = sub_14001586C(v14, 0i64);
  v16 = FileInformation.ftLastAccessTime;
  *(_QWORD *)(v8 + 32) = v15;
  v17 = sub_14001586C(v16, v15);
  v18 = *(_QWORD *)(v8 + 32);
  v19 = FileInformation.ftCreationTime;
  *(_QWORD *)(v8 + 24) = v17;
  *(_QWORD *)(v8 + 40) = sub_14001586C(v19, v18);
  *(_DWORD *)(v8 + 20) = 0;
  if ( FileInformation.nFileSizeHigh || FileInformation.nFileSizeLow > 0x7FFFFFFF )
  {
    *(_DWORD *)sub_140015334() = 132;
    return 0;
  }
  *(_DWORD *)(v8 + 20) = FileInformation.nFileSizeLow;
  return 1;
}

//----- (000000014001586C) ----------------------------------------------------
__int64 __fastcall sub_14001586C(FILETIME a1, __int64 a2)
{
  FILETIME FileTime; // [rsp+40h] [rbp-38h]
  struct _SYSTEMTIME LocalTime; // [rsp+48h] [rbp-30h]
  struct _SYSTEMTIME SystemTime; // [rsp+58h] [rbp-20h]

  FileTime = a1;
  if ( !*(_QWORD *)&a1 )
    return a2;
  if ( FileTimeToSystemTime(&FileTime, &SystemTime) && SystemTimeToTzSpecificLocalTime(0i64, &SystemTime, &LocalTime) )
    return sub_14001FE30(LocalTime.wYear, LocalTime.wMonth, LocalTime.wDay, LocalTime.wHour, LocalTime.wMinute);
  return -1i64;
}
// 14001FE30: using guessed type __int64 __fastcall sub_14001FE30(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014001590C) ----------------------------------------------------
__int64 __usercall sub_14001590C@<rax>(__m128i *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rdi
  __m128i *v4; // rsi
  __m128i v5; // xmm0
  __int64 v6; // rax
  int v7; // eax

  *(_BYTE *)(a2 + 24) = 0;
  v3 = a2;
  v4 = (__m128i *)(a2 + 8);
  if ( a1 )
  {
    v5 = *a1;
LABEL_5:
    _mm_storeu_si128(v4, v5);
    return v3;
  }
  if ( !dword_140040924 )
  {
    v5 = (__m128i)off_14003E2C8;
    goto LABEL_5;
  }
  v6 = sub_14001B620(a3);
  *(_QWORD *)v3 = v6;
  v4->m128i_i64[0] = *(_QWORD *)(v6 + 144);
  *(_QWORD *)(v3 + 16) = *(_QWORD *)(v6 + 136);
  sub_14001DE54(v4->m128i_i64, v6, a3);
  sub_14001DEC0((LPVOID *)(v3 + 16), *(_QWORD *)v3, a3);
  v7 = *(_DWORD *)(*(_QWORD *)v3 + 936i64);
  if ( !(v7 & 2) )
  {
    *(_DWORD *)(*(_QWORD *)v3 + 936i64) = v7 | 2;
    *(_BYTE *)(v3 + 24) = 1;
  }
  return v3;
}
// 140040924: using guessed type int dword_140040924;

//----- (00000001400159A8) ----------------------------------------------------
__int16 __usercall sub_1400159A8@<ax>(const __m128i *a1@<rdx>, unsigned int a2@<ecx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  char v5; // di
  const __m128i *v6; // r8
  __int16 v7; // bx
  bool v8; // zf
  char v9; // dl
  const __m128i *v10; // rcx
  signed __int16 v11; // ax
  unsigned __int16 v12; // bx
  unsigned __int16 *v13; // rax
  unsigned __int16 *v14; // rsi
  unsigned __int16 v15; // ax

  v5 = 1;
  v6 = a1;
  v7 = a2;
  if ( (a2 >> 4) & 1 )
    goto LABEL_28;
  if ( !a1 )
    goto LABEL_29;
  if ( (unsigned __int16)(LOWORD(a1->m128i_i64[0]) - 65) > 0x19u
    && (LOWORD(a1->m128i_i64[0]) < 0x61u || LOWORD(a1->m128i_i64[0]) > 0x7Au)
    || (v8 = WORD1(a1->m128i_i64[0]) == 58, v9 = 1, !v8) )
  {
    v9 = 0;
  }
  v10 = v6;
  if ( v9 )
    v10 = (const __m128i *)((char *)v6 + 4);
  if ( !LOWORD(v10->m128i_i64[0])
    || (LOWORD(v10->m128i_i64[0]) == 92 || LOWORD(v10->m128i_i64[0]) == 47) && !WORD1(v10->m128i_i64[0]) )
  {
LABEL_28:
    v11 = 16704;
  }
  else
  {
LABEL_29:
    v11 = -32512;
  }
  v12 = v11 | ~(v7 << 7) & 0x80;
  if ( !v6
    || (v13 = (unsigned __int16 *)sub_14002A4E8(v6, 0x2Eu), (v14 = v13) == 0i64)
    || (unsigned int)sub_14001F994(L".exe", v13, a3, a4, a5)
    && (unsigned int)sub_14001F994(L".cmd", v14, a3, a4, a5)
    && (unsigned int)sub_14001F994(L".bat", v14, a3, a4, a5)
    && (unsigned int)sub_14001F994(L".com", v14, a3, a4, a5) )
  {
    v5 = 0;
  }
  v15 = v12 | 0x40;
  if ( !v5 )
    v15 = v12;
  return v15 | (v15 >> 3) & 0x38 | ((unsigned __int16)(v15 | (v15 >> 3) & 0x38) >> 6) & 7;
}
// 1400326C0: using guessed type wchar_t aExe[5];
// 1400326D0: using guessed type wchar_t aCmd[5];
// 1400326E0: using guessed type wchar_t aBat[5];
// 1400326F0: using guessed type wchar_t aCom[5];

//----- (0000000140015AE4) ----------------------------------------------------
char __usercall sub_140015AE4@<al>(int *a1@<rdx>, unsigned __int16 *a2@<rcx>, __m256i *a3@<ymm0>)
{
  int *v3; // rbx
  int v4; // er8
  int v6; // eax

  v3 = a1;
  *a1 = 0;
  v4 = *a2;
  if ( (unsigned int)(v4 - 65) > 0x19 && (unsigned int)(v4 - 97) > 0x19 || a2[1] != 58 )
  {
    v6 = sub_14001F828(a3);
  }
  else
  {
    if ( !a2[2] )
    {
      sub_1400152A8(2);
      return 0;
    }
    if ( (unsigned int)(v4 - 65) <= 0x19 )
      v4 += 32;
    v6 = v4 - 96;
  }
  *v3 = v6;
  return 1;
}

//----- (0000000140015B44) ----------------------------------------------------
char __fastcall sub_140015B44(_WORD *a1)
{
  unsigned __int64 v1; // rax
  __int16 *v2; // rcx
  __int16 v3; // ax
  __int16 *v4; // rcx
  __int16 v5; // ax
  char result; // al

  v1 = -1i64;
  do
    ++v1;
  while ( a1[v1] );
  if ( v1 < 5 || *a1 != 92 && *a1 != 47 )
    goto LABEL_25;
  if ( a1[1] != 92 && a1[1] != 47 )
    goto LABEL_25;
  if ( a1[2] == 92 )
    goto LABEL_25;
  if ( a1[2] == 47 )
    goto LABEL_25;
  v2 = a1 + 3;
  v3 = *v2;
  if ( !*v2 )
    goto LABEL_25;
  do
  {
    if ( v3 == 92 )
      break;
    if ( v3 == 47 )
      break;
    ++v2;
    v3 = *v2;
  }
  while ( *v2 );
  if ( !v3 )
    goto LABEL_25;
  v4 = v2 + 1;
  v5 = *v4;
  if ( !*v4 )
    goto LABEL_25;
  do
  {
    if ( v5 == 92 )
      break;
    if ( v5 == 47 )
      break;
    ++v4;
    v5 = *v4;
  }
  while ( *v4 );
  if ( !v5 || !v4[1] )
    result = 1;
  else
LABEL_25:
    result = 0;
  return result;
}

//----- (0000000140015BE8) ----------------------------------------------------
char __usercall sub_140015BE8@<al>(LPCWSTR lpRootPathName@<rcx>, __m256i *a2@<ymm0>)
{
  WCHAR *v2; // rbp
  char v3; // di
  __m128i *v4; // rbx
  int v5; // er14
  __m128i *v6; // rsi
  signed __int64 v7; // rax
  char v9; // [rsp+30h] [rbp-238h]

  v2 = (WCHAR *)lpRootPathName;
  v3 = 0;
  if ( !sub_14001F920(lpRootPathName, L"./\\") )
    return 0;
  v4 = 0i64;
  v5 = *(_DWORD *)sub_140015334();
  *(_DWORD *)sub_140015334() = 0;
  v6 = sub_140016238(v2, (__m128i *)&v9, 0x104ui64, a2);
  if ( !v6 )
  {
    if ( *(_DWORD *)sub_140015334() == 34 )
    {
      *(_DWORD *)sub_140015334() = v5;
      v4 = sub_140016238(v2, 0i64, 0i64, a2);
      v6 = v4;
      if ( v4 )
        goto LABEL_6;
    }
    sub_140014F8C(v4);
    return 0;
  }
  *(_DWORD *)sub_140015334() = v5;
LABEL_6:
  v7 = -1i64;
  do
    ++v7;
  while ( *((_WORD *)v6->m128i_i64 + v7) );
  if ( (v7 == 3 || sub_140015B44(v6)) && GetDriveTypeW(v2) > 1 )
    v3 = 1;
  sub_140014F8C(v4);
  return v3;
}
// 140032700: using guessed type wchar_t asc_140032700[4];

//----- (0000000140015CF8) ----------------------------------------------------
__int64 __usercall sub_140015CF8@<rax>(_OWORD *a1@<rdx>, const CHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  _OWORD *v5; // rbx
  const CHAR *v6; // rdi
  unsigned int v7; // ebx
  UINT v8; // er9
  __int64 v10; // [rsp+20h] [rbp-50h]
  __int64 v11; // [rsp+28h] [rbp-48h]
  char v12; // [rsp+38h] [rbp-38h]
  __int64 v13; // [rsp+40h] [rbp-30h]
  __int64 v14; // [rsp+48h] [rbp-28h]
  LPVOID lpMem; // [rsp+50h] [rbp-20h]
  __int64 v16; // [rsp+58h] [rbp-18h]
  __int64 v17; // [rsp+60h] [rbp-10h]
  char v18; // [rsp+68h] [rbp-8h]
  char v19; // [rsp+80h] [rbp+10h]

  v5 = a1;
  v6 = a2;
  if ( a2 )
  {
    v13 = 0i64;
    v14 = 0i64;
    lpMem = 0i64;
    v16 = 0i64;
    v17 = 0i64;
    v18 = 0;
    sub_14001590C(0i64, (__int64)&v10, a4);
    v8 = 65001;
    if ( *(_DWORD *)(v11 + 12) == 65001 )
    {
      if ( v12 )
        *(_DWORD *)(v10 + 936) &= 0xFFFFFFFD;
    }
    else if ( (unsigned int)sub_14001F2F4() )
    {
      if ( v12 )
        *(_DWORD *)(v10 + 936) &= 0xFFFFFFFD;
      v8 = 0;
    }
    else
    {
      if ( v12 )
        *(_DWORD *)(v10 + 936) &= 0xFFFFFFFD;
      v8 = 1;
    }
    if ( (unsigned int)sub_1400153F4(v6, (__int64)&v13, (__int64)&v19, v8) )
    {
      if ( v18 )
        sub_14001AE1C(lpMem);
      v7 = -1;
    }
    else
    {
      v7 = sub_140015570((__m128i *)lpMem, v5, a3, a4, a5);
      if ( v18 )
        sub_14001AE1C(lpMem);
    }
  }
  else
  {
    v7 = sub_140015570(0i64, a1, a3, a4, a5);
  }
  return v7;
}

//----- (0000000140015E04) ----------------------------------------------------
__int64 __usercall sub_140015E04@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  return sub_14001FF60(a1, a2, a1 == 0 ? 4 : 0, a1 != 0 ? 0x200 : 0, a3);
}

//----- (0000000140015E40) ----------------------------------------------------
_BYTE *__fastcall sub_140015E40(_BYTE *a1, char *a2, unsigned __int64 a3)
{
  _BYTE *v3; // r11
  unsigned __int64 v4; // rax
  signed __int64 v5; // r10
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rax
  unsigned int v8; // eax
  signed __int64 v9; // rcx
  char v10; // al
  unsigned __int64 v12; // rax
  bool v13; // cf
  signed __int64 v14; // r8
  signed __int64 v15; // r8
  signed __int64 v16; // r8
  unsigned __int64 v17; // rax
  signed __int64 v18; // r8
  signed __int64 v19; // r8
  unsigned __int64 v20; // rax
  signed __int64 v21; // r8
  signed __int64 v22; // r8
  unsigned int v23; // eax
  signed __int64 v24; // r8

  v3 = a1;
  if ( !a3 )
    return v3;
  if ( (unsigned __int8)a1 & 7 )
  {
    while ( *a1 )
    {
      if ( !((unsigned __int8)++a1 & 7) )
        goto LABEL_5;
    }
  }
  else
  {
    while ( 1 )
    {
      do
      {
LABEL_5:
        v4 = *(_QWORD *)a1;
        v5 = (*(_QWORD *)a1 + 9151031864016699135i64) ^ ~*(_QWORD *)a1;
        a1 += 8;
      }
      while ( !(v5 & 0x8101010101010100ui64) );
      a1 -= 8;
      if ( !(_BYTE)v4 )
        break;
      ++a1;
      if ( !BYTE1(v4) )
        break;
      ++a1;
      v6 = v4 >> 16;
      if ( !(_BYTE)v6 )
        break;
      ++a1;
      if ( !BYTE1(v6) )
        break;
      ++a1;
      v7 = v6 >> 16;
      if ( !(_BYTE)v7 )
        break;
      ++a1;
      if ( !BYTE1(v7) )
        break;
      ++a1;
      v8 = (unsigned int)v7 >> 16;
      if ( !(_BYTE)v8 )
        break;
      ++a1;
      if ( !BYTE1(v8) )
        break;
      ++a1;
    }
  }
  v9 = a1 - a2;
  if ( (unsigned __int8)a2 & 7 )
  {
    while ( 1 )
    {
      v10 = *a2;
      a2[v9] = *a2;
      if ( !v10 )
        return v3;
      ++a2;
      if ( !--a3 )
      {
        a2[v9] = 0;
        return v3;
      }
      if ( !((unsigned __int8)a2 & 7) )
        goto LABEL_23;
    }
  }
  do
  {
LABEL_23:
    while ( 1 )
    {
      v12 = *(_QWORD *)a2;
      v13 = a3 < 8;
      a3 -= 8i64;
      if ( v13 || a3 == 0 || ((v12 + 9151031864016699135i64) ^ ~v12) & 0x8101010101010100ui64 )
        break;
      *(_QWORD *)&a2[v9] = v12;
      a2 += 8;
    }
    v14 = a3 + 8;
    if ( !v14 )
      break;
    a2[v9] = v12;
    if ( !(_BYTE)v12 )
      return v3;
    ++a2;
    v15 = v14 - 1;
    if ( !v15 )
      break;
    a2[v9] = BYTE1(v12);
    if ( !BYTE1(v12) )
      return v3;
    ++a2;
    v16 = v15 - 1;
    if ( !v16 )
      break;
    v17 = v12 >> 16;
    a2[v9] = v17;
    if ( !(_BYTE)v17 )
      return v3;
    ++a2;
    v18 = v16 - 1;
    if ( !v18 )
      break;
    a2[v9] = BYTE1(v17);
    if ( !BYTE1(v17) )
      return v3;
    ++a2;
    v19 = v18 - 1;
    if ( !v19 )
      break;
    v20 = v17 >> 16;
    a2[v9] = v20;
    if ( !(_BYTE)v20 )
      return v3;
    ++a2;
    v21 = v19 - 1;
    if ( !v21 )
      break;
    a2[v9] = BYTE1(v20);
    if ( !BYTE1(v20) )
      return v3;
    ++a2;
    v22 = v21 - 1;
    if ( !v22 )
      break;
    v23 = (unsigned int)v20 >> 16;
    a2[v9] = v23;
    if ( !(_BYTE)v23 )
      return v3;
    ++a2;
    v24 = v22 - 1;
    if ( !v24 )
      break;
    a2[v9] = BYTE1(v23);
    if ( !BYTE1(v23) )
      return v3;
    ++a2;
    a3 = v24 - 1;
  }
  while ( a3 );
  a2[v9] = 0;
  return v3;
}

//----- (0000000140015FD8) ----------------------------------------------------
unsigned __int8 *__usercall sub_140015FD8@<rax>(unsigned __int8 *a1@<rdx>, unsigned __int8 *a2@<rcx>, __m256i *a3@<ymm0>)
{
  unsigned __int8 *v3; // rbx
  unsigned __int8 *v4; // rdi
  __int64 v5; // rax

  v3 = a1;
  v4 = a2;
  v5 = sub_14001B620(a3);
  return sub_140020098(v4, v3, (unsigned __int8 **)(v5 + 48));
}

//----- (0000000140016008) ----------------------------------------------------
signed __int64 __fastcall sub_140016008(__int64 a1, LPCWSTR *a2)
{
  __int64 v2; // rbx
  unsigned __int64 v3; // rax
  int v4; // eax
  signed __int64 result; // rax

  v2 = a1;
  v3 = GetFullPathNameW(*a2, *(_DWORD *)(a1 + 24), *(LPWSTR *)(a1 + 16), 0i64);
  if ( (_DWORD)v3 )
  {
    if ( v3 > *(_QWORD *)(v2 + 24) )
    {
      if ( *(_BYTE *)(v2 + 40) )
        *(_BYTE *)(v2 + 40) = 0;
      *(_DWORD *)sub_140015334() = 34;
      result = 34i64;
      *(_BYTE *)(v2 + 40) = 0;
      *(_QWORD *)(v2 + 24) = 0i64;
    }
    else
    {
      *(_QWORD *)(v2 + 32) = v3;
      result = 0i64;
    }
  }
  else
  {
    v4 = GetLastError();
    sub_1400152A8(v4);
    result = *(unsigned int *)sub_140015334();
  }
  return result;
}

//----- (000000014001607C) ----------------------------------------------------
__int64 __fastcall sub_14001607C(__int64 a1, LPCWSTR *a2)
{
  LPCWSTR *v2; // rsi
  __int64 v3; // rbx
  DWORD v4; // eax
  __int64 v5; // rdi
  int v6; // eax
  __int64 result; // rax
  __int64 v8; // rax
  WCHAR *v9; // r8
  signed __int64 v10; // rdx
  __int64 v11; // rax

  v2 = a2;
  v3 = a1;
  v4 = GetFullPathNameW(*a2, *(_DWORD *)(a1 + 24), *(LPWSTR *)(a1 + 16), 0i64);
  v5 = v4;
  if ( !v4 )
    goto LABEL_2;
  if ( (unsigned __int64)v4 <= *(_QWORD *)(v3 + 24) )
  {
    *(_QWORD *)(v3 + 32) = v4;
    return 0i64;
  }
  if ( *(_BYTE *)(v3 + 40) )
  {
    sub_140014F8C(*(LPVOID *)(v3 + 16));
    *(_BYTE *)(v3 + 40) = 0;
  }
  v8 = sub_140014FA0(2 * v5 + 2);
  *(_QWORD *)(v3 + 16) = v8;
  v9 = (WCHAR *)v8;
  v10 = 0i64;
  result = v8 == 0 ? 0xC : 0;
  if ( !(_DWORD)result )
    v10 = v5 + 1;
  *(_BYTE *)(v3 + 40) = (_DWORD)result == 0;
  *(_QWORD *)(v3 + 24) = v10;
  if ( !(_DWORD)result )
  {
    v11 = GetFullPathNameW(*v2, v10, v9, 0i64);
    if ( !(_DWORD)v11 )
    {
LABEL_2:
      v6 = GetLastError();
      sub_1400152A8(v6);
      return *(unsigned int *)sub_140015334();
    }
    *(_QWORD *)(v3 + 32) = v11;
    return 0i64;
  }
  return result;
}
// 140014FA0: using guessed type __int64 __fastcall sub_140014FA0(_QWORD);

//----- (0000000140016154) ----------------------------------------------------
__m128i *__usercall sub_140016154@<rax>(__int64 *a1@<rcx>, __m256i *a2@<ymm0>)
{
  __m128i *v2; // rdi
  __int64 *v3; // rbx
  __int64 v4; // rcx
  __m128i *v5; // rax
  unsigned __int64 v6; // rsi
  __int64 v7; // r14
  unsigned __int64 v8; // rbp
  __int64 v9; // rax

  v2 = (__m128i *)a1[2];
  v3 = a1;
  if ( v2 )
  {
    v4 = a1[4];
    if ( v4 )
    {
      if ( *((_BYTE *)v3 + 40) )
        goto LABEL_14;
      v5 = (__m128i *)sub_140014FA0(2 * v4);
      v6 = v3[3];
      v2 = v5;
      v7 = v3[2];
      v8 = v3[4];
      if ( !v6 )
        goto LABEL_14;
      if ( !v5 )
        goto LABEL_6;
      if ( v7 && v8 >= v6 )
      {
        sub_14000CA50(v5, (const __m128i *)v3[2], v3[3]);
      }
      else
      {
        sub_14000D100(0i64, (__int64)v5, v3[4], a2);
        if ( !v7 )
        {
LABEL_6:
          *(_DWORD *)sub_140015334() = 22;
LABEL_13:
          sub_14001ADB4(a2);
          goto LABEL_14;
        }
        if ( v8 < v6 )
        {
          *(_DWORD *)sub_140015334() = 34;
          goto LABEL_13;
        }
      }
LABEL_14:
      v9 = *v3;
      v3[4] = 0i64;
      v3[2] = v9;
      v3[3] = v3[1];
      return v2;
    }
  }
  return 0i64;
}
// 140014FA0: using guessed type __int64 __fastcall sub_140014FA0(_QWORD);

//----- (0000000140016238) ----------------------------------------------------
__m128i *__usercall sub_140016238@<rax>(_WORD *a1@<rdx>, __m128i *a2@<rcx>, unsigned __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  __m128i *v4; // rbx
  __m128i *v5; // rdi
  __m128i *v6; // rdi
  int v7; // eax
  __m128i *v9; // [rsp+20h] [rbp-30h]
  unsigned __int64 v10; // [rsp+28h] [rbp-28h]
  __m128i *v11; // [rsp+30h] [rbp-20h]
  unsigned __int64 v12; // [rsp+38h] [rbp-18h]
  __int64 v13; // [rsp+40h] [rbp-10h]
  char v14; // [rsp+48h] [rbp-8h]
  _WORD *v15; // [rsp+60h] [rbp+10h]

  v4 = 0i64;
  v5 = a2;
  if ( a1 && *a1 )
  {
    v15 = a1;
    v13 = 0i64;
    v14 = 0;
    if ( a2 )
    {
      v9 = a2;
      v10 = a3;
      v11 = a2;
      v12 = a3;
      if ( !(unsigned int)sub_140016008((__int64)&v9, (LPCWSTR *)&v15) )
        v4 = v5;
    }
    else
    {
      v9 = 0i64;
      v10 = 0i64;
      v11 = 0i64;
      v12 = 0i64;
      sub_14001607C((__int64)&v9, (LPCWSTR *)&v15);
      v6 = sub_140016154((__int64 *)&v9, a4);
      if ( v14 )
        sub_140014F8C(v11);
      v4 = v6;
    }
  }
  else
  {
    v7 = 0x7FFFFFFF;
    if ( a3 < 0x7FFFFFFF )
      v7 = a3;
    v4 = sub_1400203B0(v7, a2, a4);
  }
  return v4;
}

//----- (00000001400162EC) ----------------------------------------------------
__int64 __usercall sub_1400162EC@<rax>(__int16 *a1@<rdx>, const WCHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  __int16 *v5; // rbx
  const WCHAR *v6; // rdi
  __int64 v8; // rbx
  __int64 v9; // [rsp+40h] [rbp+8h]

  v5 = a1;
  v6 = a2;
  if ( !a2 || !a1 || !*a1 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a4);
    return 0i64;
  }
  if ( !*a2 )
  {
    *(_DWORD *)sub_140015334() = 22;
    return 0i64;
  }
  sub_14001B0FC(&v9);
  if ( !v9 )
  {
    *(_DWORD *)sub_140015334() = 24;
    return 0i64;
  }
  v8 = sub_1400207BC(v5, v6, v9, a3, a4, a5);
  if ( !v8 )
    sub_14001B154(v9);
  sub_1400151E8(v9);
  return v8;
}

//----- (00000001400163B8) ----------------------------------------------------
__int64 __usercall sub_1400163B8@<rax>(__int16 *a1@<rdx>, const WCHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  return sub_1400162EC(a1, a2, a3, a4, a5);
}

//----- (00000001400163C4) ----------------------------------------------------
signed __int64 __usercall sub_1400163C4@<rax>(unsigned __int8 **a1@<rdx>, __int64 a2@<rcx>, unsigned int a3@<r8d>, unsigned __int8 a4@<r9b>, __m256i *a5@<ymm0>)
{
  unsigned __int8 *v5; // r12
  unsigned int v6; // ebp
  int v7; // er15
  unsigned __int8 **v8; // rbx
  __int64 v9; // r13
  unsigned __int8 *v10; // rcx
  int v11; // esi
  unsigned int v12; // er14
  int v13; // edi
  int v14; // eax
  unsigned __int8 *v15; // rcx
  char v16; // dl
  unsigned __int8 *v17; // r8
  signed int v18; // eax
  signed int v19; // eax
  unsigned int v20; // er9
  unsigned int v21; // ecx
  unsigned __int8 *v22; // r8
  unsigned int v23; // edx
  BOOL v24; // ecx
  bool v25; // cf
  bool v26; // zf
  unsigned __int8 *v27; // rax
  signed __int64 result; // rax
  signed int v29; // eax
  signed int v30; // ecx
  int v31; // edi
  unsigned __int8 *v32; // rdx
  unsigned __int8 *v33; // rax

  v5 = *a1;
  v6 = a3;
  v7 = a4;
  v8 = a1;
  v9 = a2;
  if ( !*a1 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
    goto LABEL_6;
  }
  if ( a3 && a3 - 2 > 0x22 )
  {
    *(_BYTE *)(a2 + 48) = 1;
    *(_DWORD *)(a2 + 44) = 22;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)a2);
LABEL_6:
    v10 = v8[1];
    if ( v10 )
      *(_QWORD *)v10 = *v8;
    return 0i64;
  }
  v11 = *v5;
  v12 = 0;
  *a1 = v5 + 1;
  if ( !*(_BYTE *)(a2 + 40) )
    sub_140014910((signed __int64 *)a2, a5);
  while ( (unsigned int)sub_140016E50(8, v11, (__m128i *)(v9 + 24), a5) )
    v11 = *(*v8)++;
  v13 = v7 | 2;
  if ( (_BYTE)v11 != 45 )
    v13 = v7;
  if ( !(((_BYTE)v11 - 43) & 0xFD) )
    LOBYTE(v11) = *(*v8)++;
  if ( !(v6 & 0xFFFFFFEF) )
  {
    if ( (unsigned __int8)(v11 - 48) > 9u )
    {
      if ( (unsigned __int8)(v11 - 97) > 0x19u )
      {
        if ( (unsigned __int8)(v11 - 65) > 0x19u )
          goto LABEL_31;
        v14 = (char)v11 - 55;
      }
      else
      {
        v14 = (char)v11 - 87;
      }
    }
    else
    {
      v14 = (char)v11 - 48;
    }
    if ( !v14 )
    {
      v15 = *v8;
      v16 = **v8;
      v17 = *v8 + 1;
      *v8 = v17;
      if ( (v16 - 88) & 0xDF )
      {
        *v8 = v15;
        v18 = 8;
        if ( v6 )
          v18 = v6;
        v6 = v18;
        if ( v16 && *v15 != v16 )
        {
          *(_DWORD *)sub_140015334() = 22;
          sub_14001ADB4(a5);
        }
        goto LABEL_35;
      }
      LOBYTE(v11) = *v17;
      *v8 = v17 + 1;
      v19 = 16;
      goto LABEL_32;
    }
LABEL_31:
    v19 = 10;
LABEL_32:
    if ( v6 )
      v19 = v6;
    v6 = v19;
  }
LABEL_35:
  v20 = 0xFFFFFFFF / v6;
  while ( 1 )
  {
    if ( (unsigned __int8)(v11 - 48) > 9u )
    {
      if ( (unsigned __int8)(v11 - 97) > 0x19u )
        v21 = (unsigned __int8)(v11 - 65) > 0x19u ? -1 : (char)v11 - 55;
      else
        v21 = (char)v11 - 87;
    }
    else
    {
      v21 = (char)v11 - 48;
    }
    v22 = *v8;
    if ( v21 >= v6 )
      break;
    LOBYTE(v11) = *v22;
    v23 = v6 * v12 + v21;
    v24 = v23 < v6 * v12;
    v25 = v12 < v20;
    v26 = v12 == v20;
    v12 = v23;
    *v8 = v22 + 1;
    v13 |= 4 * (!v25 && !v26 || v24) | 8;
  }
  *v8 = v22 - 1;
  if ( (_BYTE)v11 && *(v22 - 1) != (_BYTE)v11 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
  }
  if ( !(v13 & 8) )
  {
    v27 = v8[1];
    *v8 = v5;
    if ( v27 )
      *(_QWORD *)v27 = v5;
    return 0i64;
  }
  if ( v13 & 4 )
  {
    v29 = 1;
    v30 = v13;
    goto LABEL_60;
  }
  if ( !(v13 & 1) )
  {
    if ( !(v13 & 2) )
      goto LABEL_71;
    goto LABEL_70;
  }
  if ( !(v13 & 2) )
  {
    if ( v12 <= 0x7FFFFFFF )
    {
LABEL_71:
      v33 = v8[1];
      if ( v33 )
        *(_QWORD *)v33 = *v8;
      return v12;
    }
    goto LABEL_59;
  }
  if ( v12 <= 0x80000000 )
  {
LABEL_70:
    v12 = -v12;
    goto LABEL_71;
  }
LABEL_59:
  v30 = 1;
  v29 = v13;
LABEL_60:
  v31 = v13 & 2;
  *(_BYTE *)(v9 + 48) = 1;
  *(_DWORD *)(v9 + 44) = 34;
  if ( !(v30 & v29) )
  {
    v12 = -1;
    goto LABEL_71;
  }
  v32 = v8[1];
  if ( v31 )
  {
    if ( v32 )
      *(_QWORD *)v32 = *v8;
    result = 0x80000000i64;
  }
  else
  {
    if ( v32 )
      *(_QWORD *)v32 = *v8;
    result = 0x7FFFFFFFi64;
  }
  return result;
}

//----- (00000001400166B4) ----------------------------------------------------
signed __int64 __usercall sub_1400166B4@<rax>(WCHAR **a1@<rdx>, __int64 a2@<rcx>, unsigned int a3@<r8d>, unsigned __int8 a4@<r9b>, __m256i *a5@<ymm0>)
{
  WCHAR *v5; // r12
  int v6; // esi
  unsigned int v7; // er15
  WCHAR **v8; // rdi
  WCHAR **v9; // rcx
  WCHAR v10; // bx
  unsigned int v11; // er14
  int v12; // eax
  int v13; // esi
  signed int v14; // ecx
  int v15; // eax
  int v16; // ecx
  unsigned int v17; // eax
  bool v18; // cf
  bool v19; // zf
  unsigned int v20; // eax
  WCHAR *v21; // rcx
  WCHAR v22; // dx
  WCHAR *v23; // r8
  signed int v24; // eax
  unsigned int v25; // er9
  unsigned int v26; // ecx
  signed int v27; // eax
  signed int v28; // eax
  int v29; // ecx
  WCHAR *v30; // r8
  unsigned int v31; // edx
  BOOL v32; // ecx
  WCHAR **v33; // rax
  signed __int64 result; // rax
  signed int v35; // eax
  signed int v36; // ecx
  WCHAR **v37; // rdx
  WCHAR **v38; // rdx
  WCHAR *v39; // [rsp+90h] [rbp-48h]
  __int64 v40; // [rsp+E0h] [rbp+8h]

  v40 = a2;
  v5 = *a1;
  v6 = a4;
  v7 = a3;
  v39 = *a1;
  v8 = a1;
  if ( !*a1 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
    goto LABEL_6;
  }
  if ( a3 && a3 - 2 > 0x22 )
  {
    *(_BYTE *)(a2 + 48) = 1;
    *(_DWORD *)(a2 + 44) = 22;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)a2);
LABEL_6:
    v9 = (WCHAR **)v8[1];
    if ( v9 )
      *v9 = *v8;
    return 0i64;
  }
  v10 = *v5;
  *a1 = v5 + 1;
  v11 = 0;
  if ( !*(_BYTE *)(a2 + 40) )
    sub_140014910((signed __int64 *)a2, a5);
  while ( (unsigned int)sub_140019024(v10, 8u) )
  {
    v10 = **v8;
    ++*v8;
  }
  v12 = v6;
  v13 = v6 | 2;
  if ( v10 != 45 )
    v13 = v12;
  if ( !((v10 - 43) & 0xFFFD) )
  {
    v10 = **v8;
    ++*v8;
  }
  v14 = 48;
  if ( v7 & 0xFFFFFFEF )
    goto LABEL_73;
  if ( v10 >= 0x30u )
  {
    if ( v10 < 0x3Au )
    {
LABEL_19:
      v15 = v10 - v14;
      goto LABEL_60;
    }
    if ( v10 >= 0xFF10u )
    {
      if ( v10 < 0xFF1Au )
      {
        v15 = v10 - 65296;
LABEL_60:
        if ( v15 != -1 )
          goto LABEL_66;
        goto LABEL_61;
      }
    }
    else if ( v10 >= 0x660u )
    {
      if ( v10 < 0x66Au )
      {
        v15 = v10 - 1632;
        goto LABEL_60;
      }
      if ( v10 >= 0x6F0u )
      {
        if ( v10 < 0x6FAu )
        {
          v15 = v10 - 1776;
          goto LABEL_60;
        }
        if ( v10 >= 0x966u )
        {
          if ( v10 < 0x970u )
          {
            v15 = v10 - 2406;
            goto LABEL_60;
          }
          if ( v10 >= 0x9E6u )
          {
            if ( v10 < 0x9F0u )
            {
              v15 = v10 - 2534;
              goto LABEL_60;
            }
            if ( v10 >= 0xA66u )
            {
              if ( v10 < 0xA70u )
              {
                v15 = v10 - 2662;
                goto LABEL_60;
              }
              v14 = 2790;
              if ( v10 >= 0xAE6u )
              {
                if ( v10 < 0xAF0u )
                  goto LABEL_19;
                v14 = 2918;
                if ( v10 >= 0xB66u )
                {
                  if ( v10 < 0xB70u )
                    goto LABEL_19;
                  v14 = 3174;
                  if ( v10 >= 0xC66u )
                  {
                    if ( v10 < 0xC70u )
                      goto LABEL_19;
                    v14 = 3302;
                    if ( v10 >= 0xCE6u )
                    {
                      if ( v10 < 0xCF0u )
                        goto LABEL_19;
                      v14 = 3430;
                      if ( v10 >= 0xD66u )
                      {
                        if ( v10 < 0xD70u )
                          goto LABEL_19;
                        v14 = 3664;
                        if ( v10 >= 0xE50u )
                        {
                          if ( v10 < 0xE5Au )
                            goto LABEL_19;
                          v14 = 3792;
                          if ( v10 >= 0xED0u )
                          {
                            if ( v10 < 0xEDAu )
                              goto LABEL_19;
                            v14 = 3872;
                            if ( v10 >= 0xF20u )
                            {
                              if ( v10 < 0xF2Au )
                                goto LABEL_19;
                              v14 = 4160;
                              if ( v10 >= 0x1040u )
                              {
                                if ( v10 < 0x104Au )
                                  goto LABEL_19;
                                v14 = 6112;
                                if ( v10 >= 0x17E0u )
                                {
                                  if ( v10 < 0x17EAu )
                                    goto LABEL_19;
                                  v14 = 6160;
                                  if ( (unsigned __int16)(v10 - 6160) <= 9u )
                                    goto LABEL_19;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_61:
  v16 = v10;
  v17 = v10 - 65;
  v18 = v17 < 0x19;
  v19 = v17 == 25;
  v20 = v10 - 97;
  if ( !v18 && !v19 && v20 > 0x19 )
    goto LABEL_81;
  if ( v20 <= 0x19 )
    v16 = v10 - 32;
  v15 = v16 - 55;
LABEL_66:
  if ( v15 )
  {
LABEL_81:
    v27 = 10;
    goto LABEL_78;
  }
  v21 = *v8;
  v22 = **v8;
  v23 = *v8 + 1;
  *v8 = v23;
  if ( !((v22 - 88) & 0xFFDF) )
  {
    v10 = *v23;
    *v8 = v23 + 1;
    v27 = 16;
LABEL_78:
    if ( v7 )
      v27 = v7;
    v7 = v27;
    goto LABEL_73;
  }
  *v8 = v21;
  v24 = 8;
  if ( v7 )
    v24 = v7;
  v7 = v24;
  if ( v22 && *v21 != v22 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
  }
LABEL_73:
  v25 = 0xFFFFFFFF / v7;
  while ( 1 )
  {
    if ( v10 >= 0x30u )
    {
      if ( v10 < 0x3Au )
      {
        v26 = v10 - 48;
        goto LABEL_119;
      }
      if ( v10 >= 0xFF10u )
      {
        if ( v10 < 0xFF1Au )
        {
          v26 = v10 - 65296;
LABEL_119:
          if ( v26 != -1 )
            goto LABEL_128;
          goto LABEL_120;
        }
      }
      else if ( v10 >= 0x660u )
      {
        if ( v10 < 0x66Au )
        {
          v26 = v10 - 1632;
          goto LABEL_119;
        }
        v28 = 1776;
        if ( v10 >= 0x6F0u )
        {
          if ( v10 < 0x6FAu )
            goto LABEL_88;
          v28 = 2406;
          if ( v10 >= 0x966u )
          {
            if ( v10 < 0x970u )
              goto LABEL_88;
            v28 = 2534;
            if ( v10 >= 0x9E6u )
            {
              if ( v10 < 0x9F0u )
                goto LABEL_88;
              v28 = 2662;
              if ( v10 >= 0xA66u )
              {
                if ( v10 < 0xA70u )
                  goto LABEL_88;
                v28 = 2790;
                if ( v10 >= 0xAE6u )
                {
                  if ( v10 < 0xAF0u )
                    goto LABEL_88;
                  v28 = 2918;
                  if ( v10 >= 0xB66u )
                  {
                    if ( v10 < 0xB70u )
                      goto LABEL_88;
                    v28 = 3174;
                    if ( v10 >= 0xC66u )
                    {
                      if ( v10 < 0xC70u )
                        goto LABEL_88;
                      v28 = 3302;
                      if ( v10 >= 0xCE6u )
                      {
                        if ( v10 < 0xCF0u )
                          goto LABEL_88;
                        v28 = 3430;
                        if ( v10 >= 0xD66u )
                        {
                          if ( v10 < 0xD70u )
                            goto LABEL_88;
                          v28 = 3664;
                          if ( v10 >= 0xE50u )
                          {
                            if ( v10 < 0xE5Au )
                              goto LABEL_88;
                            v28 = 3792;
                            if ( v10 >= 0xED0u )
                            {
                              if ( v10 < 0xEDAu )
                                goto LABEL_88;
                              v28 = 3872;
                              if ( v10 >= 0xF20u )
                              {
                                if ( v10 < 0xF2Au )
                                  goto LABEL_88;
                                v28 = 4160;
                                if ( v10 >= 0x1040u )
                                {
                                  if ( v10 < 0x104Au )
                                    goto LABEL_88;
                                  v28 = 6112;
                                  if ( v10 >= 0x17E0u )
                                  {
                                    if ( v10 < 0x17EAu )
                                    {
LABEL_88:
                                      v26 = v10 - v28;
                                      goto LABEL_119;
                                    }
                                    if ( (unsigned __int16)(v10 - 6160) <= 9u )
                                    {
                                      v26 = v10 - 6160;
                                      goto LABEL_119;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_120:
    if ( ((v29 = v10, v10 < 0x41u) || v10 > 0x5Au) && (v10 < 0x61u || v10 > 0x7Au) )
    {
      v26 = -1;
    }
    else
    {
      if ( (unsigned __int16)(v10 - 97) <= 0x19u )
        v29 = v10 - 32;
      v26 = v29 - 55;
    }
LABEL_128:
    v30 = *v8;
    if ( v26 >= v7 )
      break;
    v10 = *v30;
    v31 = v7 * v11 + v26;
    v32 = v31 < v7 * v11;
    v18 = v11 < v25;
    v19 = v11 == v25;
    v11 = v31;
    *v8 = v30 + 1;
    v13 |= 4 * (!v18 && !v19 || v32) | 8;
  }
  *v8 = v30 - 1;
  if ( v10 && *(v30 - 1) != v10 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
  }
  if ( v13 & 8 )
  {
    if ( v13 & 4 )
    {
      v35 = 1;
      v36 = v13;
LABEL_145:
      *(_BYTE *)(v40 + 48) = 1;
      *(_DWORD *)(v40 + 44) = 34;
      if ( v36 & v35 )
      {
        v37 = (WCHAR **)v8[1];
        if ( v13 & 2 )
        {
          if ( v37 )
            *v37 = *v8;
          result = 0x80000000i64;
        }
        else
        {
          if ( v37 )
            *v37 = *v8;
          result = 0x7FFFFFFFi64;
        }
        return result;
      }
      v11 = -1;
LABEL_156:
      v38 = (WCHAR **)v8[1];
      if ( v38 )
        *v38 = *v8;
      return v11;
    }
    if ( v13 & 1 )
    {
      if ( !(v13 & 2) )
      {
        if ( v11 <= 0x7FFFFFFF )
          goto LABEL_156;
        goto LABEL_144;
      }
      if ( v11 > 0x80000000 )
      {
LABEL_144:
        v36 = 1;
        v35 = v13;
        goto LABEL_145;
      }
    }
    else if ( !(v13 & 2) )
    {
      goto LABEL_156;
    }
    v11 = -v11;
    goto LABEL_156;
  }
  v33 = (WCHAR **)v8[1];
  *v8 = v39;
  if ( v33 )
    *v33 = v39;
  return 0i64;
}

//----- (0000000140016E50) ----------------------------------------------------
__int64 __usercall sub_140016E50@<rax>(__int16 a1@<dx>, int a2@<ecx>, __m128i *a3@<r8>, __m256i *a4@<ymm0>)
{
  __int64 v4; // rdi
  unsigned int v5; // ebx
  __int16 v6; // si
  unsigned int v7; // ebp
  __int64 v8; // rax
  __int64 result; // rax
  __int64 v10; // rax

  v4 = a2;
  v5 = 0;
  v6 = a1;
  v7 = a2 + 1;
  if ( a3 )
  {
    v10 = a3->m128i_i64[0];
    if ( v7 > 0x100 )
    {
      if ( *(_DWORD *)(v10 + 8) <= 1 )
        result = 0i64;
      else
        result = sub_140020888(a1, a2, a3, a4);
    }
    else
    {
      result = (unsigned __int16)(a1 & *(_WORD *)(*(_QWORD *)v10 + 2i64 * a2));
    }
  }
  else
  {
    v8 = sub_140020858(a4);
    if ( v7 <= 0x100 )
      v5 = (unsigned __int16)(v6 & *(_WORD *)(v8 + 2 * v4));
    result = v5;
  }
  return result;
}

//----- (0000000140016EC8) ----------------------------------------------------
__int64 __usercall sub_140016EC8@<rax>(__int64 *a1@<rdx>, __int64 a2@<rcx>, unsigned int a3@<r8d>, __m256i *a4@<ymm0>)
{
  unsigned int v4; // edi
  int v5; // ebx
  int v6; // ebx
  __int64 v8; // [rsp+20h] [rbp-50h]
  __int64 *v9; // [rsp+28h] [rbp-48h]
  __int64 v10; // [rsp+30h] [rbp-40h]
  char v11; // [rsp+40h] [rbp-30h]
  __int128 v12; // [rsp+48h] [rbp-28h]
  char v13; // [rsp+58h] [rbp-18h]
  int v14; // [rsp+5Ch] [rbp-14h]
  char v15; // [rsp+60h] [rbp-10h]
  int v16; // [rsp+64h] [rbp-Ch]
  char v17; // [rsp+68h] [rbp-8h]

  v10 = 0i64;
  v11 = 0;
  v13 = 0;
  v15 = 0;
  v17 = 0;
  if ( !dword_140040924 )
  {
    v13 = 1;
    _mm_storeu_si128((__m128i *)&v12, off_14003E2C8);
  }
  v8 = a2;
  v9 = a1;
  if ( a1 )
    *a1 = a2;
  v4 = sub_1400163C4((unsigned __int8 **)&v8, (__int64)&v10, a3, 0, a4);
  if ( v13 == 2 )
    *(_DWORD *)(v10 + 936) &= 0xFFFFFFFD;
  if ( v15 )
  {
    v5 = v14;
    *(_DWORD *)(sub_14001009C(&v10, a4) + 32) = v5;
  }
  if ( v17 )
  {
    v6 = v16;
    *(_DWORD *)(sub_14001009C(&v10, a4) + 36) = v6;
  }
  return v4;
}
// 140040924: using guessed type int dword_140040924;

//----- (0000000140016F7C) ----------------------------------------------------
__int64 __usercall sub_140016F7C@<rax>(__int64 *a1@<rdx>, __int64 a2@<rcx>, unsigned int a3@<r8d>, __m256i *a4@<ymm0>)
{
  unsigned int v4; // edi
  int v5; // ebx
  int v6; // ebx
  __int64 v8; // [rsp+20h] [rbp-50h]
  __int64 *v9; // [rsp+28h] [rbp-48h]
  __int64 v10; // [rsp+30h] [rbp-40h]
  char v11; // [rsp+40h] [rbp-30h]
  __int128 v12; // [rsp+48h] [rbp-28h]
  char v13; // [rsp+58h] [rbp-18h]
  int v14; // [rsp+5Ch] [rbp-14h]
  char v15; // [rsp+60h] [rbp-10h]
  int v16; // [rsp+64h] [rbp-Ch]
  char v17; // [rsp+68h] [rbp-8h]

  v10 = 0i64;
  v11 = 0;
  v13 = 0;
  v15 = 0;
  v17 = 0;
  if ( !dword_140040924 )
  {
    v13 = 1;
    _mm_storeu_si128((__m128i *)&v12, off_14003E2C8);
  }
  v8 = a2;
  v9 = a1;
  if ( a1 )
    *a1 = a2;
  v4 = sub_1400166B4((WCHAR **)&v8, (__int64)&v10, a3, 1u, a4);
  if ( v13 == 2 )
    *(_DWORD *)(v10 + 936) &= 0xFFFFFFFD;
  if ( v15 )
  {
    v5 = v14;
    *(_DWORD *)(sub_14001009C(&v10, a4) + 32) = v5;
  }
  if ( v17 )
  {
    v6 = v16;
    *(_DWORD *)(sub_14001009C(&v10, a4) + 36) = v6;
  }
  return v4;
}
// 140040924: using guessed type int dword_140040924;

//----- (0000000140017030) ----------------------------------------------------
signed __int64 __usercall sub_140017030@<rax>(const CHAR *a1@<rdx>, WCHAR *a2@<rcx>, unsigned __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  __int64 v5; // rbx
  unsigned __int64 v6; // rbp
  WCHAR *v7; // rsi
  unsigned __int64 v8; // rdi
  signed __int64 result; // rax
  __int64 v10; // rax
  UINT v11; // ecx
  __int64 v12; // rax
  __int64 v13; // rax
  int v14; // er9
  const CHAR *v15; // r8
  bool i; // zf
  __int64 v17; // [rsp+60h] [rbp+8h]
  const CHAR *v18; // [rsp+68h] [rbp+10h]

  v18 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = 0i64;
  if ( a2 )
  {
    if ( !a3 )
      return 0i64;
    *a2 = 0;
  }
  if ( !a1 )
  {
    *(_BYTE *)(a4 + 48) = 1;
    *(_DWORD *)(a4 + 44) = 22;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)a4);
    return -1i64;
  }
  if ( !*(_BYTE *)(a4 + 40) )
  {
    sub_140014910((signed __int64 *)a4, a5);
    a1 = v18;
  }
  v10 = *(_QWORD *)(v5 + 24);
  v11 = *(_DWORD *)(v10 + 12);
  if ( v11 == 65001 )
  {
    v17 = 0i64;
    return sub_1400209D4(v7, (char **)&v18, v6, &v17, v5);
  }
  v12 = *(_QWORD *)(v10 + 312);
  if ( !v7 )
  {
    v8 = -1i64;
    if ( !v12 )
    {
      do
        ++v8;
      while ( a1[v8] );
      goto LABEL_16;
    }
    v13 = sub_14001FB10(v11, 9, a1, -1, 0i64, 0);
    if ( !(_DWORD)v13 )
    {
      *(_BYTE *)(v5 + 48) = 1;
      *(_DWORD *)(v5 + 44) = 42;
      goto LABEL_16;
    }
    return v13 - 1;
  }
  if ( !v12 )
  {
    if ( v6 )
    {
      do
      {
        *v7 = (unsigned __int8)a1[v8];
        if ( !a1[v8] )
          break;
        ++v8;
        ++v7;
      }
      while ( v8 < v6 );
    }
    goto LABEL_16;
  }
  v8 = -1i64;
  v13 = sub_14001FB10(v11, 9, a1, -1, v7, v6);
  if ( (_DWORD)v13 )
    return v13 - 1;
  if ( GetLastError() != 122 )
    goto LABEL_19;
  v14 = v6;
  v15 = v18;
  for ( i = (_DWORD)v6 == 0; !i; i = v14 == 0 )
  {
    --v14;
    if ( !*v15 )
      break;
    if ( *(_WORD *)(**(_QWORD **)(v5 + 24) + 2i64 * *(unsigned __int8 *)v15) < 0 && !*++v15 )
      goto LABEL_19;
    ++v15;
  }
  result = sub_14001FB10(*(_DWORD *)(*(_QWORD *)(v5 + 24) + 12i64), 1, v18, (_DWORD)v15 - (_DWORD)v18, v7, v6);
  if ( !(_DWORD)result )
  {
LABEL_19:
    *(_BYTE *)(v5 + 48) = 1;
    *(_DWORD *)(v5 + 44) = 42;
    *v7 = 0;
LABEL_16:
    result = v8;
  }
  return result;
}

//----- (000000014001722C) ----------------------------------------------------
signed __int64 __usercall sub_14001722C@<rax>(const CHAR *a1@<rdx>, WCHAR *a2@<rcx>, unsigned __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  signed __int64 v4; // rdi
  int v5; // ebx
  int v6; // ebx
  __int64 v8; // [rsp+20h] [rbp-40h]
  char v9; // [rsp+30h] [rbp-30h]
  __int128 v10; // [rsp+38h] [rbp-28h]
  char v11; // [rsp+48h] [rbp-18h]
  int v12; // [rsp+4Ch] [rbp-14h]
  char v13; // [rsp+50h] [rbp-10h]
  int v14; // [rsp+54h] [rbp-Ch]
  char v15; // [rsp+58h] [rbp-8h]

  v8 = 0i64;
  v9 = 0;
  v11 = 0;
  v13 = 0;
  v15 = 0;
  if ( !dword_140040924 )
  {
    v11 = 1;
    _mm_storeu_si128((__m128i *)&v10, off_14003E2C8);
  }
  v4 = sub_140017030(a1, a2, a3, (__int64)&v8, a4);
  if ( v11 == 2 )
    *(_DWORD *)(v8 + 936) &= 0xFFFFFFFD;
  if ( v13 )
  {
    v5 = v12;
    *(_DWORD *)(sub_14001009C(&v8, a4) + 32) = v5;
  }
  if ( v15 )
  {
    v6 = v14;
    *(_DWORD *)(sub_14001009C(&v8, a4) + 36) = v6;
  }
  return v4;
}
// 140040924: using guessed type int dword_140040924;

//----- (00000001400172E0) ----------------------------------------------------
signed __int64 __fastcall sub_1400172E0(unsigned __int8 *a1, __int64 a2)
{
  __int64 v2; // rdx
  unsigned __int8 v3; // al
  __int64 v4; // rax
  signed __int64 result; // rax

  v2 = a2 - (_QWORD)a1;
  if ( (unsigned __int8)a1 & 7 )
  {
LABEL_2:
    while ( 1 )
    {
      v3 = *a1;
      if ( *a1 != a1[v2] )
        break;
      ++a1;
      if ( !v3 )
        goto LABEL_8;
      if ( !((unsigned __int8)a1 & 7) )
        goto LABEL_5;
    }
    result = -(signed __int64)(v3 < a1[v2]) | 1;
  }
  else
  {
    do
    {
LABEL_5:
      if ( (((_WORD)v2 + (_WORD)a1) & 0xFFFu) > 0xFF8 )
        goto LABEL_2;
      v4 = *(_QWORD *)a1;
      if ( *(_QWORD *)a1 != *(_QWORD *)&a1[v2] )
        goto LABEL_2;
      a1 += 8;
    }
    while ( !((v4 - 72340172838076673i64) & ~v4 & 0x8080808080808080ui64) );
LABEL_8:
    result = 0i64;
  }
  return result;
}

//----- (0000000140017348) ----------------------------------------------------
void __usercall sub_140017348(__int64 a1@<rcx>, __int64 *a2@<rdx>, __int64 **a3@<r8>, __int64 *a4@<r9>, __m256i *a5@<ymm0>)
{
  __int64 *v5; // rdi
  __int64 **v6; // rbx
  __int64 v7; // rcx
  unsigned int v8; // ecx

  v5 = a4;
  v6 = a3;
  sub_1400151DC(*a2);
  v7 = **v6;
  if ( v7 )
  {
    v8 = *(_DWORD *)(v7 + 20);
    if ( (v8 >> 13) & 1 )
    {
      if ( (v8 & 3) == 2 && v8 & 0xC0 || _bittest((const signed int *)&v8, 0xBu) )
      {
        if ( *(_BYTE *)v6[2] || (*(_DWORD *)(**v6 + 20) >> 1) & 1 )
        {
          if ( (unsigned int)sub_1400175F4(**v6, a5) == -1 )
            *(_DWORD *)v6[3] = -1;
          else
            ++*(_DWORD *)v6[1];
        }
      }
      else
      {
        ++*(_DWORD *)v6[1];
      }
    }
  }
  sub_1400151E8(*v5);
}

//----- (00000001400173E4) ----------------------------------------------------
void __usercall sub_1400173E4(__int64 a1@<rcx>, int *a2@<rdx>, _QWORD *a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  int *v5; // rdi
  _QWORD *v6; // rsi
  __int64 *v7; // rbx
  __int64 *v8; // r14
  __int64 v9; // rax
  int v10; // ecx
  __int64 v11; // rdx
  __int64 v12; // rcx
  _DWORD *v13; // rax
  __int64 v14; // [rsp+20h] [rbp-58h]
  __int64 v15; // [rsp+28h] [rbp-50h]
  __int64 v16; // [rsp+30h] [rbp-48h]
  __int64 *v17; // [rsp+38h] [rbp-40h]
  __int64 *v18; // [rsp+40h] [rbp-38h]
  _DWORD *v19; // [rsp+48h] [rbp-30h]
  __int64 v20; // [rsp+50h] [rbp-28h]
  __int64 v21; // [rsp+58h] [rbp-20h]
  char v22; // [rsp+88h] [rbp+10h]
  __int64 v23; // [rsp+98h] [rbp+20h]

  v23 = a4;
  v5 = (int *)a4;
  v6 = a3;
  sub_140020BC8(*a2);
  v7 = (__int64 *)lpMem;
  v8 = (__int64 *)((char *)lpMem + 8 * dword_1400406C0);
  while ( 1 )
  {
    v17 = v7;
    if ( v7 == v8 )
      break;
    v9 = *v7;
    v14 = v9;
    if ( v9 )
    {
      v10 = *(_DWORD *)(v9 + 20);
      if ( (*(_DWORD *)(v9 + 20) >> 13) & 1 )
      {
        if ( (v10 & 3) == 2 && v10 & 0xC0 || _bittest(&v10, 0xBu) )
        {
          v11 = v6[2];
          v12 = v6[1];
          v13 = (_DWORD *)*v6;
          v18 = &v14;
          v19 = v13;
          v20 = v12;
          v21 = v11;
          v15 = v14;
          v16 = v14;
          sub_140017348((__int64)&v22, &v16, &v18, &v15, a5);
        }
        else
        {
          ++*(_DWORD *)*v6;
        }
      }
    }
    ++v7;
  }
  sub_140020C28(*v5);
}
// 1400406C0: using guessed type int dword_1400406C0;

//----- (00000001400174C8) ----------------------------------------------------
__int64 __usercall sub_1400174C8@<rax>(__int64 *a1@<rdx>, __int64 **a2@<r8>, __int64 *a3@<r9>, __m256i *a4@<ymm0>)
{
  __int64 *v4; // rbx
  __int64 **v5; // rdi

  v4 = a3;
  v5 = a2;
  sub_1400151DC(*a1);
  LODWORD(v5) = sub_1400175F4(**v5, a4);
  sub_1400151E8(*v4);
  return (unsigned int)v5;
}

//----- (0000000140017508) ----------------------------------------------------
__int64 __usercall sub_140017508@<rax>(char a1@<cl>, __m256i *a2@<ymm0>)
{
  __int64 result; // rax
  int v3; // [rsp+20h] [rbp-20h]
  int v4; // [rsp+24h] [rbp-1Ch]
  unsigned int *v5; // [rsp+28h] [rbp-18h]
  char *v6; // [rsp+30h] [rbp-10h]
  unsigned int *v7; // [rsp+38h] [rbp-8h]
  char v8; // [rsp+50h] [rbp+10h]
  char v9; // [rsp+58h] [rbp+18h]
  unsigned int v10; // [rsp+60h] [rbp+20h]
  unsigned int v11; // [rsp+68h] [rbp+28h]

  v8 = a1;
  v11 = 0;
  v10 = 0;
  v5 = &v11;
  v6 = &v8;
  v7 = &v10;
  v3 = 8;
  v4 = 8;
  sub_1400173E4((__int64)&v9, &v4, &v5, (__int64)&v3, a2);
  result = v10;
  if ( v8 )
    result = v11;
  return result;
}

//----- (0000000140017568) ----------------------------------------------------
signed __int64 __usercall sub_140017568@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rbx
  __int64 v4; // rbp
  int v5; // ecx
  signed int v6; // edi
  unsigned __int16 *v7; // rsi
  int v8; // eax

  v3 = a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 20);
  if ( (v5 & 3) == 2 )
  {
    if ( v5 & 0xC0 )
    {
      v6 = *(_DWORD *)v3 - *(_DWORD *)(v3 + 8);
      *(_DWORD *)(v3 + 16) = 0;
      v7 = *(unsigned __int16 **)(v3 + 8);
      *(_QWORD *)v3 = v7;
      if ( v6 > 0 )
      {
        v8 = sub_14001A924(v3, a3);
        if ( v6 != (unsigned int)sub_14001D310(v7, v8, v6, v4, a3) )
        {
          _InterlockedOr((volatile signed __int32 *)(v3 + 20), 0x10u);
          return 0xFFFFFFFFi64;
        }
        if ( (*(_DWORD *)(v3 + 20) >> 2) & 1 )
          _InterlockedAnd((volatile signed __int32 *)(v3 + 20), 0xFFFFFFFD);
      }
    }
  }
  return 0i64;
}

//----- (00000001400175F4) ----------------------------------------------------
__int64 __usercall sub_1400175F4@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rbx
  unsigned int v3; // edi
  signed int v4; // eax
  int v5; // ebx
  int v6; // ebx
  __int64 v8; // [rsp+20h] [rbp-40h]
  char v9; // [rsp+30h] [rbp-30h]
  __int128 v10; // [rsp+38h] [rbp-28h]
  char v11; // [rsp+48h] [rbp-18h]
  int v12; // [rsp+4Ch] [rbp-14h]
  char v13; // [rsp+50h] [rbp-10h]
  int v14; // [rsp+54h] [rbp-Ch]
  char v15; // [rsp+58h] [rbp-8h]

  v8 = 0i64;
  v2 = a1;
  v9 = 0;
  v11 = 0;
  v13 = 0;
  v15 = 0;
  if ( !dword_140040924 )
  {
    v11 = 1;
    _mm_storeu_si128((__m128i *)&v10, off_14003E2C8);
  }
  if ( a1 )
  {
    if ( (unsigned int)sub_140017568((__int64)&v8, a1, a2)
      || (*(_DWORD *)(v2 + 20) >> 11) & 1 && (v4 = sub_14001A924(v2, a2), (unsigned int)sub_140020CD0(v4, a2)) )
    {
      v3 = -1;
    }
    else
    {
      v3 = 0;
    }
  }
  else
  {
    v3 = sub_140017508(0, a2);
  }
  if ( v11 == 2 )
    *(_DWORD *)(v8 + 936) &= 0xFFFFFFFD;
  if ( v13 )
  {
    v5 = v12;
    *(_DWORD *)(sub_14001009C(&v8, a2) + 32) = v5;
  }
  if ( v15 )
  {
    v6 = v14;
    *(_DWORD *)(sub_14001009C(&v8, a2) + 36) = v6;
  }
  return v3;
}
// 140040924: using guessed type int dword_140040924;

//----- (00000001400176C8) ----------------------------------------------------
__int64 __usercall sub_1400176C8@<rax>(__m256i *a1@<ymm0>)
{
  return sub_140017508(1, a1);
}

//----- (00000001400176D0) ----------------------------------------------------
__int64 __usercall sub_1400176D0@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  int v3; // edx
  __int64 v4; // [rsp+20h] [rbp-18h]
  __int64 v5; // [rsp+48h] [rbp+10h]
  __int64 v6; // [rsp+50h] [rbp+18h]
  __int64 *v7; // [rsp+58h] [rbp+20h]

  v5 = a1;
  if ( !a1 )
    return sub_140017508(0, a2);
  v3 = *(_DWORD *)(a1 + 20);
  if ( ((*(_DWORD *)(a1 + 20) & 3) != 2 || !(v3 & 0xC0)) && !_bittest(&v3, 0xBu) )
    return 0i64;
  v7 = &v5;
  v6 = v5;
  v4 = v5;
  return sub_1400174C8(&v4, &v7, &v6, a2);
}

//----- (0000000140017750) ----------------------------------------------------
__int64 __fastcall sub_140017750(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  __int64 v3; // r11
  __int64 v4; // rcx
  bool v5; // zf
  __int64 result; // rax
  unsigned __int64 v7; // rax
  bool v8; // cf
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rax
  unsigned int v11; // eax
  _QWORD *v12; // rcx
  unsigned __int64 i; // r8
  unsigned __int64 v14; // r8

  v3 = a1;
  if ( !a3 )
    return v3;
  v4 = a1 - (_QWORD)a2;
  if ( (unsigned __int8)a2 & 7 )
  {
    while ( 1 )
    {
      v5 = *a2 == 0;
      a2[v4] = *a2;
      if ( v5 )
        break;
      ++a2;
      if ( !--a3 )
        return v3;
      if ( !((unsigned __int8)a2 & 7) )
        goto LABEL_9;
    }
LABEL_29:
    v12 = &a2[v4];
    if ( a3 >= 0x10 )
    {
      while ( (unsigned __int8)v12 & 7 )
      {
        v12 = (_QWORD *)((char *)v12 + 1);
        *(_BYTE *)v12 = 0;
        --a3;
      }
      v8 = a3 < 0x20;
      for ( i = a3 - 32; !v8; i -= 32i64 )
      {
        *v12 = 0i64;
        v12[1] = 0i64;
        v12[2] = 0i64;
        v12[3] = 0i64;
        v12 += 4;
        v8 = i < 0x20;
      }
      v14 = i + 32;
      while ( 1 )
      {
        v8 = v14 < 8;
        v14 -= 8i64;
        if ( v8 )
          break;
        *v12 = 0i64;
        ++v12;
      }
      a3 = v14 + 8;
    }
    while ( 1 )
    {
      v8 = a3-- < 1;
      if ( v8 )
        break;
      *(_BYTE *)v12 = 0;
      v12 = (_QWORD *)((char *)v12 + 1);
    }
    result = v3;
  }
  else
  {
    do
    {
LABEL_9:
      while ( 1 )
      {
        v7 = *(_QWORD *)a2;
        v8 = a3 < 8;
        a3 -= 8i64;
        if ( v8 || a3 == 0 || ((v7 + 9151031864016699135i64) ^ ~v7) & 0x8101010101010100ui64 )
          break;
        *(_QWORD *)&a2[v4] = v7;
        a2 += 8;
      }
      a3 += 8i64;
      if ( !a3 )
        break;
      a2[v4] = v7;
      if ( !(_BYTE)v7 )
        goto LABEL_29;
      ++a2;
      if ( !--a3 )
        break;
      a2[v4] = BYTE1(v7);
      if ( !BYTE1(v7) )
        goto LABEL_29;
      ++a2;
      if ( !--a3 )
        break;
      v9 = v7 >> 16;
      a2[v4] = v9;
      if ( !(_BYTE)v9 )
        goto LABEL_29;
      ++a2;
      if ( !--a3 )
        break;
      a2[v4] = BYTE1(v9);
      if ( !BYTE1(v9) )
        goto LABEL_29;
      ++a2;
      if ( !--a3 )
        break;
      v10 = v9 >> 16;
      a2[v4] = v10;
      if ( !(_BYTE)v10 )
        goto LABEL_29;
      ++a2;
      if ( !--a3 )
        break;
      a2[v4] = BYTE1(v10);
      if ( !BYTE1(v10) )
        goto LABEL_29;
      ++a2;
      if ( !--a3 )
        break;
      v11 = (unsigned int)v10 >> 16;
      a2[v4] = v11;
      if ( !(_BYTE)v11 )
        goto LABEL_29;
      ++a2;
      if ( !--a3 )
        break;
      a2[v4] = BYTE1(v11);
      if ( !BYTE1(v11) )
        goto LABEL_29;
      ++a2;
      --a3;
    }
    while ( a3 );
    result = v3;
  }
  return result;
}

//----- (00000001400178B4) ----------------------------------------------------
_WORD *__usercall sub_1400178B4@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rdi
  signed __int64 v3; // rbx
  __int64 v4; // rbx
  _WORD *v5; // rax
  _WORD *v6; // rsi

  v2 = a1;
  if ( !a1 )
    return 0i64;
  v3 = -1i64;
  do
    ++v3;
  while ( *(_WORD *)(a1 + 2 * v3) );
  v4 = v3 + 1;
  v5 = (_WORD *)sub_140014FA0(2 * v4);
  v6 = v5;
  if ( !v5 )
    return 0i64;
  if ( (unsigned int)sub_140020D64(v4, v5, v2, a2) )
  {
    sub_14001ADD4(a2);
    JUMPOUT(*(_QWORD *)&byte_140017935);
  }
  return v6;
}
// 140014FA0: using guessed type __int64 __fastcall sub_140014FA0(_QWORD);
// 140017935: using guessed type char;

//----- (0000000140017938) ----------------------------------------------------
_WORD *__fastcall sub_140017938(_WORD *a1, __int64 a2, __int64 a3)
{
  _WORD *v3; // r9
  _WORD *v4; // rdi
  __int64 v5; // rdx
  __int16 v6; // ax
  __int64 i; // rcx

  v3 = a1;
  v4 = a1;
  if ( a3 )
  {
    v5 = a2 - (_QWORD)a1;
    while ( 1 )
    {
      v6 = *(_WORD *)((char *)v4 + v5);
      *v4 = v6;
      ++v4;
      --a3;
      if ( !v6 )
        break;
      if ( !a3 )
        return v3;
    }
    if ( a3 )
    {
      for ( i = a3; i; --i )
      {
        *v4 = 0;
        ++v4;
      }
    }
  }
  return v3;
}

//----- (0000000140017980) ----------------------------------------------------
__int64 __usercall sub_140017980@<rax>(__m128i *a1@<rdx>, __m128i *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  __m128i *v5; // rbx
  __m128i *v6; // rdi

  v5 = a1;
  v6 = a2;
  sub_140020BC8(11);
  LODWORD(v5) = sub_1400179C0(v5, v6, a3, a4, a5);
  sub_140020C28(11);
  return (unsigned int)v5;
}

//----- (00000001400179C0) ----------------------------------------------------
signed __int64 __usercall sub_1400179C0@<rax>(__m128i *a1@<rdx>, __m128i *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  unsigned int v5; // ebx
  const WCHAR *v6; // rsi
  const WCHAR *v7; // rdi
  _WORD *v9; // rax

  v5 = 0;
  v6 = (const WCHAR *)a1;
  v7 = (const WCHAR *)a2;
  if ( !qword_1400408F0 && !qword_1400408F8 )
    return 0xFFFFFFFFi64;
  if ( !a2 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a4);
    return 0xFFFFFFFFi64;
  }
  v9 = sub_140017A54(a1, a2, a3, a4, a5);
  if ( !v9 || (unsigned int)sub_1400216E4(v9) || qword_1400408F0 && !sub_140017BA8(v7, v6) )
    v5 = -1;
  sub_14001AE1C(0i64);
  return v5;
}

//----- (0000000140017A54) ----------------------------------------------------
_WORD *__usercall sub_140017A54@<rax>(__m128i *a1@<rdx>, __m128i *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  __m128i *v5; // rdi
  __int64 v6; // rsi
  unsigned __int64 v7; // r14
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rbp
  unsigned __int64 v11; // r15
  _WORD *v12; // rax
  _WORD *v13; // rbx
  _WORD *v14; // rcx
  __int64 v15; // rdx
  __int64 v16; // r8
  const __m128i *v17; // rax
  signed __int64 v18; // rdi
  _WORD *v19; // rax

  v5 = a1;
  v6 = (__int64)a2;
  if ( a1 )
  {
    v7 = sub_14001DC7C(0x7FFFui64, a2, a3, a5);
    v8 = sub_14001DC7C(0x7FFFui64, v5, a3, a5);
    v9 = v8;
    if ( v7 < 0x7FFF && v8 < 0x7FFF )
    {
      v11 = v7 + v8;
      v12 = sub_14001F068(v7 + v8 + 2, 2ui64);
      v13 = v12;
      if ( v12 )
      {
        sub_140020D64(v11 + 2, v12, v6, a4);
        v13[v7] = 61;
        v14 = &v13[v7 + 1];
        v15 = v9 + 1;
        v16 = (__int64)v5;
LABEL_15:
        sub_140020D64(v15, v14, v16, a4);
        goto LABEL_16;
      }
      goto LABEL_13;
    }
LABEL_3:
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a4);
    return 0i64;
  }
  v17 = sub_14000D644(a2, 0x3Du);
  if ( v17
    && ((signed __int64)(((unsigned __int64)v17 - v6) & 0xFFFFFFFFFFFFFFFEui64) >= 65534
     || (unsigned __int64)sub_14001DC7C(0x7FFFui64, (__m128i *)((char *)v17->m128i_i64 + 2), a3, a5) >= 0x7FFF) )
  {
    goto LABEL_3;
  }
  v18 = -1i64;
  do
    ++v18;
  while ( *(_WORD *)(v6 + 2 * v18) );
  v19 = sub_14001F068(v18 + 1, 2ui64);
  v13 = v19;
  if ( v19 )
  {
    v16 = v6;
    v15 = v18 + 1;
    v14 = v19;
    goto LABEL_15;
  }
LABEL_13:
  v13 = 0i64;
LABEL_16:
  sub_14001AE1C(0i64);
  return v13;
}

//----- (0000000140017BA8) ----------------------------------------------------
bool __fastcall sub_140017BA8(const WCHAR *a1, const WCHAR *a2)
{
  const WCHAR *v2; // rsi
  const WCHAR *v3; // rbp
  int v4; // eax
  unsigned __int64 v5; // rdi
  int v6; // eax
  CHAR *v7; // rax
  CHAR *v8; // rbx
  CHAR *v9; // rcx
  int v11; // eax
  int v12; // ecx
  _DWORD *v13; // rax
  CHAR *v14; // rax
  int v15; // ebx
  __int64 v16; // [rsp+28h] [rbp-20h]
  __int64 v17; // [rsp+28h] [rbp-20h]
  __int64 v18; // [rsp+28h] [rbp-20h]

  v2 = a2;
  v3 = a1;
  LODWORD(v16) = 0;
  v4 = sub_1400203D8(0, 0, a1, -1, 0i64, v16, 0i64, 0i64);
  v5 = v4;
  if ( !v4 )
    goto LABEL_2;
  if ( v2 )
  {
    LODWORD(v17) = 0;
    v6 = sub_1400203D8(0, 0, v2, -1, 0i64, v17, 0i64, 0i64);
    if ( !v6 )
    {
LABEL_2:
      v5 = 0i64;
      *(_DWORD *)sub_140015334() = 42;
      goto LABEL_6;
    }
    v5 += v6;
  }
LABEL_6:
  v7 = (CHAR *)sub_14001F068(v5, 1ui64);
  v8 = v7;
  if ( !v7 )
  {
    v9 = 0i64;
LABEL_8:
    sub_14001AE1C(v9);
    return 0;
  }
  LODWORD(v17) = v5;
  v11 = sub_1400203D8(0, 0, v3, -1, v7, v17, 0i64, 0i64);
  v12 = v11;
  if ( !v11
    || v2
    && (v14 = &v8[v11], LODWORD(v18) = v5 - v12, *(v14 - 1) = 61, !sub_1400203D8(0, 0, v2, -1, v14, v18, 0i64, 0i64)) )
  {
    v13 = sub_140015334();
    v9 = v8;
    *v13 = 42;
    goto LABEL_8;
  }
  v15 = sub_1400216DC(v8);
  sub_14001AE1C(0i64);
  return v15 == 0;
}

//----- (0000000140017CFC) ----------------------------------------------------
__int64 __usercall sub_140017CFC@<rax>(__m128i *a1@<rdx>, __m128i *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  unsigned int v5; // ebx

  v5 = 0;
  if ( a1 )
  {
    if ( (unsigned int)sub_140017980(a1, a2, a3, a4, a5) )
      v5 = *(_DWORD *)sub_140015334();
  }
  else
  {
    v5 = 22;
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a4);
  }
  return v5;
}

//----- (0000000140017D34) ----------------------------------------------------
signed __int64 __fastcall sub_140017D34(const WCHAR *a1)
{
  int v1; // eax

  if ( RemoveDirectoryW(a1) )
    return 0i64;
  v1 = GetLastError();
  sub_1400152A8(v1);
  return 0xFFFFFFFFi64;
}

//----- (0000000140017D5C) ----------------------------------------------------
HANDLE __usercall sub_140017D5C@<rax>(__int64 a1@<rdx>, const WCHAR *a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rbx
  HANDLE v5; // rdi
  DWORD v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int FindFileData; // [rsp+30h] [rbp-268h]
  char v11; // [rsp+34h] [rbp-264h]
  char v12; // [rsp+3Ch] [rbp-25Ch]
  char v13; // [rsp+44h] [rbp-254h]
  int v14; // [rsp+50h] [rbp-248h]
  char v15; // [rsp+5Ch] [rbp-23Ch]

  v3 = a1;
  if ( !a1 || !a2 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a3);
    return (HANDLE)-1i64;
  }
  v5 = FindFirstFileExW(a2, 0, &FindFileData, 0, 0i64, 0);
  if ( v5 == (HANDLE)-1i64 )
  {
    v6 = GetLastError() - 2;
    if ( !v6 )
      goto LABEL_22;
    v7 = v6 - 1;
    if ( !v7 )
      goto LABEL_22;
    v8 = v7 - 5;
    if ( !v8 )
    {
      *(_DWORD *)sub_140015334() = 12;
      return (HANDLE)-1i64;
    }
    if ( v8 == 10 )
    {
LABEL_22:
      *(_DWORD *)sub_140015334() = 2;
      return (HANDLE)-1i64;
    }
    *(_DWORD *)sub_140015334() = 22;
    return (HANDLE)-1i64;
  }
  v9 = FindFileData;
  if ( FindFileData == 128 )
    v9 = 0;
  *(_DWORD *)v3 = v9;
  *(_QWORD *)(v3 + 8) = sub_140017FCC((const FILETIME *)&v11);
  *(_QWORD *)(v3 + 16) = sub_140017FCC((const FILETIME *)&v12);
  *(_QWORD *)(v3 + 24) = sub_140017FCC((const FILETIME *)&v13);
  *(_DWORD *)(v3 + 32) = v14;
  if ( (unsigned int)sub_140020D64(260i64, (_WORD *)(v3 + 36), (__int64)&v15, a3) )
  {
    sub_14001ADD4(a3);
    __debugbreak();
    JUMPOUT(*(_QWORD *)sub_140017EA4);
  }
  return v5;
}

//----- (0000000140017EA4) ----------------------------------------------------
__int64 __usercall sub_140017EA4@<rax>(__int64 a1@<rdx>, void *a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rbx
  __int64 result; // rax
  DWORD v5; // eax
  int v6; // eax
  int v7; // eax
  DWORD v8; // eax
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+30h] [rbp-268h]

  v3 = a1;
  if ( !a2 || a2 == (void *)-1i64 || !a1 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a3);
    return 0xFFFFFFFFi64;
  }
  if ( !FindNextFileW(a2, &FindFileData) )
  {
    v5 = GetLastError() - 2;
    if ( !v5 )
      goto LABEL_22;
    v6 = v5 - 1;
    if ( !v6 )
      goto LABEL_22;
    v7 = v6 - 5;
    if ( !v7 )
    {
      *(_DWORD *)sub_140015334() = 12;
      return 0xFFFFFFFFi64;
    }
    if ( v7 == 10 )
    {
LABEL_22:
      *(_DWORD *)sub_140015334() = 2;
      return 0xFFFFFFFFi64;
    }
    *(_DWORD *)sub_140015334() = 22;
    return 0xFFFFFFFFi64;
  }
  v8 = FindFileData.dwFileAttributes;
  if ( FindFileData.dwFileAttributes == 128 )
    v8 = 0;
  *(_DWORD *)v3 = v8;
  *(_QWORD *)(v3 + 8) = sub_140017FCC(&FindFileData.ftCreationTime);
  *(_QWORD *)(v3 + 16) = sub_140017FCC(&FindFileData.ftLastAccessTime);
  *(_QWORD *)(v3 + 24) = sub_140017FCC(&FindFileData.ftLastWriteTime);
  *(_DWORD *)(v3 + 32) = FindFileData.nFileSizeLow;
  result = sub_140020D64(260i64, (_WORD *)(v3 + 36), (__int64)FindFileData.cFileName, a3);
  if ( (_DWORD)result )
  {
    sub_14001ADD4(a3);
    JUMPOUT(*(_QWORD *)&byte_140017FCA);
  }
  return result;
}
// 140017FCA: using guessed type char;

//----- (0000000140017FCC) ----------------------------------------------------
__int64 __fastcall sub_140017FCC(const FILETIME *a1)
{
  __int64 result; // rax
  struct _SYSTEMTIME LocalTime; // [rsp+40h] [rbp-38h]
  struct _SYSTEMTIME SystemTime; // [rsp+50h] [rbp-28h]

  if ( (a1->dwLowDateTime || a1->dwHighDateTime)
    && FileTimeToSystemTime(a1, &SystemTime)
    && SystemTimeToTzSpecificLocalTime(0i64, &SystemTime, &LocalTime) )
  {
    result = sub_14001FE30(LocalTime.wYear, LocalTime.wMonth, LocalTime.wDay, LocalTime.wHour, LocalTime.wMinute);
  }
  else
  {
    result = -1i64;
  }
  return result;
}
// 14001FE30: using guessed type __int64 __fastcall sub_14001FE30(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000000014001805C) ----------------------------------------------------
signed __int64 __fastcall sub_14001805C(void *a1)
{
  if ( FindClose(a1) )
    return 0i64;
  *(_DWORD *)sub_140015334() = 22;
  return 0xFFFFFFFFi64;
}

//----- (0000000140018094) ----------------------------------------------------
char *sub_140018094()
{
  char *v0; // rax
  char *v1; // rsi
  char *v2; // rbx
  signed __int64 v3; // rbp
  signed __int64 v4; // rdi
  _BYTE *v5; // rcx
  unsigned int v6; // eax

  v0 = (char *)sub_14001F068(0x40ui64, 0x48ui64);
  v1 = 0i64;
  v2 = v0;
  if ( v0 )
  {
    v3 = (signed __int64)(v0 + 4608);
    if ( v0 != v0 + 4608 )
    {
      v4 = (signed __int64)(v0 + 48);
      do
      {
        sub_14001F444((LPCRITICAL_SECTION)(v4 - 48), 0xFA0u);
        *(_QWORD *)(v4 - 8) = -1i64;
        v5 = (_BYTE *)(v4 + 14);
        *(_BYTE *)(v4 + 13) &= 0xF8u;
        v6 = 0;
        *(_QWORD *)v4 = 0i64;
        *(_DWORD *)(v4 + 8) = 168427520;
        *(_BYTE *)(v4 + 12) = 10;
        do
        {
          *v5 = 0;
          ++v6;
          ++v5;
        }
        while ( v6 < 5 );
        v4 += 72i64;
      }
      while ( v4 - 48 != v3 );
    }
    v1 = v2;
  }
  sub_14001AE1C(0i64);
  return v1;
}

//----- (000000014001813C) ----------------------------------------------------
void __fastcall sub_14001813C(LPCRITICAL_SECTION lpCriticalSection)
{
  LONG *v1; // rsi
  LPCRITICAL_SECTION v2; // rbx
  struct _RTL_CRITICAL_SECTION *v3; // rdi

  if ( lpCriticalSection )
  {
    v1 = &lpCriticalSection[115].LockCount;
    v2 = lpCriticalSection;
    v3 = lpCriticalSection;
    if ( lpCriticalSection != (LPCRITICAL_SECTION)&lpCriticalSection[115].LockCount )
    {
      do
      {
        DeleteCriticalSection(v3);
        v3 = (struct _RTL_CRITICAL_SECTION *)((char *)v3 + 72);
      }
      while ( v3 != (struct _RTL_CRITICAL_SECTION *)v1 );
    }
    sub_14001AE1C(v2);
  }
}

//----- (000000014001818C) ----------------------------------------------------
signed __int64 __usercall sub_14001818C@<rax>(unsigned int a1@<ecx>, __m256i *a2@<ymm0>)
{
  int v2; // esi
  signed __int64 result; // rax
  unsigned int v4; // edi
  __int64 v5; // rbx
  int v6; // eax
  char *v7; // rax

  v2 = a1;
  if ( a1 < 0x2000 )
  {
    v4 = 0;
    sub_140020BC8(7);
    v5 = 0i64;
    v6 = dword_140040D70;
    while ( v2 >= v6 )
    {
      if ( !qword_140040970[v5] )
      {
        v7 = sub_140018094();
        qword_140040970[v5] = (__int64)v7;
        if ( !v7 )
        {
          v4 = 12;
          break;
        }
        v6 = dword_140040D70 + 64;
        dword_140040D70 += 64;
      }
      ++v5;
    }
    sub_140020C28(7);
    result = v4;
  }
  else
  {
    *(_DWORD *)sub_140015334() = 9;
    sub_14001ADB4(a2);
    result = 9i64;
  }
  return result;
}
// 140040D70: using guessed type int dword_140040D70;

//----- (0000000140018234) ----------------------------------------------------
void __fastcall sub_140018234(int a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(qword_140040970[(signed __int64)a1 >> 6] + 72i64 * (a1 & 0x3F)));
}

//----- (000000014001825C) ----------------------------------------------------
signed __int64 __fastcall sub_14001825C(signed int a1, void *a2)
{
  signed int v2; // ebx
  void *v3; // rdi
  unsigned __int64 v4; // rsi
  signed __int64 v5; // rbp
  int v6; // ebx
  DWORD v7; // ecx

  v2 = a1;
  v3 = a2;
  if ( a1 >= 0 && a1 < (unsigned int)dword_140040D70 )
  {
    v4 = (unsigned __int64)a1 >> 6;
    v5 = 9i64 * (a1 & 0x3F);
    if ( *(_QWORD *)(qword_140040970[v4] + 72i64 * (a1 & 0x3F) + 40) == -1i64 )
    {
      if ( (unsigned int)sub_140019214() == 1 )
      {
        if ( !v2 )
        {
          v7 = -10;
          goto LABEL_11;
        }
        v6 = v2 - 1;
        if ( !v6 )
        {
          v7 = -11;
          goto LABEL_11;
        }
        if ( v6 == 1 )
        {
          v7 = -12;
LABEL_11:
          SetStdHandle(v7, v3);
          goto LABEL_12;
        }
      }
LABEL_12:
      *(_QWORD *)(qword_140040970[v4] + 8 * v5 + 40) = v3;
      return 0i64;
    }
  }
  *(_DWORD *)sub_140015334() = 9;
  *(_DWORD *)sub_140015314() = 0;
  return 0xFFFFFFFFi64;
}
// 140040D70: using guessed type int dword_140040D70;

//----- (000000014001831C) ----------------------------------------------------
void __fastcall sub_14001831C(int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(qword_140040970[(signed __int64)a1 >> 6] + 72i64 * (a1 & 0x3F)));
}

//----- (0000000140018344) ----------------------------------------------------
__int64 sub_140018344()
{
  unsigned int v0; // er14
  signed int i; // ebx
  __int64 v2; // rsi
  char *v3; // rax
  int v4; // ebx
  __int64 j; // rdi
  __int64 v6; // rdi
  signed int v7; // ebx
  signed __int64 v8; // r8
  signed __int64 v9; // rcx

  sub_140020BC8(7);
  v0 = -1;
  for ( i = 0; i < 128; ++i )
  {
    v2 = qword_140040970[i];
    if ( !v2 )
    {
      v3 = sub_140018094();
      qword_140040970[i] = (__int64)v3;
      if ( v3 )
      {
        dword_140040D70 += 64;
        v4 = i << 6;
        sub_140018234(v4);
        *(_BYTE *)(qword_140040970[(signed __int64)v4 >> 6] + 56) = 1;
        v0 = v4;
      }
      break;
    }
    for ( j = qword_140040970[i]; j != v2 + 4608; j += 72i64 )
    {
      if ( !(*(_BYTE *)(j + 56) & 1) )
      {
        EnterCriticalSection((LPCRITICAL_SECTION)j);
        if ( !(*(_BYTE *)(j + 56) & 1) )
        {
          v6 = j - v2;
          v7 = i << 6;
          v8 = (signed __int64)(signed int)(v7
                                          + ((unsigned __int64)((unsigned __int128)(v6
                                                                                  * (signed __int128)1024819115206086201i64) >> 64) >> 63)
                                          + ((signed __int64)((unsigned __int128)(v6
                                                                                * (signed __int128)1024819115206086201i64) >> 64) >> 2)) >> 6;
          v9 = 9i64
             * (((_BYTE)v7
               + ((((unsigned __int128)(v6 * (signed __int128)1024819115206086201i64) >> 64) & 0x8000000000000000ui64) != 0i64)
               + (unsigned __int8)((signed __int64)((unsigned __int128)(v6 * (signed __int128)1024819115206086201i64) >> 64) >> 2)) & 0x3F);
          *(_BYTE *)(qword_140040970[v8] + 8 * v9 + 56) = 1;
          *(_QWORD *)(qword_140040970[v8] + 8 * v9 + 40) = -1i64;
          v0 = v7
             + ((unsigned __int64)((unsigned __int128)(v6 * (signed __int128)1024819115206086201i64) >> 64) >> 63)
             + ((signed __int64)((unsigned __int128)(v6 * (signed __int128)1024819115206086201i64) >> 64) >> 2);
          goto LABEL_14;
        }
        LeaveCriticalSection((LPCRITICAL_SECTION)j);
      }
    }
  }
LABEL_14:
  sub_140020C28(7);
  return v0;
}
// 140040D70: using guessed type int dword_140040D70;

//----- (0000000140018484) ----------------------------------------------------
signed __int64 __fastcall sub_140018484(signed int a1)
{
  signed int v1; // ebx
  unsigned __int64 v2; // rsi
  signed __int64 v3; // rdi
  __int64 v4; // rax
  int v5; // ebx
  DWORD v6; // ecx

  v1 = a1;
  if ( a1 >= 0 && a1 < (unsigned int)dword_140040D70 )
  {
    v2 = (unsigned __int64)a1 >> 6;
    v3 = 9i64 * (a1 & 0x3F);
    v4 = qword_140040970[v2];
    if ( *(_BYTE *)(v4 + 72i64 * (a1 & 0x3F) + 56) & 1 )
    {
      if ( *(_QWORD *)(v4 + 72i64 * (a1 & 0x3F) + 40) != -1i64 )
      {
        if ( (unsigned int)sub_140019214() == 1 )
        {
          if ( !v1 )
          {
            v6 = -10;
            goto LABEL_12;
          }
          v5 = v1 - 1;
          if ( !v5 )
          {
            v6 = -11;
            goto LABEL_12;
          }
          if ( v5 == 1 )
          {
            v6 = -12;
LABEL_12:
            SetStdHandle(v6, 0i64);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_QWORD *)(qword_140040970[v2] + 8 * v3 + 40) = -1i64;
        return 0i64;
      }
    }
  }
  *(_DWORD *)sub_140015334() = 9;
  *(_DWORD *)sub_140015314() = 0;
  return 0xFFFFFFFFi64;
}
// 140040D70: using guessed type int dword_140040D70;

//----- (0000000140018540) ----------------------------------------------------
signed __int64 __usercall sub_140018540@<rax>(unsigned __int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rax

  if ( (_DWORD)a1 == -2 )
  {
    *(_DWORD *)sub_140015314() = 0;
    *(_DWORD *)sub_140015334() = 9;
  }
  else
  {
    if ( (a1 & 0x80000000) == 0i64 && (unsigned int)a1 < dword_140040D70 )
    {
      a1 = (signed int)a1;
      v2 = a1;
      v3 = a1 & 0x3F;
      v4 = qword_140040970[v2 >> 6];
      if ( *(_BYTE *)(v4 + 72 * v3 + 56) & 1 )
        return *(_QWORD *)(v4 + 72 * v3 + 40);
    }
    *(_DWORD *)sub_140015314() = 0;
    *(_DWORD *)sub_140015334() = 9;
    sub_14001ADB4(a2);
  }
  return -1i64;
}
// 140040D70: using guessed type int dword_140040D70;

//----- (00000001400185B8) ----------------------------------------------------
signed __int64 __fastcall sub_1400185B8(const WCHAR *a1)
{
  int v1; // eax

  if ( DeleteFileW(a1) )
    return 0i64;
  v1 = GetLastError();
  sub_1400152A8(v1);
  return 0xFFFFFFFFi64;
}

//----- (00000001400185E0) ----------------------------------------------------
_WORD *__usercall sub_1400185E0@<rax>(__int64 a1@<rdx>, const WCHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  __int64 v5; // r12
  const WCHAR *v6; // rsi
  int v7; // eax
  __int16 *v8; // rbx
  __int16 *v9; // rdi
  __int16 *v10; // rsi
  const WCHAR *v11; // rax
  signed __int64 v12; // r14
  signed __int64 v13; // rbp
  signed __int64 v14; // rax
  __int64 v15; // r15
  _WORD *v16; // rax
  _WORD *v17; // rbx
  void *v18; // rcx
  signed __int64 v20; // rax
  signed __int64 v21; // rcx
  LPVOID lpMem; // [rsp+60h] [rbp+8h]

  v5 = a1;
  v6 = a2;
  lpMem = 0i64;
  v7 = sub_140021AD8(0i64, &lpMem, (__m128i *)L"TMP", a3, a4, a5);
  if ( v7 )
  {
    if ( v7 == 22 )
    {
      sub_14001ADD4(a4);
      __debugbreak();
      goto LABEL_42;
    }
    v8 = 0i64;
  }
  else
  {
    v8 = (__int16 *)lpMem;
    if ( lpMem )
    {
      if ( !(unsigned int)sub_140021B78(0, (const WCHAR *)lpMem, a4) )
      {
        v9 = v8;
        v10 = v8;
        v8 = 0i64;
        goto LABEL_17;
      }
      v11 = sub_140018908(v8);
      v9 = (__int16 *)v11;
      if ( v11 && !(unsigned int)sub_140021B78(0, v11, a4) )
      {
        sub_14001AE1C(0i64);
        v10 = v9;
        goto LABEL_17;
      }
      sub_14001AE1C(v9);
    }
  }
  if ( !v6 || (unsigned int)sub_140021B78(0, v6, a4) )
  {
    v9 = (__int16 *)&unk_140032734;
    if ( (unsigned int)sub_140021B78(0, (const WCHAR *)&unk_140032734, a4) )
      v9 = (__int16 *)&unk_140032738;
  }
  else
  {
    v9 = (__int16 *)v6;
  }
  v10 = 0i64;
LABEL_17:
  sub_14001AE1C(v8);
  v12 = -1i64;
  if ( v5 )
  {
    v13 = -1i64;
    do
      ++v13;
    while ( *(_WORD *)(v5 + 2 * v13) );
  }
  else
  {
    LODWORD(v13) = 0;
  }
  v14 = -1i64;
  do
    ++v14;
  while ( v9[v14] );
  v15 = (unsigned int)(v13 + v14 + 12);
  v16 = (_WORD *)sub_140014F84(v15, 2i64);
  v17 = v16;
  if ( !v16 )
  {
    v18 = 0i64;
LABEL_26:
    sub_140014F8C(v18);
    sub_14001AE1C(v10);
    return 0i64;
  }
  *v16 = 0;
  if ( (unsigned int)sub_140021B00(v15, v16, (__int64)v9, a4) )
    goto LABEL_42;
  v20 = -1i64;
  do
    ++v20;
  while ( v9[v20] );
  v21 = (signed __int64)&v9[v20];
  if ( v9 != (__int16 *)v21
    && *(_WORD *)(v21 - 2) != 92
    && *(_WORD *)(v21 - 2) != 47
    && (unsigned int)sub_140021B00(v15, v17, (__int64)&unk_140032730, a4) )
  {
    goto LABEL_42;
  }
  if ( v5 && (unsigned int)sub_140021B00(v15, v17, v5, a4) )
  {
LABEL_42:
    sub_14001ADD4(a4);
    JUMPOUT(*(_QWORD *)&byte_140018812);
  }
  do
    ++v12;
  while ( v17[v12] );
  if ( !sub_140018814(&v17[v12], v17, v15 - (2 * v12 >> 1), (unsigned int)v13, a4) )
  {
    v18 = v17;
    goto LABEL_26;
  }
  sub_140014F8C(0i64);
  sub_14001AE1C(v10);
  return v17;
}
// 140014F84: using guessed type __int64 __fastcall sub_140014F84(_QWORD, _QWORD);
// 140018812: using guessed type char;
// 140032740: using guessed type wchar_t aTmp_0[4];

//----- (0000000140018814) ----------------------------------------------------
char __usercall sub_140018814@<al>(_WORD *a1@<rdx>, const WCHAR *a2@<rcx>, unsigned __int64 a3@<r8>, unsigned __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // r15
  _WORD *v7; // r12
  const WCHAR *v8; // r14
  char v9; // bl
  signed int v10; // esi
  int v11; // edi
  unsigned int v12; // ecx
  _DWORD *v13; // rax

  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = a2;
  v9 = 0;
  sub_140020BC8(12);
  v10 = dword_14003E430;
  if ( (unsigned int)dword_140041184 < v5 )
    v10 = 1;
  dword_14003E430 = v10;
  dword_140041184 = v5;
  v11 = *(_DWORD *)sub_140015334();
  while ( 1 )
  {
    v12 = dword_14003E430 + 1;
    dword_14003E430 = v12;
    if ( v12 - v10 > 0x7FFFFFFF )
      break;
    if ( (unsigned int)sub_14002183C(v7, v12, v6, 0xAu, a5) )
    {
      sub_14001ADD4(a5);
      JUMPOUT(*(_QWORD *)&byte_140018904);
    }
    *(_DWORD *)sub_140015334() = 0;
    if ( (unsigned int)sub_140021B78(0, v8, a5) && *(_DWORD *)sub_140015334() != 13 )
    {
      v13 = sub_140015334();
      v9 = 1;
      goto LABEL_10;
    }
  }
  v13 = sub_140015334();
LABEL_10:
  *v13 = v11;
  sub_140020C28(12);
  return v9;
}
// 140018904: using guessed type char;
// 14003E430: using guessed type int dword_14003E430;
// 140041184: using guessed type int dword_140041184;

//----- (0000000140018908) ----------------------------------------------------
_WORD *__fastcall sub_140018908(__int16 *a1)
{
  __int16 *v1; // rdi
  signed __int64 v2; // rdx
  __int64 v3; // rcx
  __int16 *v4; // r9
  __int16 v5; // r8
  bool v6; // zf
  signed __int64 v7; // rax
  _WORD *v8; // rax
  _WORD *v9; // rbx
  _WORD *v11; // rcx
  __int16 v12; // ax

  v1 = a1;
  v2 = 0i64;
  v3 = 0i64;
  v4 = v1;
  v5 = *v1;
  if ( !*v1 )
    return 0i64;
  do
  {
    v6 = v5 == 34;
    v7 = v2 + 1;
    ++v4;
    v5 = *v4;
    if ( !v6 )
      v7 = v2;
    ++v3;
    v2 = v7;
  }
  while ( v5 );
  if ( !v7 )
    return 0i64;
  v8 = sub_14001F068(v3 - v7 + 1, 2ui64);
  v9 = v8;
  if ( !v8 )
  {
    sub_14001AE1C(0i64);
    return 0i64;
  }
  v11 = v8;
  while ( 1 )
  {
    v12 = *v1;
    if ( !*v1 )
      break;
    if ( v12 != 34 )
    {
      *v11 = v12;
      ++v11;
    }
    ++v1;
  }
  *v11 = 0;
  sub_14001AE1C(0i64);
  return v9;
}

//----- (00000001400189B4) ----------------------------------------------------
_WORD *__usercall sub_1400189B4@<rax>(__int64 a1@<rdx>, const WCHAR *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  return sub_1400185E0(a1, a2, a3, a4, a5);
}

//----- (00000001400189D8) ----------------------------------------------------
__int64 __usercall sub_1400189D8@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rdi
  __int64 result; // rax
  signed __int64 v4; // rbx
  _BYTE *v5; // rdx

  v2 = a1;
  if ( a1 )
  {
    sub_1400151DC(a1);
    _InterlockedAnd((volatile signed __int32 *)(v2 + 20), 0xFFFFFFE7);
    if ( (unsigned int)sub_14001A924(v2, a2) == -1 || (unsigned int)sub_14001A924(v2, a2) == -2 )
    {
      v5 = &unk_14003E3E0;
    }
    else
    {
      v4 = (signed __int64)(signed int)sub_14001A924(v2, a2) >> 6;
      v5 = (_BYTE *)(qword_140040970[v4] + 72 * (sub_14001A924(v2, a2) & 0x3F));
    }
    v5[56] &= 0xFDu;
    sub_1400151E8(v2);
    result = 0i64;
  }
  else
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a2);
    result = (unsigned int)(v2 + 22);
  }
  return result;
}

//----- (0000000140018A8C) ----------------------------------------------------
signed __int64 __usercall sub_140018A8C@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  signed __int64 result; // rax
  signed __int64 v6; // rdi

  v3 = a1;
  v4 = a2;
  if ( a2 )
  {
    sub_1400151DC(a2);
    v6 = sub_140018AF8(v3, v4, a3);
    sub_1400151E8(v4);
    result = v6;
  }
  else
  {
    *(_BYTE *)(a1 + 48) = 1;
    *(_DWORD *)(a1 + 44) = 22;
    sub_14001ACE8(0i64, a3, 0i64, (signed __int64 *)a1);
    result = -1i64;
  }
  return result;
}

//----- (0000000140018AF8) ----------------------------------------------------
signed __int64 __usercall sub_140018AF8@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  unsigned int v6; // eax
  __int64 v7; // rsi
  __int64 v8; // r11
  unsigned __int64 v9; // r10
  __int64 v10; // rcx
  signed __int64 v11; // rdx
  char v12; // si

  v3 = a1;
  v4 = a2;
  if ( !a2 )
  {
    *(_BYTE *)(a1 + 48) = 1;
    *(_DWORD *)(a1 + 44) = 22;
    sub_14001ACE8(0i64, a3, 0i64, (signed __int64 *)a1);
    return -1i64;
  }
  v6 = sub_14001A924(a2, a3);
  v7 = (signed int)v6;
  if ( *(_DWORD *)(v4 + 16) < 0 )
    *(_DWORD *)(v4 + 16) = 0;
  v8 = sub_14001C74C(v6, 0i64, 1i64, v3);
  if ( v8 < 0 )
    return -1i64;
  if ( !(*(_DWORD *)(v4 + 20) & 0xC0) )
    return v8 - *(signed int *)(v4 + 16);
  v9 = *(_QWORD *)v4 - *(_QWORD *)(v4 + 8);
  v10 = v7 >> 6;
  v11 = 9 * (v7 & 0x3F);
  v12 = *(_BYTE *)(qword_140040970[v7 >> 6] + 72 * (v7 & 0x3F) + 57);
  if ( *(_DWORD *)(v4 + 20) & 3 )
  {
    if ( v12 == 1 && *(_BYTE *)(qword_140040970[v10] + 8 * v11 + 61) & 2 )
      return sub_140018DA4(v8, v4, v3, a3);
    if ( *(_BYTE *)(qword_140040970[v10] + 8 * v11 + 56) < 0 )
      v9 += sub_140018F28(*(_BYTE **)(v4 + 8), *(_BYTE **)v4, v12);
  }
  else if ( !((*(_DWORD *)(v4 + 20) >> 2) & 1) )
  {
    *(_BYTE *)(v3 + 48) = 1;
    *(_DWORD *)(v3 + 44) = 22;
    return -1i64;
  }
  if ( !v8 )
    return v9;
  if ( *(_DWORD *)(v4 + 20) & 1 )
    return sub_140018C48(v8, v4, v9, v3, a3);
  if ( v12 == 1 )
    v9 >>= 1;
  return v9 + v8;
}
// 14001C74C: using guessed type __int64 __fastcall sub_14001C74C(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140018C48) ----------------------------------------------------
signed __int64 __usercall sub_140018C48@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  __int64 v5; // r14
  __int64 v6; // rbx
  unsigned int v7; // eax
  unsigned int v8; // er12
  __int64 v9; // rdi
  __int64 v10; // rcx
  signed __int64 v11; // rax
  signed __int64 v12; // r13
  __int64 v13; // rax
  char v14; // si
  signed __int64 result; // rax
  signed __int64 v16; // rbp
  signed __int64 v17; // rax
  signed __int64 v18; // rdx
  bool v19; // zf
  signed __int64 v20; // [rsp+60h] [rbp+8h]
  __int64 v21; // [rsp+70h] [rbp+18h]
  __int64 v22; // [rsp+78h] [rbp+20h]

  v22 = a4;
  v21 = a3;
  v5 = a1;
  v6 = a2;
  v7 = sub_14001A924(a2, a5);
  v8 = v7;
  v9 = 0i64;
  v10 = v7 & 0x3F;
  v11 = (signed __int64)(signed int)v7 >> 6;
  v20 = v11;
  v12 = 9 * v10;
  v13 = qword_140040970[v11];
  v14 = *(_BYTE *)(v13 + 72 * v10 + 57);
  if ( !*(_DWORD *)(v6 + 16) )
    return v5;
  v16 = *(_QWORD *)v6 + *(signed int *)(v6 + 16) - *(_QWORD *)(v6 + 8);
  if ( *(_BYTE *)(v13 + 72 * v10 + 56) < 0 )
  {
    if ( sub_14001C74C(v8, 0i64, 2i64, v22) == v5 )
    {
      v18 = sub_140018F28(*(_BYTE **)(v6 + 8), (_BYTE *)(*(_QWORD *)(v6 + 8) + v16), v14) + v16;
      v19 = ((*(_DWORD *)(v6 + 20) >> 5) & 1) == 0;
    }
    else
    {
      result = sub_14001C74C(v8, v5, 0i64, v22);
      if ( result == -1 )
        return result;
      v18 = 512i64;
      if ( v16 > 512 || !((*(_DWORD *)(v6 + 20) >> 6) & 1) || (*(_WORD *)(v6 + 20) >> 8) & 1 )
        v18 = *(signed int *)(v6 + 32);
      v19 = (*(_BYTE *)(qword_140040970[v20] + 8 * v12 + 56) & 4) == 0;
    }
    if ( !v19 )
    {
      LOBYTE(v9) = (unsigned __int8)(v14 - 1) <= 1u;
      v18 += v9 + 1;
    }
    v17 = v18;
  }
  else
  {
    v17 = *(_QWORD *)v6 + *(signed int *)(v6 + 16) - *(_QWORD *)(v6 + 8);
  }
  return v5 + v21 / ((v14 == 1) + 1i64) - v17 / ((v14 == 1) + 1i64);
}
// 14001C74C: using guessed type __int64 __fastcall sub_14001C74C(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140018DA4) ----------------------------------------------------
signed __int64 __usercall sub_140018DA4@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  __int64 v4; // r15
  __int64 v5; // rbp
  __int64 v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // r14
  signed __int64 v10; // rsi
  __int64 v11; // r13
  __int64 v12; // rcx
  char *v13; // rdx
  char *v14; // rcx
  DWORD NumberOfBytesRead; // [rsp+30h] [rbp-1058h]
  char Buffer[4096]; // [rsp+40h] [rbp-1048h]

  v4 = a3;
  v5 = a1;
  v6 = a2;
  v7 = 0i64;
  v8 = (signed int)sub_14001A924(a2, a4);
  if ( !*(_DWORD *)(v6 + 16) )
    return v5;
  v10 = (*(_QWORD *)v6 - *(_QWORD *)(v6 + 8)) / 2i64;
  v11 = sub_14001C74C((unsigned int)v8, *(_QWORD *)(qword_140040970[v8 >> 6] + 72 * (v8 & 0x3F) + 48), 0i64, v4);
  v12 = qword_140040970[v8 >> 6];
  if ( v11 != *(_QWORD *)(v12 + 72 * (v8 & 0x3F) + 48)
    || !ReadFile(*(HANDLE *)(v12 + 72 * (v8 & 0x3F) + 40), Buffer, 0x1000u, &NumberOfBytesRead, 0i64)
    || sub_14001C74C((unsigned int)v8, v5, 0i64, v4) < 0
    || v10 > NumberOfBytesRead )
  {
    return -1i64;
  }
  v13 = &Buffer[NumberOfBytesRead];
  v14 = Buffer;
  if ( v10 )
  {
    do
    {
      if ( v14 >= v13 )
        break;
      if ( *v14 == 13 )
      {
        if ( v14 < v13 - 1 && v14[1] == 10 )
          ++v14;
      }
      else
      {
        v14 += byte_14003E2E0[(unsigned __int8)*v14];
      }
      ++v7;
      ++v14;
    }
    while ( v7 != v10 );
  }
  return v14 - Buffer + v11;
}
// 14001C74C: using guessed type __int64 __fastcall sub_14001C74C(_QWORD, _QWORD, _QWORD, _QWORD);
// 140018DA4: using guessed type char Buffer[4096];

//----- (0000000140018F28) ----------------------------------------------------
signed __int64 __fastcall sub_140018F28(_BYTE *a1, _BYTE *a2, char a3)
{
  _BYTE *v3; // r9
  signed __int64 v4; // r8
  signed __int64 v5; // rax
  signed __int64 result; // rax
  signed __int64 v7; // r8
  signed __int64 v8; // rcx

  v3 = a1;
  if ( (unsigned __int8)(a3 - 1) > 1u )
  {
    v7 = 0i64;
    if ( a1 != a2 )
    {
      do
      {
        v8 = v7 + 1;
        if ( *v3 != 10 )
          v8 = v7;
        ++v3;
        v7 = v8;
      }
      while ( v3 != a2 );
    }
    result = v7;
  }
  else
  {
    v4 = 0i64;
    if ( a1 != a2 )
    {
      do
      {
        v5 = v4 + 1;
        if ( *(_WORD *)v3 != 10 )
          v5 = v4;
        v3 += 2;
        v4 = v5;
      }
      while ( v3 != a2 );
    }
    result = 2 * v4;
  }
  return result;
}

//----- (0000000140018F80) ----------------------------------------------------
signed __int64 __usercall sub_140018F80@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  signed __int64 v2; // rdi
  int v3; // ebx
  int v4; // ebx
  __int64 v6; // [rsp+20h] [rbp-40h]
  char v7; // [rsp+30h] [rbp-30h]
  __int128 v8; // [rsp+38h] [rbp-28h]
  char v9; // [rsp+48h] [rbp-18h]
  int v10; // [rsp+4Ch] [rbp-14h]
  char v11; // [rsp+50h] [rbp-10h]
  int v12; // [rsp+54h] [rbp-Ch]
  char v13; // [rsp+58h] [rbp-8h]

  v6 = 0i64;
  v7 = 0;
  v9 = 0;
  v11 = 0;
  v13 = 0;
  if ( !dword_140040924 )
  {
    v9 = 1;
    _mm_storeu_si128((__m128i *)&v8, off_14003E2C8);
  }
  v2 = sub_140018A8C((__int64)&v6, a1, a2);
  if ( v9 == 2 )
    *(_DWORD *)(v6 + 936) &= 0xFFFFFFFD;
  if ( v11 )
  {
    v3 = v10;
    *(_DWORD *)(sub_14001009C(&v6, a2) + 32) = v3;
  }
  if ( v13 )
  {
    v4 = v12;
    *(_DWORD *)(sub_14001009C(&v6, a2) + 36) = v4;
  }
  return v2;
}
// 140040924: using guessed type int dword_140040924;

//----- (0000000140019024) ----------------------------------------------------
__int64 __fastcall sub_140019024(WCHAR a1, unsigned __int16 a2)
{
  int v2; // ebx
  unsigned int v3; // eax
  WORD CharType; // [rsp+30h] [rbp+8h]
  WCHAR SrcStr; // [rsp+40h] [rbp+18h]

  v2 = a2;
  if ( a1 != -1 )
  {
    if ( a1 < 0x100u )
    {
      v3 = *((unsigned __int16 *)off_14003E428 + a1);
      return v2 & v3;
    }
    SrcStr = a1;
    CharType = 0;
    if ( GetStringTypeW(1u, &SrcStr, 1, &CharType) )
    {
      v3 = CharType;
      return v2 & v3;
    }
  }
  return 0i64;
}
// 14003E428: using guessed type void *off_14003E428;

//----- (0000000140019090) ----------------------------------------------------
signed __int64 __fastcall sub_140019090(int a1, __int64 a2)
{
  __int64 v2; // rsi
  int v3; // edi
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v9; // r8
  __int64 v10; // rbp
  signed __int64 v11; // rcx
  signed __int64 v12; // rdx
  int v13; // edi
  signed int v14; // edx

  v2 = a2;
  v3 = a1;
  v4 = (_QWORD *)sub_14001B798();
  v5 = v4;
  if ( !v4 )
    return 0i64;
  v6 = *v4;
  v7 = v6;
  if ( v6 == v6 + 192 )
    return 0i64;
  while ( *(_DWORD *)v7 != v3 )
  {
    v7 += 16i64;
    if ( v7 == v6 + 192 )
      return 0i64;
  }
  if ( !v7 )
    return 0i64;
  v9 = *(_QWORD *)(v7 + 8);
  if ( !v9 )
    return 0i64;
  if ( v9 == 5 )
  {
    *(_QWORD *)(v7 + 8) = 0i64;
    return 1i64;
  }
  if ( v9 != 1 )
  {
    v10 = v5[1];
    v5[1] = v2;
    if ( *(_DWORD *)(v7 + 4) != 8 )
    {
      *(_QWORD *)(v7 + 8) = 0i64;
      sub_14002A5D0(*(unsigned int *)(v7 + 4));
      goto LABEL_38;
    }
    v11 = v6 + 48;
    v12 = v11 + 144;
    while ( v11 != v12 )
    {
      *(_QWORD *)(v11 + 8) = 0i64;
      v11 += 16i64;
    }
    v13 = *((_DWORD *)v5 + 4);
    switch ( *(_DWORD *)v7 )
    {
      case 0xC000008D:
        v14 = 130;
        break;
      case 0xC000008E:
        v14 = 131;
        break;
      case 0xC000008F:
        v14 = 134;
        break;
      case 0xC0000090:
        v14 = 129;
        break;
      case 0xC0000091:
        v14 = 132;
        break;
      case 0xC0000092:
        v14 = 138;
        break;
      case 0xC0000093:
        v14 = 133;
        break;
      case 0xC00002B4:
        v14 = 142;
        break;
      case 0xC00002B5:
        v14 = 141;
        break;
      default:
LABEL_36:
        sub_14002A5D0(8i64);
        *((_DWORD *)v5 + 4) = v13;
LABEL_38:
        v5[1] = v10;
        return 0xFFFFFFFFi64;
    }
    *((_DWORD *)v5 + 4) = v14;
    goto LABEL_36;
  }
  return 0xFFFFFFFFi64;
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (0000000140019214) ----------------------------------------------------
__int64 sub_140019214()
{
  return (unsigned int)dword_1400406D4;
}
// 1400406D4: using guessed type int dword_1400406D4;

//----- (000000014001921C) ----------------------------------------------------
void __fastcall sub_14001921C(int a1)
{
  dword_1400406D4 = a1;
}
// 1400406D4: using guessed type int dword_1400406D4;

//----- (0000000140019224) ----------------------------------------------------
bool sub_140019224()
{
  return __ROR8__(_security_cookie ^ qword_1400406D8, _security_cookie & 0x3F) != 0i64;
}
// 1400406D8: using guessed type __int64 qword_1400406D8;

//----- (0000000140019244) ----------------------------------------------------
void __fastcall sub_140019244(__int64 a1)
{
  qword_1400406D8 = a1;
}
// 1400406D8: using guessed type __int64 qword_1400406D8;

//----- (000000014001924C) ----------------------------------------------------
__int64 __fastcall sub_14001924C(__int64 a1)
{
  __int64 result; // rax

  if ( __ROR8__(_security_cookie ^ qword_1400406D8, _security_cookie & 0x3F) )
    result = sub_14002A5D0(a1);
  else
    result = 0i64;
  return result;
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);
// 1400406D8: using guessed type __int64 qword_1400406D8;

//----- (0000000140019288) ----------------------------------------------------
void __fastcall sub_140019288(__int64 a1)
{
  qword_1400406D8 = _security_cookie ^ __ROR8__(a1, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
}
// 1400406D8: using guessed type __int64 qword_1400406D8;

//----- (00000001400192B0) ----------------------------------------------------
__int64 __fastcall sub_1400192B0(signed __int16 *a1, signed __int16 **a2, signed __int16 *a3, _QWORD *a4, _QWORD *a5)
{
  _QWORD *v5; // rbx
  bool v6; // r9
  signed __int16 *v7; // r10
  signed __int16 v8; // ax
  bool v9; // di
  __int64 result; // rax
  signed int v11; // er10
  unsigned int v12; // eax
  signed __int16 v13; // ax

  v5 = a4;
  *a5 = 0i64;
  *a4 = 1i64;
  if ( a2 )
  {
    *a2 = a3;
    ++a2;
  }
  v6 = 0;
  do
  {
    v7 = a1;
    if ( *a1 == 34 )
    {
      v8 = 34;
      v6 = v6 == 0;
      ++a1;
    }
    else
    {
      ++*a5;
      if ( a3 )
      {
        *a3 = *a1;
        ++a3;
      }
      v8 = *a1;
      ++a1;
      if ( !v8 )
      {
        a1 = v7;
        goto LABEL_15;
      }
    }
  }
  while ( v6 || v8 != 32 && v8 != 9 );
  if ( a3 )
    *(a3 - 1) = 0;
LABEL_15:
  v9 = 0;
  while ( 1 )
  {
    result = (unsigned __int16)*a1;
    if ( !(_WORD)result )
      break;
    while ( (_WORD)result == 32 || (_WORD)result == 9 )
    {
      ++a1;
      result = (unsigned __int16)*a1;
    }
    if ( !(_WORD)result )
      break;
    if ( a2 )
    {
      *a2 = a3;
      ++a2;
    }
    ++*v5;
    while ( 1 )
    {
      v11 = 1;
      v12 = 0;
      while ( *a1 == 92 )
      {
        ++a1;
        ++v12;
      }
      if ( *a1 == 34 )
      {
        if ( !(v12 & 1) )
        {
          if ( v9 && a1[1] == 34 )
          {
            ++a1;
          }
          else
          {
            v11 = 0;
            v9 = v9 == 0;
          }
        }
        v12 >>= 1;
      }
      while ( v12 )
      {
        --v12;
        if ( a3 )
        {
          *a3 = 92;
          ++a3;
        }
        ++*a5;
      }
      v13 = *a1;
      if ( !*a1 || !v9 && (v13 == 32 || v13 == 9) )
        break;
      if ( v11 )
      {
        if ( a3 )
        {
          *a3 = v13;
          ++a3;
        }
        ++*a5;
      }
      ++a1;
    }
    if ( a3 )
    {
      *a3 = 0;
      ++a3;
    }
    ++*a5;
  }
  if ( a2 )
    *a2 = 0i64;
  ++*v5;
  return result;
}

//----- (0000000140019454) ----------------------------------------------------
LPVOID __fastcall sub_140019454(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  signed __int64 v3; // rcx
  LPVOID v4; // rbx

  if ( a1 >= 0x1FFFFFFFFFFFFFFFi64 )
    return 0i64;
  if ( a2 >= 0xFFFFFFFFFFFFFFFFui64 / a3 )
    return 0i64;
  v3 = 8 * a1;
  if ( ~v3 <= a3 * a2 )
    return 0i64;
  v4 = sub_14001F068(a3 * a2 + v3, 1ui64);
  sub_14001AE1C(0i64);
  return v4;
}

//----- (00000001400194B4) ----------------------------------------------------
__int64 __usercall sub_1400194B4@<rax>(int a1@<ecx>, __m256i *a2@<ymm0>)
{
  unsigned int v2; // edi
  int v3; // er14
  signed int v4; // ebx
  signed __int16 *v5; // rsi
  __int64 v6; // r15
  signed __int16 **v7; // rax
  signed __int16 **v8; // rbx
  signed __int16 **v9; // rcx
  unsigned int v10; // esi
  void *v11; // rdx
  int v12; // ecx
  _QWORD *i; // rax
  LPVOID lpMem; // [rsp+68h] [rbp+38h]
  __int128 v16; // [rsp+70h] [rbp+40h]

  v2 = 0;
  v3 = a1;
  if ( a1 )
  {
    if ( (unsigned int)(a1 - 1) <= 1 )
    {
      GetModuleFileNameW(0i64, &Filename, 0x104u);
      v5 = (signed __int16 *)qword_1400406B8;
      qword_140040690 = (__int64)&Filename;
      if ( !qword_1400406B8 || !*(_WORD *)qword_1400406B8 )
        v5 = (signed __int16 *)&Filename;
      v16 = 0ui64;
      sub_1400192B0(v5, 0i64, 0i64, &v16, (_QWORD *)&v16 + 1);
      v6 = v16;
      v7 = (signed __int16 **)sub_140019454(v16, *((unsigned __int64 *)&v16 + 1), 2ui64);
      v8 = v7;
      if ( v7 )
      {
        sub_1400192B0(v5, v7, (signed __int16 *)&v7[v6], &v16, (_QWORD *)&v16 + 1);
        if ( v3 == 1 )
        {
          qword_1400406A8 = v8;
          dword_140040698 = v16 - 1;
          v9 = 0i64;
        }
        else
        {
          lpMem = 0i64;
          v10 = sub_14002236C(v8, &lpMem);
          if ( v10 )
          {
            sub_14001AE1C(lpMem);
            lpMem = 0i64;
            sub_14001AE1C(v8);
            return v10;
          }
          v11 = lpMem;
          v12 = 0;
          for ( i = lpMem; *i; ++v12 )
            ++i;
          dword_140040698 = v12;
          lpMem = 0i64;
          qword_1400406A8 = v11;
          sub_14001AE1C(0i64);
          v9 = v8;
          lpMem = 0i64;
        }
        sub_14001AE1C(v9);
        return v2;
      }
      v4 = 12;
      *(_DWORD *)sub_140015334() = 12;
      sub_14001AE1C(0i64);
    }
    else
    {
      v4 = 22;
      *(_DWORD *)sub_140015334() = 22;
      sub_14001ADB4(a2);
    }
    v2 = v4;
  }
  return v2;
}
// 14002236C: using guessed type __int64 __fastcall sub_14002236C(_QWORD, _QWORD);
// 140040690: using guessed type __int64 qword_140040690;
// 140040698: using guessed type int dword_140040698;
// 1400406B8: using guessed type __int64 qword_1400406B8;

//----- (0000000140019638) ----------------------------------------------------
signed __int64 __usercall sub_140019638@<rax>(__m256i *a1@<ymm0>)
{
  unsigned int v1; // edi
  signed __int64 result; // rax
  char *v3; // rax
  char *v4; // rbx
  void **v5; // rax

  v1 = 0;
  if ( qword_1400408F0 )
    return 0i64;
  sub_140022B70(a1);
  v3 = sub_140022EAC();
  v4 = v3;
  if ( v3 )
  {
    v5 = sub_14001971C(v3, a1);
    if ( v5 )
    {
      qword_140040908 = (__int64)v5;
      qword_1400408F0 = v5;
    }
    else
    {
      v1 = -1;
    }
    sub_14001AE1C(0i64);
    sub_14001AE1C(v4);
    result = v1;
  }
  else
  {
    sub_14001AE1C(0i64);
    result = 0xFFFFFFFFi64;
  }
  return result;
}
// 140040908: using guessed type __int64 qword_140040908;

//----- (00000001400196AC) ----------------------------------------------------
signed __int64 __usercall sub_1400196AC@<rax>(__m256i *a1@<ymm0>)
{
  unsigned int v1; // edi
  signed __int64 result; // rax
  __int16 *v3; // rax
  __int16 *v4; // rbx
  void **v5; // rax

  v1 = 0;
  if ( qword_1400408F8 )
    return 0i64;
  v3 = (__int16 *)sub_140022FBC();
  v4 = v3;
  if ( v3 )
  {
    v5 = sub_14001982C(v3, a1);
    if ( v5 )
    {
      qword_140040900 = (__int64)v5;
      qword_1400408F8 = v5;
    }
    else
    {
      v1 = -1;
    }
    sub_14001AE1C(0i64);
    sub_14001AE1C(v4);
    result = v1;
  }
  else
  {
    sub_14001AE1C(0i64);
    result = 0xFFFFFFFFi64;
  }
  return result;
}
// 140040900: using guessed type __int64 qword_140040900;

//----- (000000014001971C) ----------------------------------------------------
void **__usercall sub_14001971C@<rax>(char *a1@<rcx>, __m256i *a2@<ymm0>)
{
  char *v2; // rsi
  signed __int64 v3; // rcx
  char *v4; // r8
  char i; // dl
  signed __int64 v6; // rax
  signed __int64 v7; // rax
  void **v8; // rax
  void **v9; // rbx
  void **result; // rax
  void **v11; // r14
  signed __int64 v12; // rbp
  signed __int64 v13; // rbp
  _BYTE *v14; // rax
  _BYTE *v15; // rdi

  v2 = a1;
  v3 = 0i64;
  v4 = v2;
  for ( i = *v2; i; i = *v4 )
  {
    v6 = v3 + 1;
    if ( i == 61 )
      v6 = v3;
    v3 = v6;
    v7 = -1i64;
    do
      ++v7;
    while ( v4[v7] );
    v4 += v7 + 1;
  }
  v8 = (void **)sub_14001F068(v3 + 1, 8ui64);
  v9 = v8;
  if ( v8 )
  {
    v11 = v8;
    while ( *v2 )
    {
      v12 = -1i64;
      do
        ++v12;
      while ( v2[v12] );
      v13 = v12 + 1;
      if ( *v2 != 61 )
      {
        v14 = sub_14001F068(v13, 1ui64);
        v15 = v14;
        if ( !v14 )
        {
          sub_140019948(v9);
          sub_14001AE1C(0i64);
          goto LABEL_9;
        }
        if ( (unsigned int)sub_14001A94C(v13, v14, (__int64)v2, a2) )
        {
          sub_14001ADD4(a2);
          JUMPOUT(*(_QWORD *)&byte_14001982A);
        }
        *v11 = v15;
        ++v11;
        sub_14001AE1C(0i64);
      }
      v2 += v13;
    }
    sub_14001AE1C(0i64);
    result = v9;
  }
  else
  {
LABEL_9:
    sub_14001AE1C(0i64);
    result = 0i64;
  }
  return result;
}
// 14001982A: using guessed type char;

//----- (000000014001982C) ----------------------------------------------------
void **__usercall sub_14001982C@<rax>(__int16 *a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int16 *v2; // r14
  signed __int64 v3; // rcx
  __int16 *v4; // r8
  __int16 i; // dx
  signed __int64 v6; // rax
  signed __int64 v7; // rax
  void **v8; // rax
  void **v9; // rbx
  void **result; // rax
  void **v11; // r15
  signed __int64 v12; // rsi
  signed __int64 v13; // rsi
  _WORD *v14; // rax
  _WORD *v15; // rdi

  v2 = a1;
  v3 = 0i64;
  v4 = v2;
  for ( i = *v2; i; i = *v4 )
  {
    v6 = v3 + 1;
    if ( i == 61 )
      v6 = v3;
    v3 = v6;
    v7 = -1i64;
    do
      ++v7;
    while ( v4[v7] );
    v4 += v7 + 1;
  }
  v8 = (void **)sub_14001F068(v3 + 1, 8ui64);
  v9 = v8;
  if ( v8 )
  {
    v11 = v8;
    while ( *v2 )
    {
      v12 = -1i64;
      do
        ++v12;
      while ( v2[v12] );
      v13 = v12 + 1;
      if ( *v2 != 61 )
      {
        v14 = sub_14001F068(v13, 2ui64);
        v15 = v14;
        if ( !v14 )
        {
          sub_140019948(v9);
          sub_14001AE1C(0i64);
          goto LABEL_9;
        }
        if ( (unsigned int)sub_140020D64(v13, v14, (__int64)v2, a2) )
        {
          sub_14001ADD4(a2);
          JUMPOUT(*(_QWORD *)&byte_140019946);
        }
        *v11 = v15;
        ++v11;
        sub_14001AE1C(0i64);
      }
      v2 += v13;
    }
    sub_14001AE1C(0i64);
    result = v9;
  }
  else
  {
LABEL_9:
    sub_14001AE1C(0i64);
    result = 0i64;
  }
  return result;
}
// 140019946: using guessed type char;

//----- (0000000140019948) ----------------------------------------------------
void __fastcall sub_140019948(void **lpMem)
{
  void *v1; // rax
  void **v2; // rbx
  void **v3; // rdi

  if ( lpMem )
  {
    v1 = *lpMem;
    v2 = lpMem;
    v3 = lpMem;
    while ( v1 )
    {
      sub_14001AE1C(v1);
      ++v3;
      v1 = *v3;
    }
    sub_14001AE1C(v2);
  }
}

//----- (000000014001998C) ----------------------------------------------------
const WCHAR *sub_14001998C()
{
  const WCHAR **v0; // rdi
  const WCHAR *result; // rax
  int v2; // eax
  int v3; // esi
  CHAR *v4; // rax
  CHAR *v5; // rbx
  int v6; // eax
  CHAR *v7; // rcx
  __int64 v8; // [rsp+28h] [rbp-20h]
  __int64 v9; // [rsp+28h] [rbp-20h]

  v0 = (const WCHAR **)qword_1400408F8;
  if ( !qword_1400408F8 )
    return (const WCHAR *)0xFFFFFFFFi64;
  while ( 1 )
  {
    result = *v0;
    if ( !*v0 )
      return result;
    LODWORD(v8) = 0;
    v2 = sub_1400203D8(0, 0, result, -1, 0i64, v8, 0i64, 0i64);
    v3 = v2;
    if ( !v2 )
      return (const WCHAR *)0xFFFFFFFFi64;
    v4 = (CHAR *)sub_14001F068(v2, 1ui64);
    v5 = v4;
    if ( !v4 )
    {
      v7 = 0i64;
LABEL_11:
      sub_14001AE1C(v7);
      return (const WCHAR *)0xFFFFFFFFi64;
    }
    LODWORD(v9) = v3;
    v6 = sub_1400203D8(0, 0, *v0, -1, v4, v9, 0i64, 0i64);
    v7 = v5;
    if ( !v6 )
      goto LABEL_11;
    sub_1400216DC(v5);
    sub_14001AE1C(0i64);
    ++v0;
  }
}

//----- (0000000140019A6C) ----------------------------------------------------
const CHAR *sub_140019A6C()
{
  const CHAR **v0; // rdi
  const CHAR *result; // rax
  int v2; // eax
  int v3; // esi
  WCHAR *v4; // rax
  WCHAR *v5; // rbx
  int v6; // eax
  WCHAR *v7; // rcx

  v0 = (const CHAR **)qword_1400408F0;
  if ( !qword_1400408F0 )
    return (const CHAR *)0xFFFFFFFFi64;
  while ( 1 )
  {
    result = *v0;
    if ( !*v0 )
      return result;
    v2 = sub_14001FB10(0, 0, result, -1, 0i64, 0);
    v3 = v2;
    if ( !v2 )
      return (const CHAR *)0xFFFFFFFFi64;
    v4 = (WCHAR *)sub_14001F068(v2, 2ui64);
    v5 = v4;
    if ( !v4 )
    {
      v7 = 0i64;
LABEL_11:
      sub_14001AE1C(v7);
      return (const CHAR *)0xFFFFFFFFi64;
    }
    v6 = sub_14001FB10(0, 0, *v0, -1, v4, v3);
    v7 = v5;
    if ( !v6 )
      goto LABEL_11;
    sub_1400216E4(v5);
    sub_14001AE1C(0i64);
    ++v0;
  }
}

//----- (0000000140019B28) ----------------------------------------------------
void __fastcall sub_140019B28(void ***a1)
{
  void **v1; // rcx

  v1 = *a1;
  if ( v1 != (void **)qword_140040908 )
    sub_140019948(v1);
}
// 140040908: using guessed type __int64 qword_140040908;

//----- (0000000140019B44) ----------------------------------------------------
void __fastcall sub_140019B44(void ***a1)
{
  void **v1; // rcx

  v1 = *a1;
  if ( v1 != (void **)qword_140040900 )
    sub_140019948(v1);
}
// 140040900: using guessed type __int64 qword_140040900;

//----- (0000000140019B60) ----------------------------------------------------
LPVOID __usercall sub_140019B60@<rax>(__m256i *a1@<ymm0>)
{
  LPVOID result; // rax

  result = qword_1400408F0;
  if ( !qword_1400408F0 )
  {
    if ( qword_1400408F8 == qword_1400408F0 || (unsigned int)sub_140019638(a1) && (unsigned int)sub_14001998C() )
      result = 0i64;
    else
      result = qword_1400408F0;
  }
  return result;
}

//----- (0000000140019B9C) ----------------------------------------------------
LPVOID __usercall sub_140019B9C@<rax>(__m256i *a1@<ymm0>)
{
  LPVOID result; // rax

  result = qword_1400408F8;
  if ( !qword_1400408F8 )
  {
    if ( qword_1400408F0 == qword_1400408F8 || (unsigned int)sub_1400196AC(a1) && (unsigned int)sub_140019A6C() )
      result = 0i64;
    else
      result = qword_1400408F8;
  }
  return result;
}

//----- (0000000140019BD8) ----------------------------------------------------
void sub_140019BD8()
{
  sub_140019B28((void ***)&qword_1400408F0);
  sub_140019B44((void ***)&qword_1400408F8);
  sub_140019948((void **)qword_140040908);
  sub_140019948((void **)qword_140040900);
}
// 140040900: using guessed type __int64 qword_140040900;
// 140040908: using guessed type __int64 qword_140040908;

//----- (0000000140019C24) ----------------------------------------------------
unsigned __int16 *sub_140019C24()
{
  unsigned __int16 *v0; // rcx
  bool v1; // dl
  unsigned __int16 v2; // ax

  v0 = (unsigned __int16 *)&unk_140040910;
  v1 = 0;
  if ( qword_1400406B8 )
    v0 = (unsigned __int16 *)qword_1400406B8;
  while ( 1 )
  {
    v2 = *v0;
    if ( *v0 <= 0x20u )
    {
      if ( !v2 )
        return v0;
      if ( !v1 )
        break;
    }
    if ( v2 == 34 )
      v1 = v1 == 0;
    ++v0;
  }
  do
  {
    if ( v2 > 0x20u )
      break;
    ++v0;
    v2 = *v0;
  }
  while ( *v0 );
  return v0;
}
// 1400406B8: using guessed type __int64 qword_1400406B8;

//----- (0000000140019C78) ----------------------------------------------------
__int64 __fastcall sub_140019C78(__int64 *a1, __int64 *a2)
{
  __int64 *v2; // rdi
  __int64 *v3; // rbx
  __int64 result; // rax

  if ( a1 != a2 )
  {
    v2 = a2;
    v3 = a1;
    do
    {
      result = *v3;
      if ( *v3 )
        result = sub_14002A5D0(a1);
      ++v3;
    }
    while ( v3 != v2 );
  }
  return result;
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (0000000140019CBC) ----------------------------------------------------
__int64 __fastcall sub_140019CBC(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rdi
  _QWORD *v3; // rbx
  bool i; // zf
  __int64 result; // rax

  v2 = a2;
  v3 = a1;
  for ( i = a1 == a2; !i; i = v3 == v2 )
  {
    if ( *v3 )
    {
      result = sub_14002A5D0(a1);
      if ( (_DWORD)result )
        return result;
    }
    ++v3;
  }
  return 0i64;
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (0000000140019D04) ----------------------------------------------------
void __fastcall sub_140019D04(__int64 a1, int *a2, int **a3, int *a4)
{
  int *v4; // rbx
  int **v5; // rdi

  v4 = a4;
  v5 = a3;
  sub_140020BC8(*a2);
  sub_140019D3C(v5);
  sub_140020C28(*v4);
}

//----- (0000000140019D3C) ----------------------------------------------------
int *__fastcall sub_140019D3C(int **a1)
{
  int **v1; // rbx
  int v2; // ecx
  void *v3; // rcx
  int *result; // rax

  v1 = a1;
  if ( byte_140040920 )
    return result;
  _InterlockedExchange(&dword_140040914, 1);
  v2 = **a1;
  if ( !v2 )
  {
    if ( qword_140040918 != _security_cookie )
      sub_14002A5D0(0i64);
    v3 = &unk_140040930;
    goto LABEL_8;
  }
  if ( v2 == 1 )
  {
    v3 = &unk_140040948;
LABEL_8:
    sub_14001A620((__int64)v3);
  }
  if ( !**v1 )
    sub_140019C78((__int64 *)&unk_14002B4B8, (__int64 *)&unk_14002B4E0);
  sub_140019C78((__int64 *)&unk_14002B4E8, (__int64 *)&unk_14002B4F0);
  result = v1[1];
  if ( !*result )
  {
    byte_140040920 = 1;
    result = v1[2];
    *(_BYTE *)result = 1;
  }
  return result;
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);
// 140040914: using guessed type int dword_140040914;
// 140040918: using guessed type __int64 qword_140040918;
// 140040920: using guessed type char byte_140040920;

//----- (0000000140019E08) ----------------------------------------------------
void __fastcall sub_140019E08(UINT uExitCode, int a2, int a3)
{
  unsigned int v3; // ebx
  HMODULE v4; // rax
  char *v5; // rcx
  char v6; // [rsp+20h] [rbp-30h]
  int v7; // [rsp+24h] [rbp-2Ch]
  int v8; // [rsp+28h] [rbp-28h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  int *v10; // [rsp+38h] [rbp-18h]
  int *v11; // [rsp+40h] [rbp-10h]
  char *v12; // [rsp+48h] [rbp-8h]
  int v13; // [rsp+68h] [rbp+18h]
  int v14; // [rsp+70h] [rbp+20h]
  char v15; // [rsp+78h] [rbp+28h]

  v14 = a3;
  v13 = a2;
  v9 = -2i64;
  v3 = uExitCode;
  if ( !a3 )
  {
    v4 = GetModuleHandleW(0i64);
    if ( v4 )
    {
      if ( *(_WORD *)v4 == 23117 )
      {
        v5 = (char *)v4 + *((signed int *)v4 + 15);
        if ( *(_DWORD *)v5 == 17744 && *((_WORD *)v5 + 12) == 523 && *((_DWORD *)v5 + 33) > 0xEu && *((_DWORD *)v5 + 62) )
          sub_140019F28(v3);
      }
    }
  }
  v15 = 0;
  v10 = &v13;
  v11 = &v14;
  v12 = &v15;
  v7 = 2;
  v8 = 2;
  sub_140019D04((__int64)&v6, &v8, &v10, &v7);
  if ( !v14 )
    sub_140019ED0(v3);
}

//----- (0000000140019ED0) ----------------------------------------------------
void __fastcall __noreturn sub_140019ED0(UINT uExitCode)
{
  UINT v1; // ebx
  HANDLE v2; // rax

  v1 = uExitCode;
  if ( sub_140019F04() )
  {
    v2 = GetCurrentProcess();
    TerminateProcess(v2, v1);
  }
  sub_140019F28(v1);
  ExitProcess(v1);
}

//----- (0000000140019F04) ----------------------------------------------------
bool sub_140019F04()
{
  bool result; // al

  if ( (unsigned int)sub_14002308C() == 1 )
    result = 0;
  else
    result = sub_140023058() == 0;
  return result;
}

//----- (0000000140019F28) ----------------------------------------------------
int __fastcall sub_140019F28(unsigned int a1)
{
  unsigned int v1; // ebx
  FARPROC v2; // rax
  HMODULE v3; // rcx
  HMODULE phModule; // [rsp+48h] [rbp+10h]

  v1 = a1;
  phModule = 0i64;
  LODWORD(v2) = GetModuleHandleExW(0, L"mscoree.dll", &phModule);
  v3 = phModule;
  if ( (_DWORD)v2 )
  {
    v2 = GetProcAddress(phModule, "CorExitProcess");
    if ( v2 )
      LODWORD(v2) = sub_14002A5D0(v1);
    v3 = phModule;
  }
  if ( v3 )
    LODWORD(v2) = FreeLibrary(v3);
  return (signed int)v2;
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (0000000140019F98) ----------------------------------------------------
void __fastcall sub_140019F98(__int64 a1)
{
  qword_140040918 = a1;
}
// 140040918: using guessed type __int64 qword_140040918;

//----- (0000000140019FA0) ----------------------------------------------------
void sub_140019FA0()
{
  sub_140019E08(0, 2, 1);
}

//----- (0000000140019FB0) ----------------------------------------------------
void sub_140019FB0()
{
  sub_140019E08(0, 0, 1);
}

//----- (0000000140019FC0) ----------------------------------------------------
void __fastcall sub_140019FC0(UINT a1)
{
  sub_140019E08(a1, 2, 0);
}

//----- (0000000140019FCC) ----------------------------------------------------
__int64 __usercall sub_140019FCC@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rdx
  int v3; // ecx
  __int64 result; // rax

  v2 = a1;
  if ( qword_140040918 != _security_cookie )
    sub_14001A878(a2);
  v3 = _security_cookie & 0x3F;
  result = (unsigned int)(64 - v3);
  qword_140040918 = _security_cookie ^ __ROR8__(v2, 64 - (unsigned __int8)v3);
  return result;
}
// 140040918: using guessed type __int64 qword_140040918;

//----- (000000014001A00C) ----------------------------------------------------
void __fastcall sub_14001A00C(UINT a1)
{
  sub_140019E08(a1, 0, 0);
}

//----- (000000014001A018) ----------------------------------------------------
signed __int64 __usercall sub_14001A018@<rax>(_DWORD *a1@<rcx>, __m256i *a2@<ymm0>)
{
  signed __int64 result; // rax

  if ( a1 )
  {
    *a1 = dword_1400411A8;
    result = 0i64;
  }
  else
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a2);
    result = 22i64;
  }
  return result;
}
// 1400411A8: using guessed type int dword_1400411A8;

//----- (000000014001A048) ----------------------------------------------------
signed __int64 __usercall sub_14001A048@<rax>(signed __int32 a1@<ecx>, __m256i *a2@<ymm0>)
{
  signed __int64 result; // rax

  if ( (a1 - 0x4000) & 0xFFFF3FFF || a1 == 49152 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a2);
    result = 22i64;
  }
  else
  {
    _InterlockedExchange(&dword_1400411A8, a1);
    result = 0i64;
  }
  return result;
}
// 1400411A8: using guessed type int dword_1400411A8;

//----- (000000014001A088) ----------------------------------------------------
signed __int64 __fastcall sub_14001A088(int a1, int a2)
{
  int v2; // er10
  signed __int64 v3; // r9
  __int64 v4; // rax
  __int64 v5; // rdx
  char v6; // cl
  char v7; // r11
  int v8; // ebx
  signed __int64 result; // rax

  v2 = a2;
  v3 = (signed __int64)a1 >> 6;
  v4 = a1 & 0x3F;
  v5 = qword_140040970[v3];
  v6 = *(_BYTE *)(v5 + 72 * v4 + 56);
  v7 = *(_BYTE *)(v5 + 72 * v4 + 57);
  v8 = *(_BYTE *)(v5 + 72 * v4 + 56) & 0x80;
  if ( v2 == 0x4000 )
  {
    *(_BYTE *)(v5 + 72 * v4 + 56) = v6 | 0x80;
    *(_BYTE *)(qword_140040970[v3] + 72 * v4 + 57) = 0;
  }
  else if ( v2 == 0x8000 )
  {
    *(_BYTE *)(v5 + 72 * v4 + 56) = v6 & 0x7F;
  }
  else if ( (v2 - 0x10000) & 0xFFFEFFFF )
  {
    if ( v2 == 0x40000 )
    {
      *(_BYTE *)(v5 + 72 * v4 + 56) = v6 | 0x80;
      *(_BYTE *)(qword_140040970[v3] + 72 * v4 + 57) = 1;
    }
  }
  else
  {
    *(_BYTE *)(v5 + 72 * v4 + 56) = v6 | 0x80;
    *(_BYTE *)(qword_140040970[v3] + 72 * v4 + 57) = 2;
  }
  if ( !v8 )
    return 0x8000i64;
  if ( !v7 )
    return 0x4000i64;
  result = 0x10000i64;
  if ( v7 == 1 )
    result = 0x40000i64;
  return result;
}

//----- (000000014001A16C) ----------------------------------------------------
void __fastcall sub_14001A16C(__int64 a1, int *a2, __int64 a3, int *a4)
{
  int *v4; // rdi
  __int64 *i; // rbx

  v4 = a4;
  sub_140020BC8(*a2);
  for ( i = qword_140040968; i != qword_140040970; ++i )
  {
    if ( (wchar_t **)*i != &off_14003E170 )
      *i = sub_1400238F4(i, (__int64)&off_14003E170);
  }
  sub_140020C28(*v4);
}
// 14003E170: using guessed type wchar_t *off_14003E170;
// 140040968: using guessed type __int64 qword_140040968[];

//----- (000000014001A1DC) ----------------------------------------------------
__int64 sub_14001A1DC()
{
  return (unsigned int)_InterlockedExchange(&dword_140040924, 1);
}
// 140040924: using guessed type int dword_140040924;

//----- (000000014001A1F0) ----------------------------------------------------
void sub_14001A1F0()
{
  __int64 v0; // [rsp+30h] [rbp+8h]
  int v1; // [rsp+38h] [rbp+10h]
  int v2; // [rsp+40h] [rbp+18h]

  v1 = 4;
  v2 = 4;
  sub_14001A16C((__int64)&v0, &v2, (__int64)&v0, &v1);
}

//----- (000000014001A220) ----------------------------------------------------
signed __int64 __usercall sub_14001A220@<rax>(int a1@<ecx>, __m256i *a2@<ymm0>)
{
  int v2; // ebx
  __int64 v3; // rax
  int v4; // er8
  int v5; // ecx
  unsigned int v7; // er8

  v2 = a1;
  v3 = sub_14001B620(a2);
  v4 = *(_DWORD *)(v3 + 936);
  v5 = -((*(_DWORD *)(v3 + 936) & 2) != 0);
  if ( v2 == -1 )
  {
    dword_14003EA20 = -1;
  }
  else if ( v2 )
  {
    if ( v2 == 1 )
    {
      v7 = v4 | 2;
    }
    else
    {
      if ( v2 != 2 )
      {
        *(_DWORD *)sub_140015334() = 22;
        sub_14001ADB4(a2);
        return 0xFFFFFFFFi64;
      }
      v7 = v4 & 0xFFFFFFFD;
    }
    *(_DWORD *)(v3 + 936) = v7;
  }
  return (unsigned int)(v5 + 2);
}
// 14003EA20: using guessed type int dword_14003EA20;

//----- (000000014001A28C) ----------------------------------------------------
__int64 sub_14001A28C()
{
  return (unsigned int)dword_140040928;
}
// 140040928: using guessed type int dword_140040928;

//----- (000000014001A294) ----------------------------------------------------
signed __int64 __usercall sub_14001A294@<rax>(unsigned __int32 a1@<ecx>, __m256i *a2@<ymm0>)
{
  if ( a1 <= 1 )
    return (unsigned int)_InterlockedExchange(&dword_140040928, a1);
  *(_DWORD *)sub_140015334() = 22;
  sub_14001ADB4(a2);
  return 0xFFFFFFFFi64;
}
// 140040928: using guessed type int dword_140040928;

//----- (000000014001A2C0) ----------------------------------------------------
int *sub_14001A2C0()
{
  return &dword_14004092C;
}
// 14004092C: using guessed type int dword_14004092C;

//----- (000000014001A2C8) ----------------------------------------------------
__int64 __usercall sub_14001A2C8@<rax>(int *a1@<rdx>, _QWORD **a2@<r8>, int *a3@<r9>, __m256i *a4@<ymm0>)
{
  int *v4; // rbx
  _QWORD **v5; // rdi

  v4 = a3;
  v5 = a2;
  sub_140020BC8(*a1);
  LODWORD(v5) = sub_14001A340(v5, a4);
  sub_140020C28(*v4);
  return (unsigned int)v5;
}

//----- (000000014001A304) ----------------------------------------------------
__int64 __fastcall sub_14001A304(__int64 a1, int *a2, _QWORD **a3, int *a4)
{
  int *v4; // rbx
  _QWORD **v5; // rdi

  v4 = a4;
  v5 = a3;
  sub_140020BC8(*a2);
  LODWORD(v5) = sub_14001A4F0(v5);
  sub_140020C28(*v4);
  return (unsigned int)v5;
}

//----- (000000014001A340) ----------------------------------------------------
signed __int64 __usercall sub_14001A340@<rax>(_QWORD **a1@<rcx>, __m256i *a2@<ymm0>)
{
  _QWORD **v2; // r15
  _QWORD *v3; // rdx
  uintptr_t v4; // r10
  void *v5; // rsi
  uintptr_t *v6; // r9
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // rbx
  signed __int64 v9; // rdi
  unsigned __int64 v10; // rdi
  __int64 v11; // r14
  unsigned __int64 v12; // rcx
  signed __int64 result; // rax

  v2 = a1;
  v3 = (_QWORD *)**a1;
  if ( v3 )
  {
    v4 = _security_cookie;
    v5 = (void *)__ROR8__(*v3 ^ _security_cookie, _security_cookie & 0x3F);
    v6 = (uintptr_t *)__ROR8__(v3[1] ^ _security_cookie, _security_cookie & 0x3F);
    v7 = __ROR8__(v3[2] ^ _security_cookie, _security_cookie & 0x3F);
    if ( v6 != (uintptr_t *)v7 )
    {
LABEL_14:
      *v6 = v4 ^ __ROR8__(*v2[1], 64 - ((unsigned __int8)v4 & 0x3Fu));
      *(_QWORD *)**v2 = _security_cookie ^ __ROR8__(v5, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
      *(_QWORD *)(**v2 + 8i64) = _security_cookie ^ __ROR8__(v6 + 1, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
      result = 0i64;
      *(_QWORD *)(**v2 + 16i64) = _security_cookie ^ __ROR8__(v7, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
      return result;
    }
    v8 = (signed __int64)(v7 - (_QWORD)v5) >> 3;
    v9 = v8;
    if ( v8 > 0x200 )
      v9 = 512i64;
    v10 = v8 + v9;
    if ( !v10 )
      v10 = 32i64;
    if ( v10 >= v8 && (v11 = sub_14002395C(v5, v10, 8ui64, a2), sub_14001AE1C(0i64), v11)
      || (v10 = v8 + 4, v11 = sub_14002395C(v5, v8 + 4, 8ui64, a2), sub_14001AE1C(0i64), v11) )
    {
      v4 = _security_cookie;
      v6 = (uintptr_t *)(v11 + 8 * v8);
      v7 = v11 + 8 * v10;
      v5 = (void *)v11;
      v12 = (v11 + 8 * v10 - (unsigned __int64)v6 + 7) >> 3;
      if ( (unsigned __int64)v6 > v7 )
        v12 = 0i64;
      if ( v12 )
      {
        memset64(v6, _security_cookie, v12);
        v4 = _security_cookie;
      }
      goto LABEL_14;
    }
  }
  return 0xFFFFFFFFi64;
}

//----- (000000014001A4F0) ----------------------------------------------------
signed __int64 __fastcall sub_14001A4F0(_QWORD **a1)
{
  _QWORD **v1; // rsi
  _QWORD *v2; // rdx
  uintptr_t v4; // r8
  uintptr_t *v5; // rdi
  uintptr_t *v6; // rbx
  uintptr_t v7; // r14
  uintptr_t v8; // rcx
  __int64 v9; // r15
  __int64 v10; // rbp
  _QWORD *v11; // rdx

  v1 = a1;
  v2 = (_QWORD *)**a1;
  if ( !v2 )
    return 0xFFFFFFFFi64;
  v4 = _security_cookie;
  v5 = (uintptr_t *)__ROR8__(*v2 ^ _security_cookie, _security_cookie & 0x3F);
  v6 = (uintptr_t *)__ROR8__(v2[1] ^ _security_cookie, _security_cookie & 0x3F);
  if ( (unsigned __int64)v5 - 1 <= 0xFFFFFFFFFFFFFFFDui64 )
  {
    v7 = _security_cookie;
    v8 = _security_cookie & 0x3F;
    v9 = __ROR8__(*v2 ^ _security_cookie, _security_cookie & 0x3F);
    v10 = __ROR8__(v2[1] ^ _security_cookie, _security_cookie & 0x3F);
    while ( 1 )
    {
      --v6;
      if ( v6 < v5 )
        break;
      if ( *v6 != v7 )
      {
        *v6 = v7;
        sub_14002A5D0(v8);
        v4 = _security_cookie;
        v8 = _security_cookie & 0x3F;
        v11 = (_QWORD *)**v1;
        if ( __ROR8__(*v11 ^ _security_cookie, v8) != v9 || __ROR8__(v11[1] ^ _security_cookie, v8) != v10 )
        {
          v9 = __ROR8__(*v11 ^ _security_cookie, v8);
          v5 = (uintptr_t *)__ROR8__(*v11 ^ _security_cookie, v8);
          v10 = __ROR8__(v11[1] ^ _security_cookie, v8);
          v6 = (uintptr_t *)__ROR8__(v11[1] ^ _security_cookie, v8);
        }
      }
    }
    if ( v5 != (uintptr_t *)-1i64 )
    {
      sub_14001AE1C(v5);
      v4 = _security_cookie;
    }
    *(_QWORD *)**v1 = v4;
    *(_QWORD *)(**v1 + 8i64) = v4;
    *(_QWORD *)(**v1 + 16i64) = v4;
  }
  return 0i64;
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (000000014001A610) ----------------------------------------------------
__int64 __usercall sub_14001A610@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  return sub_14001A68C(a1, (__int64)&unk_140040930, a2);
}

//----- (000000014001A620) ----------------------------------------------------
__int64 __fastcall sub_14001A620(__int64 a1)
{
  __int64 *v2; // [rsp+20h] [rbp-18h]
  __int64 v3; // [rsp+28h] [rbp-10h]
  __int64 v4; // [rsp+40h] [rbp+8h]
  __int64 v5; // [rsp+48h] [rbp+10h]
  int v6; // [rsp+50h] [rbp+18h]
  int v7; // [rsp+58h] [rbp+20h]

  v4 = a1;
  v3 = -2i64;
  v2 = &v4;
  v6 = 2;
  v7 = 2;
  return sub_14001A304((__int64)&v5, &v7, &v2, &v6);
}

//----- (000000014001A664) ----------------------------------------------------
signed __int64 __fastcall sub_14001A664(uintptr_t *a1)
{
  uintptr_t v2; // rax

  if ( !a1 )
    return 0xFFFFFFFFi64;
  if ( *a1 == a1[2] )
  {
    v2 = _security_cookie;
    *a1 = _security_cookie;
    a1[1] = v2;
    a1[2] = v2;
  }
  return 0i64;
}

//----- (000000014001A68C) ----------------------------------------------------
__int64 __usercall sub_14001A68C@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  int v4; // [rsp+20h] [rbp-20h]
  __int64 *v5; // [rsp+28h] [rbp-18h]
  __int64 *v6; // [rsp+30h] [rbp-10h]
  __int64 v7; // [rsp+50h] [rbp+10h]
  __int64 v8; // [rsp+58h] [rbp+18h]
  int v9; // [rsp+68h] [rbp+28h]

  v8 = a1;
  v7 = a2;
  v5 = &v7;
  v6 = &v8;
  v9 = 2;
  v4 = 2;
  return sub_14001A2C8(&v4, &v5, &v9, a3);
}

//----- (000000014001A6E0) ----------------------------------------------------
char sub_14001A6E0()
{
  qword_140040968[0] = (__int64)&off_14003E170;
  return 1;
}
// 14003E170: using guessed type wchar_t *off_14003E170;
// 140040968: using guessed type __int64 qword_140040968[];

//----- (000000014001A700) ----------------------------------------------------
char sub_14001A700()
{
  sub_14001A664((uintptr_t *)&unk_140040930);
  sub_14001A664((uintptr_t *)&unk_140040948);
  return 1;
}

//----- (000000014001A730) ----------------------------------------------------
char sub_14001A730()
{
  sub_140019BD8();
  return 1;
}

//----- (000000014001A740) ----------------------------------------------------
char sub_14001A740()
{
  __int64 v0; // rbx

  v0 = _security_cookie;
  sub_14001AC44(_security_cookie);
  sub_140023B08(v0);
  sub_140023C00(v0);
  sub_140019244(v0);
  sub_140019F98(v0);
  return 1;
}

//----- (000000014001A780) ----------------------------------------------------
char sub_14001A780()
{
  return sub_14000D9B8(0);
}

//----- (000000014001A790) ----------------------------------------------------
char sub_14001A790()
{
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)qword_140041198, 0xFFFFFFFF) == 1
    && qword_140041198 != &unk_14003E440 )
  {
    sub_14001AE1C(qword_140041198);
    qword_140041198 = &unk_14003E440;
  }
  return 1;
}

//----- (000000014001A7D0) ----------------------------------------------------
char sub_14001A7D0()
{
  sub_14001AE1C(qword_140040D78);
  qword_140040D78 = 0i64;
  sub_14001AE1C(qword_140040D80);
  qword_140040D80 = 0i64;
  sub_14001AE1C(qword_1400406A0);
  qword_1400406A0 = 0i64;
  sub_14001AE1C(qword_1400406A8);
  qword_1400406A8 = 0i64;
  return 1;
}

//----- (000000014001A82C) ----------------------------------------------------
char sub_14001A82C()
{
  return sub_140023A2C(&off_1400328F0, &off_1400329F0);
}
// 1400328F0: using guessed type __int64 (__fastcall *off_1400328F0)();
// 1400329F0: using guessed type void *off_1400329F0;

//----- (000000014001A840) ----------------------------------------------------
char __usercall sub_14001A840@<al>(char a1@<cl>, __m256i *a2@<ymm0>)
{
  if ( !a1 )
    return sub_140023AC0((__int64)&off_1400328F0, (__int64)&off_1400329F0);
  if ( lpMem )
    sub_1400176C8(a2);
  return 1;
}
// 1400328F0: using guessed type __int64 (__fastcall *off_1400328F0)();
// 1400329F0: using guessed type void *off_1400329F0;

//----- (000000014001A878) ----------------------------------------------------
void __usercall __noreturn sub_14001A878(__m256i *a1@<ymm0>)
{
  __int64 v1; // rcx

  if ( *(_QWORD *)(sub_14001B620(a1) + 24) )
    sub_14002A5D0(v1);
  sub_14001A9AC(a1);
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (000000014001A8AC) ----------------------------------------------------
_BYTE *__usercall sub_14001A8AC@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rdi
  signed __int64 v3; // rbx
  _BYTE *v4; // rax
  _BYTE *v5; // rsi

  v2 = a1;
  if ( !a1 )
    return 0i64;
  v3 = -1i64;
  do
    ++v3;
  while ( *(_BYTE *)(a1 + v3) );
  v4 = (_BYTE *)sub_140014FA0(v3 + 1);
  v5 = v4;
  if ( !v4 )
    return 0i64;
  if ( (unsigned int)sub_14001A94C(v3 + 1, v4, v2, a2) )
  {
    sub_14001ADD4(a2);
    JUMPOUT(*(_QWORD *)&byte_14001A920);
  }
  return v5;
}
// 140014FA0: using guessed type __int64 __fastcall sub_140014FA0(_QWORD);
// 14001A920: using guessed type char;

//----- (000000014001A924) ----------------------------------------------------
signed __int64 __usercall sub_14001A924@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  if ( a1 )
    return *(unsigned int *)(a1 + 24);
  *(_DWORD *)sub_140015334() = 22;
  sub_14001ADB4(a2);
  return 0xFFFFFFFFi64;
}

//----- (000000014001A94C) ----------------------------------------------------
__int64 __usercall sub_14001A94C@<rax>(__int64 a1@<rdx>, _BYTE *a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  unsigned int v4; // ebx
  _DWORD *v5; // rax
  _BYTE *v7; // r9
  __int64 v8; // r8
  char v9; // al

  v4 = 0;
  if ( !a2 || !a1 )
  {
LABEL_5:
    v5 = sub_140015334();
    v4 = 22;
LABEL_6:
    *v5 = v4;
    sub_14001ADB4(a4);
    return v4;
  }
  if ( !a3 )
  {
    *a2 = 0;
    goto LABEL_5;
  }
  v7 = a2;
  v8 = a3 - (_QWORD)a2;
  while ( 1 )
  {
    v9 = v7[v8];
    *v7++ = v9;
    if ( !v9 )
      return v4;
    if ( !--a1 )
    {
      *a2 = 0;
      v5 = sub_140015334();
      v4 = 34;
      goto LABEL_6;
    }
  }
}

//----- (000000014001A9AC) ----------------------------------------------------
void __usercall __noreturn sub_14001A9AC(__m256i *a1@<ymm0>)
{
  if ( sub_140023BD0() )
    sub_140023C20(0x16u, a1);
  if ( byte_14003E160 & 2 )
  {
    if ( IsProcessorFeaturePresent(0x17u) )
      __fastfail(7u);
    sub_14001AAE8(1073741845, 3, 1, a1);
  }
  sub_140019FC0(3u);
  JUMPOUT(*(_QWORD *)&byte_14001AA01);
}
// 14001AA01: using guessed type char byte_14001AA01;
// 14003E160: using guessed type char byte_14003E160;

//----- (000000014001AA04) ----------------------------------------------------
__int64 __fastcall sub_14001AA04(_WORD *a1, _WORD *a2, __int64 a3)
{
  if ( !a3 )
    return 0i64;
  while ( --a3 && *a1 && *a1 == *a2 )
  {
    ++a1;
    ++a2;
  }
  return (unsigned __int16)*a1 - (unsigned int)(unsigned __int16)*a2;
}

//----- (000000014001AA30) ----------------------------------------------------
signed __int64 __fastcall sub_14001AA30(signed __int64 *a1)
{
  signed __int64 v1; // rsi
  __int64 v2; // rdi
  signed __int64 *v3; // rbx
  signed __int64 v4; // rax
  DWORD v5; // ecx
  DWORD dwErrCode; // [rsp+30h] [rbp+8h]

  v1 = *a1;
  v2 = 0i64;
  v3 = a1;
  if ( !*a1 )
  {
    dwErrCode = GetLastError();
    if ( *((_BYTE *)v3 + 16) )
    {
      v2 = v3[1];
    }
    else
    {
      v3[1] = 0i64;
      *((_BYTE *)v3 + 16) = 1;
    }
    v4 = sub_14001B860((__int64)&dwErrCode, v2);
    v5 = dwErrCode;
    v1 = v4;
    *v3 = v4;
    SetLastError(v5);
  }
  return v1;
}

//----- (000000014001AA9C) ----------------------------------------------------
signed __int64 __fastcall sub_14001AA9C(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rsi
  DWORD v5; // eax

  v2 = 0i64;
  v3 = a2;
  v4 = a1;
  if ( *(_BYTE *)(a2 + 16) )
  {
    v2 = *(_QWORD *)(a2 + 8);
  }
  else
  {
    v5 = GetLastError();
    *(_QWORD *)(v3 + 8) = 0i64;
    *(_BYTE *)(v3 + 16) = 1;
    SetLastError(v5);
  }
  return v4 + 8 * v2;
}

//----- (000000014001AAE8) ----------------------------------------------------
void __usercall sub_14001AAE8(int a1@<edx>, int a2@<ecx>, int a3@<r8d>, __m256i *a4@<ymm0>)
{
  int v4; // edi
  int v5; // esi
  int v6; // ebx
  DWORD64 v7; // r14
  struct _RUNTIME_FUNCTION *v8; // rax
  BOOL v9; // edi
  unsigned __int64 ImageBase; // [rsp+40h] [rbp-C0h]
  struct _EXCEPTION_POINTERS ExceptionInfo; // [rsp+48h] [rbp-B8h]
  unsigned __int64 EstablisherFrame; // [rsp+58h] [rbp-A8h]
  PVOID HandlerData; // [rsp+60h] [rbp-A0h]
  int v14; // [rsp+70h] [rbp-90h]
  int v15; // [rsp+74h] [rbp-8Ch]
  DWORD64 v16; // [rsp+80h] [rbp-80h]
  _CONTEXT ContextRecord; // [rsp+110h] [rbp+10h]
  DWORD64 retaddr; // [rsp+608h] [rbp+508h]
  __int64 v19; // [rsp+610h] [rbp+510h]

  v4 = a3;
  v5 = a1;
  v6 = a2;
  if ( a2 != -1 )
    sub_14000C584();
  sub_14000D100(0i64, (__int64)&v14, 0x98ui64, a4);
  sub_14000D100(0i64, (__int64)&ContextRecord, 0x4D0ui64, a4);
  ExceptionInfo.ExceptionRecord = (PEXCEPTION_RECORD)&v14;
  ExceptionInfo.ContextRecord = &ContextRecord;
  RtlCaptureContext(&ContextRecord);
  v7 = ContextRecord.Rip;
  v8 = RtlLookupFunctionEntry(ContextRecord.Rip, &ImageBase, 0i64);
  if ( v8 )
    RtlVirtualUnwind(0, ImageBase, v7, v8, &ContextRecord, &HandlerData, &EstablisherFrame, 0i64);
  ContextRecord.Rip = retaddr;
  v14 = v5;
  ContextRecord.Rsp = (DWORD64)&v19;
  v16 = retaddr;
  v15 = v4;
  v9 = IsDebuggerPresent();
  SetUnhandledExceptionFilter(0i64);
  if ( !UnhandledExceptionFilter(&ExceptionInfo) && !v9 && v6 != -1 )
    sub_14000C584();
}

//----- (000000014001AC44) ----------------------------------------------------
void __fastcall sub_14001AC44(__int64 a1)
{
  qword_140040960 = a1;
}
// 140040960: using guessed type __int64 qword_140040960;

//----- (000000014001AC4C) ----------------------------------------------------
_DWORD *__usercall sub_14001AC4C@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>, __int64 a3)
{
  _DWORD *result; // rax
  int v4; // ebx
  int v5; // ebx
  _DWORD *v6; // [rsp+30h] [rbp-40h]
  char v7; // [rsp+40h] [rbp-30h]
  __int128 v8; // [rsp+48h] [rbp-28h]
  char v9; // [rsp+58h] [rbp-18h]
  int v10; // [rsp+5Ch] [rbp-14h]
  char v11; // [rsp+60h] [rbp-10h]
  int v12; // [rsp+64h] [rbp-Ch]
  char v13; // [rsp+68h] [rbp-8h]

  v6 = 0i64;
  v7 = 0;
  v9 = 0;
  v11 = 0;
  v13 = 0;
  if ( !dword_140040924 )
  {
    v9 = 1;
    _mm_storeu_si128((__m128i *)&v8, off_14003E2C8);
  }
  result = (_DWORD *)sub_14001ACE8(a1, a2, a3, (signed __int64 *)&v6);
  if ( v9 == 2 )
  {
    result = v6;
    result[234] &= 0xFFFFFFFD;
  }
  if ( v11 )
  {
    v4 = v10;
    result = (_DWORD *)sub_14001009C((signed __int64 *)&v6, a2);
    result[8] = v4;
  }
  if ( v13 )
  {
    v5 = v12;
    result = (_DWORD *)sub_14001009C((signed __int64 *)&v6, a2);
    result[9] = v5;
  }
  return result;
}
// 140040924: using guessed type int dword_140040924;

//----- (000000014001ACE8) ----------------------------------------------------
__int64 __usercall sub_14001ACE8@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>, __int64 a3, signed __int64 *a4)
{
  __int64 v4; // rbp
  signed __int64 v5; // rax

  v4 = a1;
  v5 = sub_14001AA30(a4);
  if ( (!v5 || !*(_QWORD *)(v5 + 952))
    && !__ROR8__(
          _security_cookie ^ *(_QWORD *)sub_14001AA9C((__int64)&qword_140040960, (__int64)a4),
          _security_cookie & 0x3F) )
  {
    sub_14001ADD4(a2);
    __debugbreak();
    JUMPOUT(*(_QWORD *)sub_14001ADB4);
  }
  return sub_14002A5D0(v4);
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);
// 140040960: using guessed type __int64 qword_140040960;

//----- (000000014001ADB4) ----------------------------------------------------
_DWORD *__usercall sub_14001ADB4@<rax>(__m256i *a1@<ymm0>)
{
  return sub_14001AC4C(0i64, a1, 0i64);
}

//----- (000000014001ADD4) ----------------------------------------------------
BOOL __usercall sub_14001ADD4@<eax>(__m256i *a1@<ymm0>)
{
  HANDLE v1; // rax

  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(5u);
  sub_14001AAE8(-1073740777, 2, 1, a1);
  v1 = GetCurrentProcess();
  return TerminateProcess(v1, 0xC0000417);
}

//----- (000000014001AE1C) ----------------------------------------------------
void __fastcall sub_14001AE1C(LPVOID lpMem)
{
  int v1; // eax
  int v2; // ebx

  if ( lpMem )
  {
    if ( !HeapFree(hHeap, 0, lpMem) )
    {
      v1 = GetLastError();
      v2 = sub_140015260(v1);
      *(_DWORD *)sub_140015334() = v2;
    }
  }
}

//----- (000000014001AE58) ----------------------------------------------------
__int64 __usercall sub_14001AE58@<rax>(int *a1@<rdx>, unsigned int **a2@<r8>, int *a3@<r9>, __m256i *a4@<ymm0>)
{
  int *v4; // rdi
  unsigned int **v5; // rbx
  __int64 v6; // rdx
  unsigned int v7; // ebx

  v4 = a3;
  v5 = a2;
  sub_140018234(*a1);
  v6 = (__int64)v5[1];
  if ( *(_BYTE *)(qword_140040970[(signed __int64)(signed int)**v5 >> 6] + 72i64 * (**v5 & 0x3F) + 56) & 1 )
  {
    v7 = sub_14001B02C(v6, **v5, a4);
  }
  else
  {
    *(_BYTE *)(v6 + 48) = 1;
    *(_DWORD *)(v6 + 44) = 9;
    v7 = -1;
  }
  sub_14001831C(*v4);
  return v7;
}

//----- (000000014001AED0) ----------------------------------------------------
__int64 __usercall sub_14001AED0@<rax>(__int64 a1@<rdx>, signed int a2@<ecx>, __m256i *a3@<ymm0>)
{
  int v4; // [rsp+30h] [rbp-28h]
  int *v5; // [rsp+38h] [rbp-20h]
  __int64 v6; // [rsp+40h] [rbp-18h]
  int v7; // [rsp+60h] [rbp+8h]
  int v8; // [rsp+78h] [rbp+20h]

  v7 = a2;
  if ( a2 == -2 )
  {
    *(_BYTE *)(a1 + 56) = 1;
    *(_DWORD *)(a1 + 52) = 0;
    *(_BYTE *)(a1 + 48) = 1;
    *(_DWORD *)(a1 + 44) = 9;
  }
  else
  {
    if ( a2 >= 0
      && a2 < (unsigned int)dword_140040D70
      && *(_BYTE *)(qword_140040970[(signed __int64)a2 >> 6] + 72i64 * (a2 & 0x3F) + 56) & 1 )
    {
      v6 = a1;
      v8 = a2;
      v4 = a2;
      v5 = &v7;
      return sub_14001AE58(&v4, (unsigned int **)&v5, &v8, a3);
    }
    *(_BYTE *)(a1 + 56) = 1;
    *(_DWORD *)(a1 + 52) = 0;
    *(_BYTE *)(a1 + 48) = 1;
    *(_DWORD *)(a1 + 44) = 9;
    sub_14001ACE8(0i64, a3, 0i64, (signed __int64 *)a1);
  }
  return 0xFFFFFFFFi64;
}
// 140040D70: using guessed type int dword_140040D70;

//----- (000000014001AF94) ----------------------------------------------------
__int64 __usercall sub_14001AF94@<rax>(unsigned int a1@<ecx>, __m256i *a2@<ymm0>)
{
  unsigned int v2; // edi
  int v3; // ebx
  int v4; // ebx
  __int64 v6; // [rsp+20h] [rbp-40h]
  char v7; // [rsp+30h] [rbp-30h]
  __int128 v8; // [rsp+38h] [rbp-28h]
  char v9; // [rsp+48h] [rbp-18h]
  int v10; // [rsp+4Ch] [rbp-14h]
  char v11; // [rsp+50h] [rbp-10h]
  int v12; // [rsp+54h] [rbp-Ch]
  char v13; // [rsp+58h] [rbp-8h]

  v6 = 0i64;
  v7 = 0;
  v9 = 0;
  v11 = 0;
  v13 = 0;
  if ( !dword_140040924 )
  {
    v9 = 1;
    _mm_storeu_si128((__m128i *)&v8, off_14003E2C8);
  }
  v2 = sub_14001B02C((__int64)&v6, a1, a2);
  if ( v9 == 2 )
    *(_DWORD *)(v6 + 936) &= 0xFFFFFFFD;
  if ( v11 )
  {
    v3 = v10;
    *(_DWORD *)(sub_14001009C(&v6, a2) + 32) = v3;
  }
  if ( v13 )
  {
    v4 = v12;
    *(_DWORD *)(sub_14001009C(&v6, a2) + 36) = v4;
  }
  return v2;
}
// 140040924: using guessed type int dword_140040924;

//----- (000000014001B02C) ----------------------------------------------------
signed __int64 __usercall sub_14001B02C@<rax>(__int64 a1@<rdx>, unsigned int a2@<ecx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rdi
  __int64 v4; // rsi
  int v5; // ebx
  signed __int64 v6; // rbx
  void *v7; // rax

  v3 = (signed int)a2;
  v4 = a1;
  if ( sub_140018540(a2, a3) == -1
    || ((_DWORD)v3 == 1 && *(_BYTE *)(qword_140040970[0] + 200) & 1
     || (_DWORD)v3 == 2 && *(_BYTE *)(qword_140040970[0] + 128) & 1)
    && (v6 = sub_140018540(2ui64, a3), sub_140018540(1ui64, a3) == v6)
    || (v7 = (void *)sub_140018540((unsigned int)v3, a3), CloseHandle(v7)) )
  {
    v5 = 0;
  }
  else
  {
    v5 = GetLastError();
  }
  sub_140018484(v3);
  *(_BYTE *)(qword_140040970[v3 >> 6] + 72 * (v3 & 0x3F) + 56) = 0;
  if ( !v5 )
    return 0i64;
  sub_1400152F0(v5, v4);
  return 0xFFFFFFFFi64;
}

//----- (000000014001B0FC) ----------------------------------------------------
__int64 *__fastcall sub_14001B0FC(__int64 *a1)
{
  __int64 *v1; // rbx
  __int64 v2; // rax
  char v4; // [rsp+30h] [rbp+8h]

  v1 = a1;
  *a1 = 0i64;
  sub_140020BC8(8);
  v2 = *sub_14001B170((__int64 *)&v4);
  *v1 = v2;
  if ( v2 )
  {
    *(_DWORD *)(v2 + 16) = 0;
    *(_QWORD *)(v2 + 40) = 0i64;
    *(_QWORD *)v2 = 0i64;
    *(_QWORD *)(v2 + 8) = 0i64;
    *(_DWORD *)(v2 + 24) = -1;
  }
  sub_140020C28(8);
  return v1;
}

//----- (000000014001B154) ----------------------------------------------------
__int64 __fastcall sub_14001B154(__int64 a1)
{
  *(_DWORD *)(a1 + 24) = -1;
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 28) = 0i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  return (unsigned int)_InterlockedExchange((volatile signed __int32 *)(a1 + 20), 0);
}

//----- (000000014001B170) ----------------------------------------------------
__int64 *__fastcall sub_14001B170(__int64 *a1)
{
  __int64 *v1; // rsi
  __int64 *v2; // rdi
  __int64 *v3; // rbp
  unsigned __int32 v5; // eax
  unsigned __int32 v6; // ett

  v1 = a1;
  v2 = (__int64 *)((char *)lpMem + 24);
  v3 = (__int64 *)((char *)lpMem + 8 * (dword_1400406C0 - 3i64) + 24);
  while ( v2 != v3 )
  {
    _RBX = *v2;
    if ( !*v2 )
    {
      *v2 = (__int64)sub_14001F068(1ui64, 0x58ui64);
      sub_14001AE1C(0i64);
      if ( *v2 )
      {
        *(_DWORD *)(*v2 + 24) = -1;
        sub_14001F444((LPCRITICAL_SECTION)(*v2 + 48), 0xFA0u);
        _RBX = *v2;
        _InterlockedOr((volatile signed __int32 *)(*v2 + 20), 0x2000u);
        sub_1400151DC(_RBX);
LABEL_12:
        *v1 = _RBX;
        return v1;
      }
      break;
    }
    if ( !((*(_DWORD *)(_RBX + 20) >> 13) & 1) )
    {
      sub_1400151DC(*v2);
      __asm { prefetchw byte ptr [rbx+14h] }
      v5 = *(_DWORD *)(_RBX + 20);
      do
      {
        v6 = v5;
        v5 = _InterlockedCompareExchange((volatile signed __int32 *)(_RBX + 20), v5 | 0x2000, v5);
      }
      while ( v6 != v5 );
      if ( ~(unsigned __int8)(v5 >> 13) & 1 )
        goto LABEL_12;
      sub_1400151E8(_RBX);
    }
    ++v2;
  }
  *v1 = 0i64;
  return v1;
}
// 1400406C0: using guessed type int dword_1400406C0;

//----- (000000014001B25C) ----------------------------------------------------
__int64 __fastcall sub_14001B25C(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax

  v1 = a1;
  result = (unsigned int)(*(_DWORD *)(a1 + 20) >> 13);
  if ( result & 1 )
  {
    result = (unsigned int)(*(_DWORD *)(a1 + 20) >> 6);
    if ( result & 1 )
    {
      sub_14001AE1C(*(LPVOID *)(a1 + 8));
      _InterlockedAnd((volatile signed __int32 *)(v1 + 20), 0xFFFFFEBF);
      result = 0i64;
      *(_QWORD *)(v1 + 8) = 0i64;
      *(_QWORD *)v1 = 0i64;
      *(_DWORD *)(v1 + 16) = 0;
    }
  }
  return result;
}

//----- (000000014001B2A0) ----------------------------------------------------
void __fastcall sub_14001B2A0(__int64 a1, int *a2, __int64 a3, int *a4)
{
  int *v4; // rbx
  __int64 v5; // rdi

  v4 = a4;
  v5 = a3;
  sub_140020BC8(*a2);
  _InterlockedIncrement(*(volatile signed __int32 **)(**(_QWORD **)v5 + 136i64));
  sub_140020C28(*v4);
}

//----- (000000014001B2E0) ----------------------------------------------------
void __fastcall sub_14001B2E0(__int64 a1, int *a2, __int64 **a3, int *a4)
{
  int *v4; // rbx
  __int64 **v5; // rdi

  v4 = a4;
  v5 = a3;
  sub_140020BC8(*a2);
  sub_14001B5B8(**v5, 0i64);
  sub_140020C28(*v4);
}

//----- (000000014001B320) ----------------------------------------------------
void __fastcall sub_14001B320(__int64 a1, int *a2, __int64 a3, int *a4)
{
  int *v4; // rbx
  __int64 v5; // rdi

  v4 = a4;
  v5 = a3;
  sub_140020BC8(*a2);
  sub_14001B5B8(**(_QWORD **)v5, ***(_QWORD ***)(v5 + 8));
  sub_140020C28(*v4);
}

//----- (000000014001B368) ----------------------------------------------------
void __fastcall sub_14001B368(__int64 a1, int *a2, __int64 a3, int *a4)
{
  int *v4; // rbx
  __int64 v5; // rdi
  void *v6; // rcx

  v4 = a4;
  v5 = a3;
  sub_140020BC8(*a2);
  v6 = *(void **)(**(_QWORD **)v5 + 136i64);
  if ( v6 && _InterlockedExchangeAdd((volatile signed __int32 *)v6, 0xFFFFFFFF) == 1 && v6 != &unk_14003E440 )
    sub_14001AE1C(v6);
  sub_140020C28(*v4);
}

//----- (000000014001B3C8) ----------------------------------------------------
void __fastcall sub_14001B3C8(__int64 a1)
{
  int v1; // [rsp+20h] [rbp-30h]
  int v2; // [rsp+24h] [rbp-2Ch]
  __int64 v3; // [rsp+28h] [rbp-28h]
  __int64 *v4; // [rsp+30h] [rbp-20h]
  __int64 *v5; // [rsp+38h] [rbp-18h]
  __int64 *v6; // [rsp+40h] [rbp-10h]
  __int64 **v7; // [rsp+48h] [rbp-8h]
  char v8; // [rsp+68h] [rbp+18h]
  int v9; // [rsp+70h] [rbp+20h]
  int v10; // [rsp+78h] [rbp+28h]

  v3 = a1;
  v5 = &v3;
  v9 = 5;
  v10 = 5;
  v6 = &v3;
  v7 = &v4;
  v1 = 4;
  v2 = 4;
  v4 = qword_140040968;
  *(_DWORD *)(a1 + 40) = 1;
  *(_QWORD *)v3 = &unk_140032750;
  *(_DWORD *)(v3 + 936) = 1;
  *(_QWORD *)(v3 + 136) = &unk_14003E440;
  *(_WORD *)(v3 + 188) = 67;
  *(_WORD *)(v3 + 450) = 67;
  *(_QWORD *)(v3 + 928) = 0i64;
  sub_14001B2A0((__int64)&v8, &v10, (__int64)&v5, &v9);
  sub_14001B320((__int64)&v8, &v2, (__int64)&v6, &v1);
}
// 140040968: using guessed type __int64 qword_140040968[];

//----- (000000014001B4A0) ----------------------------------------------------
void __fastcall Callback(PVOID lpFlsData)
{
  PVOID v1; // rbx

  if ( lpFlsData )
  {
    v1 = lpFlsData;
    sub_14001B4C0((LPVOID *)lpFlsData);
    sub_14001AE1C(v1);
  }
}

//----- (000000014001B4C0) ----------------------------------------------------
void __fastcall sub_14001B4C0(LPVOID *a1)
{
  int v1; // [rsp+20h] [rbp-20h]
  int v2; // [rsp+24h] [rbp-1Ch]
  LPVOID *v3; // [rsp+28h] [rbp-18h]
  LPVOID **v4; // [rsp+30h] [rbp-10h]
  LPVOID **v5; // [rsp+38h] [rbp-8h]
  char v6; // [rsp+58h] [rbp+18h]
  int v7; // [rsp+60h] [rbp+20h]
  int v8; // [rsp+68h] [rbp+28h]

  v3 = a1;
  v4 = &v3;
  v7 = 5;
  v8 = 5;
  v5 = &v3;
  v1 = 4;
  v2 = 4;
  if ( *a1 != &unk_140032750 )
  {
    sub_14001AE1C(*a1);
    a1 = v3;
  }
  sub_14001AE1C(a1[14]);
  sub_14001AE1C(v3[11]);
  sub_14001AE1C(v3[12]);
  sub_14001AE1C(v3[13]);
  sub_14001AE1C(v3[9]);
  sub_14001AE1C(v3[10]);
  sub_14001AE1C(v3[15]);
  sub_14001AE1C(v3[16]);
  sub_14001AE1C(v3[120]);
  sub_14001B368((__int64)&v6, &v8, (__int64)&v4, &v7);
  sub_14001B2E0((__int64)&v6, &v2, (__int64 **)&v5, &v1);
}

//----- (000000014001B5B8) ----------------------------------------------------
void __fastcall sub_14001B5B8(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // rcx
  wchar_t **v5; // rcx

  v2 = a1;
  v3 = a2;
  v4 = *(_QWORD *)(a1 + 144);
  if ( v4 )
  {
    sub_1400237DC(v4);
    v5 = *(wchar_t ***)(v2 + 144);
    if ( v5 != (wchar_t **)qword_140040968[0] && v5 != &off_14003E170 && !*((_DWORD *)v5 + 4) )
      sub_1400235DC(v5);
  }
  *(_QWORD *)(v2 + 144) = v3;
  if ( v3 )
    sub_140023550(v3);
}
// 14003E170: using guessed type wchar_t *off_14003E170;
// 140040968: using guessed type __int64 qword_140040968[];

//----- (000000014001B620) ----------------------------------------------------
__int64 __usercall sub_14001B620@<rax>(__m256i *a1@<ymm0>)
{
  DWORD v1; // eax
  DWORD v2; // ecx
  DWORD v3; // ebx
  PVOID v4; // rax
  __int64 v5; // rdi
  void *v6; // rax
  void *v7; // rcx

  v1 = GetLastError();
  v2 = dwFlsIndex;
  v3 = v1;
  if ( dwFlsIndex == -1 )
  {
LABEL_7:
    if ( FlsSetValue(v2, (PVOID)0xFFFFFFFFFFFFFFFFi64) )
    {
      v6 = sub_14001F068(1ui64, 0x3C8ui64);
      v5 = (__int64)v6;
      if ( v6 )
      {
        if ( FlsSetValue(dwFlsIndex, v6) )
        {
          sub_14001B3C8(v5);
          sub_14001AE1C(0i64);
          goto LABEL_15;
        }
        FlsSetValue(dwFlsIndex, 0i64);
        v7 = (void *)v5;
      }
      else
      {
        FlsSetValue(dwFlsIndex, 0i64);
        v7 = 0i64;
      }
      sub_14001AE1C(v7);
    }
    v5 = 0i64;
    goto LABEL_15;
  }
  v4 = FlsGetValue(dwFlsIndex);
  v5 = (__int64)v4;
  if ( !v4 )
  {
    v2 = dwFlsIndex;
    goto LABEL_7;
  }
  if ( v4 == (PVOID)-1i64 )
    v5 = 0i64;
LABEL_15:
  SetLastError(v3);
  if ( !v5 )
    sub_14001A9AC(a1);
  return v5;
}

//----- (000000014001B6F4) ----------------------------------------------------
__int64 __usercall sub_14001B6F4@<rax>(__m256i *a1@<ymm0>)
{
  DWORD v1; // ecx
  PVOID v2; // rax
  __int64 v3; // rbx
  void *v4; // rax
  void *v5; // rcx

  v1 = dwFlsIndex;
  if ( dwFlsIndex != -1 )
  {
    v2 = FlsGetValue(dwFlsIndex);
    v3 = (__int64)v2;
    if ( v2 )
    {
      if ( v2 != (PVOID)-1i64 )
        return v3;
LABEL_14:
      sub_14001A9AC(a1);
    }
    v1 = dwFlsIndex;
  }
  if ( !FlsSetValue(v1, (PVOID)0xFFFFFFFFFFFFFFFFi64) )
    goto LABEL_14;
  v4 = sub_14001F068(1ui64, 0x3C8ui64);
  v3 = (__int64)v4;
  if ( !v4 )
  {
    FlsSetValue(dwFlsIndex, 0i64);
    v5 = 0i64;
LABEL_9:
    sub_14001AE1C(v5);
    goto LABEL_14;
  }
  if ( !FlsSetValue(dwFlsIndex, v4) )
  {
    FlsSetValue(dwFlsIndex, 0i64);
    v5 = (void *)v3;
    goto LABEL_9;
  }
  sub_14001B3C8(v3);
  sub_14001AE1C(0i64);
  return v3;
}

//----- (000000014001B798) ----------------------------------------------------
__int64 sub_14001B798()
{
  DWORD v0; // eax
  DWORD v1; // ecx
  DWORD v2; // ebx
  PVOID v3; // rax
  __int64 v4; // rdi
  void *v5; // rax
  void *v6; // rcx

  v0 = GetLastError();
  v1 = dwFlsIndex;
  v2 = v0;
  if ( dwFlsIndex != -1 )
  {
    v3 = FlsGetValue(dwFlsIndex);
    v4 = (__int64)v3;
    if ( v3 )
    {
      if ( v3 == (PVOID)-1i64 )
        v4 = 0i64;
      goto LABEL_15;
    }
    v1 = dwFlsIndex;
  }
  if ( FlsSetValue(v1, (PVOID)0xFFFFFFFFFFFFFFFFi64) )
  {
    v5 = sub_14001F068(1ui64, 0x3C8ui64);
    v4 = (__int64)v5;
    if ( v5 )
    {
      if ( FlsSetValue(dwFlsIndex, v5) )
      {
        sub_14001B3C8(v4);
        sub_14001AE1C(0i64);
        goto LABEL_15;
      }
      FlsSetValue(dwFlsIndex, 0i64);
      v6 = (void *)v4;
    }
    else
    {
      FlsSetValue(dwFlsIndex, 0i64);
      v6 = 0i64;
    }
    sub_14001AE1C(v6);
  }
  v4 = 0i64;
LABEL_15:
  SetLastError(v2);
  return v4;
}

//----- (000000014001B860) ----------------------------------------------------
signed __int64 __fastcall sub_14001B860(__int64 a1, __int64 a2)
{
  DWORD v2; // ecx
  __int64 v3; // rbx
  __int64 v4; // rsi
  PVOID v5; // rax
  __int64 v6; // rdi
  void *v7; // rax
  void *v8; // rcx

  v2 = dwFlsIndex;
  v3 = 0i64;
  v4 = a2;
  if ( dwFlsIndex != -1 )
  {
    v5 = FlsGetValue(dwFlsIndex);
    v6 = (__int64)v5;
    if ( v5 )
    {
      if ( v5 != (PVOID)-1i64 )
        return v6 + 968 * v4;
      return v3;
    }
    v2 = dwFlsIndex;
  }
  if ( FlsSetValue(v2, (PVOID)0xFFFFFFFFFFFFFFFFi64) )
  {
    v7 = sub_14001F068(1ui64, 0x3C8ui64);
    v6 = (__int64)v7;
    if ( v7 )
    {
      if ( FlsSetValue(dwFlsIndex, v7) )
      {
        sub_14001B3C8(v6);
        sub_14001AE1C(0i64);
        return v6 + 968 * v4;
      }
      FlsSetValue(dwFlsIndex, 0i64);
      v8 = (void *)v6;
    }
    else
    {
      FlsSetValue(dwFlsIndex, 0i64);
      v8 = 0i64;
    }
    sub_14001AE1C(v8);
  }
  return v3;
}

//----- (000000014001B920) ----------------------------------------------------
char sub_14001B920()
{
  dwFlsIndex = FlsAlloc((PFLS_CALLBACK_FUNCTION)Callback);
  if ( dwFlsIndex == -1 )
    return 0;
  if ( !sub_14001B798() )
  {
    sub_14001B960();
    return 0;
  }
  return 1;
}

//----- (000000014001B960) ----------------------------------------------------
char sub_14001B960()
{
  if ( dwFlsIndex != -1 )
  {
    FlsFree(dwFlsIndex);
    dwFlsIndex = -1;
  }
  return 1;
}

//----- (000000014001B984) ----------------------------------------------------
__int64 __usercall sub_14001B984@<rax>(_WORD *a1@<rdx>, signed int a2@<ecx>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  unsigned int v4; // er15
  signed __int64 v5; // rbp
  signed __int64 v6; // rsi
  _WORD *v7; // r14
  signed __int64 v8; // rdi
  __int64 v9; // rax
  void *v10; // r10
  unsigned __int64 v11; // r8
  signed __int16 *v12; // rbx
  signed __int16 v13; // cx
  _WORD *v14; // r9
  signed __int64 v15; // rax
  signed __int16 v16; // ax
  __int64 v18; // rdx
  char v19; // al
  __int16 Buffer; // [rsp+70h] [rbp+8h]
  __int16 v21; // [rsp+78h] [rbp+10h]
  DWORD NumberOfBytesRead; // [rsp+80h] [rbp+18h]

  v4 = a2;
  v5 = (signed __int64)a2 >> 6;
  v6 = 0i64;
  v7 = a1;
  v8 = 9i64 * (a2 & 0x3F);
  v9 = qword_140040970[v5];
  v10 = *(void **)(v9 + 72i64 * (a2 & 0x3F) + 40);
  if ( a3 && *a1 == 10 )
    *(_BYTE *)(v9 + 72i64 * (a2 & 0x3F) + 56) |= 4u;
  else
    *(_BYTE *)(v9 + 72i64 * (a2 & 0x3F) + 56) &= 0xFBu;
  v11 = (unsigned __int64)&a1[a3];
  v12 = a1;
  if ( (unsigned __int64)a1 < v11 )
  {
    while ( 1 )
    {
      v13 = *a1;
      if ( *a1 == 26 )
        break;
      v14 = a1 + 1;
      if ( v13 == 13 )
      {
        if ( (unsigned __int64)v14 >= v11 )
        {
          if ( ReadFile(v10, &Buffer, 2u, &NumberOfBytesRead, 0i64) && NumberOfBytesRead )
          {
            if ( *(_BYTE *)(qword_140040970[v5] + 8 * v8 + 56) & 0x48 )
            {
              if ( Buffer == 10 )
                goto LABEL_21;
              v21 = Buffer;
              *v12 = 13;
              do
              {
                *(_BYTE *)(qword_140040970[v5] + 8 * v8 + v6 + 58) = *((_BYTE *)&v21 + v6);
                ++v6;
              }
              while ( v6 < 2 );
              *(_BYTE *)(qword_140040970[v5] + 8 * v8 + 60) = 10;
LABEL_30:
              ++v12;
              return 2 * (unsigned int)(v12 - v7);
            }
            if ( Buffer == 10 && v12 == v7 )
            {
LABEL_21:
              *v12 = 10;
              goto LABEL_30;
            }
            sub_14001C754((LARGE_INTEGER)-2i64, v4, 1u, a4);
            if ( Buffer == 10 )
              return 2 * (unsigned int)(v12 - v7);
          }
          v13 = 13;
LABEL_29:
          *v12 = v13;
          goto LABEL_30;
        }
        v15 = 2i64;
        if ( *v14 == 10 )
          v15 = 4i64;
        a1 = (_WORD *)((char *)a1 + v15);
        v16 = 10;
        if ( *v14 != 10 )
          v16 = 13;
        *v12 = v16;
      }
      else
      {
        ++a1;
        *v12 = v13;
      }
      ++v12;
      if ( (unsigned __int64)a1 >= v11 )
        return 2 * (unsigned int)(v12 - v7);
    }
    v18 = qword_140040970[v5];
    v19 = *(_BYTE *)(v18 + 8 * v8 + 56);
    if ( v19 & 0x40 )
      goto LABEL_29;
    *(_BYTE *)(v18 + 8 * v8 + 56) = v19 | 2;
  }
  return 2 * (unsigned int)(v12 - v7);
}

//----- (000000014001BB44) ----------------------------------------------------
signed __int64 __usercall sub_14001BB44@<rax>(const CHAR *a1@<rdx>, signed int a2@<ecx>, __int64 a3@<r8>, WCHAR *a4@<r9>, __m256i *a5@<ymm0>, int a6)
{
  unsigned int v6; // er14
  signed __int64 v7; // rbp
  WCHAR *v8; // r15
  const CHAR *v9; // rsi
  signed __int64 v10; // rdi
  __int64 v11; // rax
  void *v12; // r10
  const CHAR *v13; // r9
  const CHAR *v14; // rax
  CHAR *v15; // rbx
  CHAR v16; // cl
  const CHAR *v17; // rdx
  signed __int64 v18; // rcx
  char v19; // cl
  __int64 v20; // rdx
  char v21; // al
  unsigned int v22; // ebx
  signed __int64 result; // rax
  __int64 v24; // r8
  const CHAR *v25; // rcx
  unsigned __int8 *v26; // rbx
  unsigned int i; // edx
  unsigned __int8 v28; // cl
  char v29; // cl
  unsigned __int8 v30; // cl
  int v31; // ebx
  int v32; // eax
  int v33; // eax
  __int64 v34; // rdx
  char v35; // cl
  char Buffer; // [rsp+60h] [rbp+8h]
  DWORD NumberOfBytesRead; // [rsp+68h] [rbp+10h]

  v6 = a2;
  v7 = (signed __int64)a2 >> 6;
  v8 = a4;
  v9 = a1;
  v10 = 9i64 * (a2 & 0x3F);
  v11 = qword_140040970[v7];
  v12 = *(void **)(v11 + 72i64 * (a2 & 0x3F) + 40);
  if ( a3 && *a1 == 10 )
    *(_BYTE *)(v11 + 72i64 * (a2 & 0x3F) + 56) |= 4u;
  else
    *(_BYTE *)(v11 + 72i64 * (a2 & 0x3F) + 56) &= 0xFBu;
  v13 = &a1[a3];
  v14 = a1;
  v15 = (CHAR *)a1;
  if ( a1 >= &a1[a3] )
    goto LABEL_31;
  while ( 1 )
  {
    v16 = *v14;
    if ( *v14 == 26 )
    {
      v20 = qword_140040970[v7];
      v21 = *(_BYTE *)(v20 + 8 * v10 + 56);
      if ( !(v21 & 0x40) )
      {
        *(_BYTE *)(v20 + 8 * v10 + 56) = v21 | 2;
        goto LABEL_31;
      }
      *v15 = 26;
      goto LABEL_30;
    }
    v17 = v14 + 1;
    if ( v16 == 13 )
      break;
    ++v14;
    *v15 = v16;
LABEL_14:
    ++v15;
    if ( v14 >= v13 )
      goto LABEL_31;
  }
  if ( v17 < v13 )
  {
    if ( *v17 == 10 )
    {
      *v15 = 10;
      v18 = 2i64;
    }
    else
    {
      *v15 = 13;
      v18 = 1i64;
    }
    v14 += v18;
    goto LABEL_14;
  }
  if ( ReadFile(v12, &Buffer, 1u, &NumberOfBytesRead, 0i64) && NumberOfBytesRead )
  {
    if ( *(_BYTE *)(qword_140040970[v7] + 8 * v10 + 56) & 0x48 )
    {
      v19 = Buffer;
      if ( Buffer == 10 )
      {
LABEL_20:
        *v15 = 10;
        goto LABEL_30;
      }
      *v15 = 13;
      *(_BYTE *)(qword_140040970[v7] + 8 * v10 + 58) = v19;
    }
    else
    {
      if ( Buffer == 10 && v15 == v9 )
        goto LABEL_20;
      sub_14001C754((LARGE_INTEGER)-1i64, v6, 1u, a5);
      if ( Buffer == 10 )
        goto LABEL_31;
      *v15 = 13;
    }
  }
  else
  {
    *v15 = 13;
  }
LABEL_30:
  LODWORD(v15) = (_DWORD)v15 + 1;
LABEL_31:
  v22 = (_DWORD)v15 - (_DWORD)v9;
  if ( !v22 )
    return 0i64;
  v24 = qword_140040970[v7];
  if ( !*(_BYTE *)(v24 + 8 * v10 + 57) )
    return v22;
  v25 = &v9[v22];
  v26 = (unsigned __int8 *)(v25 - 1);
  if ( *(v25 - 1) >= 0 )
  {
    LODWORD(v26) = (_DWORD)v25;
    goto LABEL_54;
  }
  for ( i = 1; !byte_14003E2E0[*v26] && i <= 4 && v26 >= (unsigned __int8 *)v9; ++i )
    --v26;
  v28 = *v26;
  if ( !byte_14003E2E0[*v26] )
  {
    *(_DWORD *)sub_140015334() = 42;
    goto LABEL_44;
  }
  if ( byte_14003E2E0[*v26] + 1 == i )
  {
    LODWORD(v26) = i + (_DWORD)v26;
  }
  else if ( *(_BYTE *)(v24 + 8 * v10 + 56) & 0x48 )
  {
    ++v26;
    *(_BYTE *)(v24 + 8 * v10 + 58) = v28;
    if ( i >= 2 )
    {
      v29 = *v26++;
      *(_BYTE *)(qword_140040970[v7] + 8 * v10 + 59) = v29;
    }
    if ( i == 3 )
    {
      v30 = *v26;
      LODWORD(v26) = (_DWORD)v26 + 1;
      *(_BYTE *)(qword_140040970[v7] + 8 * v10 + 60) = v30;
    }
    LODWORD(v26) = (_DWORD)v26 - i;
  }
  else
  {
    sub_14001C754((LARGE_INTEGER)-i, v6, 1u, a5);
  }
LABEL_54:
  v31 = (_DWORD)v26 - (_DWORD)v9;
  v32 = sub_14001FB10(0xFDE9u, 0, v9, v31, v8, a6);
  if ( v32 )
  {
    v34 = qword_140040970[v7];
    v35 = *(_BYTE *)(v34 + 8 * v10 + 61) & 0xFD | (v31 != v32 ? 2 : 0);
    result = (unsigned int)(2 * v32);
    *(_BYTE *)(v34 + 8 * v10 + 61) = v35;
  }
  else
  {
    v33 = GetLastError();
    sub_1400152A8(v33);
LABEL_44:
    result = 0xFFFFFFFFi64;
  }
  return result;
}

//----- (000000014001BE0C) ----------------------------------------------------
signed __int64 __usercall sub_14001BE0C@<rax>(WCHAR *a1@<rdx>, int a2@<ecx>, unsigned int a3@<r8d>, __m256i *a4@<ymm0>)
{
  unsigned int v4; // er14
  WCHAR *v5; // r12
  signed int v6; // esi
  BOOL v8; // eax
  signed __int64 v9; // r15
  unsigned int v10; // ebx

  v4 = a3;
  v5 = a1;
  v6 = a2;
  if ( a2 == -2 )
  {
    *(_DWORD *)sub_140015314() = 0;
    *(_DWORD *)sub_140015334() = 9;
    return 0xFFFFFFFFi64;
  }
  v8 = a2 >= 0 && a2 < (unsigned int)dword_140040D70;
  if ( !v8 || (v9 = (signed __int64)a2 >> 6, !(*(_BYTE *)(qword_140040970[v9] + 72i64 * (a2 & 0x3F) + 56) & 1)) )
  {
    *(_DWORD *)sub_140015314() = 0;
    *(_DWORD *)sub_140015334() = 9;
LABEL_11:
    sub_14001ADB4(a4);
    return 0xFFFFFFFFi64;
  }
  if ( a3 > 0x7FFFFFFF )
  {
    *(_DWORD *)sub_140015314() = 0;
    *(_DWORD *)sub_140015334() = 22;
    goto LABEL_11;
  }
  sub_140018234(a2);
  v10 = -1;
  if ( *(_BYTE *)(qword_140040970[v9] + 72i64 * (v6 & 0x3F) + 56) & 1 )
  {
    v10 = sub_14001BF2C(v5, v6, v4, a4);
  }
  else
  {
    *(_DWORD *)sub_140015334() = 9;
    *(_DWORD *)sub_140015314() = 0;
  }
  sub_14001831C(v6);
  return v10;
}
// 140040D70: using guessed type int dword_140040D70;

//----- (000000014001BF2C) ----------------------------------------------------
signed __int64 __usercall sub_14001BF2C@<rax>(WCHAR *a1@<rdx>, signed int a2@<ecx>, unsigned int a3@<r8d>, __m256i *a4@<ymm0>)
{
  unsigned int v4; // er13
  unsigned __int64 v5; // r12
  unsigned __int64 v6; // r8
  __int64 v7; // rax
  WCHAR *v8; // rbx
  int v9; // er10
  unsigned int v10; // ebp
  WCHAR *v11; // r15
  LARGE_INTEGER v12; // rax
  __int64 v13; // rax
  signed int v14; // edi
  char v15; // al
  char v16; // cl
  char v17; // cl
  int v18; // eax
  signed int v19; // edi
  unsigned __int64 v21; // rdx
  signed int v22; // eax
  __int64 v23; // r8
  WCHAR *v24; // r10
  signed __int16 *v25; // rax
  signed __int16 *v26; // rdi
  unsigned __int64 v27; // r9
  signed __int16 v28; // cx
  signed __int64 v29; // r11
  DWORD Mode; // [rsp+30h] [rbp-68h]
  HANDLE hConsoleHandle; // [rsp+38h] [rbp-60h]
  unsigned __int64 v32; // [rsp+40h] [rbp-58h]
  __int64 v33; // [rsp+48h] [rbp-50h]
  WCHAR *v34; // [rsp+50h] [rbp-48h]
  char v35; // [rsp+A0h] [rbp+8h]
  WCHAR *v36; // [rsp+A8h] [rbp+10h]
  DWORD NumberOfCharsRead; // [rsp+B8h] [rbp+20h]

  v36 = a1;
  v4 = a2;
  v5 = a3;
  if ( a2 != -2 )
  {
    if ( a2 >= 0
      && a2 < (unsigned int)dword_140040D70
      && (v33 = 1i64,
          v6 = (unsigned __int64)a2 >> 6,
          v32 = (unsigned __int64)a2 >> 6,
          v7 = qword_140040970[v6],
          *(_BYTE *)(v7 + 72i64 * (a2 & 0x3F) + 56) & 1) )
    {
      if ( (unsigned int)v5 <= 0x7FFFFFFF )
      {
        if ( !(_DWORD)v5 || *(_BYTE *)(v7 + 72i64 * (a2 & 0x3F) + 56) & 2 )
          return 0i64;
        if ( a1 )
        {
          v8 = 0i64;
          v9 = *(char *)(v7 + 72i64 * (a2 & 0x3F) + 57);
          hConsoleHandle = *(HANDLE *)(v7 + 72i64 * (a2 & 0x3F) + 40);
          v35 = v9;
          if ( v9 == 1 )
          {
            if ( !(~(_BYTE)v5 & 1) )
            {
LABEL_14:
              *(_DWORD *)sub_140015314() = 0;
              *(_DWORD *)sub_140015334() = 22;
              sub_14001ADB4(a4);
LABEL_39:
              v19 = -1;
              goto LABEL_40;
            }
            v10 = (unsigned int)v5 >> 1;
            if ( (unsigned int)v5 >> 1 < 4 )
              v10 = 4;
            v8 = (WCHAR *)sub_14001DACC(v10);
            sub_14001AE1C(0i64);
            sub_14001AE1C(0i64);
            v11 = v8;
            if ( !v8 )
            {
              *(_DWORD *)sub_140015334() = 12;
              *(_DWORD *)sub_140015314() = 8;
              goto LABEL_39;
            }
            v12 = sub_14001C754(0i64, v4, 1u, a4);
            v6 = v32;
            LOBYTE(v9) = v35;
            *(LARGE_INTEGER *)(qword_140040970[v32] + 72i64 * (v4 & 0x3F) + 48) = v12;
          }
          else
          {
            if ( v9 == 2 && !(~(_BYTE)v5 & 1) )
              goto LABEL_14;
            v10 = v5;
            v11 = a1;
          }
          v13 = qword_140040970[v6];
          v14 = 0;
          v34 = v11;
          if ( *(_BYTE *)(v13 + 72i64 * (v4 & 0x3F) + 56) & 0x48 )
          {
            v15 = *(_BYTE *)(v13 + 72i64 * (v4 & 0x3F) + 58);
            if ( v15 != 10 )
            {
              if ( v10 )
              {
                *(_BYTE *)v11 = v15;
                --v10;
                v11 = (WCHAR *)((char *)v11 + 1);
                v14 = 1;
                *(_BYTE *)(qword_140040970[v6] + 72i64 * (v4 & 0x3F) + 58) = 10;
                if ( (_BYTE)v9 )
                {
                  v16 = *(_BYTE *)(qword_140040970[v6] + 72i64 * (v4 & 0x3F) + 59);
                  if ( v16 != 10 )
                  {
                    if ( v10 )
                    {
                      *(_BYTE *)v11 = v16;
                      v14 = 2;
                      v11 = (WCHAR *)((char *)v11 + 1);
                      --v10;
                      *(_BYTE *)(qword_140040970[v6] + 72i64 * (v4 & 0x3F) + 59) = 10;
                      if ( (_BYTE)v9 == 1 )
                      {
                        v17 = *(_BYTE *)(qword_140040970[v6] + 72i64 * (v4 & 0x3F) + 60);
                        if ( v17 != 10 )
                        {
                          if ( v10 )
                          {
                            *(_BYTE *)v11 = v17;
                            v14 = 3;
                            v11 = (WCHAR *)((char *)v11 + 1);
                            --v10;
                            *(_BYTE *)(qword_140040970[v6] + 72i64 * (v4 & 0x3F) + 60) = 10;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if ( (unsigned int)sub_140023E9C(v4, a4)
            && *(_BYTE *)(qword_140040970[v32] + 72i64 * (v4 & 0x3F) + 56) < 0
            && GetConsoleMode(hConsoleHandle, &Mode) )
          {
            if ( v35 == 2 )
            {
              if ( !ReadConsoleW(hConsoleHandle, v11, v10 >> 1, &NumberOfCharsRead, 0i64) )
              {
                v18 = GetLastError();
LABEL_38:
                sub_1400152A8(v18);
                goto LABEL_39;
              }
              v19 = v14 + 2 * NumberOfCharsRead;
              goto LABEL_46;
            }
          }
          else
          {
            LOBYTE(v33) = 0;
          }
          if ( !ReadFile(hConsoleHandle, v11, v10, &NumberOfCharsRead, 0i64) || NumberOfCharsRead > (unsigned int)v5 )
          {
            v18 = GetLastError();
            if ( v18 == 5 )
            {
              *(_DWORD *)sub_140015334() = 9;
              *(_DWORD *)sub_140015314() = 5;
              goto LABEL_39;
            }
            if ( v18 == 109 )
            {
              v19 = 0;
              goto LABEL_40;
            }
            goto LABEL_38;
          }
          v19 = NumberOfCharsRead + v14;
LABEL_46:
          v21 = v32;
          if ( *(_BYTE *)(qword_140040970[v32] + 72i64 * (v4 & 0x3F) + 56) < 0 )
          {
            if ( v35 == 2 )
            {
              v23 = (unsigned __int64)v19 >> 1;
              if ( (_BYTE)v33 )
              {
                v24 = v34;
                v25 = (signed __int16 *)v34;
                v26 = (signed __int16 *)v34;
                v27 = (unsigned __int64)&v34[v23];
                if ( (unsigned __int64)v34 < v27 )
                {
                  while ( 1 )
                  {
                    v28 = *v25;
                    if ( *v25 == 26 )
                      break;
                    if ( v28 != 13 || (unsigned __int64)(v25 + 1) >= v27 || v25[1] != 10 )
                    {
                      v29 = 2i64;
                    }
                    else
                    {
                      v28 = 10;
                      v29 = 4i64;
                    }
                    v25 = (signed __int16 *)((char *)v25 + v29);
                    *v26 = v28;
                    ++v26;
                    if ( (unsigned __int64)v25 >= v27 )
                      goto LABEL_61;
                  }
                  *(_BYTE *)(qword_140040970[v21] + 72i64 * (v4 & 0x3F) + 56) |= 2u;
                }
LABEL_61:
                v19 = 2 * (unsigned __int64)(((char *)v26 - (char *)v24) >> 1);
                goto LABEL_40;
              }
              v22 = sub_14001B984(v34, v4, v23, a4);
            }
            else
            {
              v22 = sub_14001BB44((const CHAR *)v11, v4, v19, v36, a4, v5 >> 1);
            }
            v19 = v22;
          }
LABEL_40:
          sub_14001AE1C(v8);
          return (unsigned int)v19;
        }
      }
      *(_DWORD *)sub_140015314() = 0;
      *(_DWORD *)sub_140015334() = 22;
    }
    else
    {
      *(_DWORD *)sub_140015314() = 0;
      *(_DWORD *)sub_140015334() = 9;
    }
    sub_14001ADB4(a4);
    return 0xFFFFFFFFi64;
  }
  *(_DWORD *)sub_140015314() = 0;
  *(_DWORD *)sub_140015334() = 9;
  return 0xFFFFFFFFi64;
}
// 140040D70: using guessed type int dword_140040D70;

//----- (000000014001C37C) ----------------------------------------------------
__int64 __usercall sub_14001C37C@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rsi
  unsigned int v3; // edi
  WCHAR *v5; // rdi
  unsigned int v6; // ebx
  int v7; // eax
  unsigned int v8; // eax
  signed __int64 v9; // rbx
  _BYTE *v10; // rdx
  unsigned __int8 *v11; // rax

  v2 = a1;
  if ( !a1 )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a2);
    return (unsigned int)-1;
  }
  if ( !((*(_DWORD *)(a1 + 20) >> 13) & 1) || (*(_DWORD *)(a1 + 20) >> 12) & 1 )
    return (unsigned int)-1;
  if ( (*(_DWORD *)(a1 + 20) >> 1) & 1 )
  {
    _InterlockedOr((volatile signed __int32 *)(a1 + 20), 0x10u);
    return (unsigned int)-1;
  }
  _InterlockedOr((volatile signed __int32 *)(a1 + 20), 1u);
  if ( !(*(_DWORD *)(a1 + 20) & 0x4C0) )
    sub_140023EFC(a1);
  v5 = *(WCHAR **)(v2 + 8);
  v6 = *(_DWORD *)(v2 + 32);
  *(_QWORD *)v2 = v5;
  v7 = sub_14001A924(v2, a2);
  v8 = sub_14001BE0C(v5, v7, v6, a2);
  *(_DWORD *)(v2 + 16) = v8;
  if ( v8 >= 0xFFFFFFFF || v8 == 0 )
  {
    _InterlockedOr((volatile signed __int32 *)(v2 + 20), v8 != 0 ? 16 : 8);
    *(_DWORD *)(v2 + 16) = 0;
    return (unsigned int)-1;
  }
  if ( !(*(_DWORD *)(v2 + 20) & 6) )
  {
    if ( (unsigned int)sub_14001A924(v2, a2) == -1 || (unsigned int)sub_14001A924(v2, a2) == -2 )
    {
      v10 = &unk_14003E3E0;
    }
    else
    {
      v9 = (signed __int64)(signed int)sub_14001A924(v2, a2) >> 6;
      v10 = (_BYTE *)(qword_140040970[v9] + 72 * (sub_14001A924(v2, a2) & 0x3F));
    }
    if ( (v10[56] & 0x82) == -126 )
      _InterlockedOr((volatile signed __int32 *)(v2 + 20), 0x20u);
  }
  if ( *(_DWORD *)(v2 + 32) == 512 && (*(_DWORD *)(v2 + 20) >> 6) & 1 && !((*(_WORD *)(v2 + 20) >> 8) & 1) )
    *(_DWORD *)(v2 + 32) = 4096;
  v11 = *(unsigned __int8 **)v2;
  --*(_DWORD *)(v2 + 16);
  v3 = *v11;
  *(_QWORD *)v2 = v11 + 1;
  return v3;
}

//----- (000000014001C4E4) ----------------------------------------------------
signed __int64 __usercall sub_14001C4E4@<rax>(LARGE_INTEGER a1@<rdx>, int a2@<ecx>, DWORD a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  __int64 v5; // rbx
  DWORD v6; // er13
  unsigned int v7; // esi
  BOOL v9; // eax
  signed __int64 v10; // r15
  LARGE_INTEGER v11; // r14
  LARGE_INTEGER v12; // [rsp+68h] [rbp+10h]

  v12 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  if ( a2 == -2 )
  {
    *(_BYTE *)(a4 + 56) = 1;
    *(_DWORD *)(a4 + 52) = 0;
    *(_BYTE *)(a4 + 48) = 1;
    *(_DWORD *)(a4 + 44) = 9;
    return -1i64;
  }
  v9 = a2 >= 0 && a2 < (unsigned int)dword_140040D70;
  if ( !v9 || (v10 = (signed __int64)a2 >> 6, !(*(_BYTE *)(qword_140040970[v10] + 72i64 * (a2 & 0x3F) + 56) & 1)) )
  {
    *(_BYTE *)(a4 + 56) = 1;
    *(_DWORD *)(a4 + 52) = 0;
    *(_BYTE *)(a4 + 48) = 1;
    *(_DWORD *)(a4 + 44) = 9;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)a4);
    return -1i64;
  }
  sub_140018234(a2);
  v11.QuadPart = -1i64;
  if ( *(_BYTE *)(qword_140040970[v10] + 72i64 * (v7 & 0x3F) + 56) & 1 )
  {
    v11 = sub_14001C604(v12, v7, v6, v5, a5);
  }
  else
  {
    *(_BYTE *)(v5 + 48) = 1;
    *(_DWORD *)(v5 + 44) = 9;
    *(_BYTE *)(v5 + 56) = 1;
    *(_DWORD *)(v5 + 52) = 0;
  }
  sub_14001831C(v7);
  return v11.QuadPart;
}
// 140040D70: using guessed type int dword_140040D70;

//----- (000000014001C604) ----------------------------------------------------
LARGE_INTEGER __usercall sub_14001C604@<rax>(LARGE_INTEGER a1@<rdx>, unsigned int a2@<ecx>, DWORD a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  __int64 v5; // rdi
  __int64 v6; // rbx
  DWORD v7; // esi
  LARGE_INTEGER v8; // rbp
  void *v9; // rax
  LARGE_INTEGER result; // rax
  int v11; // eax
  LARGE_INTEGER NewFilePointer; // [rsp+20h] [rbp-18h]

  v5 = (signed int)a2;
  v6 = a4;
  v7 = a3;
  v8 = a1;
  v9 = (void *)sub_140018540(a2, a5);
  if ( v9 == (void *)-1i64 )
  {
    *(_BYTE *)(v6 + 48) = 1;
    *(_DWORD *)(v6 + 44) = 9;
    return (LARGE_INTEGER)-1i64;
  }
  if ( !SetFilePointerEx(v9, v8, &NewFilePointer, v7) )
  {
    v11 = GetLastError();
    sub_1400152F0(v11, v6);
    return (LARGE_INTEGER)-1i64;
  }
  result = NewFilePointer;
  if ( NewFilePointer.QuadPart == -1 )
    return (LARGE_INTEGER)-1i64;
  *(_BYTE *)(qword_140040970[v5 >> 6] + 72 * (v5 & 0x3F) + 56) &= 0xFDu;
  return result;
}

//----- (000000014001C6B0) ----------------------------------------------------
signed __int64 __usercall sub_14001C6B0@<rax>(LARGE_INTEGER a1@<rdx>, int a2@<ecx>, DWORD a3@<r8d>, __m256i *a4@<ymm0>)
{
  signed __int64 v4; // rdi
  int v5; // ebx
  int v6; // ebx
  __int64 v8; // [rsp+20h] [rbp-40h]
  char v9; // [rsp+30h] [rbp-30h]
  __int128 v10; // [rsp+38h] [rbp-28h]
  char v11; // [rsp+48h] [rbp-18h]
  int v12; // [rsp+4Ch] [rbp-14h]
  char v13; // [rsp+50h] [rbp-10h]
  int v14; // [rsp+54h] [rbp-Ch]
  char v15; // [rsp+58h] [rbp-8h]

  v8 = 0i64;
  v9 = 0;
  v11 = 0;
  v13 = 0;
  v15 = 0;
  if ( !dword_140040924 )
  {
    v11 = 1;
    _mm_storeu_si128((__m128i *)&v10, off_14003E2C8);
  }
  v4 = sub_14001C4E4(a1, a2, a3, (__int64)&v8, a4);
  if ( v11 == 2 )
    *(_DWORD *)(v8 + 936) &= 0xFFFFFFFD;
  if ( v13 )
  {
    v5 = v12;
    *(_DWORD *)(sub_14001009C(&v8, a4) + 32) = v5;
  }
  if ( v15 )
  {
    v6 = v14;
    *(_DWORD *)(sub_14001009C(&v8, a4) + 36) = v6;
  }
  return v4;
}
// 140040924: using guessed type int dword_140040924;

//----- (000000014001C754) ----------------------------------------------------
LARGE_INTEGER __usercall sub_14001C754@<rax>(LARGE_INTEGER a1@<rdx>, unsigned int a2@<ecx>, DWORD a3@<r8d>, __m256i *a4@<ymm0>)
{
  LARGE_INTEGER v4; // rdi
  int v5; // ebx
  int v6; // ebx
  __int64 v8; // [rsp+20h] [rbp-40h]
  char v9; // [rsp+30h] [rbp-30h]
  __int128 v10; // [rsp+38h] [rbp-28h]
  char v11; // [rsp+48h] [rbp-18h]
  int v12; // [rsp+4Ch] [rbp-14h]
  char v13; // [rsp+50h] [rbp-10h]
  int v14; // [rsp+54h] [rbp-Ch]
  char v15; // [rsp+58h] [rbp-8h]

  v8 = 0i64;
  v9 = 0;
  v11 = 0;
  v13 = 0;
  v15 = 0;
  if ( !dword_140040924 )
  {
    v11 = 1;
    _mm_storeu_si128((__m128i *)&v10, off_14003E2C8);
  }
  v4 = sub_14001C604(a1, a2, a3, (__int64)&v8, a4);
  if ( v11 == 2 )
    *(_DWORD *)(v8 + 936) &= 0xFFFFFFFD;
  if ( v13 )
  {
    v5 = v12;
    *(_DWORD *)(sub_14001009C(&v8, a4) + 32) = v5;
  }
  if ( v15 )
  {
    v6 = v14;
    *(_DWORD *)(sub_14001009C(&v8, a4) + 36) = v6;
  }
  return v4;
}
// 140040924: using guessed type int dword_140040924;

//----- (000000014001C7F8) ----------------------------------------------------
void __usercall sub_14001C7F8(__m256i *a1@<ymm0>)
{
  _BYTE *v1; // rsi
  signed __int64 v2; // rdi
  HANDLE *v3; // rbx
  __int64 v4; // rbp
  __int64 v5; // rcx
  signed __int64 v6; // rdx
  __int64 v7; // [rsp+20h] [rbp-78h]
  __int16 v8; // [rsp+62h] [rbp-36h]
  signed int *v9; // [rsp+68h] [rbp-30h]

  GetStartupInfoW((LPSTARTUPINFOW)&v7);
  if ( v8 && v9 )
  {
    v1 = v9 + 1;
    v2 = 0x2000i64;
    v3 = (HANDLE *)((char *)v9 + *v9 + 4);
    if ( *v9 < 0x2000 )
      v2 = (unsigned int)*v9;
    sub_14001818C(v2, a1);
    if ( (signed int)v2 > dword_140040D70 )
      v2 = (unsigned int)dword_140040D70;
    if ( (_DWORD)v2 )
    {
      v4 = 0i64;
      do
      {
        if ( *v3 != (HANDLE)-1i64 && *v3 != (HANDLE)-2i64 && *v1 & 1 && (*v1 & 8 || GetFileType(*v3)) )
        {
          v5 = qword_140040970[v4 >> 6];
          v6 = 9 * (v4 & 0x3F);
          *(_QWORD *)(v5 + 8 * v6 + 40) = *v3;
          *(_BYTE *)(v5 + 8 * v6 + 56) = *v1;
        }
        ++v4;
        ++v1;
        ++v3;
        --v2;
      }
      while ( v2 );
    }
  }
}
// 140040D70: using guessed type int dword_140040D70;

//----- (000000014001C8E8) ----------------------------------------------------
unsigned __int64 sub_14001C8E8()
{
  int v0; // esi
  __int64 v1; // r14
  __int64 v2; // rcx
  signed __int64 v3; // rbx
  __int64 v4; // rdi
  unsigned __int64 result; // rax
  DWORD v6; // ecx
  char *v7; // rax
  char *v8; // rbp

  v0 = 0;
  v1 = 0i64;
  do
  {
    v2 = v0 & 0x3F;
    v3 = 9 * v2;
    v4 = qword_140040970[(signed __int64)v0 >> 6];
    result = *(_QWORD *)(v4 + 72 * v2 + 40) + 2i64;
    if ( result <= 1 )
    {
      *(_BYTE *)(v4 + 72 * v2 + 56) = -127;
      if ( v0 )
      {
        if ( v0 == 1 )
          v6 = -11;
        else
          v6 = -12;
      }
      else
      {
        v6 = -10;
      }
      v7 = (char *)GetStdHandle(v6);
      v8 = v7;
      if ( (unsigned __int64)v7 >= 0xFFFFFFFFFFFFFFFFui64
        || v7 + 1 == (char *)1
        || (LODWORD(result) = GetFileType(v7), !(_DWORD)result) )
      {
        *(_BYTE *)(v4 + 8 * v3 + 56) |= 0x40u;
        *(_QWORD *)(v4 + 8 * v3 + 40) = -2i64;
        result = (unsigned __int64)lpMem;
        if ( lpMem )
        {
          result = *(_QWORD *)((char *)lpMem + v1);
          *(_DWORD *)(result + 24) = -2;
        }
      }
      else
      {
        result = (unsigned __int8)result;
        *(_QWORD *)(v4 + 8 * v3 + 40) = v8;
        if ( (unsigned __int8)result == 2 )
        {
          *(_BYTE *)(v4 + 8 * v3 + 56) |= 0x40u;
        }
        else if ( (_DWORD)result == 3 )
        {
          *(_BYTE *)(v4 + 8 * v3 + 56) |= 8u;
        }
      }
    }
    else
    {
      *(_BYTE *)(v4 + 72 * v2 + 56) |= 0x80u;
    }
    ++v0;
    v1 += 8i64;
  }
  while ( v0 != 3 );
  return result;
}

//----- (000000014001C9F0) ----------------------------------------------------
char __usercall sub_14001C9F0@<al>(__m256i *a1@<ymm0>)
{
  char v1; // bl

  sub_140020BC8(7);
  v1 = 0;
  if ( !(unsigned int)sub_14001818C(0, a1) )
  {
    sub_14001C7F8(a1);
    sub_14001C8E8();
    v1 = 1;
  }
  sub_140020C28(7);
  return v1;
}

//----- (000000014001CA30) ----------------------------------------------------
char sub_14001CA30()
{
  unsigned __int64 v0; // rbx
  struct _RTL_CRITICAL_SECTION *v1; // rcx

  v0 = 0i64;
  do
  {
    v1 = (struct _RTL_CRITICAL_SECTION *)qword_140040970[v0];
    if ( v1 )
    {
      sub_14001813C(v1);
      qword_140040970[v0] = 0i64;
    }
    ++v0;
  }
  while ( v0 < 128 );
  return 1;
}

//----- (000000014001CA70) ----------------------------------------------------
__int64 __usercall sub_14001CA70@<rax>(int a1@<edx>, __int64 a2@<rcx>, unsigned __int64 a3@<r8>, unsigned int a4@<r9d>, __m256i *a5@<ymm0>)
{
  __m128i *v5; // rsi
  __int64 v6; // r14
  __int64 v7; // rbx
  signed __int64 v8; // r13
  signed __int64 v9; // r15
  unsigned __int64 v10; // r12
  int v11; // edi
  LPOVERLAPPED v12; // r10
  int v13; // ecx
  __int64 v14; // r9
  int v15; // edx
  unsigned int v16; // er12
  int v17; // edx
  signed __int64 v18; // r14
  _BYTE *v19; // rcx
  int v20; // er12
  __int64 v21; // rdx
  signed __int64 v22; // r8
  signed __int64 v23; // rcx
  char *v24; // rdx
  signed __int64 v25; // rdx
  __int64 v26; // r13
  __int64 v27; // r8
  unsigned __int64 v28; // r14
  __int64 v29; // r8
  char v30; // cl
  unsigned __int64 v31; // r8
  CHAR *v32; // rdx
  __int64 v33; // r9
  int v34; // eax
  DWORD v35; // er14
  HANDLE v36; // r12
  char *v37; // rsi
  __int64 v38; // rdx
  __int64 v39; // r9
  __int16 v41; // [rsp+8h] [rbp-71h]
  int v42; // [rsp+Ch] [rbp-6Dh]
  DWORD NumberOfBytesWritten; // [rsp+10h] [rbp-69h]
  unsigned __int64 v44; // [rsp+18h] [rbp-61h]
  LPOVERLAPPED lpOverlapped; // [rsp+20h] [rbp-59h]
  __int64 v46; // [rsp+28h] [rbp-51h]
  __int64 v47; // [rsp+30h] [rbp-49h]
  unsigned __int64 v48; // [rsp+38h] [rbp-41h]
  __int64 v49; // [rsp+40h] [rbp-39h]
  __int64 v50; // [rsp+48h] [rbp-31h]
  char *v51; // [rsp+50h] [rbp-29h]
  __m128i *v52; // [rsp+58h] [rbp-21h]
  HANDLE hFile; // [rsp+60h] [rbp-19h]
  __int64 v54; // [rsp+68h] [rbp-11h]
  __int64 v55; // [rsp+70h] [rbp-9h]
  char v56[8]; // [rsp+78h] [rbp-1h]
  char v57; // [rsp+80h] [rbp+7h]
  char v58; // [rsp+81h] [rbp+8h]
  char Buffer; // [rsp+88h] [rbp+Fh]
  __int64 v60; // [rsp+F8h] [rbp+7Fh]

  v55 = -2i64;
  v5 = (__m128i *)a3;
  v48 = a3;
  v6 = a1;
  v7 = a2;
  lpOverlapped = (LPOVERLAPPED)v60;
  v8 = (signed __int64)a1 >> 6;
  v49 = v8;
  v9 = 9i64 * (a1 & 0x3F);
  hFile = *(HANDLE *)(qword_140040970[v8] + 72i64 * (a1 & 0x3F) + 40);
  v10 = a3 + a4;
  LODWORD(v47) = GetConsoleOutputCP();
  v11 = 0;
  v12 = (LPOVERLAPPED)v60;
  if ( !*(_BYTE *)(v60 + 40) )
  {
    sub_140014910((signed __int64 *)lpOverlapped, a5);
    v12 = lpOverlapped;
  }
  v13 = *((_DWORD *)v12->hEvent + 3);
  HIDWORD(v47) = *((_DWORD *)v12->hEvent + 3);
  *(_QWORD *)v7 = 0i64;
  *(_DWORD *)(v7 + 8) = 0;
  if ( v48 < v10 )
  {
    v14 = v6 >> 6;
    v54 = v6 >> 6;
    v15 = 0;
    while ( 1 )
    {
      LOBYTE(v41) = v5->m128i_i64[0];
      v42 = 0;
      v16 = 1;
      if ( v13 == 65001 )
      {
        v17 = 0;
        v18 = 0i64;
        v19 = (_BYTE *)(qword_140040970[v14] + 8 * v9 + 62);
        do
        {
          if ( !*v19 )
            break;
          ++v17;
          ++v18;
          ++v19;
        }
        while ( v18 < 5 );
        if ( v18 <= 0 )
        {
          v26 = byte_14003E2E0[LOBYTE(v5->m128i_i64[0])];
          v27 = v44 - (_QWORD)v5;
          if ( (signed int)v26 + 1 > (signed __int64)(v44 - (_QWORD)v5) )
          {
            if ( v27 > 0 )
            {
              v38 = 0i64;
              v39 = v49;
              do
              {
                *(_BYTE *)(v38 + qword_140040970[v39] + 8 * v9 + 62) = *((_BYTE *)v5->m128i_i64 + v38);
                ++v11;
                ++v38;
              }
              while ( v11 < v27 );
            }
            *(_DWORD *)(v7 + 4) += v27;
            return v7;
          }
          v46 = 0i64;
          v52 = v5;
          v28 = (unsigned int)((_DWORD)v26 == 3) + 1;
          if ( sub_1400209D4(&v42, (char **)&v52, v28, &v46, (__int64)v12) == -1 )
            return v7;
          v5 = (__m128i *)((char *)v5 + v26);
          v16 = v28;
          v8 = v49;
        }
        else
        {
          v20 = byte_14003E2E0[*(unsigned __int8 *)(qword_140040970[v8] + 8 * v9 + 62)] + 1;
          LODWORD(v46) = v20 - v17;
          v21 = v44 - (_QWORD)v5;
          v22 = (signed int)v46;
          if ( (signed int)v46 > (signed __int64)(v44 - (_QWORD)v5) )
          {
            if ( v21 > 0 )
            {
              v37 = (char *)v5->m128i_i64 - v18;
              do
              {
                *(_BYTE *)(v18 + qword_140040970[v8] + 8 * v9 + 62) = v37[v18];
                ++v11;
                ++v18;
              }
              while ( v11 < v21 );
            }
            *(_DWORD *)(v7 + 4) += v21;
            return v7;
          }
          v23 = 0i64;
          v24 = (char *)(qword_140040970[v14] + 8 * v9 + 62);
          do
            v56[v23++] = *v24++;
          while ( v23 < v18 );
          if ( v22 > 0 )
          {
            sub_14000CA50((__m128i *)&v56[v18], v5, v22);
            v12 = lpOverlapped;
          }
          v25 = 0i64;
          do
            *(_BYTE *)(v25++ + qword_140040970[v8] + 8 * v9 + 62) = 0;
          while ( v25 < v18 );
          v50 = 0i64;
          v51 = v56;
          v16 = (v20 == 4) + 1;
          if ( sub_1400209D4(&v42, &v51, v16, &v50, (__int64)v12) == -1 )
            return v7;
          v5 = (__m128i *)((char *)v5 + (signed int)v46 - 1);
        }
      }
      else
      {
        v29 = qword_140040970[v8];
        v30 = *(_BYTE *)(v29 + 8 * v9 + 61);
        if ( v30 & 4 )
        {
          v57 = *(_BYTE *)(v29 + 8 * v9 + 62);
          v58 = v5->m128i_i64[0];
          *(_BYTE *)(v29 + 8 * v9 + 61) = v30 & 0xFB;
          v31 = 2i64;
          v32 = &v57;
          goto LABEL_29;
        }
        v33 = LOBYTE(v5->m128i_i64[0]);
        if ( *(_WORD *)(*(_QWORD *)v12->hEvent + 2 * v33) >= 0 )
        {
          v31 = 1i64;
          v32 = (CHAR *)v5;
LABEL_29:
          if ( (unsigned int)sub_14001EED8(v32, (WCHAR *)&v42, v31, (__int64)v12, a5) == -1 )
            return v7;
          goto LABEL_30;
        }
        if ( (unsigned __int64)v5->m128i_u64 + 1 >= v44 )
        {
          *(_BYTE *)(v29 + 8 * v9 + 62) = v33;
          *(_BYTE *)(qword_140040970[v8] + 8 * v9 + 61) |= 4u;
          *(_DWORD *)(v7 + 4) = v15 + 1;
          return v7;
        }
        if ( (unsigned int)sub_14001EED8((CHAR *)v5->m128i_i64, (WCHAR *)&v42, 2ui64, (__int64)v12, a5) == -1 )
          return v7;
        v5 = (__m128i *)((char *)v5 + 1);
      }
LABEL_30:
      v5 = (__m128i *)((char *)v5 + 1);
      LODWORD(v46) = 5;
      v34 = sub_1400203D8(0, 0, (const WCHAR *)&v42, v16, &Buffer, v46, 0i64, 0i64);
      v35 = v34;
      if ( !v34 )
        return v7;
      v36 = hFile;
      if ( !WriteFile(hFile, &Buffer, v34, &NumberOfBytesWritten, 0i64) )
      {
LABEL_48:
        *(_DWORD *)v7 = GetLastError();
        return v7;
      }
      v15 = *(_DWORD *)(v7 + 8) + (_DWORD)v5 - v48;
      *(_DWORD *)(v7 + 4) = v15;
      if ( NumberOfBytesWritten < v35 )
        return v7;
      if ( (_BYTE)v41 == 10 )
      {
        if ( !WriteFile(v36, &v41, 1u, &NumberOfBytesWritten, 0i64) )
          goto LABEL_48;
        if ( NumberOfBytesWritten < 1 )
          return v7;
        ++*(_DWORD *)(v7 + 8);
        v15 = ++*(_DWORD *)(v7 + 4);
      }
      if ( (unsigned __int64)v5 >= v44 )
        return v7;
      v12 = lpOverlapped;
      v14 = v54;
      v13 = HIDWORD(v47);
    }
  }
  return v7;
}
// 14001CA70: using guessed type char var_88[8];

//----- (000000014001CEE8) ----------------------------------------------------
DWORD *__fastcall sub_14001CEE8(DWORD *a1, int a2, char *a3, int a4)
{
  DWORD *v4; // rdi
  unsigned __int64 v5; // rbp
  char *v6; // rsi
  void *v7; // r14
  char *v8; // rbx
  char v9; // al
  DWORD v10; // ebx
  DWORD v11; // eax
  DWORD NumberOfBytesWritten; // [rsp+30h] [rbp-1438h]
  char Buffer; // [rsp+40h] [rbp-1428h]
  char v15; // [rsp+143Fh] [rbp-29h]

  v4 = a1;
  v5 = (unsigned __int64)&a3[a4];
  v6 = a3;
  v7 = *(void **)(qword_140040970[(signed __int64)a2 >> 6] + 72i64 * (a2 & 0x3F) + 40);
  *(_QWORD *)a1 = 0i64;
  a1[2] = 0;
  if ( (unsigned __int64)a3 < v5 )
  {
    while ( 1 )
    {
      v8 = &Buffer;
      do
      {
        if ( (unsigned __int64)v6 >= v5 )
          break;
        v9 = *v6++;
        if ( v9 == 10 )
        {
          ++v4[2];
          *v8++ = 13;
        }
        *v8++ = v9;
      }
      while ( v8 < &v15 );
      v10 = (_DWORD)v8 - (unsigned __int64)&Buffer;
      if ( !WriteFile(v7, &Buffer, v10, &NumberOfBytesWritten, 0i64) )
        break;
      v11 = NumberOfBytesWritten;
      v4[1] += NumberOfBytesWritten;
      if ( v11 < v10 || (unsigned __int64)v6 >= v5 )
        return v4;
    }
    *v4 = GetLastError();
  }
  return v4;
}

//----- (000000014001CFEC) ----------------------------------------------------
DWORD *__fastcall sub_14001CFEC(DWORD *a1, int a2, __int16 *a3, unsigned int a4)
{
  DWORD *v4; // rdi
  unsigned __int64 v5; // rbp
  __int16 *v6; // rsi
  void *v7; // r14
  char *v8; // rbx
  __int16 v9; // ax
  DWORD v10; // ebx
  DWORD v11; // eax
  DWORD NumberOfBytesWritten; // [rsp+30h] [rbp-1438h]
  char Buffer; // [rsp+40h] [rbp-1428h]
  char v15; // [rsp+143Eh] [rbp-2Ah]

  v4 = a1;
  v5 = (unsigned __int64)a3 + a4;
  v6 = a3;
  v7 = *(void **)(qword_140040970[(signed __int64)a2 >> 6] + 72i64 * (a2 & 0x3F) + 40);
  *(_QWORD *)a1 = 0i64;
  a1[2] = 0;
  if ( (unsigned __int64)a3 < v5 )
  {
    while ( 1 )
    {
      v8 = &Buffer;
      do
      {
        if ( (unsigned __int64)v6 >= v5 )
          break;
        v9 = *v6;
        ++v6;
        if ( v9 == 10 )
        {
          v4[2] += 2;
          *(_WORD *)v8 = 13;
          v8 += 2;
        }
        *(_WORD *)v8 = v9;
        v8 += 2;
      }
      while ( v8 < &v15 );
      v10 = 2 * (unsigned __int64)((v8 - &Buffer) >> 1);
      if ( !WriteFile(v7, &Buffer, v10, &NumberOfBytesWritten, 0i64) )
        break;
      v11 = NumberOfBytesWritten;
      v4[1] += NumberOfBytesWritten;
      if ( v11 < v10 || (unsigned __int64)v6 >= v5 )
        return v4;
    }
    *v4 = GetLastError();
  }
  return v4;
}

//----- (000000014001D108) ----------------------------------------------------
DWORD *__fastcall sub_14001D108(DWORD *a1, int a2, __int16 *a3, unsigned int a4)
{
  DWORD *v4; // rbx
  unsigned __int64 v5; // r14
  int v6; // er15
  __int16 *v7; // rdi
  void *v8; // r12
  bool v9; // cf
  char *v10; // rax
  __int16 v11; // cx
  int v12; // eax
  unsigned int v13; // ebp
  unsigned int v14; // esi
  __int64 v16; // [rsp+28h] [rbp-1470h]
  DWORD NumberOfBytesWritten; // [rsp+40h] [rbp-1458h]
  char v18; // [rsp+50h] [rbp-1448h]
  char v19; // [rsp+6F8h] [rbp-DA0h]
  struct _OVERLAPPED Overlapped; // [rsp+700h] [rbp-D98h]

  v4 = a1;
  v5 = (unsigned __int64)a3 + a4;
  v6 = (signed int)a3;
  v7 = a3;
  v8 = *(void **)(qword_140040970[(signed __int64)a2 >> 6] + 72i64 * (a2 & 0x3F) + 40);
  *(_QWORD *)a1 = 0i64;
  v9 = (unsigned __int64)a3 < v5;
  a1[2] = 0;
  while ( v9 )
  {
    v10 = &v18;
    do
    {
      if ( (unsigned __int64)v7 >= v5 )
        break;
      v11 = *v7;
      ++v7;
      if ( v11 == 10 )
      {
        *(_WORD *)v10 = 13;
        v10 += 2;
      }
      *(_WORD *)v10 = v11;
      v10 += 2;
    }
    while ( v10 < &v19 );
    LODWORD(v16) = 3413;
    v12 = sub_1400203D8(0xFDE9u, 0, (const WCHAR *)&v18, (v10 - &v18) >> 1, (CHAR *)&Overlapped, v16, 0i64, 0i64);
    v13 = v12;
    if ( !v12 )
      goto LABEL_13;
    v14 = 0;
    if ( v12 )
    {
      while ( WriteFile(v8, (char *)&Overlapped + v14, v13 - v14, &NumberOfBytesWritten, 0i64) )
      {
        v14 += NumberOfBytesWritten;
        if ( v14 >= v13 )
          goto LABEL_12;
      }
LABEL_13:
      *v4 = GetLastError();
      return v4;
    }
LABEL_12:
    v4[1] = (_DWORD)v7 - v6;
    v9 = (unsigned __int64)v7 < v5;
  }
  return v4;
}

//----- (000000014001D278) ----------------------------------------------------
__int64 __usercall sub_14001D278@<rax>(unsigned __int16 *a1@<rdx>, int a2@<ecx>, unsigned int a3@<r8d>, __m256i *a4@<ymm0>)
{
  unsigned int v4; // edi
  int v5; // ebx
  int v6; // ebx
  __int64 v8; // [rsp+20h] [rbp-40h]
  char v9; // [rsp+30h] [rbp-30h]
  __int128 v10; // [rsp+38h] [rbp-28h]
  char v11; // [rsp+48h] [rbp-18h]
  int v12; // [rsp+4Ch] [rbp-14h]
  char v13; // [rsp+50h] [rbp-10h]
  int v14; // [rsp+54h] [rbp-Ch]
  char v15; // [rsp+58h] [rbp-8h]

  v8 = 0i64;
  v9 = 0;
  v11 = 0;
  v13 = 0;
  v15 = 0;
  if ( !dword_140040924 )
  {
    v11 = 1;
    _mm_storeu_si128((__m128i *)&v10, off_14003E2C8);
  }
  v4 = sub_14001D310(a1, a2, a3, (__int64)&v8, a4);
  if ( v11 == 2 )
    *(_DWORD *)(v8 + 936) &= 0xFFFFFFFD;
  if ( v13 )
  {
    v5 = v12;
    *(_DWORD *)(sub_14001009C(&v8, a4) + 32) = v5;
  }
  if ( v15 )
  {
    v6 = v14;
    *(_DWORD *)(sub_14001009C(&v8, a4) + 36) = v6;
  }
  return v4;
}
// 140040924: using guessed type int dword_140040924;

//----- (000000014001D310) ----------------------------------------------------
signed __int64 __usercall sub_14001D310@<rax>(unsigned __int16 *a1@<rdx>, int a2@<ecx>, unsigned int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  __int64 v5; // rbx
  unsigned int v6; // er13
  signed int v7; // esi
  BOOL v9; // eax
  signed __int64 v10; // r15
  unsigned int v11; // er14
  unsigned __int16 *v12; // [rsp+68h] [rbp+10h]

  v12 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  if ( a2 == -2 )
  {
    *(_BYTE *)(a4 + 56) = 1;
    *(_DWORD *)(a4 + 52) = 0;
    *(_BYTE *)(a4 + 48) = 1;
    *(_DWORD *)(a4 + 44) = 9;
    return 0xFFFFFFFFi64;
  }
  v9 = a2 >= 0 && a2 < (unsigned int)dword_140040D70;
  if ( !v9 || (v10 = (signed __int64)a2 >> 6, !(*(_BYTE *)(qword_140040970[v10] + 72i64 * (a2 & 0x3F) + 56) & 1)) )
  {
    *(_BYTE *)(a4 + 56) = 1;
    *(_DWORD *)(a4 + 52) = 0;
    *(_BYTE *)(a4 + 48) = 1;
    *(_DWORD *)(a4 + 44) = 9;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)a4);
    return 0xFFFFFFFFi64;
  }
  sub_140018234(a2);
  v11 = -1;
  if ( *(_BYTE *)(qword_140040970[v10] + 72i64 * (v7 & 0x3F) + 56) & 1 )
  {
    v11 = sub_14001D430(v12, v7, v6, v5, a5);
  }
  else
  {
    *(_BYTE *)(v5 + 48) = 1;
    *(_DWORD *)(v5 + 44) = 9;
    *(_BYTE *)(v5 + 56) = 1;
    *(_DWORD *)(v5 + 52) = 0;
  }
  sub_14001831C(v7);
  return v11;
}
// 140040D70: using guessed type int dword_140040D70;

//----- (000000014001D430) ----------------------------------------------------
signed __int64 __usercall sub_14001D430@<rax>(unsigned __int16 *a1@<rdx>, signed int a2@<ecx>, unsigned int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  int v5; // edi
  __int64 v6; // r14
  unsigned int v7; // er15
  __int64 v8; // rbx
  unsigned __int16 *v9; // rsi
  __int64 v11; // rax
  signed __int64 v12; // r12
  signed __int64 v13; // r13
  __int64 v14; // rcx
  unsigned __int16 *v15; // r12
  unsigned __int16 *v16; // r15
  DWORD v17; // er14
  __int64 v18; // rax
  __int64 v19; // xmm0_8
  __int64 v20; // rcx
  void *v21; // rcx
  char v22; // [rsp+30h] [rbp-48h]
  unsigned __int16 v23; // [rsp+30h] [rbp-48h]
  DWORD NumberOfBytesWritten[2]; // [rsp+38h] [rbp-40h]
  int v25; // [rsp+40h] [rbp-38h]
  __int64 v26; // [rsp+48h] [rbp-30h]
  DWORD Mode; // [rsp+58h] [rbp-20h]
  __int64 v28; // [rsp+60h] [rbp-18h]

  v5 = 0;
  v6 = a3;
  v7 = a2;
  v8 = a4;
  v9 = a1;
  if ( !a3 )
    return 0i64;
  if ( !a1
    || (v11 = a2 & 0x3F,
        v12 = (signed __int64)a2 >> 6,
        v28 = (signed __int64)a2 >> 6,
        v13 = 9 * v11,
        v14 = qword_140040970[v12],
        v22 = *(_BYTE *)(v14 + 72 * v11 + 57),
        (unsigned __int8)(v22 - 1) <= 1u)
    && !(~(_BYTE)a3 & 1) )
  {
    *(_BYTE *)(a4 + 56) = 1;
    *(_DWORD *)(a4 + 52) = 0;
    *(_BYTE *)(a4 + 48) = 1;
    *(_DWORD *)(a4 + 44) = 22;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)a4);
    return 0xFFFFFFFFi64;
  }
  if ( *(_BYTE *)(v14 + 72 * v11 + 56) & 0x20 )
    sub_14001C7F0(v7, 0i64, 2i64);
  v26 = 0i64;
  if ( (unsigned int)sub_140023E9C(v7, a5) && *(_BYTE *)(qword_140040970[v12] + 8 * v13 + 56) < 0 )
  {
    if ( !*(_BYTE *)(v8 + 40) )
      sub_140014910((signed __int64 *)v8, a5);
    if ( (*(_QWORD *)(*(_QWORD *)(v8 + 24) + 312i64) || *(_BYTE *)(qword_140040970[v12] + 8 * v13 + 57))
      && GetConsoleMode(*(HANDLE *)(qword_140040970[v12] + 8 * v13 + 40), &Mode) )
    {
      if ( v22 )
      {
        if ( v22 != 1 && v22 != 2 )
          goto LABEL_43;
        v15 = (unsigned __int16 *)((char *)v9 + v6);
        *(_QWORD *)NumberOfBytesWritten = 0i64;
        v16 = v9;
        if ( v9 < (unsigned __int16 *)((char *)v9 + v6) )
        {
          v17 = NumberOfBytesWritten[1];
          while ( 1 )
          {
            v23 = *v16;
            if ( (unsigned __int16)sub_140023F68(*v16) != v23 )
              break;
            v17 += 2;
            NumberOfBytesWritten[1] = v17;
            if ( v23 == 10 )
            {
              if ( (unsigned __int16)sub_140023F68(0xDu) != 13 )
                break;
              NumberOfBytesWritten[1] = ++v17;
              ++v5;
            }
            ++v16;
            if ( v16 >= v15 )
              goto LABEL_28;
          }
          NumberOfBytesWritten[0] = GetLastError();
        }
LABEL_28:
        v12 = v28;
        goto LABEL_41;
      }
      v18 = sub_14001CA70(v7, (__int64)NumberOfBytesWritten, (unsigned __int64)v9, v6, a5);
LABEL_30:
      v19 = *(_QWORD *)v18;
      v5 = *(_DWORD *)(v18 + 8);
LABEL_42:
      v26 = v19;
      goto LABEL_43;
    }
  }
  v20 = qword_140040970[v12];
  if ( *(_BYTE *)(v20 + 8 * v13 + 56) >= 0 )
  {
    v21 = *(void **)(v20 + 8 * v13 + 40);
    *(_QWORD *)NumberOfBytesWritten = 0i64;
    v25 = 0;
    if ( !WriteFile(v21, v9, v6, &NumberOfBytesWritten[1], 0i64) )
      NumberOfBytesWritten[0] = GetLastError();
    v5 = v25;
LABEL_41:
    v19 = *(_QWORD *)NumberOfBytesWritten;
    goto LABEL_42;
  }
  switch ( v22 )
  {
    case 0:
      v18 = (__int64)sub_14001CEE8(NumberOfBytesWritten, v7, (char *)v9, v6);
      goto LABEL_30;
    case 1:
      v18 = (__int64)sub_14001D108(NumberOfBytesWritten, v7, (__int16 *)v9, v6);
      goto LABEL_30;
    case 2:
      v18 = (__int64)sub_14001CFEC(NumberOfBytesWritten, v7, (__int16 *)v9, v6);
      goto LABEL_30;
  }
LABEL_43:
  if ( HIDWORD(v26) )
    return (unsigned int)(HIDWORD(v26) - v5);
  if ( (_DWORD)v26 )
  {
    if ( (_DWORD)v26 == 5 )
    {
      *(_BYTE *)(v8 + 48) = 1;
      *(_DWORD *)(v8 + 44) = 9;
      *(_BYTE *)(v8 + 56) = 1;
      *(_DWORD *)(v8 + 52) = 5;
    }
    else
    {
      sub_1400152F0(v26, v8);
    }
    return 0xFFFFFFFFi64;
  }
  if ( !(*(_BYTE *)(qword_140040970[v12] + 8 * v13 + 56) & 0x40) || *(_BYTE *)v9 != 26 )
  {
    *(_DWORD *)(v8 + 52) = 0;
    *(_BYTE *)(v8 + 48) = 1;
    *(_DWORD *)(v8 + 44) = 28;
    *(_BYTE *)(v8 + 56) = 1;
    return 0xFFFFFFFFi64;
  }
  return 0i64;
}
// 14001C7F0: using guessed type __int64 __fastcall sub_14001C7F0(_QWORD, _QWORD, _QWORD);

//----- (000000014001D738) ----------------------------------------------------
bool __usercall sub_14001D738@<al>(__int64 a1@<rdx>, char a2@<cl>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  __int64 v4; // rsi
  __int64 v5; // rbx
  int v6; // eax
  int v7; // ebp
  unsigned __int16 *v8; // rdx
  signed int v9; // edi
  bool v10; // zf
  _BYTE *v11; // rdx
  unsigned __int16 v13[4]; // [rsp+30h] [rbp+8h]

  LOBYTE(v13[0]) = a2;
  v4 = a3;
  v5 = a1;
  v6 = sub_14001A924(a1, a4);
  if ( !(*(_DWORD *)(v5 + 20) & 0xC0) )
    return (unsigned int)sub_14001D310(v13, v6, 1u, v4, a4) == 1;
  v7 = 0;
  v8 = *(unsigned __int16 **)(v5 + 8);
  v9 = *(_DWORD *)v5 - *(_DWORD *)(v5 + 8);
  *(_QWORD *)v5 = (char *)v8 + 1;
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v5 + 32) - 1;
  if ( v9 <= 0 )
  {
    if ( (unsigned int)(v6 + 2) <= 1 )
      v11 = &unk_14003E3E0;
    else
      v11 = (_BYTE *)(qword_140040970[(signed __int64)v6 >> 6] + 72i64 * (v6 & 0x3F));
    if ( v11[56] & 0x20 && sub_14001C6B0(0i64, v6, 2u, a4) == -1 )
    {
      _InterlockedOr((volatile signed __int32 *)(v5 + 20), 0x10u);
      return 1;
    }
  }
  else
  {
    v7 = sub_14001D310(v8, v6, v9, v4, a4);
  }
  v10 = v7 == v9;
  **(_BYTE **)(v5 + 8) = v13[0];
  return v10;
}

//----- (000000014001D830) ----------------------------------------------------
bool __usercall sub_14001D830@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  void *v3; // rax
  void *v4; // rbx
  LARGE_INTEGER FileSize; // [rsp+30h] [rbp+8h]
  LARGE_INTEGER NewFilePointer; // [rsp+38h] [rbp+10h]

  if ( (*(_DWORD *)(a1 + 20) >> 3) & 1 )
    return 1;
  if ( !(*(_DWORD *)(a1 + 20) & 0xC0) || *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) )
  {
    v3 = (void *)sub_140018540(*(unsigned int *)(a1 + 24), a2);
    v4 = v3;
    if ( v3 != (void *)-1i64 && SetFilePointerEx(v3, 0i64, &NewFilePointer, 1u) && GetFileSizeEx(v4, &FileSize) )
      return NewFilePointer.QuadPart == FileSize.QuadPart;
  }
  return 0;
}

//----- (000000014001D8AC) ----------------------------------------------------
signed __int64 __usercall sub_14001D8AC@<rax>(__int64 a1@<rdx>, unsigned __int8 a2@<cl>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  unsigned __int8 v4; // si
  __int64 v5; // rdi
  __int64 v6; // rbx
  bool v8; // al

  v4 = a2;
  v5 = a3;
  v6 = a1;
  sub_14001A924(a1, a4);
  if ( !(*(_DWORD *)(v6 + 20) & 6) )
  {
    *(_DWORD *)(v5 + 44) = 9;
LABEL_3:
    *(_BYTE *)(v5 + 48) = 1;
LABEL_4:
    _InterlockedOr((volatile signed __int32 *)(v6 + 20), 0x10u);
    return 0xFFFFFFFFi64;
  }
  if ( (*(_DWORD *)(v6 + 20) >> 12) & 1 )
  {
    *(_DWORD *)(v5 + 44) = 34;
    goto LABEL_3;
  }
  if ( *(_DWORD *)(v6 + 20) & 1 )
  {
    v8 = sub_14001D830(v6, a4);
    *(_DWORD *)(v6 + 16) = 0;
    if ( !v8 )
      goto LABEL_4;
    *(_QWORD *)v6 = *(_QWORD *)(v6 + 8);
    _InterlockedAnd((volatile signed __int32 *)(v6 + 20), 0xFFFFFFFE);
  }
  _InterlockedOr((volatile signed __int32 *)(v6 + 20), 2u);
  _InterlockedAnd((volatile signed __int32 *)(v6 + 20), 0xFFFFFFF7);
  *(_DWORD *)(v6 + 16) = 0;
  if ( !(*(_DWORD *)(v6 + 20) & 0x4C0) && !sub_14001D978((char *)v6, a4) )
    sub_140023EFC(v6);
  if ( !sub_14001D738(v6, v4, v5, a4) )
    goto LABEL_4;
  return v4;
}

//----- (000000014001D978) ----------------------------------------------------
bool __usercall sub_14001D978@<al>(char *a1@<rcx>, __m256i *a2@<ymm0>)
{
  char *v2; // rbx
  signed int v3; // eax

  v2 = a1;
  if ( a1 == sub_140015160(2u) )
    return 1;
  if ( v2 != sub_140015160(1u) )
    return 0;
  v3 = sub_14001A924((__int64)v2, a2);
  return (unsigned int)sub_140023E9C(v3, a2) != 0;
}

//----- (000000014001D9C4) ----------------------------------------------------
char __usercall sub_14001D9C4@<al>(char *a1@<rcx>, __m256i *a2@<ymm0>)
{
  char *v2; // rbx
  LPVOID *v3; // rdi

  v2 = a1;
  if ( !sub_14001D978(a1, a2) )
    return 0;
  if ( v2 == sub_140015160(1u) )
  {
    v3 = &qword_140040D78;
  }
  else
  {
    if ( v2 != sub_140015160(2u) )
      return 0;
    v3 = &qword_140040D80;
  }
  ++dword_1400406D0;
  if ( *((_DWORD *)v2 + 5) & 0x4C0 )
    return 0;
  _InterlockedOr((volatile signed __int32 *)v2 + 5, 0x282u);
  if ( !*v3 )
  {
    *v3 = sub_14001DACC(0x1000ui64);
    sub_14001AE1C(0i64);
  }
  if ( *v3 )
  {
    *((_QWORD *)v2 + 1) = *v3;
    *(_QWORD *)v2 = *v3;
    *((_DWORD *)v2 + 4) = 4096;
    *((_DWORD *)v2 + 8) = 4096;
  }
  else
  {
    *((_DWORD *)v2 + 4) = 2;
    *((_QWORD *)v2 + 1) = v2 + 28;
    *(_QWORD *)v2 = v2 + 28;
    *((_DWORD *)v2 + 8) = 2;
  }
  return 1;
}
// 1400406D0: using guessed type int dword_1400406D0;

//----- (000000014001DA8C) ----------------------------------------------------
signed __int64 __usercall sub_14001DA8C@<rax>(__int64 a1@<rdx>, char a2@<cl>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  __int64 v4; // rbx
  signed __int64 result; // rax

  if ( a2 )
  {
    v4 = a1;
    result = (unsigned int)(*(_DWORD *)(a1 + 20) >> 9);
    if ( result & 1 )
    {
      result = sub_140017568(a3, a1, a4);
      _InterlockedAnd((volatile signed __int32 *)(v4 + 20), 0xFFFFFD7F);
      *(_DWORD *)(v4 + 32) = 0;
      *(_QWORD *)(v4 + 8) = 0i64;
      *(_QWORD *)v4 = 0i64;
    }
  }
  return result;
}

//----- (000000014001DACC) ----------------------------------------------------
LPVOID __fastcall sub_14001DACC(unsigned __int64 a1)
{
  SIZE_T v1; // rbx
  LPVOID result; // rax

  v1 = a1;
  if ( a1 > 0xFFFFFFFFFFFFFFE0ui64 )
  {
LABEL_9:
    *(_DWORD *)sub_140015334() = 12;
    result = 0i64;
  }
  else
  {
    if ( !a1 )
      v1 = 1i64;
    while ( 1 )
    {
      result = HeapAlloc(hHeap, 0, v1);
      if ( result )
        break;
      if ( !(unsigned int)sub_14001A28C() || !(unsigned int)sub_140023B10(v1) )
        goto LABEL_9;
    }
  }
  return result;
}

//----- (000000014001DB2C) ----------------------------------------------------
char *__usercall sub_14001DB2C@<rax>(unsigned __int64 a1@<rdx>, __m128i *a2@<rcx>, __int128 _XMM1@<xmm1>, __m256i _YMM1@<ymm1>)
{
  __m128i *v4; // r9
  unsigned __int64 v5; // r10
  __m128i *v6; // rax
  __m128i *v7; // rcx
  _BYTE *v8; // rcx
  unsigned __int64 v9; // r8
  unsigned __int64 v11; // r10
  __m128i *v12; // rax
  __m128i *v13; // rcx
  unsigned __int64 v14; // r8
  __m128i *i; // rax

  v4 = a2;
  if ( dword_14003E028 < 5 )
  {
    if ( dword_14003E028 < 1 )
    {
      for ( i = (__m128i *)((char *)a2 + a1); a2 != i; a2 = (__m128i *)((char *)a2 + 1) )
      {
        if ( !LOBYTE(a2->m128i_i64[0]) )
          break;
      }
      return (char *)((char *)a2 - (char *)v4);
    }
    v11 = (16i64 - ((unsigned __int8)a2 & 0xF)) & -(signed __int64)(((unsigned __int8)a2 & 0xF) != 0i64);
    v12 = a2;
    if ( a1 < v11 )
      v11 = a1;
    v13 = (__m128i *)((char *)a2 + v11);
    if ( v4 != (__m128i *)&v4->m128i_i8[v11] )
    {
      do
      {
        if ( !LOBYTE(v12->m128i_i64[0]) )
          break;
        v12 = (__m128i *)((char *)v12 + 1);
      }
      while ( v12 != v13 );
    }
    v8 = (_BYTE *)((char *)v12 - (char *)v4);
    if ( (char *)v12 - (char *)v4 == v11 )
    {
      a2 = v12;
      v14 = (unsigned __int64)v12->m128i_u64 + ((a1 - v11) & 0xFFFFFFFFFFFFFFF0ui64);
      if ( v12 != (__m128i *)v14 )
      {
        do
        {
          if ( _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0i64, *a2)) )
            break;
          ++a2;
        }
        while ( a2 != (__m128i *)v14 );
      }
      while ( a2 != (__m128i *)&v4->m128i_i8[a1] && LOBYTE(a2->m128i_i64[0]) )
        a2 = (__m128i *)((char *)a2 + 1);
      return (char *)((char *)a2 - (char *)v4);
    }
  }
  else
  {
    v5 = (32i64 - ((unsigned __int8)a2 & 0x1F)) & -(signed __int64)(((unsigned __int8)a2 & 0x1F) != 0i64);
    v6 = a2;
    if ( a1 < v5 )
      v5 = a1;
    v7 = (__m128i *)((char *)a2 + v5);
    if ( v4 != v7 )
    {
      do
      {
        if ( !LOBYTE(v6->m128i_i64[0]) )
          break;
        v6 = (__m128i *)((char *)v6 + 1);
      }
      while ( v6 != v7 );
    }
    v8 = (_BYTE *)((char *)v6 - (char *)v4);
    if ( (char *)v6 - (char *)v4 == v5 )
    {
      a2 = v6;
      v9 = (unsigned __int64)v6->m128i_u64 + ((a1 - v5) & 0xFFFFFFFFFFFFFFE0ui64);
      if ( v6 != (__m128i *)v9 )
      {
        do
        {
          __asm
          {
            vpxor   xmm1, xmm1, xmm1
            vpcmpeqb ymm1, ymm1, ymmword ptr [rcx]
            vpmovmskb eax, ymm1
            vzeroupper
          }
          if ( _EAX )
            break;
          a2 += 2;
        }
        while ( a2 != (__m128i *)v9 );
      }
      while ( a2 != (__m128i *)&v4->m128i_i8[a1] && LOBYTE(a2->m128i_i64[0]) )
        a2 = (__m128i *)((char *)a2 + 1);
      return (char *)((char *)a2 - (char *)v4);
    }
  }
  return v8;
}
// 14003E028: using guessed type int dword_14003E028;

//----- (000000014001DC7C) ----------------------------------------------------
signed __int64 __usercall sub_14001DC7C@<rax>(unsigned __int64 a1@<rdx>, __m128i *a2@<rcx>, __int128 _XMM1@<xmm1>, __m256i _YMM1@<ymm1>)
{
  unsigned __int64 v4; // r10
  signed __int64 v5; // rax
  __m128i *i; // rdx
  __m128i *v7; // rdx
  unsigned __int64 v8; // r11
  signed __int64 v9; // rax
  signed __int64 v10; // rdx
  __m128i *v11; // r9
  unsigned __int64 j; // rdx
  signed __int64 v14; // rax
  __m128i *v15; // rdx
  unsigned __int64 v16; // r11
  signed __int64 v17; // rax
  unsigned __int64 v18; // rdx
  signed __int64 v19; // rax

  v4 = a1;
  if ( dword_14003E028 < 5 )
  {
    if ( dword_14003E028 < 1 )
    {
      v19 = (signed __int64)a2->m128i_i64 + 2 * a1;
      for ( i = a2; i != (__m128i *)v19; i = (__m128i *)((char *)i + 2) )
      {
        if ( !LOWORD(i->m128i_i64[0]) )
          break;
      }
      return ((char *)i - (char *)a2) >> 1;
    }
    if ( (unsigned __int8)a2 & 1 )
    {
      v14 = (signed __int64)a2->m128i_i64 + 2 * a1;
      for ( i = a2; i != (__m128i *)v14; i = (__m128i *)((char *)i + 2) )
      {
        if ( !LOWORD(i->m128i_i64[0]) )
          break;
      }
      return ((char *)i - (char *)a2) >> 1;
    }
    v15 = a2;
    v16 = ((16i64 - ((unsigned __int8)a2 & 0xF)) & (unsigned __int64)-(signed __int64)(((unsigned __int8)a2 & 0xF) != 0i64)) >> 1;
    if ( v4 < v16 )
      v16 = v4;
    v17 = (signed __int64)a2->m128i_i64 + 2 * v16;
    if ( a2 != (__m128i *)v17 )
    {
      do
      {
        if ( !LOWORD(v15->m128i_i64[0]) )
          break;
        v15 = (__m128i *)((char *)v15 + 2);
      }
      while ( v15 != (__m128i *)v17 );
    }
    v10 = ((char *)v15 - (char *)a2) >> 1;
    if ( v10 == v16 )
    {
      v11 = (__m128i *)((char *)a2 + 2 * v10);
      v18 = (unsigned __int64)a2 + 2 * (v10 + ((v4 - v16) & 0xFFFFFFFFFFFFFFF0ui64));
      while ( v11 != (__m128i *)v18 && !_mm_movemask_epi8(_mm_cmpeq_epi16((__m128i)0i64, *v11)) )
        ++v11;
      while ( v11 != (__m128i *)((char *)a2 + 2 * v4) && LOWORD(v11->m128i_i64[0]) )
        v11 = (__m128i *)((char *)v11 + 2);
LABEL_20:
      i = v11;
      return ((char *)i - (char *)a2) >> 1;
    }
  }
  else
  {
    if ( (unsigned __int8)a2 & 1 )
    {
      v5 = (signed __int64)a2->m128i_i64 + 2 * a1;
      for ( i = a2; i != (__m128i *)v5; i = (__m128i *)((char *)i + 2) )
      {
        if ( !LOWORD(i->m128i_i64[0]) )
          break;
      }
      return ((char *)i - (char *)a2) >> 1;
    }
    v7 = a2;
    v8 = ((32i64 - ((unsigned __int8)a2 & 0x1F)) & (unsigned __int64)-(signed __int64)(((unsigned __int8)a2 & 0x1F) != 0i64)) >> 1;
    if ( v4 < v8 )
      v8 = v4;
    v9 = (signed __int64)a2->m128i_i64 + 2 * v8;
    if ( a2 != (__m128i *)v9 )
    {
      do
      {
        if ( !LOWORD(v7->m128i_i64[0]) )
          break;
        v7 = (__m128i *)((char *)v7 + 2);
      }
      while ( v7 != (__m128i *)v9 );
    }
    v10 = ((char *)v7 - (char *)a2) >> 1;
    if ( v10 == v8 )
    {
      v11 = (__m128i *)((char *)a2 + 2 * v10);
      for ( j = (unsigned __int64)a2 + 2 * (v10 + ((v4 - v8) & 0xFFFFFFFFFFFFFFE0ui64)); v11 != (__m128i *)j; v11 += 2 )
      {
        __asm
        {
          vpxor   xmm1, xmm1, xmm1
          vpcmpeqw ymm1, ymm1, ymmword ptr [r9]
          vpmovmskb eax, ymm1
          vzeroupper
        }
        if ( _EAX )
          break;
      }
      while ( v11 != (__m128i *)((char *)a2 + 2 * v4) && LOWORD(v11->m128i_i64[0]) )
        v11 = (__m128i *)((char *)v11 + 2);
      goto LABEL_20;
    }
  }
  return v10;
}
// 14003E028: using guessed type int dword_14003E028;

//----- (000000014001DE54) ----------------------------------------------------
__int64 __usercall sub_14001DE54@<rax>(__int64 *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 result; // rax
  __int64 *v4; // rbx

  result = qword_140040968[0];
  v4 = a1;
  if ( *a1 != qword_140040968[0] )
  {
    result = *(unsigned int *)(a2 + 936);
    if ( !((unsigned int)result & dword_14003EA20) )
    {
      result = sub_140023884(a3);
      *v4 = result;
    }
  }
  return result;
}
// 14003EA20: using guessed type int dword_14003EA20;
// 140040968: using guessed type __int64 qword_140040968[];

//----- (000000014001DE88) ----------------------------------------------------
__int64 __usercall sub_14001DE88@<rax>(__int64 *a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  __int64 *v4; // rbx
  __int64 result; // rax

  v4 = a1;
  result = qword_140040968[a3];
  if ( *a1 != result )
  {
    result = *(unsigned int *)(a2 + 936);
    if ( !((unsigned int)result & dword_14003EA20) )
    {
      result = sub_140023884(a4);
      *v4 = result;
    }
  }
  return result;
}
// 14003EA20: using guessed type int dword_14003EA20;
// 140040968: using guessed type __int64 qword_140040968[];

//----- (000000014001DEC0) ----------------------------------------------------
volatile signed __int32 *__usercall sub_14001DEC0@<rax>(LPVOID *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  volatile signed __int32 *result; // rax
  LPVOID *v4; // rbx

  result = (volatile signed __int32 *)qword_140041198;
  v4 = a1;
  if ( *a1 != qword_140041198 )
  {
    result = (volatile signed __int32 *)*(unsigned int *)(a2 + 936);
    if ( !((unsigned int)result & dword_14003EA20) )
    {
      result = sub_140022BD0(a3);
      *v4 = (LPVOID)result;
    }
  }
  return result;
}
// 14003EA20: using guessed type int dword_14003EA20;

//----- (000000014001DEF4) ----------------------------------------------------
volatile signed __int32 *__usercall sub_14001DEF4@<rax>(_QWORD *a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  _QWORD *v4; // rbx
  volatile signed __int32 *result; // rax

  v4 = a1;
  result = (volatile signed __int32 *)*(&qword_140041198 + a3);
  if ( (volatile signed __int32 *)*a1 != result )
  {
    result = (volatile signed __int32 *)*(unsigned int *)(a2 + 936);
    if ( !((unsigned int)result & dword_14003EA20) )
    {
      result = sub_140022BD0(a4);
      *v4 = result;
    }
  }
  return result;
}
// 14003EA20: using guessed type int dword_14003EA20;

//----- (000000014001DF2C) ----------------------------------------------------
__int64 __usercall sub_14001DF2C@<rax>(signed __int64 a1@<rdx>, unsigned __int64 *a2@<rcx>, unsigned __int64 a3@<r8>, _BYTE *a4@<r9>, __m256i *a5@<ymm0>, __int64 a6, int a7, char a8, int a9, int a10, __int64 a11)
{
  int v11; // edi
  __m128i *v12; // rbx
  unsigned __int64 *v13; // r14
  __int64 result; // rax
  __m128i *v15; // rax
  char *v16; // r12
  signed __int64 v17; // r15
  int v18; // ebp
  _BYTE *v19; // rsi
  char v20; // al
  unsigned __int64 v21; // r10
  unsigned __int16 v22; // ax
  char *i; // rcx
  char v24; // dl
  _BYTE *v25; // r9
  signed __int64 v26; // rcx
  signed __int64 v27; // rdx
  char v28; // al
  _BYTE *v29; // r8
  unsigned __int64 v30; // rdx
  unsigned __int64 v31; // rdx
  unsigned __int64 v32; // rdx

  *(_BYTE *)a1 = 0;
  v11 = 0;
  if ( a7 >= 0 )
    v11 = a7;
  v12 = (__m128i *)a1;
  v13 = a2;
  if ( a3 <= v11 + 11 )
  {
    *(_BYTE *)(a11 + 48) = 1;
    *(_DWORD *)(a11 + 44) = 34;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)a11);
    return 34i64;
  }
  if ( ((*a2 >> 52) & 0x7FF) != 2047 )
  {
    if ( (*a2 & 0x8000000000000000ui64) != 0i64 )
    {
      *(_BYTE *)a1 = 45;
      v12 = (__m128i *)(a1 + 1);
    }
    v16 = (char *)v12->m128i_i64 + 1;
    v17 = 1023i64;
    v18 = 32 * (unsigned __int8)(a8 ^ 1) + 7;
    if ( *a2 & 0x7FF0000000000000i64 )
    {
      LOBYTE(v12->m128i_i64[0]) = 49;
    }
    else
    {
      LOBYTE(v12->m128i_i64[0]) = 48;
      v17 = (*a2 & 0xFFFFFFFFFFFFFi64) != 0 ? 0x3FE : 0;
    }
    v19 = (char *)v12->m128i_i64 + 2;
    if ( v11 )
    {
      if ( !*(_BYTE *)(a11 + 40) )
        sub_140014910((signed __int64 *)a11, a5);
      v20 = ***(_BYTE ***)(*(_QWORD *)(a11 + 24) + 248i64);
    }
    else
    {
      v20 = 0;
    }
    *v16 = v20;
    if ( *v13 & 0xFFFFFFFFFFFFFi64 )
    {
      a1 = 48i64;
      v21 = 4222124650659840i64;
      while ( v11 > 0 )
      {
        v22 = ((v21 & *v13 & 0xFFFFFFFFFFFFFi64) >> a1) + 48;
        if ( v22 > 0x39u )
          LOBYTE(v22) = v18 + v22;
        *v19 = v22;
        --v11;
        ++v19;
        v21 >>= 4;
        LOWORD(a1) = a1 - 4;
        if ( (a1 & 0x8000u) != 0i64 )
          goto LABEL_36;
      }
      if ( !sub_14001E928(v13, v21, a1, a10) )
        goto LABEL_38;
      for ( i = v19 - 1; ; --i )
      {
        v24 = *i;
        if ( (*i - 70) & 0xDF )
          break;
        *i = 48;
      }
      if ( i == v16 )
      {
        ++*(i - 1);
      }
      else
      {
        if ( v24 == 57 )
          v24 = 32 * (a8 ^ 1) + 64;
        *i = v24 + 1;
      }
    }
LABEL_36:
    if ( v11 > 0 )
    {
      LOBYTE(a1) = 48;
      sub_14000D100(a1, (__int64)v19, (unsigned int)v11, a5);
      v19 += (unsigned int)v11;
    }
LABEL_38:
    if ( !*v16 )
      v19 = (char *)v12->m128i_i64 + 1;
    *v19 = 32 * (a8 ^ 1) + 80;
    v25 = v19 + 2;
    v26 = ((*v13 >> 52) & 0x7FF) - v17;
    v27 = v26;
    if ( v26 < 0 )
      v26 = v17 - ((*v13 >> 52) & 0x7FF);
    v28 = 43;
    v29 = v19 + 2;
    if ( v27 < 0 )
      v28 = 45;
    v19[1] = v28;
    *v25 = 48;
    if ( v26 >= 1000
      && (v29 = v19 + 3,
          v30 = ((unsigned __int64)((unsigned __int128)(v26 * (signed __int128)2361183241434822607i64) >> 64) >> 63)
              + ((signed __int64)((unsigned __int128)(v26 * (signed __int128)2361183241434822607i64) >> 64) >> 7),
          *v25 = v30 + 48,
          v26 += -1000i64 * v30,
          v19 + 3 != v19 + 2)
      || v26 >= 100 )
    {
      v31 = ((unsigned __int64)(v26 + ((unsigned __int128)(v26 * (signed __int128)-6640827866535438581i64) >> 64)) >> 63)
          + ((signed __int64)(v26 + ((unsigned __int128)(v26 * (signed __int128)-6640827866535438581i64) >> 64)) >> 6);
      *v29++ = v31 + 48;
      v26 += -100i64 * v31;
      if ( v29 != v25 )
        goto LABEL_54;
    }
    if ( v26 >= 10 )
    {
LABEL_54:
      v32 = ((unsigned __int64)((unsigned __int128)(v26 * (signed __int128)7378697629483820647i64) >> 64) >> 63)
          + ((signed __int64)((unsigned __int128)(v26 * (signed __int128)7378697629483820647i64) >> 64) >> 2);
      *v29++ = v32 + 48;
      v26 += -10i64 * v32;
    }
    *v29 = v26 + 48;
    v29[1] = 0;
    return 0i64;
  }
  result = sub_14001E2C4((_BYTE *)a1, a2, a3, a4, a5, a6, v11, 0, a9, a10, a11);
  if ( (_DWORD)result )
  {
    LOBYTE(v12->m128i_i64[0]) = 0;
    return result;
  }
  v15 = sub_14000D508(v12, 101);
  if ( v15 )
  {
    LOBYTE(v15->m128i_i64[0]) = 32 * (a8 ^ 1) + 80;
    BYTE3(v15->m128i_i64[0]) = 0;
  }
  return 0i64;
}

//----- (000000014001E2C4) ----------------------------------------------------
__int64 __usercall sub_14001E2C4@<rax>(_BYTE *a1@<rdx>, unsigned __int64 *a2@<rcx>, unsigned __int64 a3@<r8>, _BYTE *a4@<r9>, __m256i *a5@<ymm0>, __int64 a6, int a7, char a8, int a9, int a10, __int64 a11)
{
  unsigned __int64 v11; // rsi
  _BYTE *v12; // rdi
  int v13; // eax
  _BOOL8 v14; // r9
  _BOOL8 v15; // rcx
  unsigned __int64 v16; // rdx
  __int64 result; // rax
  __int64 v18; // [rsp+20h] [rbp-38h]
  int v19; // [rsp+40h] [rbp-18h]

  v11 = a3;
  v12 = a1;
  v13 = sub_14002462C(a7 + 1, *a2, 1, (__int64)&v19, a5, a4, a6);
  v14 = v19 == 45;
  LODWORD(v18) = v13;
  v15 = a7 > 0;
  v16 = v11 - v15 - v14;
  if ( v11 == -1i64 )
    v16 = -1i64;
  result = sub_140024074(v16, &v12[v14 + v15], a7 + 1, (__int64)&v19, a5, v18, a10, a11);
  if ( !(_DWORD)result )
    return sub_14001E3C0(v11, v12, a7, a8, a5, a9, (__int64)&v19, 0, a11);
  *v12 = 0;
  return result;
}

//----- (000000014001E3C0) ----------------------------------------------------
signed __int64 __usercall sub_14001E3C0@<rax>(unsigned __int64 a1@<rdx>, _BYTE *a2@<rcx>, int a3@<r8d>, char a4@<r9b>, __m256i *a5@<ymm0>, int a6, __int64 a7, unsigned __int8 a8, __int64 a9)
{
  int v9; // eax
  __int64 v10; // rbp
  char v11; // r13
  unsigned __int64 v12; // r15
  _BYTE *v13; // rdi
  signed __int64 result; // rax
  _BYTE *v15; // rdx
  signed __int64 v16; // r8
  _BYTE *v17; // rbx
  signed __int64 v18; // rbx
  __int64 v19; // rdx
  __m128i *v20; // rcx
  int v21; // er8

  v9 = 0;
  v10 = a3;
  v11 = a4;
  v12 = a1;
  v13 = a2;
  if ( a3 > 0 )
    v9 = a3;
  if ( a1 > v9 + 9 )
  {
    if ( a8 )
    {
      v15 = &a2[*(_DWORD *)a7 == 45];
      if ( a3 > 0 )
      {
        v16 = -1i64;
        do
          ++v16;
        while ( v15[v16] );
        sub_14000CA50((__m128i *)(v15 + 1), (const __m128i *)v15, v16 + 1);
      }
    }
    v17 = v13;
    if ( *(_DWORD *)a7 == 45 )
    {
      *v13 = 45;
      v17 = v13 + 1;
    }
    if ( (signed int)v10 > 0 )
    {
      *v17 = v17[1];
      ++v17;
      if ( !*(_BYTE *)(a9 + 40) )
        sub_140014910((signed __int64 *)a9, a5);
      *v17 = ***(_BYTE ***)(*(_QWORD *)(a9 + 24) + 248i64);
    }
    v18 = (signed __int64)&v17[v10 + (a8 ^ 1i64)];
    v19 = (__int64)&v13[v12 - v18];
    if ( v12 == -1i64 )
      v19 = -1i64;
    if ( (unsigned int)sub_14001A94C(v19, (_BYTE *)v18, (__int64)"e+000", a5) )
    {
      sub_14001ADD4(a5);
      JUMPOUT(*(_QWORD *)&byte_14001E5A0);
    }
    v20 = (__m128i *)(v18 + 2);
    if ( v11 )
      *(_BYTE *)v18 = 69;
    if ( **(_BYTE **)(a7 + 8) != 48 )
    {
      v21 = *(_DWORD *)(a7 + 4) - 1;
      if ( v21 < 0 )
      {
        v21 = 1 - *(_DWORD *)(a7 + 4);
        *(_BYTE *)(v18 + 1) = 45;
      }
      if ( v21 >= 100 )
      {
        *(_BYTE *)(v18 + 2) += v21 / 100;
        v21 %= 100;
      }
      if ( v21 >= 10 )
      {
        *(_BYTE *)(v18 + 3) += v21 / 10;
        v21 %= 10;
      }
      *(_BYTE *)(v18 + 4) += v21;
    }
    if ( a6 == 2 && LOBYTE(v20->m128i_i64[0]) == 48 )
      sub_14000CA50(v20, (const __m128i *)(v18 + 3), 3ui64);
    result = 0i64;
  }
  else
  {
    *(_BYTE *)(a9 + 48) = 1;
    *(_DWORD *)(a9 + 44) = 34;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)a9);
    result = 34i64;
  }
  return result;
}
// 14001E5A0: using guessed type char;

//----- (000000014001E5A4) ----------------------------------------------------
__int64 __usercall sub_14001E5A4@<rax>(_BYTE *a1@<rdx>, unsigned __int64 *a2@<rcx>, __int64 a3@<r8>, _BYTE *a4@<r9>, __m256i *a5@<ymm0>, __int64 a6, __int64 a7, int a8, __int64 a9)
{
  __int64 v9; // rdi
  _BYTE *v10; // rbx
  unsigned __int64 v11; // rcx
  int v12; // eax
  _BOOL8 v13; // r9
  unsigned __int64 v14; // rdx
  __int64 result; // rax
  __int64 v16; // [rsp+20h] [rbp-38h]
  __int128 v17; // [rsp+40h] [rbp-18h]

  v9 = a3;
  v10 = a1;
  v11 = *a2;
  v17 = 0i64;
  v12 = sub_14002462C(a7, v11, 0, (__int64)&v17, a5, a4, a6);
  v13 = (_DWORD)v17 == 45;
  v14 = v9 - v13;
  LODWORD(v16) = v12;
  if ( v9 == -1 )
    v14 = -1i64;
  result = sub_140024074(v14, &v10[v13], (signed int)a7 + DWORD1(v17), (__int64)&v17, a5, v16, a8, a9);
  if ( !(_DWORD)result )
    return sub_14001E67C(v10, a7, (__int64)&v17, a5, 0, a9);
  *v10 = 0;
  return result;
}

//----- (000000014001E67C) ----------------------------------------------------
__int64 __usercall sub_14001E67C@<rax>(_BYTE *a1@<rcx>, int a2@<r8d>, __int64 a3@<r9>, __m256i *a4@<ymm0>, char a5, __int64 a6)
{
  _BYTE *v6; // rbx
  __int64 v7; // rcx
  __int64 v8; // r14
  int v9; // ebp
  __int64 v10; // rax
  signed __int64 v11; // rdi
  bool v12; // al
  signed __int64 v13; // rsi
  signed __int64 v14; // r8
  _BYTE *v15; // rbx
  const __m128i *v16; // rsi
  signed __int64 v17; // r8
  int v18; // eax
  int v19; // eax

  v6 = a1;
  v7 = *(signed int *)(a3 + 4);
  v8 = a3;
  v9 = a2;
  if ( a5 && (_DWORD)v7 - 1 == a2 )
    *(_WORD *)&v6[(*(_DWORD *)a3 == 45) - 1 + v7] = 48;
  if ( *(_DWORD *)a3 == 45 )
    *v6++ = 45;
  v10 = *(signed int *)(a3 + 4);
  v11 = -1i64;
  if ( (signed int)v10 > 0 )
  {
    v15 = &v6[v10];
  }
  else
  {
    v12 = !(_DWORD)v10 && **(_BYTE **)(a3 + 8) == 48;
    if ( a5 && v12 )
    {
      v13 = (signed __int64)(v6 + 1);
    }
    else
    {
      v13 = (signed __int64)(v6 + 1);
      v14 = -1i64;
      do
        ++v14;
      while ( v6[v14] );
      sub_14000CA50((__m128i *)(v6 + 1), (const __m128i *)v6, v14 + 1);
    }
    *v6 = 48;
    v15 = (_BYTE *)v13;
  }
  if ( v9 > 0 )
  {
    v16 = (const __m128i *)(v15 + 1);
    v17 = -1i64;
    do
      ++v17;
    while ( v15[v17] );
    sub_14000CA50((__m128i *)(v15 + 1), (const __m128i *)v15, v17 + 1);
    if ( !*(_BYTE *)(a6 + 40) )
      sub_140014910((signed __int64 *)a6, a4);
    *v15 = ***(_BYTE ***)(*(_QWORD *)(a6 + 24) + 248i64);
    v18 = *(_DWORD *)(v8 + 4);
    if ( v18 < 0 )
    {
      v19 = -v18;
      if ( a5 || v19 < v9 )
        v9 = v19;
      do
        ++v11;
      while ( *((_BYTE *)v16->m128i_i64 + v11) );
      sub_14000CA50((__m128i *)((char *)v16 + v9), v16, v11 + 1);
      sub_14000D100(48i64, (__int64)v16, v9, a4);
    }
  }
  return 0i64;
}

//----- (000000014001E7D4) ----------------------------------------------------
__int64 __usercall sub_14001E7D4@<rax>(_BYTE *a1@<rdx>, unsigned __int64 *a2@<rcx>, unsigned __int64 a3@<r8>, _BYTE *a4@<r9>, __m256i *a5@<ymm0>, __int64 a6, int a7, char a8, int a9, int a10, __int64 a11)
{
  unsigned __int64 v11; // rbp
  unsigned __int64 v12; // rcx
  _BYTE *v13; // rdi
  int v14; // eax
  _BOOL8 v15; // r8
  unsigned __int64 v16; // rdx
  int v17; // er15
  char *v18; // rbx
  __int64 result; // rax
  int v20; // eax
  char v21; // al
  __int64 v22; // [rsp+20h] [rbp-38h]
  __int128 v23; // [rsp+40h] [rbp-18h]

  v11 = a3;
  v12 = *a2;
  v13 = a1;
  v23 = 0i64;
  v14 = sub_14002462C(a7, v12, 0, (__int64)&v23, a5, a4, a6);
  v15 = (_DWORD)v23 == 45;
  v16 = v11 - v15;
  v17 = DWORD1(v23) - 1;
  LODWORD(v22) = v14;
  v18 = &v13[v15];
  if ( v11 == -1i64 )
    v16 = -1i64;
  result = sub_140024074(v16, v18, a7, (__int64)&v23, a5, v22, a10, a11);
  if ( (_DWORD)result )
  {
    *v13 = 0;
  }
  else
  {
    v20 = DWORD1(v23) - 1;
    if ( DWORD1(v23) - 1 < -4 || v20 >= a7 )
    {
      result = sub_14001E3C0(v11, v13, a7, a8, a5, a9, (__int64)&v23, 1u, a11);
    }
    else
    {
      if ( v17 < v20 )
      {
        do
          v21 = *v18++;
        while ( v21 );
        *(v18 - 2) = 0;
      }
      result = sub_14001E67C(v13, a7, (__int64)&v23, a5, 1, a11);
    }
  }
  return result;
}

//----- (000000014001E928) ----------------------------------------------------
bool __fastcall sub_14001E928(unsigned __int64 *a1, __int64 a2, __int16 a3, int a4)
{
  int v4; // er14
  unsigned __int64 *v5; // rdi
  unsigned __int64 v6; // rbx
  __int64 v7; // rbp
  int v9; // eax
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rax
  char v12; // dl

  v4 = a3;
  v5 = a1;
  v6 = (a2 & *a1 & 0xFFFFFFFFFFFFFi64) >> a3;
  v7 = a2;
  if ( !a4 )
    return (unsigned __int16)v6 >= 8u;
  v9 = sub_140025944();
  switch ( v9 )
  {
    case 0:
      v10 = *v5;
      v11 = (v7 & *v5 & 0xFFFFFFFFFFFFFi64) >> v4;
      if ( (unsigned __int16)v11 > 8u )
        return 1;
      if ( (unsigned __int16)v11 >= 8u )
      {
        v12 = 1;
        if ( !(v10 & ((1i64 << v4) - 1) & 0xFFFFFFFFFFFFFi64) )
        {
          if ( v4 == 48 )
            LOBYTE(v10) = (v10 & 0x7FF0000000000000i64) != 0;
          else
            v10 = (v7 & (v10 >> 4) & 0xFFFFFFFFFFFFi64) >> v4;
          v12 = v10 & 1;
        }
        return v12;
      }
      return 0;
    case 512:
      if ( (_WORD)v6 && (*v5 & 0x8000000000000000ui64) == 0i64 )
        return 1;
      return 0;
    case 256:
      if ( (_WORD)v6 && (*v5 & 0x8000000000000000ui64) != 0i64 )
        return 1;
      return 0;
  }
  return 0;
}

//----- (000000014001EA40) ----------------------------------------------------
signed __int64 __usercall sub_14001EA40@<rax>(_BYTE *a1@<rdx>, unsigned __int64 *a2@<rcx>, unsigned __int64 a3@<r8>, _BYTE *a4@<r9>, __m256i *a5@<ymm0>, __int64 a6, __int64 a7, int a8, unsigned __int64 a9, __int64 a10, __int64 a11)
{
  unsigned __int64 v11; // r11
  _BYTE *v12; // r10
  bool v14; // si
  unsigned __int64 v15; // rdx
  unsigned int v16; // er8
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // r8
  int v20; // edx
  int v21; // ebx
  __int64 v22; // [rsp+28h] [rbp-30h]

  v11 = a3;
  v12 = a1;
  if ( !a1 )
  {
    *(_BYTE *)(a11 + 48) = 1;
    *(_DWORD *)(a11 + 44) = 22;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)a11);
    return 22i64;
  }
  if ( !a3 || !a4 || !a6 )
  {
    *(_BYTE *)(a11 + 48) = 1;
    *(_DWORD *)(a11 + 44) = 22;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)a11);
    return 22i64;
  }
  v14 = (_DWORD)a7 == 65 || (unsigned int)(a7 - 69) <= 2;
  if ( a9 & 8 || (v15 = *a2, ((*a2 >> 52) & 0x7FF) != 2047) )
  {
    v20 = (a9 >> 4) & 1 | 2;
    v21 = (a9 & 0x20) != 0 ? a10 : 0;
    if ( (_DWORD)a7 != 65 )
    {
      switch ( (_DWORD)a7 )
      {
        case 0x45:
          return sub_14001E2C4(v12, a2, a3, a4, a5, a6, a8, v14, v20, v21, a11);
        case 0x46:
          goto LABEL_37;
        case 0x47:
          return sub_14001E7D4(v12, a2, a3, a4, a5, a6, a8, v14, v20, v21, a11);
      }
      if ( (_DWORD)a7 != 97 )
      {
        if ( (_DWORD)a7 != 101 )
        {
          if ( (_DWORD)a7 != 102 )
            return sub_14001E7D4(v12, a2, a3, a4, a5, a6, a8, v14, v20, v21, a11);
LABEL_37:
          LODWORD(v22) = a8;
          return sub_14001E5A4(v12, a2, a3, a4, a5, a6, v22, v21, a11);
        }
        return sub_14001E2C4(v12, a2, a3, a4, a5, a6, a8, v14, v20, v21, a11);
      }
    }
    return sub_14001DF2C((signed __int64)v12, a2, a3, a4, a5, a6, a8, v14, v20, v21, a11);
  }
  v16 = 12;
  if ( v15 & 0xFFFFFFFFFFFFFi64 )
  {
    if ( (v15 & 0x8000000000000000ui64) == 0i64 || (v15 & 0xFFFFFFFFFFFFFi64) != 0x8000000000000i64 )
      v17 = (-(signed __int64)((v15 & 0x8000000000000i64) != 0) & 0xFFFFFFFFFFFFFFFCui64) + 8;
    else
      v17 = 12i64;
  }
  else
  {
    v17 = 0i64;
  }
  v18 = v15 >> 63;
  if ( v11 >= v18 + 4 )
  {
    v19 = -1i64;
    if ( (_BYTE)v18 )
    {
      *v12++ = 45;
      *v12 = 0;
      if ( v11 != -1i64 )
        --v11;
    }
    do
      ++v19;
    while ( *((_BYTE *)*(&off_1400330A0 + v17 + 2 * !v14) + v19) );
    if ( (unsigned int)sub_14001A94C(
                         v11,
                         v12,
                         (__int64)*(&off_1400330A0 + v17 + 2 * !v14 + (unsigned int)(v11 <= v19)),
                         a5) )
    {
      sub_14001ADD4(a5);
      JUMPOUT(*(_QWORD *)&byte_14001ED24);
    }
    v16 = 0;
  }
  else
  {
    *v12 = 0;
  }
  return v16;
}
// 14001ED24: using guessed type char;
// 1400330A0: using guessed type void *off_1400330A0;

//----- (000000014001ED28) ----------------------------------------------------
signed __int64 __usercall sub_14001ED28@<rax>(CHAR *a1@<rdx>, int *a2@<rcx>, unsigned __int64 a3@<r8>, unsigned __int16 a4@<r9w>, __m256i *a5@<ymm0>, __int64 a6)
{
  unsigned int v6; // ebx
  unsigned __int64 v7; // rbp
  CHAR *v8; // r14
  int *v9; // rsi
  __int64 v10; // rdi
  unsigned int v11; // esi
  __int64 v12; // rax
  UINT v13; // ecx
  signed int v14; // eax
  signed __int64 result; // rax
  int v16; // eax
  __int64 v17; // [rsp+28h] [rbp-30h]
  __int64 v18; // [rsp+68h] [rbp+10h]
  unsigned __int16 v19; // [rsp+78h] [rbp+20h]

  v19 = a4;
  v6 = 0;
  v7 = a3;
  v8 = a1;
  v9 = a2;
  if ( !a1 && a3 )
  {
    if ( a2 )
      *a2 = 0;
    return 0i64;
  }
  if ( a2 )
    *a2 = -1;
  v10 = a6;
  if ( a3 > 0x7FFFFFFF )
  {
    v11 = 22;
LABEL_40:
    *(_DWORD *)(v10 + 44) = v11;
    *(_BYTE *)(v10 + 48) = 1;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)v10);
    return v11;
  }
  if ( !*(_BYTE *)(a6 + 40) )
  {
    sub_140014910((signed __int64 *)a6, a5);
    a4 = v19;
  }
  v12 = *(_QWORD *)(v10 + 24);
  v13 = *(_DWORD *)(v12 + 12);
  if ( v13 != 65001 )
  {
    if ( !*(_QWORD *)(v12 + 312) )
    {
      if ( a4 > 0xFFu )
      {
        if ( v8 && v7 )
          sub_14000D100(0i64, (__int64)v8, v7, a5);
        goto LABEL_23;
      }
      if ( !v8 )
      {
LABEL_28:
        if ( v9 )
          *v9 = 1;
        return 0i64;
      }
      if ( v7 )
      {
        *v8 = a4;
        goto LABEL_28;
      }
LABEL_39:
      v11 = 34;
      goto LABEL_40;
    }
    LODWORD(v18) = 0;
    LODWORD(v17) = v7;
    v16 = sub_1400203D8(v13, 0, &v19, 1, v8, v17, 0i64, (BOOL *)&v18);
    if ( v16 )
    {
      if ( !(_DWORD)v18 )
      {
        if ( v9 )
          *v9 = v16;
        return 0i64;
      }
    }
    else if ( GetLastError() == 122 )
    {
      if ( v8 && v7 )
        sub_14000D100(0i64, (__int64)v8, v7, a5);
      goto LABEL_39;
    }
LABEL_23:
    result = 42i64;
    *(_DWORD *)(v10 + 44) = 42;
    *(_BYTE *)(v10 + 48) = 1;
    return result;
  }
  v18 = 0i64;
  v14 = sub_140025958(v8, a4, &v18, v10);
  if ( v9 )
    *v9 = v14;
  if ( v14 <= 4 )
    return 0i64;
  if ( *(_BYTE *)(v10 + 48) )
    v6 = *(_DWORD *)(v10 + 44);
  return v6;
}

//----- (000000014001EED8) ----------------------------------------------------
unsigned __int64 __usercall sub_14001EED8@<rax>(CHAR *a1@<rdx>, WCHAR *a2@<rcx>, unsigned __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  __int64 v5; // rbx
  unsigned __int64 v6; // rbp
  CHAR *v7; // rsi
  WCHAR *v8; // rdi
  __int64 v9; // rdx
  UINT v10; // er10
  unsigned __int64 result; // rax
  int v12; // er9

  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = a2;
  if ( !a1 || !a3 )
  {
    qword_140040D88 = 0i64;
    return 0i64;
  }
  if ( !*a1 )
  {
    if ( a2 )
      *a2 = 0;
    return 0i64;
  }
  if ( !*(_BYTE *)(a4 + 40) )
    sub_140014910((signed __int64 *)a4, a5);
  v9 = *(_QWORD *)(v5 + 24);
  v10 = *(_DWORD *)(v9 + 12);
  if ( v10 != 65001 )
  {
    if ( !*(_QWORD *)(v9 + 312) )
    {
      if ( v8 )
        *v8 = (unsigned __int8)*v7;
      return 1i64;
    }
    if ( *(_WORD *)(*(_QWORD *)v9 + 2i64 * (unsigned __int8)*v7) >= 0 )
    {
      if ( sub_14001FB10(v10, 9, v7, 1, v8, v8 != 0i64) )
        return 1i64;
    }
    else
    {
      v12 = *(_DWORD *)(v9 + 8);
      if ( v12 > 1 && (signed int)v6 >= v12 && sub_14001FB10(v10, 9, v7, v12, v8, v8 != 0i64)
        || v6 >= *(signed int *)(*(_QWORD *)(v5 + 24) + 8i64) && v7[1] )
      {
        return *(unsigned int *)(*(_QWORD *)(v5 + 24) + 8i64);
      }
    }
    *(_BYTE *)(v5 + 48) = 1;
    result = 0xFFFFFFFFi64;
    *(_DWORD *)(v5 + 44) = 42;
    return result;
  }
  result = sub_140020990((signed __int16 *)v8, v7, v6, &qword_140040D88, v5);
  if ( (result & 0x80000000) != 0i64 )
    result = 0xFFFFFFFFi64;
  return result;
}
// 140040D88: using guessed type __int64 qword_140040D88;

//----- (000000014001F050) ----------------------------------------------------
_BOOL8 sub_14001F050()
{
  return qword_140040D90 == (_security_cookie | 1);
}
// 140040D90: using guessed type __int64 qword_140040D90;

//----- (000000014001F068) ----------------------------------------------------
LPVOID __fastcall sub_14001F068(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  LPVOID result; // rax

  if ( a1 && 0xFFFFFFFFFFFFFFE0ui64 / a1 < a2 )
  {
LABEL_10:
    *(_DWORD *)sub_140015334() = 12;
    result = 0i64;
  }
  else
  {
    v2 = a2 * a1;
    if ( !(a2 * a1) )
      v2 = 1i64;
    while ( 1 )
    {
      result = HeapAlloc(hHeap, 8u, v2);
      if ( result )
        break;
      if ( !(unsigned int)sub_14001A28C() || !(unsigned int)sub_140023B10(v2) )
        goto LABEL_10;
    }
  }
  return result;
}

//----- (000000014001F0E0) ----------------------------------------------------
FARPROC __fastcall sub_14001F0E0(unsigned int a1, const CHAR *a2, unsigned int *a3, unsigned int *a4)
{
  unsigned int *v6; // r12
  unsigned int *v7; // rbp
  const CHAR *v8; // r13
  uintptr_t v9; // r11
  __int64 v10; // r10
  FARPROC result; // rax
  HMODULE v13; // rbx
  WCHAR *v14; // r14

  _R15 = a1;
  _R14 = 5368709120i64;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = _security_cookie;
  v10 = __ROR8__(_security_cookie ^ qword_140040E50[a1], _security_cookie & 0x3F);
  if ( v10 == -1 )
    return 0i64;
  if ( v10 )
    return (FARPROC)__ROR8__(_security_cookie ^ qword_140040E50[a1], _security_cookie & 0x3F);
  if ( a3 == a4 )
  {
LABEL_16:
    _RDI = v9 ^ __ROR8__(-1i64, 64 - ((unsigned __int8)v9 & 0x3Fu));
    __asm { xchg    rdi, rva qword_140040E50[r14+r15*8] }
    return 0i64;
  }
  while ( 1 )
  {
    _RSI = *v7;
    v13 = (HMODULE)qword_140040DA0[_RSI];
    if ( v13 )
    {
      if ( v13 != (HMODULE)-1i64 )
        goto LABEL_21;
      goto LABEL_14;
    }
    v14 = off_140033180[_RSI];
    v13 = LoadLibraryExW(off_140033180[_RSI], 0i64, 0x800u);
    if ( v13 )
      break;
    if ( GetLastError() == 87 )
    {
      if ( (unsigned int)sub_14001AA04(v14, L"api-ms-", 7i64) )
      {
        if ( (unsigned int)sub_14001AA04(v14, L"ext-ms-", 7i64) )
        {
          v13 = LoadLibraryExW(v14, 0i64, 0);
          if ( v13 )
            break;
        }
      }
    }
    _RAX = -1i64;
    _R14 = 5368709120i64;
    __asm { xchg    rax, rva qword_140040DA0[r14+rsi*8] }
LABEL_14:
    ++v7;
    if ( v7 == v6 )
      goto LABEL_15;
  }
  _RAX = v13;
  _R14 = 5368709120i64;
  __asm { xchg    rax, rva qword_140040DA0[r14+rsi*8] }
  if ( _RAX )
    FreeLibrary(v13);
LABEL_21:
  result = GetProcAddress(v13, v8);
  if ( !result )
  {
LABEL_15:
    v9 = _security_cookie;
    goto LABEL_16;
  }
  _RDX = _security_cookie ^ __ROR8__(result, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
  __asm { xchg    rdx, rva qword_140040E50[r14+r15*8] }
  return result;
}
// 140032268: using guessed type wchar_t aApiMs[8];
// 140033180: using guessed type wchar_t *off_140033180[21];
// 1400336C8: using guessed type wchar_t aExtMs[8];

//----- (000000014001F29C) ----------------------------------------------------
__int64 sub_14001F29C()
{
  __int64 result; // rax

  if ( sub_14001F0E0(
         0x19u,
         "AppPolicyGetProcessTerminationMethod",
         (unsigned int *)&unk_140033744,
         (unsigned int *)"AppPolicyGetProcessTerminationMethod") )
  {
    result = sub_14002A5D0(-6i64);
  }
  else
  {
    result = 3221226021i64;
  }
  return result;
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (000000014001F2F4) ----------------------------------------------------
__int64 sub_14001F2F4()
{
  __int64 v0; // rcx
  __int64 result; // rax

  if ( sub_14001F0E0(0, "AreFileApisANSI", (unsigned int *)&unk_1400336D8, (unsigned int *)&unk_1400336DC) )
    result = sub_14002A5D0(v0);
  else
    result = 1i64;
  return result;
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (000000014001F338) ----------------------------------------------------
int __fastcall sub_14001F338(unsigned __int16 *a1, DWORD a2, const WCHAR *a3, int a4, const WCHAR *lpString2, int cchCount2)
{
  int v6; // ebx
  const WCHAR *v7; // rdi
  DWORD v8; // esi
  unsigned __int16 *v9; // rbp
  LCID v11; // eax

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( sub_14001F0E0(1u, "CompareStringEx", (unsigned int *)&unk_1400336F0, (unsigned int *)"CompareStringEx") )
    return sub_14002A5D0(v9);
  v11 = sub_14001F5A0(v9);
  return CompareStringW(v11, v8, v7, v6, lpString2, cchCount2);
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (000000014001F444) ----------------------------------------------------
int __fastcall sub_14001F444(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
{
  DWORD v2; // ebx
  struct _RTL_CRITICAL_SECTION *v3; // rdi
  int result; // eax

  v2 = dwSpinCount;
  v3 = lpCriticalSection;
  if ( sub_14001F0E0(0xFu, "InitializeCriticalSectionEx", (unsigned int *)"\a", (unsigned int *)&unk_140033710) )
    result = sub_14002A5D0(v3);
  else
    result = InitializeCriticalSectionAndSpinCount(v3, v2);
  return result;
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (000000014001F4B4) ----------------------------------------------------
int __fastcall sub_14001F4B4(unsigned __int16 *a1, DWORD a2, const WCHAR *a3, int a4, WCHAR *lpDestStr, int cchDest)
{
  int v6; // ebx
  const WCHAR *v7; // rdi
  DWORD v8; // esi
  unsigned __int16 *v9; // rbp
  LCID v11; // eax

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( sub_14001F0E0(0x11u, "LCMapStringEx", (unsigned int *)&unk_140033710, (unsigned int *)"LCMapStringEx") )
    return sub_14002A5D0(v9);
  v11 = sub_14001F5A0(v9);
  return LCMapStringW(v11, v8, v7, v6, lpDestStr, cchDest);
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (000000014001F5A0) ----------------------------------------------------
__int64 __fastcall sub_14001F5A0(unsigned __int16 *a1)
{
  unsigned __int16 *v1; // rbx
  __int64 result; // rax

  v1 = a1;
  if ( sub_14001F0E0(0x13u, "LocaleNameToLCID", (unsigned int *)&unk_140033728, (unsigned int *)"LocaleNameToLCID") )
    result = sub_14002A5D0(v1);
  else
    result = sub_1400259FC(v1);
  return result;
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (000000014001F600) ----------------------------------------------------
char sub_14001F600()
{
  memset64(qword_140040E50, _security_cookie, 0x1Fui64);
  return 1;
}

//----- (000000014001F630) ----------------------------------------------------
char __fastcall sub_14001F630(char a1)
{
  __int64 *v1; // rbx
  HMODULE v2; // rcx

  if ( !a1 )
  {
    v1 = qword_140040DA0;
    do
    {
      v2 = (HMODULE)*v1;
      if ( *v1 )
      {
        if ( v2 != (HMODULE)-1i64 )
          FreeLibrary(v2);
        *v1 = 0i64;
      }
      ++v1;
    }
    while ( v1 != (__int64 *)&unk_140040E48 );
  }
  return 1;
}

//----- (000000014001F674) ----------------------------------------------------
__int64 __usercall sub_14001F674@<rax>(__m256i *a1@<ymm0>)
{
  signed int i; // ebx
  __int64 v2; // rcx
  unsigned int v4; // [rsp+20h] [rbp-18h]

  v4 = 0;
  sub_140020BC8(8);
  for ( i = 3; i != dword_1400406C0; ++i )
  {
    v2 = *((_QWORD *)lpMem + i);
    if ( v2 )
    {
      if ( (*(_DWORD *)(v2 + 20) >> 13) & 1 )
      {
        if ( (unsigned int)sub_14001019C(*((_QWORD *)lpMem + i), a1) != -1 )
          ++v4;
      }
      DeleteCriticalSection((LPCRITICAL_SECTION)(*((_QWORD *)lpMem + i) + 48i64));
      sub_14001AE1C(*((LPVOID *)lpMem + i));
      *((_QWORD *)lpMem + i) = 0i64;
    }
  }
  sub_140020C28(8);
  return v4;
}
// 1400406C0: using guessed type int dword_1400406C0;

//----- (000000014001F728) ----------------------------------------------------
char **sub_14001F728()
{
  return off_1400338D0;
}
// 1400338D0: using guessed type char *off_1400338D0[44];

//----- (000000014001F730) ----------------------------------------------------
const char *sub_14001F730()
{
  return "+";
}

//----- (000000014001F738) ----------------------------------------------------
__int64 __usercall sub_14001F738@<rax>(__int64 a1@<rdx>, _BYTE *a2@<rcx>, __int64 a3@<r8>, signed __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  unsigned int v5; // er10
  __int64 v6; // r11
  _DWORD *v7; // rax
  unsigned int v8; // ebx
  __int64 v10; // rbx
  _BYTE *v11; // rdx
  __int64 v12; // r8
  signed __int64 v13; // rdi
  char v14; // al
  char v15; // al
  signed __int64 v16; // rsi
  signed __int64 v17; // rax

  v5 = 0;
  v6 = a1;
  if ( a4 )
  {
    if ( !a2 )
      goto LABEL_4;
  }
  else if ( !a2 )
  {
    if ( !a1 )
      return v5;
    goto LABEL_4;
  }
  if ( !a1 )
  {
LABEL_4:
    v7 = sub_140015334();
    v8 = 22;
LABEL_5:
    *v7 = v8;
    sub_14001ADB4(a5);
    return v8;
  }
  if ( !a4 )
  {
    *a2 = 0;
    return v5;
  }
  if ( !a3 )
  {
    *a2 = 0;
    goto LABEL_4;
  }
  v10 = a3 - (_QWORD)a2;
  v11 = a2;
  v12 = v6;
  v13 = a4;
  if ( a4 == -1 )
  {
    while ( 1 )
    {
      v14 = v11[v10];
      *v11++ = v14;
      if ( !v14 )
        break;
      if ( !--v12 )
        goto LABEL_24;
    }
  }
  else
  {
    while ( 1 )
    {
      v15 = v11[v10];
      v16 = v13;
      *v11++ = v15;
      if ( !v15 )
        break;
      if ( --v12 )
      {
        if ( --v13 )
          continue;
      }
      v17 = v16 - 1;
      if ( !v12 )
        v17 = v16;
      if ( !v17 )
        *v11 = 0;
LABEL_24:
      if ( v12 )
        return v5;
      if ( a4 == -1 )
      {
        a2[v6 - 1] = 0;
        return 80;
      }
      *a2 = 0;
      v7 = sub_140015334();
      v8 = 34;
      goto LABEL_5;
    }
  }
  return v5;
}

//----- (000000014001F828) ----------------------------------------------------
__int64 __usercall sub_14001F828@<rax>(__m256i *a1@<ymm0>)
{
  DWORD v1; // eax
  unsigned int v2; // edi
  int v3; // edi
  DWORD v4; // esi
  WCHAR *v5; // rax
  WCHAR *v6; // rbx
  int v7; // ecx
  int v8; // edi
  WCHAR Buffer; // [rsp+20h] [rbp-228h]
  __int16 v11; // [rsp+22h] [rbp-226h]

  sub_14000D100(0i64, (__int64)&Buffer, 0x20Aui64, a1);
  v1 = GetCurrentDirectoryW(0x105u, &Buffer);
  if ( v1 > 0x104 )
  {
    v4 = v1 + 1;
    v5 = (WCHAR *)sub_14001F068(v1 + 1, 2ui64);
    v2 = 0;
    v6 = v5;
    if ( v5 && GetCurrentDirectoryW(v4, v5) )
    {
      if ( *v6 && v6[1] == 58 )
      {
        v7 = *v6;
        v8 = v7 - 32;
        if ( (unsigned int)(v7 - 97) > 0x19 )
          v8 = *v6;
        v2 = v8 - 64;
      }
    }
    else
    {
      *(_DWORD *)sub_140015334() = 12;
    }
    sub_14001AE1C(v6);
  }
  else
  {
    v2 = 0;
    if ( Buffer && v11 == 58 )
    {
      v3 = Buffer - 32;
      if ( (unsigned int)Buffer - 97 > 0x19 )
        v3 = Buffer;
      v2 = v3 - 64;
    }
  }
  return v2;
}

//----- (000000014001F920) ----------------------------------------------------
_WORD *__fastcall sub_14001F920(_WORD *a1, __int16 *a2)
{
  __int16 *v2; // r8
  __int16 v3; // ax

  while ( 1 )
  {
    if ( !*a1 )
      return 0i64;
    v2 = a2;
    if ( *a2 )
      break;
LABEL_6:
    ++a1;
  }
  v3 = *a2;
  while ( v3 != *a1 )
  {
    ++v2;
    v3 = *v2;
    if ( !*v2 )
      goto LABEL_6;
  }
  return a1;
}

//----- (000000014001F954) ----------------------------------------------------
__int64 __fastcall sub_14001F954(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2; // r11
  unsigned __int16 *v3; // r10
  int v4; // er8
  int v5; // edx
  int v6; // er9
  int v7; // ecx
  __int64 result; // rax

  v2 = a2;
  v3 = a1;
  do
  {
    v4 = *v3;
    ++v3;
    v5 = *v2;
    ++v2;
    v6 = v4 + 32;
    if ( (unsigned int)(v4 - 65) > 0x19 )
      v6 = v4;
    v7 = v5 + 32;
    if ( (unsigned int)(v5 - 65) > 0x19 )
      v7 = v5;
    result = (unsigned int)(v6 - v7);
  }
  while ( v6 == v7 && v6 );
  return result;
}

//----- (000000014001F994) ----------------------------------------------------
__int64 __usercall sub_14001F994@<rax>(unsigned __int16 *a1@<rdx>, unsigned __int16 *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  if ( dword_140040924 )
    return sub_14001F9DC(a1, a2, 0i64, a3, a4, a5);
  if ( a2 && a1 )
    return sub_14001F954(a2, a1);
  *(_DWORD *)sub_140015334() = 22;
  sub_14001ADB4(a4);
  return 0x7FFFFFFFi64;
}
// 140040924: using guessed type int dword_140040924;

//----- (000000014001F9DC) ----------------------------------------------------
signed __int64 __usercall sub_14001F9DC@<rax>(unsigned __int16 *a1@<rdx>, unsigned __int16 *a2@<rcx>, __m128i *a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>)
{
  unsigned __int16 *v6; // rdi
  unsigned __int16 *v7; // rbx
  signed __int64 result; // rax
  __int64 v9; // rcx
  unsigned int v10; // esi
  unsigned __int16 v11; // ax
  unsigned __int8 v12; // dl
  unsigned __int16 v13; // ax
  int v14; // ebp
  unsigned __int16 v15; // ax
  unsigned __int8 v16; // dl
  unsigned __int16 v17; // ax
  __int64 v18; // [rsp+20h] [rbp-38h]
  __m128i v19; // [rsp+28h] [rbp-30h]
  char v20; // [rsp+38h] [rbp-20h]

  v6 = a1;
  v7 = a2;
  if ( a2 && a1 )
  {
    sub_14001590C(a3, (__int64)&v18, a5);
    v9 = v19.m128i_i64[0];
    if ( *(_QWORD *)(v19.m128i_i64[0] + 312) )
    {
      do
      {
        v11 = *v7;
        ++v7;
        if ( v11 >= 0x100u )
        {
          v13 = sub_140025AA0(&v19, v11, a4, a5, a6);
          v9 = v19.m128i_i64[0];
        }
        else
        {
          v12 = v11;
          if ( *((_BYTE *)&unk_140034750 + 2 * (unsigned __int8)v11 + 2) & 1 )
            v12 = *(_BYTE *)((unsigned __int8)v11 + *(_QWORD *)(v9 + 272));
          v13 = v12;
        }
        v14 = v13;
        v15 = *v6;
        ++v6;
        if ( v15 >= 0x100u )
        {
          v17 = sub_140025AA0(&v19, v15, a4, a5, a6);
          v9 = v19.m128i_i64[0];
        }
        else
        {
          v16 = v15;
          if ( *((_BYTE *)&unk_140034750 + 2 * (unsigned __int8)v15 + 2) & 1 )
            v16 = *(_BYTE *)((unsigned __int8)v15 + *(_QWORD *)(v9 + 272));
          v17 = v16;
        }
        v10 = v14 - v17;
      }
      while ( v14 == v17 && v14 );
    }
    else
    {
      v10 = sub_14001F954(v7, v6);
    }
    if ( v20 )
      *(_DWORD *)(v18 + 936) &= 0xFFFFFFFD;
    result = v10;
  }
  else
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
    result = 0x7FFFFFFFi64;
  }
  return result;
}

//----- (000000014001FB10) ----------------------------------------------------
int __fastcall sub_14001FB10(UINT a1, char a2, const CHAR *a3, int a4, WCHAR *a5, int a6)
{
  bool v6; // zf

  if ( a1 > 0xDEAC )
  {
    if ( a1 == 57005
      || a1 == 57006
      || a1 == 57007
      || a1 == 57008
      || a1 == 57009
      || a1 == 57010
      || a1 == 57011
      || a1 == 65000 )
    {
      goto LABEL_15;
    }
    if ( a1 != 65001 )
      return MultiByteToWideChar(a1, a2, a3, a4, a5, a6);
    goto LABEL_26;
  }
  if ( a1 == 57004 )
    goto LABEL_15;
  if ( a1 > 0xC433 )
  {
    if ( a1 == 50229 )
      goto LABEL_15;
    if ( a1 != 54936 )
    {
      if ( a1 != 57002 )
      {
        v6 = a1 == 57003;
        goto LABEL_14;
      }
LABEL_15:
      a2 = 0;
      return MultiByteToWideChar(a1, a2, a3, a4, a5, a6);
    }
LABEL_26:
    a2 &= 8u;
    return MultiByteToWideChar(a1, a2, a3, a4, a5, a6);
  }
  if ( a1 == 50227 || a1 == 42 || a1 == 50220 || a1 == 50221 || a1 == 50222 )
    goto LABEL_15;
  v6 = a1 == 50225;
LABEL_14:
  if ( v6 )
    goto LABEL_15;
  return MultiByteToWideChar(a1, a2, a3, a4, a5, a6);
}

//----- (000000014001FBA0) ----------------------------------------------------
bool __fastcall sub_14001FBA0(int a1)
{
  bool result; // al

  if ( a1 % 4 || a1 == 100 * (a1 / 100) )
    result = a1 + 1900 == 400 * ((a1 + 1900) / 400);
  else
    result = 1;
  return result;
}

//----- (000000014001FBFC) ----------------------------------------------------
signed __int64 __usercall sub_14001FBFC@<rax>(int a1@<edx>, int a2@<ecx>, int a3@<r8d>, int a4@<r9d>, __m256i *a5@<ymm0>, unsigned int a6, unsigned int a7, int a8)
{
  int v8; // ebx
  signed int v9; // esi
  __int64 v10; // r13
  __int64 v11; // rdi
  int v12; // esi
  signed __int64 v13; // rdi
  signed __int64 v14; // r14
  signed __int64 result; // rax
  int v16; // [rsp+30h] [rbp-48h]
  int v17; // [rsp+34h] [rbp-44h]
  int v18; // [rsp+38h] [rbp-40h]
  int v19; // [rsp+3Ch] [rbp-3Ch]
  unsigned int v20; // [rsp+40h] [rbp-38h]
  unsigned int v21; // [rsp+44h] [rbp-34h]
  int v22; // [rsp+48h] [rbp-30h]
  int v23; // [rsp+50h] [rbp-28h]
  int v24; // [rsp+54h] [rbp-24h]
  int v25; // [rsp+5Ch] [rbp-1Ch]

  v8 = a2 - 1900;
  v9 = a3;
  v10 = a4;
  v11 = a1;
  if ( a2 - 1900 >= 70
    && (unsigned __int64)v8 <= 0x44D
    && (v19 = a1 - 1, (unsigned int)(a1 - 1) <= 0xB)
    && a3 > 0
    && (a3 <= dword_1400386B0[a1] - dword_1400386B0[a1 - 1] || sub_14001FBA0(v8) && (_DWORD)v11 == 2 && v9 <= 29)
    && (unsigned int)v10 <= 0x17
    && a6 <= 0x3B
    && a7 <= 0x3B )
  {
    v12 = dword_1400386B0[v11 - 1] + v9;
    if ( sub_14001FBA0(v8) && (signed int)v11 > 2 )
      ++v12;
    sub_140026814(a5);
    v18 = 0;
    v17 = 0;
    v16 = 0;
    if ( (unsigned int)sub_140025C18(&v18, a5)
      || (unsigned int)sub_140025C48(&v17, a5)
      || (unsigned int)sub_140025C78(&v16, a5) )
    {
      sub_14001ADD4(a5);
      JUMPOUT(*(_QWORD *)&byte_14001FE2E);
    }
    v13 = (signed int)a7
        + v16
        + 60
        * ((signed int)a6
         + 60 * (v10 + 24 * (v12 + 365 * (v8 - 70i64) + (v8 + 299) / 400 - (v8 - 1) / 100 + (v8 - 1) / 4 - 17)));
    v14 = v13 + v17;
    if ( a8 == 1 )
    {
      result = v13 + v17;
    }
    else
    {
      v23 = v19;
      v25 = v12;
      v24 = v8;
      v22 = v10;
      v21 = a6;
      v20 = a7;
      if ( a8 == -1 && v18 )
      {
        if ( (unsigned int)sub_140026858(&v20, a5) )
          v13 = v14;
      }
      result = v13;
    }
  }
  else
  {
    *(_DWORD *)sub_140015334() = 22;
    result = -1i64;
  }
  return result;
}
// 14001FE2E: using guessed type char;

//----- (000000014001FE38) ----------------------------------------------------
__int64 __usercall sub_14001FE38@<rax>(__int64 *a1@<rdx>, __int64 a2@<r8>, __int64 *a3@<r9>, __m256i *a4@<ymm0>)
{
  __int64 *v4; // rbx
  __int64 v5; // rdi

  v4 = a3;
  v5 = a2;
  sub_1400151DC(*a1);
  LODWORD(v5) = sub_14001FE78(v5, a4);
  sub_1400151E8(*v4);
  return (unsigned int)v5;
}

//----- (000000014001FE78) ----------------------------------------------------
signed __int64 __usercall sub_14001FE78@<rax>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rbx
  unsigned __int64 v3; // rsi
  __int64 v4; // rax
  signed __int64 v5; // rcx
  LPVOID v6; // rdi

  v2 = a1;
  v3 = **(_QWORD **)a1 & 0xFFFFFFFFFFFFFFFEui64;
  sub_140017568(*(_QWORD *)(a1 + 16), **(_QWORD **)(a1 + 8), a2);
  sub_14001B25C(**(_QWORD **)(v2 + 8));
  _InterlockedAnd((volatile signed __int32 *)(**(_QWORD **)(v2 + 8) + 20i64), 0xFFFFF81F);
  if ( **(_BYTE **)(v2 + 24) & 4 )
  {
    v4 = **(_QWORD **)(v2 + 8);
    v5 = v4 + 28;
    _InterlockedOr((volatile signed __int32 *)(v4 + 20), 0x400u);
    *(_DWORD *)(v4 + 32) = 2;
LABEL_8:
    *(_QWORD *)v4 = v5;
    *(_QWORD *)(v4 + 8) = v5;
    goto LABEL_9;
  }
  v5 = **(_QWORD **)(v2 + 32);
  if ( v5 )
  {
    v4 = **(_QWORD **)(v2 + 8);
    _InterlockedOr((volatile signed __int32 *)(v4 + 20), 0x180u);
    *(_DWORD *)(v4 + 32) = v3;
    goto LABEL_8;
  }
  v6 = sub_14001F068(v3, 1ui64);
  sub_14001AE1C(0i64);
  if ( !v6 )
  {
    ++dword_1400406D0;
    return 0xFFFFFFFFi64;
  }
  v4 = **(_QWORD **)(v2 + 8);
  _InterlockedOr((volatile signed __int32 *)(v4 + 20), 0x140u);
  *(_DWORD *)(v4 + 32) = v3;
  *(_QWORD *)v4 = v6;
  *(_QWORD *)(v4 + 8) = v6;
LABEL_9:
  *(_DWORD *)(v4 + 16) = 0;
  return 0i64;
}
// 1400406D0: using guessed type int dword_1400406D0;

//----- (000000014001FF60) ----------------------------------------------------
__int64 __usercall sub_14001FF60@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  unsigned int v5; // edi
  int v6; // ebx
  int v7; // ebx
  __int64 v9; // [rsp+30h] [rbp-39h]
  char v10; // [rsp+40h] [rbp-29h]
  __int128 v11; // [rsp+48h] [rbp-21h]
  char v12; // [rsp+58h] [rbp-11h]
  int v13; // [rsp+5Ch] [rbp-Dh]
  char v14; // [rsp+60h] [rbp-9h]
  int v15; // [rsp+64h] [rbp-5h]
  char v16; // [rsp+68h] [rbp-1h]
  __int64 v17; // [rsp+70h] [rbp+7h]
  __int64 v18; // [rsp+78h] [rbp+Fh]
  __int64 v19; // [rsp+80h] [rbp+17h]
  __int64 *v20; // [rsp+88h] [rbp+1Fh]
  __int64 *v21; // [rsp+90h] [rbp+27h]
  __int64 *v22; // [rsp+98h] [rbp+2Fh]
  int *v23; // [rsp+A0h] [rbp+37h]
  __int64 *v24; // [rsp+A8h] [rbp+3Fh]
  int v25; // [rsp+D0h] [rbp+67h]
  __int64 v26; // [rsp+D8h] [rbp+6Fh]
  __int64 v27; // [rsp+E8h] [rbp+7Fh]

  v9 = 0i64;
  v10 = 0;
  v12 = 0;
  v14 = 0;
  v16 = 0;
  if ( !dword_140040924 )
  {
    v12 = 1;
    _mm_storeu_si128((__m128i *)&v11, off_14003E2C8);
  }
  v26 = a4;
  v25 = a3;
  v17 = a1;
  v27 = a2;
  if ( !a2 || a3 != 4 && (a3 && a3 != 64 || (unsigned __int64)(a4 - 2) > 0x7FFFFFFD) )
  {
    v14 = 1;
    v13 = 22;
    sub_14001ACE8(0i64, a5, 0i64, &v9);
    v5 = -1;
  }
  else
  {
    v18 = a2;
    v20 = &v26;
    v19 = a2;
    v21 = &v27;
    v22 = &v9;
    v23 = &v25;
    v24 = &v17;
    v5 = sub_14001FE38(&v19, (__int64)&v20, &v18, a5);
  }
  if ( v12 == 2 )
    *(_DWORD *)(v9 + 936) &= 0xFFFFFFFD;
  if ( v14 )
  {
    v6 = v13;
    *(_DWORD *)(sub_14001009C(&v9, a5) + 32) = v6;
  }
  if ( v16 )
  {
    v7 = v15;
    *(_DWORD *)(sub_14001009C(&v9, a5) + 36) = v7;
  }
  return v5;
}
// 140040924: using guessed type int dword_140040924;

//----- (0000000140020098) ----------------------------------------------------
unsigned __int8 *__fastcall sub_140020098(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 **a3)
{
  unsigned __int8 *v3; // r10
  unsigned __int8 **v4; // rdi
  signed __int64 v5; // rax
  unsigned __int8 *v6; // r11
  bool v7; // cf
  unsigned __int8 *v8; // r9
  unsigned int v9; // er8
  unsigned __int8 v10; // r8
  unsigned __int8 *v11; // r11
  unsigned __int8 *v12; // rsi
  unsigned __int8 v13; // bl
  unsigned __int64 v14; // rax
  signed int v15; // edx
  unsigned __int8 *v16; // rbx
  unsigned __int8 v17; // al
  char v19[32]; // [rsp+20h] [rbp-48h]

  v3 = 0i64;
  v4 = a3;
  v5 = 0i64;
  v6 = a2;
  v7 = 1;
  v8 = a1;
  do
  {
    if ( !v7 )
    {
      _report_rangecheckfailure(a1, a2, a3, a1);
      JUMPOUT(*(_QWORD *)&byte_1400201BC);
    }
    v19[v5++] = 0;
    v7 = (unsigned __int64)v5 < 0x20;
  }
  while ( v5 < 32 );
  do
  {
    v9 = *v6++;
    v19[(unsigned __int64)v9 >> 3] |= 1 << (v9 & 7);
  }
  while ( (_BYTE)v9 );
  if ( !a1 )
    v8 = *v4;
  v10 = *v8;
  v11 = v8;
  if ( (unsigned __int8)(1 << (*v8 & 7)) & (unsigned __int8)v19[(unsigned __int64)*v8 >> 3] )
  {
    v12 = v8;
    v13 = *v8;
    do
    {
      v10 = v13;
      if ( !v13 )
        break;
      v8 = v12 + 1;
      v13 = v12[1];
      v11 = v12 + 1;
      v14 = (unsigned __int64)v12[1] >> 3;
      v15 = 1 << ((v12++)[1] & 7);
      v10 = v13;
    }
    while ( (unsigned __int8)v15 & (unsigned __int8)v19[v14] );
  }
  v16 = v11;
  if ( v10 )
  {
    v17 = *v11;
    while ( 1 )
    {
      ++v16;
      if ( (unsigned __int8)(1 << (v17 & 7)) & (unsigned __int8)v19[(unsigned __int64)v17 >> 3] )
        break;
      v17 = *v16;
      v8 = v16;
      if ( !*v16 )
        goto LABEL_17;
    }
    *v8 = 0;
    v8 = v16;
  }
LABEL_17:
  *v4 = v8;
  if ( v16 != v11 )
    v3 = v11;
  return v3;
}
// 14000BE04: using guessed type __int64 __fastcall _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400201BC: using guessed type char;
// 140020098: using guessed type char var_48[32];

//----- (00000001400201C0) ----------------------------------------------------
__m128i *__usercall sub_1400201C0@<rax>(__m128i *a1@<rdx>, unsigned int a2@<ecx>, int a3@<r8d>, __m256i *a4@<ymm0>)
{
  __m128i *v4; // rbx
  __int64 v5; // rsi
  __m128i *v6; // r14
  __int16 v7; // di
  __m128i *result; // rax
  int v9; // eax
  __m128i *v10; // rdi
  char *v11; // [rsp+20h] [rbp-50h]
  __m128i *v12; // [rsp+28h] [rbp-48h]
  __int64 v13; // [rsp+30h] [rbp-40h]
  __m128i *v14; // [rsp+38h] [rbp-38h]
  __int64 v15; // [rsp+40h] [rbp-30h]
  __int64 v16; // [rsp+48h] [rbp-28h]
  char v17; // [rsp+50h] [rbp-20h]
  char v18[6]; // [rsp+58h] [rbp-18h]
  __int16 v19; // [rsp+5Eh] [rbp-12h]

  v4 = 0i64;
  v5 = a3;
  v6 = a1;
  v7 = a2;
  if ( a3 < 0 )
    goto LABEL_2;
  if ( a2 )
  {
    if ( !(unsigned int)sub_14002032C(a2, a4) )
    {
      *(_DWORD *)sub_140015314() = 15;
      *(_DWORD *)sub_140015334() = 13;
      goto LABEL_3;
    }
    goto LABEL_9;
  }
  v9 = sub_14001F828(a4);
  v7 = v9;
  if ( v9 )
  {
LABEL_9:
    *(_DWORD *)&v18[2] = 3014714;
    *(_WORD *)v18 = v7 + 64;
    v19 = 0;
    goto LABEL_11;
  }
  *(_DWORD *)v18 = 46;
LABEL_11:
  if ( v6 )
  {
    if ( (signed int)v5 <= 0 )
    {
LABEL_2:
      *(_DWORD *)sub_140015334() = 22;
LABEL_3:
      sub_14001ADB4(a4);
      return 0i64;
    }
    LOWORD(v6->m128i_i64[0]) = 0;
    v13 = v5;
    v15 = v5;
    v12 = v6;
    v14 = v6;
    v16 = 0i64;
    v17 = 0;
    v11 = v18;
    if ( !(unsigned int)sub_140016008((__int64)&v12, (LPCWSTR *)&v11) )
      v4 = v6;
    result = v4;
  }
  else
  {
    v12 = 0i64;
    v13 = 0i64;
    v16 = 0i64;
    v14 = (__m128i *)sub_140014FA0(2 * v5);
    if ( v14 )
    {
      v17 = 1;
      v15 = v5;
    }
    else
    {
      v17 = 0;
      v15 = 0i64;
    }
    v11 = v18;
    if ( (unsigned int)sub_14001607C((__int64)&v12, (LPCWSTR *)&v11) )
    {
      if ( v17 )
        sub_140014F8C(v14);
      return 0i64;
    }
    v10 = sub_140016154((__int64 *)&v12, a4);
    if ( v17 )
      sub_140014F8C(v14);
    result = v10;
  }
  return result;
}
// 140014FA0: using guessed type __int64 __fastcall sub_140014FA0(_QWORD);

//----- (000000014002032C) ----------------------------------------------------
signed __int64 __usercall sub_14002032C@<rax>(unsigned int a1@<ecx>, __m256i *a2@<ymm0>)
{
  unsigned int v3; // ebx
  UINT v4; // eax
  WCHAR RootPathName; // [rsp+20h] [rbp-18h]
  int v6; // [rsp+22h] [rbp-16h]
  __int16 v7; // [rsp+26h] [rbp-12h]

  if ( a1 > 0x1A )
  {
    *(_DWORD *)sub_140015314() = 15;
    *(_DWORD *)sub_140015334() = 13;
    sub_14001ADB4(a2);
    return 0i64;
  }
  v3 = 0;
  if ( !a1 )
    return 1i64;
  v6 = 6029370;
  RootPathName = a1 + 64;
  v7 = 0;
  v4 = GetDriveTypeW(&RootPathName);
  if ( !v4 )
    return 0i64;
  LOBYTE(v3) = v4 != 1;
  return v3;
}

//----- (00000001400203B0) ----------------------------------------------------
__m128i *__usercall sub_1400203B0@<rax>(int a1@<edx>, __m128i *a2@<rcx>, __m256i *a3@<ymm0>)
{
  return sub_1400201C0(a2, 0, a1, a3);
}

//----- (00000001400203D8) ----------------------------------------------------
int __fastcall sub_1400203D8(UINT a1, int a2, const WCHAR *a3, int a4, CHAR *a5, __int64 a6, const CHAR *a7, BOOL *a8)
{
  int v8; // er11
  const WCHAR *v9; // rbx
  bool v10; // r10
  bool v11; // zf
  bool v12; // zf
  int v13; // eax
  unsigned int v14; // edx
  const CHAR *v15; // r9
  BOOL *v16; // r8

  v8 = a4;
  v9 = a3;
  v10 = a1 - 65000 <= 1;
  if ( a1 > 0xDEAC )
  {
    if ( a1 == 57005 || a1 == 57006 || a1 == 57007 || a1 == 57008 || a1 == 57009 || a1 == 57010 || a1 == 57011 )
      goto LABEL_25;
    v13 = a1 - 65000;
    v12 = a1 == 65000;
LABEL_21:
    if ( v12 )
      goto LABEL_25;
    v11 = v13 == 1;
    goto LABEL_23;
  }
  if ( a1 == 57004 )
    goto LABEL_25;
  if ( a1 > 0xC433 )
  {
    if ( a1 == 50229 || a1 == 54936 )
      goto LABEL_25;
    v13 = a1 - 57002;
    v12 = a1 == 57002;
    goto LABEL_21;
  }
  if ( a1 == 50227 || a1 == 42 || a1 == 50220 || a1 == 50221 || a1 == 50222 )
    goto LABEL_25;
  v11 = a1 == 50225;
LABEL_23:
  if ( !v11 )
  {
    v14 = a2 & 0xFFFFFF7F;
    goto LABEL_26;
  }
LABEL_25:
  v14 = 0;
LABEL_26:
  v15 = a7;
  v16 = a8;
  if ( v10 )
    v16 = 0i64;
  if ( v10 )
    v15 = 0i64;
  if ( v10 && a8 )
    *a8 = 0;
  return WideCharToMultiByte(a1, v14, v9, v8, a5, a6, v15, v16);
}

//----- (00000001400204B8) ----------------------------------------------------
int *__usercall sub_1400204B8@<rax>(__int16 *a1@<rdx>, int *a2@<rcx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  __int16 *v5; // r8
  int *v6; // rbx
  __int16 i; // ax
  _WORD *v8; // r8
  char v9; // dl
  char v10; // r9
  char v11; // di
  char v12; // r10
  char v13; // r11
  signed __int64 v14; // rsi
  unsigned int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // eax
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx
  int v25; // ecx
  int v26; // ecx
  int v27; // eax
  int v28; // eax
  _WORD *v29; // rdi
  bool v30; // zf
  unsigned __int16 *j; // rdi
  unsigned __int16 *k; // rcx

  v5 = a1;
  *(_QWORD *)a2 = 0i64;
  v6 = a2;
  a2[2] = 0;
  a2[1] = dword_14004092C;
  for ( i = *a1; i == 32; i = *v5 )
    ++v5;
  if ( i == 97 )
  {
    *a2 = 265;
LABEL_10:
    a2[1] = 2;
    goto LABEL_11;
  }
  if ( i != 114 )
  {
    if ( i != 119 )
      goto LABEL_81;
    *a2 = 769;
    goto LABEL_10;
  }
  a2[1] = 1;
LABEL_11:
  v8 = v5 + 1;
  v9 = 1;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 5i64;
  while ( *v8 )
  {
    v15 = (unsigned __int16)*v8;
    if ( v15 > 0x53 )
    {
      v22 = v15 - 84;
      if ( !v22 )
      {
        v28 = *v6;
        if ( !_bittest(&v28, 0xCu) )
        {
          v21 = v28 | 0x1000;
LABEL_53:
          *v6 = v21;
LABEL_54:
          v9 = 1;
          goto LABEL_55;
        }
        goto LABEL_51;
      }
      v23 = v22 - 14;
      if ( !v23 )
      {
        if ( !(*v6 & 0xC000) )
        {
          v21 = *v6 | 0x8000;
          goto LABEL_53;
        }
        goto LABEL_51;
      }
      v24 = v23 - 1;
      if ( v24 )
      {
        v25 = v24 - 11;
        if ( v25 )
        {
          v26 = v25 - 6;
          if ( v26 )
          {
            if ( v26 != 4 )
              goto LABEL_81;
            v27 = *v6;
            if ( _bittest(&v27, 9u) )
            {
              v21 = v27 | 0x400;
              goto LABEL_53;
            }
          }
          else if ( !(*v6 & 0xC000) )
          {
            v21 = *v6 | 0x4000;
            goto LABEL_53;
          }
          goto LABEL_51;
        }
        if ( v10 )
          goto LABEL_51;
        v6[1] &= 0xFFFFF7FF;
      }
      else
      {
        if ( v10 )
          goto LABEL_51;
        v6[1] |= 0x800u;
      }
      v10 = 1;
      v9 = 1;
    }
    else
    {
      if ( v15 == 83 )
      {
        if ( v12 )
          goto LABEL_51;
        *v6 |= 0x20u;
LABEL_32:
        v12 = 1;
        v9 = 1;
        goto LABEL_55;
      }
      v16 = v15 - 32;
      if ( v16 )
      {
        v17 = v16 - 11;
        if ( v17 )
        {
          v18 = v17 - 1;
          if ( !v18 )
          {
            v13 = 1;
LABEL_51:
            v9 = 0;
            goto LABEL_55;
          }
          v19 = v18 - 24;
          if ( !v19 )
          {
            if ( !(*v6 & 0x40) )
            {
              v21 = *v6 | 0x40;
              goto LABEL_53;
            }
            goto LABEL_51;
          }
          v20 = v19 - 10;
          if ( !v20 )
          {
            *v6 |= 0x80u;
            goto LABEL_54;
          }
          if ( v20 != 4 )
            goto LABEL_81;
          if ( v12 )
            goto LABEL_51;
          *v6 |= 0x10u;
          goto LABEL_32;
        }
        if ( v11 )
          goto LABEL_51;
        v11 = 1;
        if ( *v6 & 2 )
          goto LABEL_51;
        v9 = 1;
        *v6 = *v6 & 0xFFFFFFFE | 2;
        v6[1] = v6[1] & 0xFFFFFFFC | 4;
      }
    }
LABEL_55:
    v8 = (_WORD *)((char *)v8 + (v9 != 0 ? 2 : 0));
    if ( !v9 )
      break;
  }
  v29 = v8 + 1;
  if ( !v13 )
    v29 = v8;
  while ( *v29 == 32 )
    ++v29;
  if ( !v13 )
  {
    v30 = *v29 == 0;
    goto LABEL_63;
  }
  if ( (unsigned int)sub_14001AA04(v29, L"ccs", 3i64) )
    goto LABEL_81;
  for ( j = v29 + 3; *j == 32; ++j )
    ;
  if ( *j != 61 )
    goto LABEL_81;
  do
    ++j;
  while ( *j == 32 );
  if ( !(unsigned int)sub_1400268D4(L"UTF-8", j, 5i64, a3, a4, a5) )
  {
    *v6 |= 0x40000u;
    goto LABEL_77;
  }
  if ( !(unsigned int)sub_1400268D4(L"UTF-16LEUNICODE", j, 8i64, a3, a4, a5) )
  {
    *v6 |= 0x20000u;
    v14 = 8i64;
    goto LABEL_77;
  }
  if ( (unsigned int)sub_1400268D4(L"UNICODE", j, 7i64, a3, a4, a5) )
    goto LABEL_81;
  *v6 |= 0x10000u;
  v14 = 7i64;
LABEL_77:
  for ( k = &j[v14]; *k == 32; ++k )
    ;
  v30 = *k == 0;
LABEL_63:
  if ( !v30 )
  {
LABEL_81:
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a4);
    return v6;
  }
  *((_BYTE *)v6 + 8) = 1;
  return v6;
}
// 140034114: using guessed type wchar_t aCcs[4];
// 140034120: using guessed type wchar_t aUtf8_0[6];
// 140034130: using guessed type wchar_t aUtf16leunicode[16];
// 14004092C: using guessed type int dword_14004092C;

//----- (00000001400207BC) ----------------------------------------------------
__int64 __usercall sub_1400207BC@<rax>(__int16 *a1@<rdx>, const WCHAR *a2@<rcx>, __int64 a3@<r9>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>)
{
  const WCHAR *v6; // rbp
  __int64 v7; // rdi
  int *v8; // rax
  __int64 v9; // rbx
  int v10; // eax
  __int64 v12; // [rsp+30h] [rbp-28h]
  __int64 v13; // [rsp+40h] [rbp-18h]
  int v14; // [rsp+70h] [rbp+18h]

  v6 = a2;
  v7 = a3;
  v8 = sub_1400204B8(a1, (int *)&v13, a4, a5, a6);
  v9 = 0i64;
  v12 = *(_QWORD *)v8;
  if ( (unsigned __int8)v8[2] && !(unsigned int)sub_1400275BC(v6, &v14, v12, a5, 384) )
  {
    ++dword_1400406D0;
    _InterlockedOr((volatile signed __int32 *)(v7 + 20), HIDWORD(v12));
    v10 = v14;
    *(_DWORD *)(v7 + 16) = 0;
    *(_QWORD *)(v7 + 40) = 0i64;
    *(_QWORD *)(v7 + 8) = 0i64;
    *(_QWORD *)v7 = 0i64;
    v9 = v7;
    *(_DWORD *)(v7 + 24) = v10;
  }
  return v9;
}
// 1400406D0: using guessed type int dword_1400406D0;

//----- (0000000140020858) ----------------------------------------------------
__int64 __usercall sub_140020858@<rax>(__m256i *a1@<ymm0>)
{
  __int64 v1; // rax
  __int64 v3; // [rsp+30h] [rbp+8h]

  v1 = sub_14001B620(a1);
  v3 = *(_QWORD *)(v1 + 144);
  sub_14001DE54(&v3, v1, a1);
  return *(_QWORD *)v3;
}

//----- (0000000140020888) ----------------------------------------------------
__int64 __usercall sub_140020888@<rax>(int a1@<edx>, int a2@<ecx>, __m128i *a3@<r8>, __m256i *a4@<ymm0>)
{
  int v4; // esi
  __int64 v5; // rdi
  unsigned int v6; // eax
  int v7; // er9
  __int64 result; // rax
  char v9; // [rsp+40h] [rbp-40h]
  char v10; // [rsp+41h] [rbp-3Fh]
  char v11; // [rsp+42h] [rbp-3Eh]
  __int64 v12; // [rsp+48h] [rbp-38h]
  __m128i v13; // [rsp+50h] [rbp-30h]
  char v14; // [rsp+60h] [rbp-20h]
  int v15; // [rsp+68h] [rbp-18h]
  __int16 v16; // [rsp+6Ch] [rbp-14h]

  v4 = a1;
  v5 = a2;
  sub_14001590C(a3, (__int64)&v12, a4);
  if ( (unsigned int)(v5 + 1) <= 0x100 )
  {
    v6 = *(unsigned __int16 *)(*(_QWORD *)v13.m128i_i64[0] + 2 * v5);
    goto LABEL_11;
  }
  if ( *(_WORD *)(*(_QWORD *)v13.m128i_i64[0] + 2i64 * BYTE1(v5)) >= 0 )
  {
    v9 = v5;
    v7 = 1;
    v10 = 0;
  }
  else
  {
    v9 = BYTE1(v5);
    v7 = 2;
    v10 = v5;
    v11 = 0;
  }
  v15 = 0;
  v16 = 0;
  if ( (unsigned int)sub_1400233C0(1u, &v13, &v9, v7, a4, (WORD *)&v15, *(_DWORD *)(v13.m128i_i64[0] + 12), 1) )
  {
    v6 = (unsigned __int16)v15;
LABEL_11:
    result = v4 & v6;
    if ( v14 )
      *(_DWORD *)(v12 + 936) &= 0xFFFFFFFD;
    return result;
  }
  if ( v14 )
    *(_DWORD *)(v12 + 936) &= 0xFFFFFFFD;
  return 0i64;
}

//----- (0000000140020990) ----------------------------------------------------
unsigned __int64 __fastcall sub_140020990(signed __int16 *a1, char *a2, unsigned __int64 a3, _QWORD *a4, __int64 a5)
{
  signed __int16 *v5; // rbx
  unsigned __int64 result; // rax
  signed __int16 v7; // dx
  unsigned int v8; // [rsp+30h] [rbp-18h]

  v5 = a1;
  result = sub_1400275F0((__int64)&v8, a2, a3, a4, a5);
  if ( result <= 4 )
  {
    v7 = v8;
    if ( v8 > 0xFFFF )
      v7 = -3;
    if ( v5 )
      *v5 = v7;
  }
  return result;
}

//----- (00000001400209D4) ----------------------------------------------------
signed __int64 __fastcall sub_1400209D4(_WORD *a1, char **a2, unsigned __int64 a3, _QWORD *a4, __int64 a5)
{
  char *v5; // rdi
  _QWORD *v6; // r12
  unsigned __int64 v7; // rbp
  char **v8; // r15
  _WORD *v9; // r14
  _WORD *v10; // rbx
  __int64 v11; // r13
  unsigned __int64 v12; // r8
  __int64 v13; // rdx
  __int16 v14; // cx
  unsigned int v15; // ecx
  __int64 i; // rbx
  __int64 v18; // rbp
  unsigned __int64 v19; // r8
  __int64 v20; // rax
  unsigned int v21; // [rsp+60h] [rbp+8h]

  v5 = *a2;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( !a1 )
  {
    v18 = a5;
    for ( i = 0i64; ; ++i )
    {
      if ( *v5 )
        v19 = v5[1] ? (v5[2] != 0) + 3i64 : 2i64;
      else
        v19 = 1i64;
      v20 = sub_1400275F0(0i64, v5, v19, v6, v18);
      if ( v20 == -1 )
        break;
      if ( !v20 )
        return i;
      if ( v20 == 4 )
        ++i;
      v5 += v20;
    }
    *(_BYTE *)(v18 + 48) = 1;
    *(_DWORD *)(v18 + 44) = 42;
    return -1i64;
  }
  v10 = a1;
  if ( a3 )
  {
    v11 = a5;
    while ( 1 )
    {
      if ( *v5 )
        v12 = v5[1] ? (v5[2] != 0) + 3i64 : 2i64;
      else
        v12 = 1i64;
      v13 = sub_1400275F0((__int64)&v21, v5, v12, v6, v11);
      if ( v13 == -1 )
        break;
      if ( !v13 )
      {
        v5 = 0i64;
        *v10 = 0;
        goto LABEL_15;
      }
      v14 = v21;
      if ( v21 > 0xFFFF )
      {
        if ( v7 <= 1 )
          goto LABEL_15;
        v15 = v21 - 0x10000;
        v21 = v15;
        --v7;
        *v10 = (v15 >> 10) | 0xD800;
        ++v10;
        v14 = v15 & 0x3FF | 0xDC00;
      }
      *v10 = v14;
      v5 += v13;
      ++v10;
      if ( !--v7 )
        goto LABEL_15;
    }
    *v8 = v5;
    *(_BYTE *)(v11 + 48) = 1;
    *(_DWORD *)(v11 + 44) = 42;
    return -1i64;
  }
LABEL_15:
  *v8 = v5;
  return v10 - v9;
}

//----- (0000000140020B80) ----------------------------------------------------
char sub_140020B80()
{
  __int64 v0; // rbx

  v0 = 0i64;
  while ( sub_14001F444((LPCRITICAL_SECTION)&unk_140040F50 + v0, 0xFA0u) )
  {
    ++dword_140041180;
    v0 = (unsigned int)(v0 + 1);
    if ( (unsigned int)v0 >= 0xE )
      return 1;
  }
  sub_140020BF0();
  return 0;
}
// 140041180: using guessed type int dword_140041180;

//----- (0000000140020BC8) ----------------------------------------------------
void __fastcall sub_140020BC8(int a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)&unk_140040F50 + a1);
}

//----- (0000000140020BF0) ----------------------------------------------------
char sub_140020BF0()
{
  int v0; // ebx

  v0 = dword_140041180;
  while ( v0 )
  {
    DeleteCriticalSection((LPCRITICAL_SECTION)&unk_140040F50 + (unsigned int)--v0);
    --dword_140041180;
  }
  return 1;
}
// 140041180: using guessed type int dword_140041180;

//----- (0000000140020C28) ----------------------------------------------------
void __fastcall sub_140020C28(int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)&unk_140040F50 + a1);
}

//----- (0000000140020C44) ----------------------------------------------------
__int64 __usercall sub_140020C44@<rax>(int *a1@<rdx>, signed int **a2@<r8>, int *a3@<r9>, __m256i *a4@<ymm0>)
{
  int *v4; // rdi
  signed int **v5; // rbx
  void *v6; // rax
  unsigned int v7; // ebx
  DWORD v8; // ebx

  v4 = a3;
  v5 = a2;
  sub_140018234(*a1);
  if ( !(*(_BYTE *)(qword_140040970[(signed __int64)**v5 >> 6] + 72i64 * (**v5 & 0x3F) + 56) & 1) )
    goto LABEL_4;
  v6 = (void *)sub_140018540(**v5, a4);
  v7 = 0;
  if ( !FlushFileBuffers(v6) )
  {
    v8 = GetLastError();
    *(_DWORD *)sub_140015314() = v8;
LABEL_4:
    *(_DWORD *)sub_140015334() = 9;
    v7 = -1;
  }
  sub_14001831C(*v4);
  return v7;
}

//----- (0000000140020CD0) ----------------------------------------------------
__int64 __usercall sub_140020CD0@<rax>(signed int a1@<ecx>, __m256i *a2@<ymm0>)
{
  int *v3; // [rsp+20h] [rbp-18h]
  int v4; // [rsp+40h] [rbp+8h]
  int v5; // [rsp+50h] [rbp+18h]
  int v6; // [rsp+58h] [rbp+20h]

  v4 = a1;
  if ( a1 == -2 )
  {
    *(_DWORD *)sub_140015334() = 9;
  }
  else
  {
    if ( a1 >= 0
      && a1 < (unsigned int)dword_140040D70
      && *(_BYTE *)(qword_140040970[(signed __int64)a1 >> 6] + 72i64 * (a1 & 0x3F) + 56) & 1 )
    {
      v5 = a1;
      v6 = a1;
      v3 = &v4;
      return sub_140020C44(&v6, &v3, &v5, a2);
    }
    *(_DWORD *)sub_140015334() = 9;
    sub_14001ADB4(a2);
  }
  return 0xFFFFFFFFi64;
}
// 140040D70: using guessed type int dword_140040D70;

//----- (0000000140020D64) ----------------------------------------------------
__int64 __usercall sub_140020D64@<rax>(__int64 a1@<rdx>, _WORD *a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  unsigned int v4; // ebx
  _DWORD *v5; // rax
  _WORD *v7; // r9
  __int64 v8; // r8
  __int16 v9; // ax

  v4 = 0;
  if ( !a2 || !a1 )
  {
LABEL_5:
    v5 = sub_140015334();
    v4 = 22;
LABEL_6:
    *v5 = v4;
    sub_14001ADB4(a4);
    return v4;
  }
  if ( !a3 )
  {
    *a2 = 0;
    goto LABEL_5;
  }
  v7 = a2;
  v8 = a3 - (_QWORD)a2;
  while ( 1 )
  {
    v9 = *(_WORD *)((char *)v7 + v8);
    *v7 = v9;
    ++v7;
    if ( !v9 )
      return v4;
    if ( !--a1 )
    {
      *a2 = 0;
      v5 = sub_140015334();
      v4 = 34;
      goto LABEL_6;
    }
  }
}

//----- (0000000140020DCC) ----------------------------------------------------
LPVOID __fastcall sub_140020DCC(LPVOID lpMem, SIZE_T dwBytes)
{
  SIZE_T v2; // rbx
  void *v3; // rdi
  LPVOID result; // rax

  v2 = dwBytes;
  v3 = lpMem;
  if ( !lpMem )
    return sub_14001DACC(dwBytes);
  if ( !dwBytes )
  {
    sub_14001AE1C(lpMem);
    return 0i64;
  }
  if ( dwBytes > 0xFFFFFFFFFFFFFFE0ui64 )
  {
LABEL_6:
    *(_DWORD *)sub_140015334() = 12;
    return 0i64;
  }
  while ( 1 )
  {
    result = HeapReAlloc(hHeap, 0, v3, v2);
    if ( result )
      return result;
    if ( !(unsigned int)sub_14001A28C() || !(unsigned int)sub_140023B10(v2) )
      goto LABEL_6;
  }
}

//----- (0000000140020E48) ----------------------------------------------------
__int64 __usercall sub_140020E48@<rax>(LPVOID lpMem@<rcx>, int a2@<edx>, __m256i *a3@<ymm0>)
{
  unsigned int v3; // esi
  int v4; // ebx
  _BYTE *v5; // r15
  void *v6; // rdi
  _BYTE *v7; // rax
  _BYTE *v8; // r13
  _BYTE *v9; // r14
  char v10; // bp
  unsigned int v11; // ebp
  unsigned __int8 *v13; // rax
  signed __int64 v14; // r12
  char *v15; // rbx
  signed __int64 v16; // rbx
  void *v17; // rbx
  unsigned __int64 v18; // rbx
  unsigned __int64 v19; // rdx
  _QWORD *v20; // r14
  signed __int64 v21; // r14
  _BYTE *v22; // rax
  _BYTE *v23; // rbx
  char v24; // [rsp+70h] [rbp+8h]
  int v25; // [rsp+78h] [rbp+10h]

  v25 = a2;
  v3 = 0;
  v4 = a2;
  v5 = lpMem;
  if ( lpMem )
  {
    v6 = lpMem;
    v7 = sub_14000D488((__int64)lpMem, 0x3Du);
    v8 = v7;
    if ( !v7 || v7 == v5 )
    {
      *(_DWORD *)sub_140015334() = 22;
      sub_14001AE1C(v5);
      return -1i64;
    }
    v9 = qword_1400408F0;
    v10 = v7[1];
    v24 = v7[1];
    if ( qword_1400408F0 == (LPVOID)qword_140040908 )
    {
      v9 = sub_140021504((__int64 *)qword_1400408F0, a3);
      qword_1400408F0 = v9;
    }
    if ( !v9 )
    {
      if ( v4 && qword_1400408F8 )
      {
        if ( !sub_140019B60(a3) )
        {
          *(_DWORD *)sub_140015334() = 22;
LABEL_12:
          v11 = -1;
LABEL_13:
          sub_14001AE1C(v5);
          return v11;
        }
        v9 = qword_1400408F0;
        if ( qword_1400408F0 == (LPVOID)qword_140040908 )
        {
          v9 = sub_140021504((__int64 *)qword_1400408F0, a3);
          qword_1400408F0 = v9;
        }
      }
      else
      {
        if ( !v10 )
          goto LABEL_39;
        qword_1400408F0 = sub_14001F068(1ui64, 8ui64);
        sub_14001AE1C(0i64);
        v9 = qword_1400408F0;
        if ( !qword_1400408F0 )
          goto LABEL_12;
        if ( !qword_1400408F8 )
        {
          qword_1400408F8 = sub_14001F068(1ui64, 8ui64);
          sub_14001AE1C(0i64);
          if ( !qword_1400408F8 )
            goto LABEL_12;
          v9 = qword_1400408F0;
        }
      }
      if ( !v9 )
        goto LABEL_12;
    }
    v13 = *(unsigned __int8 **)v9;
    v14 = v8 - v5;
    v15 = v9;
    while ( v13 )
    {
      if ( !(unsigned int)sub_14002790C(v13, v5, v8 - v5, a3)
        && (*(_BYTE *)(v14 + *(_QWORD *)v15) == 61 || !*(_BYTE *)(v14 + *(_QWORD *)v15)) )
      {
        v16 = (v15 - v9) >> 3;
        goto LABEL_30;
      }
      v15 += 8;
      v13 = *(unsigned __int8 **)v15;
    }
    v16 = -((v15 - v9) >> 3);
LABEL_30:
    if ( v16 >= 0 && *(_QWORD *)v9 )
    {
      sub_14001AE1C(*(LPVOID *)&v9[8 * v16]);
      if ( !v10 )
      {
        while ( *(_QWORD *)&v9[8 * v16] )
        {
          *(_QWORD *)&v9[8 * v16] = *(_QWORD *)&v9[8 * v16 + 8];
          ++v16;
        }
        v17 = (void *)sub_14002395C(v9, v16, 8ui64, a3);
        sub_14001AE1C(0i64);
        if ( v17 )
          qword_1400408F0 = v17;
LABEL_45:
        if ( v25 )
        {
          v21 = -1i64;
          do
            ++v21;
          while ( v5[v21] );
          v22 = sub_14001F068(v21 + 2, 1ui64);
          v23 = v22;
          if ( !v22 )
          {
            sub_14001AE1C(0i64);
LABEL_53:
            sub_14001AE1C(v6);
            return v3;
          }
          if ( (unsigned int)sub_14001A94C(v21 + 2, v22, (__int64)v5, a3) )
          {
            sub_14001ADD4(a3);
            __debugbreak();
            JUMPOUT(*(_QWORD *)sub_1400211A0);
          }
          v8[v23 - v5] = 0;
          if ( !(unsigned int)sub_140027A24(
                                (const CHAR *)((unsigned __int64)&v8[v23 - v5 + 1] & -(signed __int64)(v24 != 0)),
                                v23,
                                a3) )
          {
            *(_DWORD *)sub_140015334() = 42;
            sub_14001AE1C(v23);
            v3 = -1;
            goto LABEL_53;
          }
          sub_14001AE1C(v23);
        }
        sub_14001AE1C(v6);
        return 0i64;
      }
      *(_QWORD *)&v9[8 * v16] = v5;
LABEL_44:
      v6 = 0i64;
      goto LABEL_45;
    }
    if ( v10 )
    {
      v18 = -v16;
      v19 = v18 + 2;
      if ( v18 + 2 < v18 )
        goto LABEL_12;
      if ( v19 >= 0x1FFFFFFFFFFFFFFFi64 )
        goto LABEL_12;
      v20 = (_QWORD *)sub_14002395C(v9, v19, 8ui64, a3);
      sub_14001AE1C(0i64);
      if ( !v20 )
        goto LABEL_12;
      v20[v18] = v5;
      v20[v18 + 1] = 0i64;
      qword_1400408F0 = v20;
      goto LABEL_44;
    }
LABEL_39:
    v11 = 0;
    goto LABEL_13;
  }
  *(_DWORD *)sub_140015334() = 22;
  return -1i64;
}
// 140040900: using guessed type __int64 qword_140040900;
// 140040908: using guessed type __int64 qword_140040908;

//----- (00000001400211A0) ----------------------------------------------------
__int64 __usercall sub_1400211A0@<rax>(LPVOID lpMem@<rcx>, int a2@<edx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  unsigned int v5; // esi
  int v6; // ebp
  __m128i *v7; // r15
  void *v8; // rdi
  const __m128i *v9; // rax
  const __m128i *v10; // r13
  _BYTE *v11; // r14
  __int16 v12; // r12
  unsigned int v13; // ebp
  __m128i *v15; // rax
  unsigned __int64 v16; // r13
  char *v17; // rbx
  signed __int64 v18; // rbx
  void *v19; // rbx
  unsigned __int64 v20; // rbx
  unsigned __int64 v21; // rdx
  _QWORD *v22; // r14
  signed __int64 v23; // r14
  signed __int64 v24; // r14
  _WORD *v25; // rax
  _WORD *v26; // rbx

  v5 = 0;
  v6 = a2;
  v7 = (__m128i *)lpMem;
  if ( lpMem )
  {
    v8 = lpMem;
    v9 = sub_14000D644((const __m128i *)lpMem, 0x3Du);
    v10 = v9;
    if ( !v9 || v9 == v7 )
    {
      *(_DWORD *)sub_140015334() = 22;
      sub_14001AE1C(v7);
      return -1i64;
    }
    v11 = qword_1400408F8;
    v12 = WORD1(v9->m128i_i64[0]);
    if ( qword_1400408F8 == (LPVOID)qword_140040900 )
    {
      v11 = sub_1400215EC((__int64 *)qword_1400408F8, a4);
      qword_1400408F8 = v11;
    }
    if ( !v11 )
    {
      if ( v6 && qword_1400408F0 )
      {
        if ( !sub_140019B9C(a4) )
        {
          *(_DWORD *)sub_140015334() = 22;
LABEL_12:
          v13 = -1;
LABEL_13:
          sub_14001AE1C(v7);
          return v13;
        }
        v11 = qword_1400408F8;
        if ( qword_1400408F8 == (LPVOID)qword_140040900 )
        {
          v11 = sub_1400215EC((__int64 *)qword_1400408F8, a4);
          qword_1400408F8 = v11;
        }
        goto LABEL_21;
      }
      if ( !v12 )
        goto LABEL_39;
      if ( qword_1400408F0 )
        goto LABEL_63;
      qword_1400408F0 = sub_14001F068(1ui64, 8ui64);
      sub_14001AE1C(0i64);
      if ( !qword_1400408F0 )
        goto LABEL_12;
      v11 = qword_1400408F8;
      if ( !qword_1400408F8 )
      {
LABEL_63:
        qword_1400408F8 = sub_14001F068(1ui64, 8ui64);
        sub_14001AE1C(0i64);
        v11 = qword_1400408F8;
        if ( !qword_1400408F8 )
          goto LABEL_12;
LABEL_21:
        if ( !v11 )
          goto LABEL_12;
        goto LABEL_22;
      }
    }
LABEL_22:
    v15 = *(__m128i **)v11;
    v16 = ((char *)v10 - (char *)v7) >> 1;
    v17 = v11;
    while ( v15 )
    {
      if ( !(unsigned int)sub_1400277CC(v15, v7, v16, a3, a4, a5)
        && (*(_WORD *)(*(_QWORD *)v17 + 2 * v16) == 61 || !*(_WORD *)(*(_QWORD *)v17 + 2 * v16)) )
      {
        v18 = (v17 - v11) >> 3;
        goto LABEL_30;
      }
      v17 += 8;
      v15 = *(__m128i **)v17;
    }
    v18 = -((v17 - v11) >> 3);
LABEL_30:
    if ( v18 >= 0 && *(_QWORD *)v11 )
    {
      sub_14001AE1C(*(LPVOID *)&v11[8 * v18]);
      if ( !v12 )
      {
        while ( *(_QWORD *)&v11[8 * v18] )
        {
          *(_QWORD *)&v11[8 * v18] = *(_QWORD *)&v11[8 * v18 + 8];
          ++v18;
        }
        v19 = (void *)sub_14002395C(v11, v18, 8ui64, a4);
        sub_14001AE1C(0i64);
        if ( v19 )
          qword_1400408F8 = v19;
LABEL_45:
        if ( v6 )
        {
          v23 = -1i64;
          do
            ++v23;
          while ( *((_WORD *)v7->m128i_i64 + v23) );
          v24 = v23 + 2;
          v25 = sub_14001F068(v24, 2ui64);
          v26 = v25;
          if ( !v25 )
          {
            sub_14001AE1C(0i64);
LABEL_53:
            sub_14001AE1C(v8);
            return v5;
          }
          if ( (unsigned int)sub_140020D64(v24, v25, (__int64)v7, a4) )
          {
            sub_14001ADD4(a4);
            __debugbreak();
            JUMPOUT(*(_QWORD *)sub_140021504);
          }
          v26[v16] = 0;
          if ( !SetEnvironmentVariableW(v26, (LPCWSTR)((unsigned __int64)&v26[v16 + 1] & -(signed __int64)(v12 != 0))) )
          {
            *(_DWORD *)sub_140015334() = 42;
            sub_14001AE1C(v26);
            v5 = -1;
            goto LABEL_53;
          }
          sub_14001AE1C(v26);
        }
        sub_14001AE1C(v8);
        return 0i64;
      }
      *(_QWORD *)&v11[8 * v18] = v7;
LABEL_44:
      v8 = 0i64;
      goto LABEL_45;
    }
    if ( v12 )
    {
      v20 = -v18;
      v21 = v20 + 2;
      if ( v20 + 2 < v20 )
        goto LABEL_12;
      if ( v21 >= 0x1FFFFFFFFFFFFFFFi64 )
        goto LABEL_12;
      v22 = (_QWORD *)sub_14002395C(v11, v21, 8ui64, a4);
      sub_14001AE1C(0i64);
      if ( !v22 )
        goto LABEL_12;
      v22[v20] = v7;
      v22[v20 + 1] = 0i64;
      qword_1400408F8 = v22;
      goto LABEL_44;
    }
LABEL_39:
    v13 = 0;
    goto LABEL_13;
  }
  *(_DWORD *)sub_140015334() = 22;
  return -1i64;
}
// 140040900: using guessed type __int64 qword_140040900;

//----- (0000000140021504) ----------------------------------------------------
_BYTE *__usercall sub_140021504@<rax>(__int64 *a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 *v2; // rdi
  __int64 v4; // rcx
  __int64 *i; // rax
  _BYTE *v6; // rbx
  __int64 v7; // rax
  signed __int64 v8; // r14
  signed __int64 v9; // rsi
  _BYTE *v10; // rcx

  v2 = a1;
  if ( !a1 )
    return 0i64;
  v4 = 0i64;
  for ( i = v2; *i; ++i )
    ++v4;
  v6 = sub_14001F068(v4 + 1, 8ui64);
  if ( !v6 )
LABEL_16:
    sub_14001A9AC(a2);
  v7 = *v2;
  if ( *v2 )
  {
    v8 = v6 - (_BYTE *)v2;
    while ( 1 )
    {
      v9 = -1i64;
      do
        ++v9;
      while ( *(_BYTE *)(v7 + v9) );
      *(__int64 *)((char *)v2 + v8) = (__int64)sub_14001F068(v9 + 1, 1ui64);
      sub_14001AE1C(0i64);
      v10 = *(_BYTE **)((char *)v2 + v8);
      if ( !v10 )
        goto LABEL_16;
      if ( (unsigned int)sub_14001A94C(v9 + 1, v10, *v2, a2) )
        break;
      ++v2;
      v7 = *v2;
      if ( !*v2 )
        goto LABEL_14;
    }
    sub_14001ADD4(a2);
    __debugbreak();
    goto LABEL_16;
  }
LABEL_14:
  sub_14001AE1C(0i64);
  return v6;
}

//----- (00000001400215EC) ----------------------------------------------------
_BYTE *__usercall sub_1400215EC@<rax>(__int64 *a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 *v2; // rdi
  __int64 v4; // rcx
  __int64 *i; // rax
  _BYTE *v6; // rbx
  __int64 v7; // rax
  signed __int64 v8; // r14
  signed __int64 v9; // rsi
  _WORD *v10; // rcx

  v2 = a1;
  if ( !a1 )
    return 0i64;
  v4 = 0i64;
  for ( i = v2; *i; ++i )
    ++v4;
  v6 = sub_14001F068(v4 + 1, 8ui64);
  if ( !v6 )
LABEL_16:
    sub_14001A9AC(a2);
  v7 = *v2;
  if ( *v2 )
  {
    v8 = v6 - (_BYTE *)v2;
    while ( 1 )
    {
      v9 = -1i64;
      do
        ++v9;
      while ( *(_WORD *)(v7 + 2 * v9) );
      *(__int64 *)((char *)v2 + v8) = (__int64)sub_14001F068(v9 + 1, 2ui64);
      sub_14001AE1C(0i64);
      v10 = *(_WORD **)((char *)v2 + v8);
      if ( !v10 )
        goto LABEL_16;
      if ( (unsigned int)sub_140020D64(v9 + 1, v10, *v2, a2) )
        break;
      ++v2;
      v7 = *v2;
      if ( !*v2 )
        goto LABEL_14;
    }
    sub_14001ADD4(a2);
    __debugbreak();
    goto LABEL_16;
  }
LABEL_14:
  sub_14001AE1C(0i64);
  return v6;
}

//----- (00000001400216EC) ----------------------------------------------------
signed __int64 __usercall sub_1400216EC@<rax>(_WORD *a1@<rdx>, unsigned int a2@<ecx>, unsigned __int64 a3@<r8>, unsigned int a4@<r9d>, __m256i *a5@<ymm0>, char a6)
{
  unsigned int v6; // ebp
  unsigned __int64 v7; // rsi
  _WORD *v8; // rbx
  unsigned int v9; // er10
  __int16 *v10; // r11
  unsigned __int64 v11; // rdi
  __int16 *v12; // r8
  __int16 *v13; // r9
  unsigned int v14; // ecx
  _WORD *v15; // rdx
  signed __int16 v16; // ax
  signed __int64 result; // rax
  __int16 v18; // cx

  v6 = a4;
  v7 = a3;
  v8 = a1;
  v9 = a2;
  v10 = a1;
  v11 = 0i64;
  if ( a6 )
  {
    v9 = -a2;
    *a1 = 45;
    v11 = 1i64;
    v10 = a1 + 1;
  }
  v12 = v10;
  do
  {
    v13 = v10;
    v14 = v9 % v6;
    v15 = v10 + 1;
    v9 /= v6;
    v16 = 87;
    if ( v14 <= 9 )
      v16 = 48;
    ++v11;
    *v10 = v14 + v16;
    if ( !v9 )
      break;
    ++v10;
  }
  while ( v11 < v7 );
  if ( v11 < v7 )
  {
    *v15 = 0;
    do
    {
      v18 = *v13;
      *v13 = *v12;
      --v13;
      *v12 = v18;
      ++v12;
    }
    while ( v12 < v13 );
    result = 0i64;
  }
  else
  {
    *v8 = 0;
    *(_DWORD *)sub_140015334() = 34;
    sub_14001ADB4(a5);
    result = 34i64;
  }
  return result;
}

//----- (00000001400217D0) ----------------------------------------------------
signed __int64 __usercall sub_1400217D0@<rax>(_WORD *a1@<rdx>, unsigned int a2@<ecx>, unsigned __int64 a3@<r8>, unsigned int a4@<r9d>, __m256i *a5@<ymm0>, unsigned __int8 a6)
{
  _DWORD *v6; // rax
  unsigned int v7; // ebx

  if ( !a1 || !a3 )
    goto LABEL_11;
  *a1 = 0;
  if ( a3 <= (unsigned __int64)a6 + 1 )
  {
    v6 = sub_140015334();
    v7 = 34;
    goto LABEL_3;
  }
  if ( a4 - 2 > 0x22 )
  {
LABEL_11:
    v6 = sub_140015334();
    v7 = 22;
LABEL_3:
    *v6 = v7;
    sub_14001ADB4(a5);
    return v7;
  }
  return sub_1400216EC(a1, a2, a3, a4, a5, a6);
}

//----- (000000014002183C) ----------------------------------------------------
signed __int64 __usercall sub_14002183C@<rax>(_WORD *a1@<rdx>, unsigned int a2@<ecx>, unsigned __int64 a3@<r8>, unsigned int a4@<r9d>, __m256i *a5@<ymm0>)
{
  return sub_1400217D0(a1, a2, a3, a4, a5, 0);
}

//----- (0000000140021850) ----------------------------------------------------
__int64 __usercall sub_140021850@<rax>(__int64 *a1@<rdx>, _QWORD *a2@<rcx>, __m128i *a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>)
{
  __m128i *v6; // r14
  __int64 *v7; // rdi
  _QWORD *v8; // rsi
  unsigned int v9; // ebx
  __int64 v10; // r14
  signed __int64 v11; // rax
  __int64 v12; // r15
  _WORD *v13; // rax

  v6 = a3;
  v7 = a1;
  v8 = a2;
  sub_140020BC8(11);
  v9 = 0;
  if ( !v8 )
    goto LABEL_19;
  *v8 = 0i64;
  if ( v7 )
    *v7 = 0i64;
  if ( v6 )
  {
    v10 = sub_140021948(v6, a4, a5, a6);
    if ( v10 )
    {
      v11 = -1i64;
      do
        ++v11;
      while ( *(_WORD *)(v10 + 2 * v11) );
      v12 = v11 + 1;
      v13 = (_WORD *)sub_140014F84(v11 + 1, 2i64);
      *v8 = v13;
      if ( v13 )
      {
        if ( (unsigned int)sub_140020D64(v12, v13, v10, a5) )
        {
          sub_14001ADD4(a5);
          JUMPOUT(*(_QWORD *)&byte_140021944);
        }
        if ( v7 )
          *v7 = v12;
      }
      else
      {
        *(_DWORD *)sub_140015334() = 12;
        v9 = 12;
      }
    }
  }
  else
  {
LABEL_19:
    v9 = 22;
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
  }
  sub_140020C28(11);
  return v9;
}
// 140014F84: using guessed type __int64 __fastcall sub_140014F84(_QWORD, _QWORD);
// 140021944: using guessed type char;

//----- (0000000140021948) ----------------------------------------------------
signed __int64 __usercall sub_140021948@<rax>(__m128i *a1@<rcx>, __int128 *a2@<xmm1>, __m256i *a3@<ymm0>, __m256i *a4@<ymm1>)
{
  __m128i *v4; // rsi
  __m128i **v5; // rax
  __m128i **v6; // rdi
  unsigned __int64 v7; // rbx
  __m128i *i; // rax
  unsigned __int64 v9; // rcx

  v4 = a1;
  v5 = (__m128i **)sub_140019B9C(a3);
  v6 = v5;
  if ( v5 && v4 )
  {
    v7 = -1i64;
    do
      ++v7;
    while ( *((_WORD *)v4->m128i_i64 + v7) );
    for ( i = *v5; i; i = *v6 )
    {
      v9 = -1i64;
      do
        ++v9;
      while ( *((_WORD *)i->m128i_i64 + v9) );
      if ( v9 > v7 && *((_WORD *)i->m128i_i64 + v7) == 61 && !(unsigned int)sub_1400277CC(v4, i, v7, a2, a3, a4) )
        return (signed __int64)(*v6)->m128i_i64 + 2 * v7 + 2;
      ++v6;
    }
  }
  return 0i64;
}

//----- (00000001400219E0) ----------------------------------------------------
__int64 __usercall sub_1400219E0@<rax>(_WORD *a1@<rdx>, unsigned __int64 *a2@<rcx>, unsigned __int64 a3@<r8>, __m128i *a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>)
{
  __m128i *v7; // r15
  unsigned __int64 v8; // rsi
  _WORD *v9; // rdi
  unsigned __int64 *v10; // r14
  unsigned int v11; // ebx
  signed int v12; // eax
  __int64 v13; // r8
  signed __int64 v14; // rax
  unsigned __int64 v15; // rax

  v7 = a4;
  v8 = a3;
  v9 = a1;
  v10 = a2;
  sub_140020BC8(11);
  v11 = 0;
  if ( !v10 )
    goto LABEL_2;
  *v10 = 0i64;
  if ( !v9 )
    goto LABEL_24;
  if ( v8 )
  {
LABEL_7:
    v12 = 1;
    goto LABEL_9;
  }
  if ( !v9 )
  {
LABEL_24:
    if ( !v8 )
      goto LABEL_7;
  }
  v12 = 0;
LABEL_9:
  if ( !v12 )
  {
LABEL_2:
    v11 = 22;
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a6);
    goto LABEL_19;
  }
  if ( v9 )
    *v9 = 0;
  v13 = sub_140021948(v7, a5, a6, a7);
  if ( v13 )
  {
    v14 = -1i64;
    do
      ++v14;
    while ( *(_WORD *)(v13 + 2 * v14) );
    v15 = v14 + 1;
    *v10 = v15;
    if ( v8 )
    {
      if ( v15 <= v8 )
      {
        if ( (unsigned int)sub_140020D64(v8, v9, v13, a6) )
        {
          sub_14001ADD4(a6);
          JUMPOUT(*(_QWORD *)&byte_140021AD6);
        }
      }
      else
      {
        v11 = 34;
      }
    }
  }
LABEL_19:
  sub_140020C28(11);
  return v11;
}
// 140021AD6: using guessed type char;

//----- (0000000140021AD8) ----------------------------------------------------
__int64 __usercall sub_140021AD8@<rax>(__int64 *a1@<rdx>, _QWORD *a2@<rcx>, __m128i *a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>)
{
  return sub_140021850(a1, a2, a3, a4, a5, a6);
}

//----- (0000000140021B00) ----------------------------------------------------
__int64 __usercall sub_140021B00@<rax>(__int64 a1@<rdx>, _WORD *a2@<rcx>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  unsigned int v4; // ebx
  _WORD *v5; // r9
  _DWORD *v6; // rax
  __int64 v8; // r8
  __int16 v9; // ax

  v4 = 0;
  v5 = a2;
  if ( !a2 || !a1 )
  {
LABEL_5:
    v6 = sub_140015334();
    v4 = 22;
LABEL_6:
    *v6 = v4;
    sub_14001ADB4(a4);
    return v4;
  }
  if ( !a3 )
  {
    *a2 = 0;
    goto LABEL_5;
  }
  while ( *a2 )
  {
    ++a2;
    if ( !--a1 )
    {
      *v5 = 0;
      goto LABEL_5;
    }
  }
  v8 = a3 - (_QWORD)a2;
  while ( 1 )
  {
    v9 = *(_WORD *)((char *)a2 + v8);
    *a2 = v9;
    ++a2;
    if ( !v9 )
      return v4;
    if ( !--a1 )
    {
      *v5 = 0;
      v6 = sub_140015334();
      v4 = 34;
      goto LABEL_6;
    }
  }
}

//----- (0000000140021B78) ----------------------------------------------------
signed __int64 __usercall sub_140021B78@<rax>(unsigned int a1@<edx>, const WCHAR *a2@<rcx>, __m256i *a3@<ymm0>)
{
  unsigned int v3; // ebx
  int v5; // eax
  char FileInformation; // [rsp+20h] [rbp-38h]

  v3 = a1;
  if ( !a2 || a1 & 0xFFFFFFF9 )
  {
    *(_DWORD *)sub_140015314() = 0;
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a3);
    return 22i64;
  }
  if ( !GetFileAttributesExW(a2, 0, &FileInformation) )
  {
    v5 = GetLastError();
    sub_1400152A8(v5);
    return *(unsigned int *)sub_140015334();
  }
  if ( !(FileInformation & 0x10) && FileInformation & 1 && (v3 >> 1) & 1 )
  {
    *(_DWORD *)sub_140015314() = 5;
    *(_DWORD *)sub_140015334() = 13;
    return *(unsigned int *)sub_140015334();
  }
  return 0i64;
}

//----- (0000000140021C30) ----------------------------------------------------
__int64 __usercall sub_140021C30@<rax>(__m256i *a1@<ymm0>)
{
  sub_140027BC4();
  return sub_140021C44(a1);
}

//----- (0000000140021C44) ----------------------------------------------------
__int64 __usercall sub_140021C44@<rax>(__m256i *a1@<ymm0>)
{
  int i; // ebx
  __int64 v2; // rdi
  unsigned int v4; // [rsp+20h] [rbp-18h]

  v4 = 0;
  sub_140020BC8(8);
  for ( i = 0; i != dword_1400406C0; ++i )
  {
    v2 = *((_QWORD *)lpMem + i);
    if ( v2 )
    {
      sub_1400151DC(v2);
      if ( (*(_DWORD *)(v2 + 20) >> 13) & 1 )
      {
        if ( *(_QWORD *)(v2 + 40) )
        {
          sub_140010104(v2, a1);
          ++v4;
        }
      }
      sub_1400151E8(v2);
    }
  }
  sub_140020C28(8);
  return v4;
}
// 1400406C0: using guessed type int dword_1400406C0;

//----- (0000000140021CE0) ----------------------------------------------------
__int64 __usercall sub_140021CE0@<rax>(__int64 a1@<rdx>, _WORD *a2@<rcx>, __int64 a3@<r8>, signed __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  unsigned int v5; // er10
  __int64 v6; // r11
  _DWORD *v7; // rax
  unsigned int v8; // ebx
  __int64 v10; // rbx
  _WORD *v11; // rdx
  __int64 v12; // r8
  signed __int64 v13; // rdi
  __int16 v14; // ax
  __int16 v15; // ax
  signed __int64 v16; // rsi
  signed __int64 v17; // rax

  v5 = 0;
  v6 = a1;
  if ( a4 )
  {
    if ( !a2 )
      goto LABEL_4;
  }
  else if ( !a2 )
  {
    if ( !a1 )
      return v5;
    goto LABEL_4;
  }
  if ( !a1 )
  {
LABEL_4:
    v7 = sub_140015334();
    v8 = 22;
LABEL_5:
    *v7 = v8;
    sub_14001ADB4(a5);
    return v8;
  }
  if ( !a4 )
  {
    *a2 = 0;
    return v5;
  }
  if ( !a3 )
  {
    *a2 = 0;
    goto LABEL_4;
  }
  v10 = a3 - (_QWORD)a2;
  v11 = a2;
  v12 = v6;
  v13 = a4;
  if ( a4 == -1 )
  {
    while ( 1 )
    {
      v14 = *(_WORD *)((char *)v11 + v10);
      *v11 = v14;
      ++v11;
      if ( !v14 )
        break;
      if ( !--v12 )
        goto LABEL_24;
    }
  }
  else
  {
    while ( 1 )
    {
      v15 = *(_WORD *)((char *)v11 + v10);
      v16 = v13;
      *v11 = v15;
      ++v11;
      if ( !v15 )
        break;
      if ( --v12 )
      {
        if ( --v13 )
          continue;
      }
      v17 = v16 - 1;
      if ( !v12 )
        v17 = v16;
      if ( !v17 )
        *v11 = 0;
LABEL_24:
      if ( v12 )
        return v5;
      if ( a4 == -1 )
      {
        a2[v6 - 1] = 0;
        return 80;
      }
      *a2 = 0;
      v7 = sub_140015334();
      v8 = 34;
      goto LABEL_5;
    }
  }
  return v5;
}

//----- (0000000140021DE0) ----------------------------------------------------
char __fastcall sub_140021DE0(unsigned __int64 a1, unsigned __int64 a2)
{
  char result; // al

  if ( a1 >= a2 )
    result = a1 > a2;
  else
    result = -1;
  return result;
}

//----- (0000000140021DF4) ----------------------------------------------------
signed __int64 __usercall sub_140021DF4@<rax>(_QWORD *a1@<rdx>, __int64 *a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 *v3; // r15
  signed __int64 result; // rax
  _WORD *v5; // rax
  _BYTE *v6; // rsi
  _BYTE *v7; // rdi
  signed __int64 v8; // rbx
  const WCHAR *v9; // rax
  const WCHAR *v10; // r14
  const WCHAR *v11; // rcx
  unsigned int v12; // eax
  unsigned int v13; // esi
  unsigned __int16 v14; // ax
  unsigned __int16 v15; // dx
  char v16; // al
  signed __int64 v17; // r13
  HANDLE v18; // rbx
  signed __int64 v19; // r12
  __int64 v20; // rdx
  LPVOID *j; // rbx
  LPVOID *i; // rbx
  unsigned __int64 v23; // rdx
  _QWORD *v24; // rax
  signed __int64 v25; // rcx
  _BYTE *v26; // rax
  _BYTE *v27; // rbx
  LPVOID *v28; // rbx
  signed __int64 v29; // rcx
  __int64 *v30; // r14
  _WORD *v31; // r12
  signed __int64 v32; // r13
  __int64 v33; // r8
  signed __int64 v34; // r15
  signed __int64 v35; // r15
  LPVOID *v36; // rbx
  LPVOID lpMem[2]; // [rsp+30h] [rbp-D0h]
  __int64 v38; // [rsp+40h] [rbp-C0h]
  unsigned __int64 v39; // [rsp+48h] [rbp-B8h]
  _QWORD *v40; // [rsp+50h] [rbp-B0h]
  char FindFileData; // [rsp+60h] [rbp-A0h]
  __int16 v42; // [rsp+8Ch] [rbp-74h]
  __int16 v43; // [rsp+8Eh] [rbp-72h]
  __int16 v44; // [rsp+90h] [rbp-70h]
  char *v45; // [rsp+2B0h] [rbp+1B0h]

  v40 = a1;
  v3 = a2;
  if ( a1 )
  {
    *a1 = 0i64;
    v5 = (_WORD *)*a2;
    _mm_storeu_si128((__m128i *)lpMem, (__m128i)0i64);
    v6 = lpMem[1];
    v7 = lpMem[0];
    v38 = 0i64;
    while ( v5 )
    {
      LODWORD(v45) = 4128810;
      WORD2(v45) = 0;
      v8 = 35184372090881i64;
      v9 = sub_14001F920(v5, (__int16 *)&v45);
      v10 = (const WCHAR *)*v3;
      v11 = v9;
      if ( v9 )
      {
        if ( v9 != v10 )
        {
          do
          {
            v14 = *v11 - 47;
            if ( v14 <= 0x2Du && _bittest64(&v8, v14) )
              break;
            --v11;
          }
          while ( v11 != v10 );
        }
        if ( *v11 == 58 && v11 != v10 + 1 )
          goto LABEL_62;
        v15 = *v11 - 47;
        if ( v15 > 0x2Du || (v16 = 1, !_bittest64(&v8, v15)) )
          v16 = 0;
        v17 = (v11 - v10 + 1) & -(signed __int64)(v16 != 0);
        v18 = FindFirstFileExW(v10, 0, &FindFileData, 0, 0i64, 0);
        if ( v18 != (HANDLE)-1i64 )
        {
          v19 = (v6 - v7) >> 3;
          do
          {
            if ( v42 != 46 || v43 && (v43 != 46 || v44) )
            {
              v13 = sub_1400221E4((__int64)v10, (__int64)&v42, v17, lpMem, a3);
              if ( v13 )
              {
                FindClose(v18);
                goto LABEL_35;
              }
            }
          }
          while ( FindNextFileW(v18, (LPWIN32_FIND_DATAW)&FindFileData) );
          v6 = lpMem[1];
          v7 = lpMem[0];
          v20 = (_QWORD)(lpMem[1] - lpMem[0]) >> 3;
          if ( v19 != v20 )
            sub_140027C20(v20 - v19, (unsigned __int64)lpMem[0] + 8 * v19, 8ui64, (__int64)sub_140021DE0, a3);
          FindClose(v18);
        }
        else
        {
LABEL_62:
          v13 = sub_1400221E4(0i64, (__int64)v10, 0i64, lpMem, a3);
          if ( v13 )
          {
LABEL_35:
            v7 = lpMem[0];
            for ( i = (LPVOID *)lpMem[0]; i != lpMem[1]; ++i )
              sub_14001AE1C(*i);
            goto LABEL_47;
          }
          v6 = lpMem[1];
          v7 = lpMem[0];
        }
      }
      else
      {
        v12 = sub_1400221E4(0i64, *v3, 0i64, lpMem, a3);
        v7 = lpMem[0];
        v13 = v12;
        if ( v12 )
        {
          for ( j = (LPVOID *)lpMem[0]; j != lpMem[1]; ++j )
            sub_14001AE1C(*j);
LABEL_47:
          sub_14001AE1C(v7);
          return v13;
        }
        v6 = lpMem[1];
      }
      ++v3;
      v5 = (_WORD *)*v3;
    }
    v23 = 0i64;
    v39 = 0i64;
    v24 = v7;
    if ( v7 != v6 )
    {
      do
      {
        v25 = -1i64;
        do
          ++v25;
        while ( *(_WORD *)(*v24 + 2 * v25) );
        ++v24;
        v23 += v25 + 1;
      }
      while ( v24 != (_QWORD *)v6 );
      v39 = v23;
    }
    v26 = sub_140019454(((v6 - v7) >> 3) + 1, v23, 2ui64);
    v27 = v26;
    if ( !v26 )
    {
      sub_14001AE1C(0i64);
      v28 = (LPVOID *)v7;
      if ( v7 != v6 )
      {
        do
        {
          sub_14001AE1C(*v28);
          ++v28;
        }
        while ( v28 != (LPVOID *)v6 );
      }
      v13 = -1;
      goto LABEL_47;
    }
    v29 = (signed __int64)&v26[8 * (((v6 - v7) >> 3) + 1)];
    v30 = (__int64 *)v7;
    v45 = &v26[8 * (((v6 - v7) >> 3) + 1)];
    v31 = &v26[8 * (((v6 - v7) >> 3) + 1)];
    if ( v7 != v6 )
    {
      v32 = v26 - v7;
      do
      {
        v33 = *v30;
        v34 = -1i64;
        do
          ++v34;
        while ( *(_WORD *)(v33 + 2 * v34) );
        v35 = v34 + 1;
        if ( (unsigned int)sub_140021CE0(v39 - (((signed __int64)v31 - v29) >> 1), v31, v33, v35, a3) )
        {
          sub_14001ADD4(a3);
          JUMPOUT(*(_QWORD *)&byte_1400221E0);
        }
        v29 = (signed __int64)v45;
        *(__int64 *)((char *)v30 + v32) = (__int64)v31;
        ++v30;
        v31 += v35;
      }
      while ( v30 != (__int64 *)v6 );
    }
    *v40 = v27;
    sub_14001AE1C(0i64);
    v36 = (LPVOID *)v7;
    if ( v7 != v6 )
    {
      do
      {
        sub_14001AE1C(*v36);
        ++v36;
      }
      while ( v36 != (LPVOID *)v6 );
    }
    sub_14001AE1C(v7);
    result = 0i64;
  }
  else
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a3);
    result = 22i64;
  }
  return result;
}
// 1400221E0: using guessed type char;

//----- (00000001400221E4) ----------------------------------------------------
signed __int64 __usercall sub_1400221E4@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, signed __int64 a3@<r8>, LPVOID *a4@<r9>, __m256i *a5@<ymm0>)
{
  signed __int64 v5; // rbp
  LPVOID *v6; // rsi
  unsigned int v7; // edi
  signed __int64 v8; // r14
  __int64 v9; // r13
  __int64 v10; // r12
  unsigned __int64 v11; // rbp
  __int64 v13; // r15
  _WORD *v14; // rax
  _WORD *v15; // rbx
  char *v16; // r14
  char *v17; // rax
  unsigned __int64 v18; // r14
  __int64 v19; // rax

  v5 = -1i64;
  v6 = a4;
  v7 = 0;
  v8 = a3;
  v9 = a1;
  v10 = a2;
  do
    ++v5;
  while ( *(_WORD *)(a2 + 2 * v5) );
  v11 = v5 + 1;
  if ( v11 > ~a3 )
    return 12i64;
  v13 = v11 + a3 + 1;
  v14 = sub_14001F068(v11 + a3 + 1, 2ui64);
  v15 = v14;
  if ( v8 && (unsigned int)sub_140021CE0(v13, v14, v9, v8, a5)
    || (unsigned int)sub_140021CE0(v13 - v8, &v15[v8], v10, v11, a5) )
  {
    sub_14001ADD4(a5);
    JUMPOUT(*(_QWORD *)&byte_140022369);
  }
  v16 = (char *)v6[2];
  if ( v6[1] != v16 )
    goto LABEL_18;
  if ( *v6 )
  {
    v18 = (v16 - (_BYTE *)*v6) >> 3;
    if ( v18 <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      v19 = sub_14002395C(*v6, 2 * v18, 8ui64, a5);
      if ( v19 )
      {
        *v6 = (LPVOID)v19;
        v6[1] = (LPVOID)(v19 + 8 * v18);
        v6[2] = (LPVOID)(v19 + 16 * v18);
        sub_14001AE1C(0i64);
        goto LABEL_18;
      }
      sub_14001AE1C(0i64);
    }
  }
  else
  {
    *v6 = sub_14001F068(4ui64, 8ui64);
    sub_14001AE1C(0i64);
    v17 = (char *)*v6;
    if ( *v6 )
    {
      v6[1] = v17;
      v6[2] = v17 + 32;
LABEL_18:
      *(_QWORD *)v6[1] = v15;
      v6[1] = (char *)v6[1] + 8;
      goto LABEL_19;
    }
  }
  v7 = 12;
  sub_14001AE1C(v15);
LABEL_19:
  sub_14001AE1C(0i64);
  return v7;
}
// 140022369: using guessed type char;

//----- (0000000140022374) ----------------------------------------------------
void __usercall sub_140022374(int *a1@<rdx>, volatile signed __int32 ****a2@<r8>, int *a3@<r9>, __m256i *a4@<ymm0>)
{
  int *v4; // rdi
  volatile signed __int32 ****v5; // rbx
  _OWORD *v6; // rax
  _OWORD *v7; // rcx
  signed __int64 v8; // r8
  signed __int64 v9; // r9
  _OWORD *v10; // rax
  _OWORD *v11; // rcx
  LPVOID *v12; // rcx

  v4 = a3;
  v5 = a2;
  sub_140020BC8(*a1);
  v6 = (**v5)[17] + 6;
  v7 = (_OWORD *)qword_140041188;
  if ( !qword_140041188 )
    goto LABEL_7;
  if ( (**v5)[17] == (volatile signed __int32 *)-24i64 )
  {
    sub_14000D100(0i64, qword_140041188, 0x101ui64, a4);
LABEL_7:
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a4);
    v8 = 2i64;
    goto LABEL_8;
  }
  v8 = 2i64;
  v9 = 2i64;
  do
  {
    *v7 = *v6;
    v7[1] = v6[1];
    v7[2] = v6[2];
    v7[3] = v6[3];
    v7[4] = v6[4];
    v7[5] = v6[5];
    v7[6] = v6[6];
    v7 += 8;
    *(v7 - 1) = v6[7];
    v6 += 8;
    --v9;
  }
  while ( v9 );
  *(_BYTE *)v7 = *(_BYTE *)v6;
LABEL_8:
  v10 = (_OWORD *)((char *)(**v5)[17] + 281);
  v11 = (_OWORD *)qword_140041190;
  if ( !qword_140041190 )
  {
LABEL_13:
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a4);
    goto LABEL_14;
  }
  if ( (**v5)[17] == (volatile signed __int32 *)-281i64 )
  {
    sub_14000D100(0i64, qword_140041190, 0x100ui64, a4);
    goto LABEL_13;
  }
  do
  {
    *v11 = *v10;
    v11[1] = v10[1];
    v11[2] = v10[2];
    v11[3] = v10[3];
    v11[4] = v10[4];
    v11[5] = v10[5];
    v11[6] = v10[6];
    v11 += 8;
    *(v11 - 1) = v10[7];
    v10 += 8;
    --v8;
  }
  while ( v8 );
LABEL_14:
  if ( _InterlockedExchangeAdd(**v5[1], 0xFFFFFFFF) == 1 )
  {
    v12 = (LPVOID *)*v5[1];
    if ( *v12 != &unk_14003E440 )
      sub_14001AE1C(*v12);
  }
  **v5[1] = (**v5)[17];
  _InterlockedIncrement((**v5)[17]);
  sub_140020C28(*v4);
}
// 140041188: using guessed type __int64 qword_140041188;
// 140041190: using guessed type __int64 qword_140041190;

//----- (0000000140022544) ----------------------------------------------------
__int64 __usercall sub_140022544@<rax>(UINT a1@<ecx>, __m256i *a2@<ymm0>)
{
  UINT v2; // ebx
  UINT v3; // eax
  __int64 v5; // [rsp+20h] [rbp-28h]
  __int64 v6; // [rsp+28h] [rbp-20h]
  char v7; // [rsp+38h] [rbp-10h]

  v2 = a1;
  sub_14001590C(0i64, (__int64)&v5, a2);
  dword_1400411A0 = 0;
  switch ( v2 )
  {
    case 0xFFFFFFFE:
      dword_1400411A0 = 1;
      v3 = GetOEMCP();
LABEL_5:
      v2 = v3;
      break;
    case 0xFFFFFFFD:
      dword_1400411A0 = 1;
      v3 = GetACP();
      goto LABEL_5;
    case 0xFFFFFFFC:
      dword_1400411A0 = 1;
      v2 = *(_DWORD *)(v6 + 12);
      break;
  }
  if ( v7 )
    *(_DWORD *)(v5 + 936) &= 0xFFFFFFFD;
  return v2;
}
// 1400411A0: using guessed type int dword_1400411A0;

//----- (00000001400225C4) ----------------------------------------------------
char __usercall sub_1400225C4@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rbx
  signed __int64 v3; // rdx
  _WORD *v4; // rdi
  signed __int64 i; // rcx
  signed __int64 v6; // rdi
  char *v7; // rcx
  __int64 v8; // rbx
  char *v9; // rcx
  char result; // al

  v2 = a1;
  sub_14000D100(0i64, a1 + 24, 0x101ui64, a2);
  v3 = 0i64;
  v4 = (_WORD *)(v2 + 12);
  *(_QWORD *)(v2 + 4) = 0i64;
  *(_QWORD *)(v2 + 544) = 0i64;
  for ( i = 6i64; i; --i )
  {
    *v4 = 0;
    ++v4;
  }
  v6 = 0i64;
  do
  {
    v7 = (char *)&unk_14003E440 + v6++;
    v7[v2 - (_QWORD)&unk_14003E458 + 48] = v7[24];
  }
  while ( v6 < 257 );
  v8 = v2 - (_QWORD)&unk_14003E559;
  do
  {
    v9 = (char *)&unk_14003E440 + v3++;
    result = v9[281];
    v9[v8 + 562] = result;
  }
  while ( v3 < 256 );
  return result;
}

//----- (000000014002265C) ----------------------------------------------------
char __usercall sub_14002265C@<al>(__int64 a1@<rcx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rdi
  UINT v3; // ecx
  unsigned int v4; // eax
  char *v5; // rcx
  signed __int64 v6; // rbx
  BYTE v7; // al
  BYTE *v8; // rdx
  unsigned int v9; // er8
  __int64 i; // rcx
  char *v11; // rdx
  _BYTE *v12; // rax
  char v13; // cl
  unsigned int v14; // edx
  _BYTE *v15; // rcx
  struct _cpinfo CPInfo; // [rsp+50h] [rbp-B0h]
  char v18[256]; // [rsp+70h] [rbp-90h]
  char v19[256]; // [rsp+170h] [rbp+70h]
  char v20[256]; // [rsp+270h] [rbp+170h]
  char v21; // [rsp+370h] [rbp+270h]

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 != 65001 && GetCPInfo(v3, &CPInfo) )
  {
    v4 = 0;
    v5 = v18;
    v6 = 256i64;
    do
      *v5++ = v4++;
    while ( v4 < 0x100 );
    v7 = CPInfo.LeadByte[0];
    v8 = CPInfo.LeadByte;
    v18[0] = 32;
    while ( v7 )
    {
      v9 = v8[1];
      for ( i = v7; (unsigned int)i <= v9 && (unsigned int)i < 0x100; i = (unsigned int)(i + 1) )
        v18[i] = 32;
      v8 += 2;
      v7 = *v8;
    }
    sub_1400233C0(1u, 0i64, v18, 256, a2, (WORD *)&v21, *(_DWORD *)(v2 + 4), 0);
    sub_140028364(
      *(unsigned __int16 **)(v2 + 544),
      0i64,
      0x100u,
      v18,
      a2,
      256,
      (WCHAR *)v19,
      256,
      *(_DWORD *)(v2 + 4),
      0);
    sub_140028364(
      *(unsigned __int16 **)(v2 + 544),
      0i64,
      0x200u,
      v18,
      a2,
      256,
      (WCHAR *)v20,
      256,
      *(_DWORD *)(v2 + 4),
      0);
    v11 = &v21;
    v12 = (_BYTE *)(v2 + 25);
    do
    {
      if ( *v11 & 1 )
      {
        *v12 |= 0x10u;
        v13 = v19[(_QWORD)v12 - v2 - 25];
      }
      else if ( *v11 & 2 )
      {
        *v12 |= 0x20u;
        v13 = v20[(_QWORD)v12 - v2 - 25];
      }
      else
      {
        v13 = 0;
      }
      v12[256] = v13;
      v11 += 2;
      ++v12;
      --v6;
    }
    while ( v6 );
  }
  else
  {
    v14 = 0;
    v15 = (_BYTE *)(v2 + 25);
    do
    {
      if ( v14 - 97 + 32 > 0x19 )
      {
        if ( v14 - 97 > 0x19 )
        {
          LOBYTE(v12) = 0;
        }
        else
        {
          *v15 |= 0x20u;
          LOBYTE(v12) = v14 - 32;
        }
      }
      else
      {
        *v15 |= 0x10u;
        LOBYTE(v12) = v14 + 32;
      }
      v15[256] = (_BYTE)v12;
      ++v14;
      ++v15;
    }
    while ( v14 < 0x100 );
  }
  return (char)v12;
}
// 14002265C: using guessed type char var_710[256];
// 14002265C: using guessed type char var_610[256];
// 14002265C: using guessed type char var_510[256];

//----- (0000000140022844) ----------------------------------------------------
signed __int64 __usercall sub_140022844@<rax>(char a1@<dl>, UINT a2@<ecx>, __int64 a3@<r8>, volatile signed __int32 **a4@<r9>, __m256i *a5@<ymm0>)
{
  char v5; // r14
  UINT v6; // ebx
  UINT v7; // edi
  signed __int64 result; // rax
  _DWORD *v9; // rbx
  char *v10; // rcx
  signed __int64 v11; // rdx
  signed __int64 v12; // r8
  _OWORD *v13; // rax
  __int128 v14; // xmm1
  __int128 v15; // xmm0
  __int128 v16; // xmm1
  __int128 v17; // xmm0
  __int128 v18; // xmm1
  __int128 v19; // xmm0
  __int128 v20; // xmm1
  __int128 v21; // xmm0
  __int128 v22; // xmm1
  __int64 v23; // rax
  _OWORD *v24; // rcx
  char *v25; // rax
  __int128 v26; // xmm1
  __int128 v27; // xmm0
  __int128 v28; // xmm1
  __int128 v29; // xmm0
  __int128 v30; // xmm1
  __int128 v31; // xmm0
  __int128 v32; // xmm1
  __int128 v33; // xmm0
  __int128 v34; // xmm1
  __int64 v35; // rax
  unsigned int v36; // esi
  void *v37; // rcx
  int v38; // [rsp+24h] [rbp-C4h]
  int v39; // [rsp+28h] [rbp-C0h]
  void **v40; // [rsp+30h] [rbp-B8h]
  _QWORD **v41; // [rsp+38h] [rbp-B0h]
  char v42; // [rsp+40h] [rbp-A8h]
  void *retaddr; // [rsp+288h] [rbp+1A0h]
  _QWORD *v44; // [rsp+290h] [rbp+1A8h]
  __int64 v45; // [rsp+2A0h] [rbp+1B8h]
  volatile signed __int32 **v46; // [rsp+2A8h] [rbp+1C0h]

  v46 = a4;
  v45 = a3;
  v5 = a1;
  v6 = a2;
  sub_140022AB4(a4, a3, a5);
  v7 = sub_140022544(v6, a5);
  if ( v7 == *(_DWORD *)(*((_QWORD *)retaddr + 17) + 4i64) )
    return 0i64;
  v9 = sub_14001DACC(0x228ui64);
  if ( v9 )
  {
    v10 = &v42;
    v11 = 4i64;
    v12 = 4i64;
    v13 = (_OWORD *)*((_QWORD *)retaddr + 17);
    do
    {
      v14 = v13[1];
      *(_OWORD *)v10 = *v13;
      v15 = v13[2];
      *((_OWORD *)v10 + 1) = v14;
      v16 = v13[3];
      *((_OWORD *)v10 + 2) = v15;
      v17 = v13[4];
      *((_OWORD *)v10 + 3) = v16;
      v18 = v13[5];
      *((_OWORD *)v10 + 4) = v17;
      v19 = v13[6];
      *((_OWORD *)v10 + 5) = v18;
      v20 = v13[7];
      v13 += 8;
      *((_OWORD *)v10 + 6) = v19;
      v10 += 128;
      *((_OWORD *)v10 - 1) = v20;
      --v12;
    }
    while ( v12 );
    v21 = *v13;
    v22 = v13[1];
    v23 = *((_QWORD *)v13 + 4);
    *(_OWORD *)v10 = v21;
    *((_OWORD *)v10 + 1) = v22;
    *((_QWORD *)v10 + 4) = v23;
    v24 = v9;
    v25 = &v42;
    do
    {
      v26 = *((_OWORD *)v25 + 1);
      *v24 = *(_OWORD *)v25;
      v27 = *((_OWORD *)v25 + 2);
      v24[1] = v26;
      v28 = *((_OWORD *)v25 + 3);
      v24[2] = v27;
      v29 = *((_OWORD *)v25 + 4);
      v24[3] = v28;
      v30 = *((_OWORD *)v25 + 5);
      v24[4] = v29;
      v31 = *((_OWORD *)v25 + 6);
      v24[5] = v30;
      v32 = *((_OWORD *)v25 + 7);
      v25 += 128;
      v24[6] = v31;
      v24 += 8;
      *(v24 - 1) = v32;
      --v11;
    }
    while ( v11 );
    v33 = *(_OWORD *)v25;
    v34 = *((_OWORD *)v25 + 1);
    v35 = *((_QWORD *)v25 + 4);
    *v24 = v33;
    v24[1] = v34;
    *((_QWORD *)v24 + 4) = v35;
    *v9 = 0;
    v36 = sub_140022BEC((__int64)v9, v7, a5);
    if ( v36 == -1 )
    {
      *(_DWORD *)sub_140015334() = 22;
      sub_14001AE1C(v9);
      result = 0xFFFFFFFFi64;
    }
    else
    {
      if ( !v5 )
        sub_14001A1DC();
      if ( _InterlockedExchangeAdd(*((volatile signed __int32 **)retaddr + 17), 0xFFFFFFFF) == 1 )
      {
        v37 = (void *)*((_QWORD *)retaddr + 17);
        if ( v37 != &unk_14003E440 )
          sub_14001AE1C(v37);
      }
      *v9 = 1;
      *((_QWORD *)retaddr + 17) = v9;
      if ( !(*((_DWORD *)retaddr + 234) & dword_14003EA20) )
      {
        v40 = &retaddr;
        v41 = &v44;
        v38 = 5;
        v39 = 5;
        sub_140022374(&v39, (volatile signed __int32 ****)&v40, &v38, a5);
        if ( v5 )
          *(&off_14003E2C8 + 1) = *v44;
      }
      sub_14001AE1C(0i64);
      result = v36;
    }
  }
  else
  {
    sub_14001AE1C(0i64);
    result = 0xFFFFFFFFi64;
  }
  return result;
}
// 14003EA20: using guessed type int dword_14003EA20;

//----- (0000000140022AB4) ----------------------------------------------------
volatile signed __int32 *__usercall sub_140022AB4@<rax>(volatile signed __int32 **a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  volatile signed __int32 **v3; // rsi
  __int64 v4; // rdi
  volatile signed __int32 *v5; // rbx
  volatile signed __int32 *v6; // rax

  v3 = a1;
  v4 = a2;
  if ( dword_14003EA20 & *(_DWORD *)(a2 + 936) && *(_QWORD *)(a2 + 144) )
  {
    v5 = *(volatile signed __int32 **)(a2 + 136);
  }
  else
  {
    sub_140020BC8(5);
    v5 = *(volatile signed __int32 **)(v4 + 136);
    if ( v5 != *v3 )
    {
      if ( v5 && _InterlockedExchangeAdd(v5, 0xFFFFFFFF) == 1 && v5 != (volatile signed __int32 *)&unk_14003E440 )
        sub_14001AE1C((LPVOID)v5);
      v6 = *v3;
      *(_QWORD *)(v4 + 136) = *v3;
      _InterlockedIncrement(v6);
      v5 = v6;
    }
    sub_140020C28(5);
  }
  if ( !v5 )
    sub_14001A9AC(a3);
  return v5;
}
// 14003EA20: using guessed type int dword_14003EA20;

//----- (0000000140022B70) ----------------------------------------------------
char __usercall sub_140022B70@<al>(__m256i *a1@<ymm0>)
{
  __int64 v1; // rax

  if ( !byte_1400411A4 )
  {
    qword_140041190 = (__int64)&unk_14003E780;
    qword_140041198 = &unk_14003E440;
    qword_140041188 = (__int64)&unk_14003E670;
    v1 = sub_14001B6F4(a1);
    sub_140022844(1, 0xFFFFFFFD, v1, (volatile signed __int32 **)&qword_140041198, a1);
    byte_1400411A4 = 1;
  }
  return 1;
}
// 140041188: using guessed type __int64 qword_140041188;
// 140041190: using guessed type __int64 qword_140041190;
// 1400411A4: using guessed type char byte_1400411A4;

//----- (0000000140022BD0) ----------------------------------------------------
volatile signed __int32 *__usercall sub_140022BD0@<rax>(__m256i *a1@<ymm0>)
{
  __int64 v1; // rax

  v1 = sub_14001B620(a1);
  return sub_140022AB4((volatile signed __int32 **)&qword_140041198, v1, a1);
}

//----- (0000000140022BEC) ----------------------------------------------------
signed __int64 __usercall sub_140022BEC@<rax>(__int64 a1@<rdx>, UINT a2@<ecx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rsi
  const wchar_t *v4; // rbx
  UINT v5; // edi
  unsigned int v6; // er14
  _DWORD *v7; // rax
  signed int v8; // ebp
  _WORD *v9; // rdi
  signed __int64 i; // rcx
  bool v11; // zf
  BYTE *v12; // rcx
  unsigned int v13; // eax
  unsigned int v14; // edx
  __int64 v15; // rdi
  __int64 v16; // rdx
  _BYTE *v17; // rax
  signed __int64 v18; // rcx
  const wchar_t *v19; // rax
  __int64 v21; // rax
  _BYTE *v22; // r11
  signed __int64 v23; // r14
  char *v24; // r9
  unsigned __int8 *v25; // rdx
  unsigned int v26; // er8
  __int64 v27; // r10
  int v28; // edi
  int v29; // edi
  int v30; // edi
  __int16 *v31; // rdi
  _WORD *v32; // rdx
  signed __int64 v33; // rcx
  __int16 v34; // ax
  struct _cpinfo CPInfo; // [rsp+20h] [rbp-48h]

  v3 = a1;
  v4 = 0i64;
  v5 = sub_140022544(a2, a3);
  if ( !v5 )
  {
LABEL_57:
    sub_1400225C4(v3, a3);
    return 0i64;
  }
  v6 = 0;
  v7 = &unk_14003E890;
  v8 = 1;
  do
  {
    if ( *v7 == v5 )
    {
      sub_14000D100(0i64, v3 + 24, 0x101ui64, a3);
      v21 = v6;
      v22 = &unk_14003E880;
      v23 = 4i64;
      v24 = (char *)&unk_14003E890 + 48 * v21 + 16;
      do
      {
        v25 = (unsigned __int8 *)v24;
        if ( *v24 )
        {
          do
          {
            if ( !v25[1] )
              break;
            v26 = *v25;
            if ( v26 <= v25[1] )
            {
              v27 = v26 + 1;
              do
              {
                if ( (unsigned int)v27 >= 0x101 )
                  break;
                ++v26;
                *(_BYTE *)(v27 + v3 + 24) |= *v22;
                v27 = (unsigned int)(v27 + 1);
              }
              while ( v26 <= v25[1] );
            }
            v25 += 2;
          }
          while ( *v25 );
        }
        v24 += 8;
        ++v22;
        --v23;
      }
      while ( v23 );
      *(_DWORD *)(v3 + 4) = v5;
      *(_DWORD *)(v3 + 8) = 1;
      v28 = v5 - 932;
      if ( v28 )
      {
        v29 = v28 - 4;
        if ( v29 )
        {
          v30 = v29 - 13;
          if ( v30 )
          {
            if ( v30 == 1 )
              v4 = L"zh-TW";
          }
          else
          {
            v4 = L"ko-KR";
          }
        }
        else
        {
          v4 = L"zh-CN";
        }
      }
      else
      {
        v4 = L"ja-JP";
      }
      *(_QWORD *)(v3 + 544) = v4;
      v31 = (__int16 *)((char *)&unk_14003E890 + 48 * v21 + 4);
      v32 = (_WORD *)(v3 + 12);
      v33 = 6i64;
      do
      {
        v34 = *v31;
        ++v31;
        *v32 = v34;
        ++v32;
        --v33;
      }
      while ( v33 );
      goto LABEL_56;
    }
    ++v6;
    v7 += 12;
  }
  while ( v6 < 5 );
  if ( v5 == 65000 || !IsValidCodePage((unsigned __int16)v5) )
    return 0xFFFFFFFFi64;
  if ( v5 == 65001 )
  {
    *(_QWORD *)(v3 + 4) = 65001i64;
    *(_QWORD *)(v3 + 544) = 0i64;
    *(_DWORD *)(v3 + 24) = 0;
    *(_WORD *)(v3 + 28) = 0;
    goto LABEL_9;
  }
  if ( !GetCPInfo(v5, &CPInfo) )
  {
    if ( dword_1400411A0 )
      goto LABEL_57;
    return 0xFFFFFFFFi64;
  }
  sub_14000D100(0i64, v3 + 24, 0x101ui64, a3);
  v11 = CPInfo.MaxCharSize == 2;
  *(_DWORD *)(v3 + 4) = v5;
  *(_QWORD *)(v3 + 544) = 0i64;
  if ( v11 )
  {
    v12 = CPInfo.LeadByte;
    if ( CPInfo.LeadByte[0] )
    {
      do
      {
        if ( !v12[1] )
          break;
        v13 = v12[1];
        v14 = *v12;
        if ( v14 <= v13 )
        {
          v15 = v14 + 1;
          v16 = v13 - v14 + 1;
          do
          {
            *(_BYTE *)(v15 + v3 + 24) |= 4u;
            v15 = (unsigned int)(v15 + 1);
            --v16;
          }
          while ( v16 );
        }
        v12 += 2;
      }
      while ( *v12 );
    }
    v17 = (_BYTE *)(v3 + 26);
    v18 = 254i64;
    do
    {
      *v17++ |= 8u;
      --v18;
    }
    while ( v18 );
    switch ( *(_DWORD *)(v3 + 4) )
    {
      case 0x3A4:
        v19 = L"ja-JP";
        break;
      case 0x3A8:
        v19 = L"zh-CN";
        break;
      case 0x3B5:
        v19 = L"ko-KR";
        break;
      case 0x3B6:
        v19 = L"zh-TW";
        break;
      default:
        v19 = 0i64;
        break;
    }
    *(_QWORD *)(v3 + 544) = v19;
  }
  else
  {
    v8 = 0;
  }
  *(_DWORD *)(v3 + 8) = v8;
LABEL_9:
  v9 = (_WORD *)(v3 + 12);
  for ( i = 6i64; i; --i )
  {
    *v9 = 0;
    ++v9;
  }
LABEL_56:
  sub_14002265C(v3, a3);
  return 0i64;
}
// 140034978: using guessed type wchar_t aJaJp[6];
// 140034988: using guessed type wchar_t aZhCn[6];
// 140034998: using guessed type wchar_t aKoKr[6];
// 1400349A8: using guessed type wchar_t aZhTw[6];
// 1400411A0: using guessed type int dword_1400411A0;

//----- (0000000140022EAC) ----------------------------------------------------
CHAR *sub_140022EAC()
{
  LPWCH v0; // rax
  CHAR *v1; // rsi
  WCHAR *v2; // rbx
  char *v4; // rbp
  signed __int64 v5; // rax
  signed __int64 v6; // rbp
  int v7; // eax
  int v8; // er14
  CHAR *v9; // rax
  CHAR *v10; // rdi
  __int64 v11; // [rsp+28h] [rbp-20h]
  __int64 v12; // [rsp+28h] [rbp-20h]

  v0 = GetEnvironmentStringsW();
  v1 = 0i64;
  v2 = v0;
  if ( !v0 )
    return 0i64;
  v4 = (char *)v0;
  if ( *v0 )
  {
    do
    {
      v5 = -1i64;
      do
        ++v5;
      while ( *(_WORD *)&v4[2 * v5] );
      v4 += 2 * v5 + 2;
    }
    while ( *(_WORD *)v4 );
  }
  v6 = (v4 - (char *)v2 + 2) >> 1;
  LODWORD(v11) = 0;
  v7 = sub_1400203D8(0, 0, v2, v6, 0i64, v11, 0i64, 0i64);
  v8 = v7;
  if ( !v7 )
  {
LABEL_8:
    FreeEnvironmentStringsW(v2);
    return 0i64;
  }
  v9 = (CHAR *)sub_14001DACC(v7);
  v10 = v9;
  if ( !v9 )
  {
    sub_14001AE1C(0i64);
    goto LABEL_8;
  }
  LODWORD(v12) = v8;
  if ( sub_1400203D8(0, 0, v2, v6, v9, v12, 0i64, 0i64) )
  {
    sub_14001AE1C(0i64);
    v1 = v10;
  }
  else
  {
    sub_14001AE1C(v10);
  }
  FreeEnvironmentStringsW(v2);
  return v1;
}

//----- (0000000140022FBC) ----------------------------------------------------
LPWCH sub_140022FBC()
{
  LPWCH result; // rax
  WCHAR *v1; // rbp
  __m128i *v2; // rbx
  char *v3; // rsi
  signed __int64 v4; // rax
  unsigned __int64 v5; // rsi
  __m128i *v6; // rax
  __m128i *v7; // rdi

  result = GetEnvironmentStringsW();
  v1 = 0i64;
  v2 = (__m128i *)result;
  if ( result )
  {
    v3 = (char *)result;
    if ( *result )
    {
      do
      {
        v4 = -1i64;
        do
          ++v4;
        while ( *(_WORD *)&v3[2 * v4] );
        v3 += 2 * v4 + 2;
      }
      while ( *(_WORD *)v3 );
    }
    v5 = 2 * ((v3 - (char *)v2 + 2) >> 1);
    v6 = (__m128i *)sub_14001DACC(v5);
    v7 = v6;
    if ( v6 )
    {
      sub_14000CA50(v6, v2, v5);
      v1 = (WCHAR *)v7;
    }
    sub_14001AE1C(0i64);
    FreeEnvironmentStringsW((LPWCH)v2);
    result = v1;
  }
  return result;
}

//----- (0000000140023058) ----------------------------------------------------
char sub_140023058()
{
  return (*(_WORD *)(*(_QWORD *)(__readgsqword(0x30u) + 96) + 188i64) >> 8) & 1;
}

//----- (0000000140023074) ----------------------------------------------------
__int64 sub_140023074()
{
  return (unsigned int)(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(__readgsqword(0x30u) + 96) + 32i64) + 8i64) >> 31);
}

//----- (000000014002308C) ----------------------------------------------------
__int64 sub_14002308C()
{
  unsigned int v0; // ebx

  v0 = 0;
  if ( !(unsigned __int8)sub_140023074() )
    sub_14001F29C();
  LOBYTE(v0) = 1;
  return v0;
}

//----- (00000001400230C0) ----------------------------------------------------
__int64 sub_1400230C0()
{
  signed int v0; // eax

  v0 = dword_1400411A8;
  if ( !dword_1400411A8 )
    v0 = 0x4000;
  dword_1400411A8 = v0;
  return 0i64;
}
// 1400411A8: using guessed type int dword_1400411A8;

//----- (00000001400230DC) ----------------------------------------------------
__int64 __usercall sub_1400230DC@<rax>(__m256i *a1@<ymm0>)
{
  __int64 v1; // rax
  __int64 v3; // [rsp+30h] [rbp+8h]

  v1 = sub_14001B620(a1);
  v3 = *(_QWORD *)(v1 + 144);
  sub_14001DE54(&v3, v1, a1);
  return *(unsigned int *)(v3 + 12);
}

//----- (000000014002310C) ----------------------------------------------------
void __fastcall sub_14002310C(_QWORD *a1)
{
  _QWORD *v1; // rbx
  void *v2; // rcx
  void *v3; // rcx
  void *v4; // rcx
  void *v5; // rcx
  void *v6; // rcx
  void *v7; // rcx
  void *v8; // rcx
  void *v9; // rcx
  void *v10; // rcx
  void *v11; // rcx
  void *v12; // rcx
  void *v13; // rcx
  void *v14; // rcx

  if ( a1 )
  {
    v1 = a1;
    v2 = (void *)a1[3];
    if ( v2 != off_14003E998 )
      sub_14001AE1C(v2);
    v3 = (void *)v1[4];
    if ( v3 != off_14003E9A0 )
      sub_14001AE1C(v3);
    v4 = (void *)v1[5];
    if ( v4 != off_14003E9A8 )
      sub_14001AE1C(v4);
    v5 = (void *)v1[6];
    if ( v5 != off_14003E9B0 )
      sub_14001AE1C(v5);
    v6 = (void *)v1[7];
    if ( v6 != off_14003E9B8 )
      sub_14001AE1C(v6);
    v7 = (void *)v1[8];
    if ( v7 != off_14003E9C0 )
      sub_14001AE1C(v7);
    v8 = (void *)v1[9];
    if ( v8 != off_14003E9C8 )
      sub_14001AE1C(v8);
    v9 = (void *)v1[13];
    if ( v9 != off_14003E9E8 )
      sub_14001AE1C(v9);
    v10 = (void *)v1[14];
    if ( v10 != off_14003E9F0 )
      sub_14001AE1C(v10);
    v11 = (void *)v1[15];
    if ( v11 != off_14003E9F8 )
      sub_14001AE1C(v11);
    v12 = (void *)v1[16];
    if ( v12 != off_14003EA00 )
      sub_14001AE1C(v12);
    v13 = (void *)v1[17];
    if ( v13 != off_14003EA08 )
      sub_14001AE1C(v13);
    v14 = (void *)v1[18];
    if ( v14 != off_14003EA10 )
      sub_14001AE1C(v14);
  }
}
// 14003E998: using guessed type void *off_14003E998;
// 14003E9A0: using guessed type void *off_14003E9A0;
// 14003E9A8: using guessed type void *off_14003E9A8;
// 14003E9B0: using guessed type void *off_14003E9B0;
// 14003E9B8: using guessed type void *off_14003E9B8;
// 14003E9C0: using guessed type void *off_14003E9C0;
// 14003E9C8: using guessed type void *off_14003E9C8;
// 14003E9E8: using guessed type void *off_14003E9E8;
// 14003E9F0: using guessed type void *off_14003E9F0;
// 14003E9F8: using guessed type void *off_14003E9F8;
// 14003EA00: using guessed type void *off_14003EA00;
// 14003EA08: using guessed type void *off_14003EA08;
// 14003EA10: using guessed type void *off_14003EA10;

//----- (0000000140023218) ----------------------------------------------------
void __fastcall sub_140023218(void **a1)
{
  void **v1; // rbx
  void *v2; // rcx
  void *v3; // rcx
  void *v4; // rcx
  void *v5; // rcx
  void *v6; // rcx

  if ( a1 )
  {
    v1 = a1;
    v2 = *a1;
    if ( v2 != off_14003E980 )
      sub_14001AE1C(v2);
    v3 = v1[1];
    if ( v3 != off_14003E988 )
      sub_14001AE1C(v3);
    v4 = v1[2];
    if ( v4 != off_14003E990 )
      sub_14001AE1C(v4);
    v5 = v1[11];
    if ( v5 != off_14003E9D8 )
      sub_14001AE1C(v5);
    v6 = v1[12];
    if ( v6 != off_14003E9E0 )
      sub_14001AE1C(v6);
  }
}
// 14003E980: using guessed type void *off_14003E980;
// 14003E988: using guessed type void *off_14003E988;
// 14003E990: using guessed type void *off_14003E990;
// 14003E9D8: using guessed type void *off_14003E9D8;
// 14003E9E0: using guessed type void *off_14003E9E0;

//----- (0000000140023284) ----------------------------------------------------
void __fastcall sub_140023284(LPVOID *a1, __int64 a2)
{
  LPVOID *v2; // rdi
  LPVOID *i; // rbx

  v2 = &a1[a2];
  for ( i = a1; i != v2; ++i )
    sub_14001AE1C(*i);
}

//----- (00000001400232B8) ----------------------------------------------------
void __fastcall sub_1400232B8(LPVOID *a1)
{
  LPVOID *v1; // rbx

  if ( a1 )
  {
    v1 = a1;
    sub_140023284(a1, 7i64);
    sub_140023284(v1 + 7, 7i64);
    sub_140023284(v1 + 14, 12i64);
    sub_140023284(v1 + 26, 12i64);
    sub_140023284(v1 + 38, 2i64);
    sub_14001AE1C(v1[40]);
    sub_14001AE1C(v1[41]);
    sub_14001AE1C(v1[42]);
    sub_140023284(v1 + 44, 7i64);
    sub_140023284(v1 + 51, 7i64);
    sub_140023284(v1 + 58, 12i64);
    sub_140023284(v1 + 70, 12i64);
    sub_140023284(v1 + 82, 2i64);
    sub_14001AE1C(v1[84]);
    sub_14001AE1C(v1[85]);
    sub_14001AE1C(v1[86]);
    sub_14001AE1C(v1[87]);
  }
}

//----- (00000001400233C0) ----------------------------------------------------
__int64 __usercall sub_1400233C0@<rax>(DWORD a1@<edx>, __m128i *a2@<rcx>, const CHAR *a3@<r8>, int a4@<r9d>, __m256i *a5@<ymm0>, WORD *lpCharType, UINT a7, int a8)
{
  DWORD v8; // er13
  int v9; // er15
  const CHAR *v10; // r12
  UINT v11; // edi
  int v12; // eax
  __int64 v13; // r14
  unsigned int v14; // edi
  unsigned __int64 v15; // rcx
  signed __int64 v16; // rax
  void *v17; // rsp
  WCHAR *v18; // rbx
  WCHAR *v19; // rax
  int v20; // eax
  __int64 v22; // [rsp+0h] [rbp-30h]
  char v23; // [rsp+30h] [rbp+0h]
  __int64 v24; // [rsp+38h] [rbp+8h]
  __int64 v25; // [rsp+40h] [rbp+10h]
  char v26; // [rsp+50h] [rbp+20h]

  v8 = a1;
  v9 = a4;
  v10 = a3;
  sub_14001590C(a2, (__int64)&v24, a5);
  v11 = a7;
  if ( !a7 )
    v11 = *(_DWORD *)(v25 + 12);
  v12 = sub_14001FB10(v11, a8 != 0 ? 9 : 1, v10, v9, 0i64, 0);
  v13 = v12;
  if ( !v12 )
  {
    v14 = 0;
    goto LABEL_21;
  }
  v15 = (2i64 * v12 + 16) & -(signed __int64)(2i64 * v12 < (unsigned __int64)(2i64 * v12 + 16));
  if ( !v15 )
  {
    v18 = 0i64;
    goto LABEL_18;
  }
  if ( v15 <= 0x400 )
  {
    v16 = v15 + 15;
    if ( v15 + 15 <= v15 )
      v16 = 1152921504606846960i64;
    v17 = alloca(v16);
    v18 = (WCHAR *)&v23;
    if ( &v22 == (__int64 *)-48i64 )
    {
LABEL_18:
      v14 = 0;
      if ( !v18 )
        goto LABEL_21;
      goto LABEL_19;
    }
    *(_DWORD *)&v23 = 52428;
    goto LABEL_13;
  }
  v19 = (WCHAR *)sub_14001DACC(v15);
  v18 = v19;
  if ( v19 )
  {
    *(_DWORD *)v19 = 56797;
LABEL_13:
    v18 += 8;
  }
  if ( !v18 )
    goto LABEL_18;
  sub_14000D100(0i64, (__int64)v18, 2 * v13, a5);
  v20 = sub_14001FB10(v11, 1, v10, v9, v18, v13);
  if ( !v20 )
    goto LABEL_18;
  v14 = GetStringTypeW(v8, v18, v20, lpCharType);
LABEL_19:
  if ( *((_DWORD *)v18 - 4) == 56797 )
    sub_14001AE1C(v18 - 8);
LABEL_21:
  if ( v26 )
    *(_DWORD *)(v24 + 936) &= 0xFFFFFFFD;
  return v14;
}

//----- (0000000140023550) ----------------------------------------------------
signed __int64 __fastcall sub_140023550(__int64 a1)
{
  volatile signed __int32 *v1; // rax
  volatile signed __int32 *v2; // rax
  volatile signed __int32 *v3; // rax
  volatile signed __int32 *v4; // rax
  volatile signed __int32 **v5; // rax
  signed __int64 v6; // r8
  volatile signed __int32 *v7; // rdx
  __int64 v8; // rcx
  signed __int64 result; // rax

  _InterlockedIncrement((volatile signed __int32 *)(a1 + 16));
  v1 = *(volatile signed __int32 **)(a1 + 224);
  if ( v1 )
    _InterlockedIncrement(v1);
  v2 = *(volatile signed __int32 **)(a1 + 240);
  if ( v2 )
    _InterlockedIncrement(v2);
  v3 = *(volatile signed __int32 **)(a1 + 232);
  if ( v3 )
    _InterlockedIncrement(v3);
  v4 = *(volatile signed __int32 **)(a1 + 256);
  if ( v4 )
    _InterlockedIncrement(v4);
  v5 = (volatile signed __int32 **)(a1 + 56);
  v6 = 6i64;
  do
  {
    if ( *(v5 - 2) != (volatile signed __int32 *)&unk_14003E2D8 && *v5 )
      _InterlockedIncrement(*v5);
    if ( *(v5 - 3) )
    {
      v7 = *(v5 - 1);
      if ( v7 )
        _InterlockedIncrement(v7);
    }
    v5 += 4;
    --v6;
  }
  while ( v6 );
  v8 = *(_QWORD *)(a1 + 288);
  if ( v8 && (void **)v8 != &off_1400329F0 )
    result = (unsigned int)_InterlockedIncrement((volatile signed __int32 *)(v8 + 348));
  else
    result = 0x7FFFFFFFi64;
  return result;
}
// 1400329F0: using guessed type void *off_1400329F0;

//----- (00000001400235DC) ----------------------------------------------------
void __fastcall sub_1400235DC(LPVOID lpMem)
{
  void **v1; // rax
  char *v2; // rbx
  _DWORD *v3; // rax
  _DWORD *v4; // rcx
  _DWORD *v5; // rcx
  _DWORD *v6; // rax
  LPVOID *v7; // rsi
  signed __int64 v8; // rbp
  _DWORD **v9; // rdi
  _DWORD *v10; // rcx
  _DWORD *v11; // rcx

  v1 = (void **)*((_QWORD *)lpMem + 31);
  v2 = (char *)lpMem;
  if ( v1 )
  {
    if ( v1 != &off_14003E980 )
    {
      v3 = (_DWORD *)*((_QWORD *)lpMem + 28);
      if ( v3 )
      {
        if ( !*v3 )
        {
          v4 = (_DWORD *)*((_QWORD *)lpMem + 30);
          if ( v4 && !*v4 )
          {
            sub_14001AE1C(v4);
            sub_14002310C(*((_QWORD **)v2 + 31));
          }
          v5 = (_DWORD *)*((_QWORD *)v2 + 29);
          if ( v5 && !*v5 )
          {
            sub_14001AE1C(v5);
            sub_140023218(*((void ***)v2 + 31));
          }
          sub_14001AE1C(*((LPVOID *)v2 + 28));
          sub_14001AE1C(*((LPVOID *)v2 + 31));
        }
      }
    }
  }
  v6 = (_DWORD *)*((_QWORD *)v2 + 32);
  if ( v6 && !*v6 )
  {
    sub_14001AE1C((LPVOID)(*((_QWORD *)v2 + 33) - 254i64));
    sub_14001AE1C((LPVOID)(*((_QWORD *)v2 + 34) - 128i64));
    sub_14001AE1C((LPVOID)(*((_QWORD *)v2 + 35) - 128i64));
    sub_14001AE1C(*((LPVOID *)v2 + 32));
  }
  sub_14002377C(*((LPVOID *)v2 + 36));
  v7 = (LPVOID *)(v2 + 296);
  v8 = 6i64;
  v9 = (_DWORD **)(v2 + 56);
  do
  {
    if ( *(v9 - 2) != (_DWORD *)&unk_14003E2D8 )
    {
      v10 = *v9;
      if ( *v9 )
      {
        if ( !*v10 )
        {
          sub_14001AE1C(v10);
          sub_14001AE1C(*v7);
        }
      }
    }
    if ( *(v9 - 3) )
    {
      v11 = *(v9 - 1);
      if ( v11 )
      {
        if ( !*v11 )
          sub_14001AE1C(v11);
      }
    }
    ++v7;
    v9 += 4;
    --v8;
  }
  while ( v8 );
  sub_14001AE1C(v2);
}
// 14003E980: using guessed type void *off_14003E980;

//----- (000000014002377C) ----------------------------------------------------
void __fastcall sub_14002377C(LPVOID lpMem)
{
  void *v1; // rbx

  if ( lpMem )
  {
    v1 = lpMem;
    if ( lpMem != &off_1400329F0 && !*((_DWORD *)lpMem + 87) )
    {
      sub_1400232B8((LPVOID *)lpMem);
      sub_14001AE1C(v1);
    }
  }
}
// 1400329F0: using guessed type void *off_1400329F0;

//----- (00000001400237B4) ----------------------------------------------------
signed __int64 __fastcall sub_1400237B4(__int64 a1)
{
  signed __int64 result; // rax

  if ( a1 && (void **)a1 != &off_1400329F0 )
    result = (unsigned int)_InterlockedDecrement((volatile signed __int32 *)(a1 + 348));
  else
    result = 0x7FFFFFFFi64;
  return result;
}
// 1400329F0: using guessed type void *off_1400329F0;

//----- (00000001400237DC) ----------------------------------------------------
void __fastcall sub_1400237DC(__int64 a1)
{
  volatile signed __int32 *v1; // rax
  volatile signed __int32 *v2; // rax
  volatile signed __int32 *v3; // rax
  volatile signed __int32 *v4; // rax
  volatile signed __int32 **v5; // rax
  signed __int64 v6; // r8
  volatile signed __int32 *v7; // rdx

  if ( a1 )
  {
    _InterlockedAdd((volatile signed __int32 *)(a1 + 16), 0xFFFFFFFF);
    v1 = *(volatile signed __int32 **)(a1 + 224);
    if ( v1 )
      _InterlockedAdd(v1, 0xFFFFFFFF);
    v2 = *(volatile signed __int32 **)(a1 + 240);
    if ( v2 )
      _InterlockedAdd(v2, 0xFFFFFFFF);
    v3 = *(volatile signed __int32 **)(a1 + 232);
    if ( v3 )
      _InterlockedAdd(v3, 0xFFFFFFFF);
    v4 = *(volatile signed __int32 **)(a1 + 256);
    if ( v4 )
      _InterlockedAdd(v4, 0xFFFFFFFF);
    v5 = (volatile signed __int32 **)(a1 + 56);
    v6 = 6i64;
    do
    {
      if ( *(v5 - 2) != (volatile signed __int32 *)&unk_14003E2D8 && *v5 )
        _InterlockedAdd(*v5, 0xFFFFFFFF);
      if ( *(v5 - 3) )
      {
        v7 = *(v5 - 1);
        if ( v7 )
          _InterlockedAdd(v7, 0xFFFFFFFF);
      }
      v5 += 4;
      --v6;
    }
    while ( v6 );
    sub_1400237B4(*(_QWORD *)(a1 + 288));
  }
}

//----- (0000000140023884) ----------------------------------------------------
__int64 __usercall sub_140023884@<rax>(__m256i *a1@<ymm0>)
{
  __int64 v1; // rax
  __int64 *v2; // rdi
  __int64 v3; // rbx

  v1 = sub_14001B620(a1);
  v2 = (__int64 *)(v1 + 144);
  if ( !(*(_DWORD *)(v1 + 936) & dword_14003EA20) || (v3 = *v2) == 0 )
  {
    sub_140020BC8(4);
    v3 = sub_1400238F4(v2, qword_140040968[0]);
    sub_140020C28(4);
    if ( !v3 )
      sub_14001A9AC(a1);
  }
  return v3;
}
// 14003EA20: using guessed type int dword_14003EA20;
// 140040968: using guessed type __int64 qword_140040968[];

//----- (00000001400238F4) ----------------------------------------------------
__int64 __fastcall sub_1400238F4(__int64 *a1, __int64 a2)
{
  __int64 v2; // rdi
  wchar_t **v3; // rbx

  v2 = a2;
  if ( !a2 || !a1 )
    return 0i64;
  v3 = (wchar_t **)*a1;
  if ( *a1 != a2 )
  {
    *a1 = a2;
    sub_140023550(a2);
    if ( v3 )
    {
      sub_1400237DC((__int64)v3);
      if ( !*((_DWORD *)v3 + 4) && v3 != &off_14003E170 )
        sub_1400235DC(v3);
    }
  }
  return v2;
}
// 14003E170: using guessed type wchar_t *off_14003E170;

//----- (000000014002395C) ----------------------------------------------------
__int64 __usercall sub_14002395C@<rax>(LPVOID lpMem@<rcx>, unsigned __int64 a2@<rdx>, unsigned __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v5; // rbx
  void *v6; // rsi
  __int64 result; // rax
  SIZE_T v8; // rdi
  SIZE_T v9; // rbx
  LPVOID v10; // rax
  __int64 v11; // rsi

  v4 = a3;
  v5 = a2;
  v6 = lpMem;
  if ( a2 && 0xFFFFFFFFFFFFFFE0ui64 / a2 < a3 )
  {
    *(_DWORD *)sub_140015334() = 12;
    result = 0i64;
  }
  else
  {
    if ( lpMem )
      v8 = sub_140028418(lpMem, a4);
    else
      v8 = 0i64;
    v9 = v4 * v5;
    v10 = sub_140020DCC(v6, v9);
    v11 = (__int64)v10;
    if ( v10 )
    {
      if ( v8 < v9 )
        sub_14000D100(0i64, (__int64)v10 + v8, v9 - v8, a4);
    }
    result = v11;
  }
  return result;
}

//----- (0000000140023A00) ----------------------------------------------------
bool sub_140023A00()
{
  hHeap = GetProcessHeap();
  return hHeap != 0i64;
}

//----- (0000000140023A20) ----------------------------------------------------
char sub_140023A20()
{
  hHeap = 0i64;
  return 1;
}

//----- (0000000140023A2C) ----------------------------------------------------
char __fastcall sub_140023A2C(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rsi
  _QWORD *v3; // rdi
  _QWORD *v4; // rbx
  _QWORD *v5; // rbx

  v2 = a2;
  v3 = a1;
  if ( a1 == a2 )
    return 1;
  v4 = a1;
  do
  {
    if ( *v4 && !(unsigned __int8)sub_14002A5D0(a1) )
      break;
    v4 += 2;
  }
  while ( v4 != v2 );
  if ( v4 == v2 )
    return 1;
  if ( v4 != v3 )
  {
    v5 = v4 - 1;
    do
    {
      if ( *(v5 - 1) )
      {
        if ( *v5 )
          sub_14002A5D0(0i64);
      }
      v5 -= 2;
    }
    while ( v5 + 1 != v3 );
  }
  return 0;
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (0000000140023AC0) ----------------------------------------------------
char __fastcall sub_140023AC0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 i; // rdi

  v2 = a2;
  for ( i = a1; v2 != i; v2 -= 16i64 )
  {
    if ( *(_QWORD *)(v2 - 8) )
      sub_14002A5D0(0i64);
  }
  return 1;
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (0000000140023B08) ----------------------------------------------------
void __fastcall sub_140023B08(__int64 a1)
{
  qword_1400411C0 = a1;
}
// 1400411C0: using guessed type __int64 qword_1400411C0;

//----- (0000000140023B10) ----------------------------------------------------
__int64 __fastcall sub_140023B10(__int64 a1)
{
  __int64 v1; // rdi
  __int64 result; // rax
  unsigned int v3; // ebx

  v1 = a1;
  result = sub_140023B50();
  v3 = 0;
  if ( result )
  {
    LOBYTE(v3) = (unsigned int)sub_14002A5D0(v1) != 0;
    result = v3;
  }
  return result;
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);

//----- (0000000140023B50) ----------------------------------------------------
__int64 sub_140023B50()
{
  __int64 v0; // rbx

  sub_140020BC8(0);
  v0 = __ROR8__(_security_cookie ^ qword_1400411C0, _security_cookie & 0x3F);
  sub_140020C28(0);
  return v0;
}
// 1400411C0: using guessed type __int64 qword_1400411C0;

//----- (0000000140023B88) ----------------------------------------------------
__int64 __fastcall sub_140023B88(__int64 a1, int *a2, __int64 a3, int *a4)
{
  int *v4; // rdi
  __int64 v5; // rbx

  v4 = a4;
  sub_140020BC8(*a2);
  v5 = __ROR8__(_security_cookie ^ qword_1400411D8, _security_cookie & 0x3F);
  sub_140020C28(*v4);
  return v5;
}
// 1400411D8: using guessed type __int64 qword_1400411D8;

//----- (0000000140023BD0) ----------------------------------------------------
__int64 sub_140023BD0()
{
  __int64 v1; // [rsp+30h] [rbp+8h]
  int v2; // [rsp+38h] [rbp+10h]
  int v3; // [rsp+40h] [rbp+18h]

  v2 = 3;
  v3 = 3;
  return sub_140023B88((__int64)&v1, &v3, (__int64)&v1, &v2);
}

//----- (0000000140023C00) ----------------------------------------------------
void __fastcall sub_140023C00(__int64 a1)
{
  qword_1400411C8 = a1;
  qword_1400411D0 = a1;
  qword_1400411D8 = a1;
  qword_1400411E0 = a1;
}
// 1400411C8: using guessed type __int64 qword_1400411C8;
// 1400411D0: using guessed type __int64 qword_1400411D0;
// 1400411D8: using guessed type __int64 qword_1400411D8;
// 1400411E0: using guessed type __int64 qword_1400411E0;

//----- (0000000140023C20) ----------------------------------------------------
signed __int64 __usercall sub_140023C20@<rax>(unsigned int a1@<ecx>, __m256i *a2@<ymm0>)
{
  unsigned int v2; // ebx
  _QWORD *v3; // r15
  char v4; // r14
  unsigned int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  __int64 *v9; // rdi
  _QWORD *v10; // rax
  __int64 v12; // rax
  signed __int64 v13; // rcx
  __int64 v14; // r13
  __int64 v15; // rsi
  signed int v16; // er12
  signed __int64 v17; // rax
  signed __int64 v18; // rcx
  int v19; // edx
  int v20; // [rsp+78h] [rbp+10h]

  v2 = a1;
  v3 = 0i64;
  v20 = 0;
  v4 = 1;
  if ( a1 != 2 )
  {
    switch ( a1 )
    {
      case 4u:
        goto LABEL_63;
      case 6u:
        goto LABEL_9;
      case 8u:
      case 0xBu:
LABEL_63:
        v10 = (_QWORD *)sub_14001B798();
        v3 = v10;
        if ( !v10 )
          return 0xFFFFFFFFi64;
        v12 = *v10;
        v13 = v12 + 192;
        while ( v12 != v13 )
        {
          if ( *(_DWORD *)(v12 + 4) == v2 )
            goto LABEL_23;
          v12 += 16i64;
        }
        v12 = 0i64;
LABEL_23:
        if ( v12 )
        {
          v9 = (__int64 *)(v12 + 8);
          v4 = 0;
          goto LABEL_30;
        }
        break;
      case 0xFu:
      case 0x15u:
      case 0x16u:
        goto LABEL_9;
    }
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a2);
    return 0xFFFFFFFFi64;
  }
LABEL_9:
  v5 = a1 - 2;
  if ( v5 )
  {
    v6 = v5 - 4;
    if ( !v6 )
    {
LABEL_26:
      v9 = &qword_1400411D8;
      goto LABEL_30;
    }
    v7 = v6 - 9;
    if ( v7 )
    {
      v8 = v7 - 6;
      if ( v8 )
      {
        if ( v8 != 1 )
        {
          v9 = 0i64;
          goto LABEL_30;
        }
        goto LABEL_26;
      }
      v9 = &qword_1400411D0;
    }
    else
    {
      v9 = &qword_1400411E0;
    }
  }
  else
  {
    v9 = &qword_1400411C8;
  }
LABEL_30:
  v14 = 0i64;
  if ( v4 )
    sub_140020BC8(3);
  v15 = *v9;
  if ( v4 )
    v15 = __ROR8__(_security_cookie ^ v15, _security_cookie & 0x3F);
  if ( v15 == 1 )
  {
    v16 = 2320;
    goto LABEL_46;
  }
  if ( !v15 )
  {
    if ( v4 )
      sub_140020C28(3);
    sub_140019FC0(3u);
    JUMPOUT(*(_QWORD *)&byte_140023E98);
  }
  v16 = 2320;
  if ( v2 > 0xB || !_bittest(&v16, v2) )
    goto LABEL_40;
  v14 = v3[1];
  v3[1] = 0i64;
  if ( v2 == 8 )
  {
    v20 = *(_DWORD *)(sub_14001B620(a2) + 16);
    *(_DWORD *)(sub_14001B620(a2) + 16) = 140;
LABEL_40:
    if ( v2 == 8 )
    {
      v17 = *v3 + 48i64;
      v18 = *v3 + 192i64;
      while ( v17 != v18 )
      {
        *(_QWORD *)(v17 + 8) = 0i64;
        v17 += 16i64;
      }
      goto LABEL_46;
    }
  }
  *v9 = _security_cookie;
LABEL_46:
  if ( v4 )
    sub_140020C28(3);
  if ( v15 != 1 )
  {
    if ( v2 == 8 )
    {
      v19 = *(_DWORD *)(sub_14001B620(a2) + 16);
      sub_14002A5D0(8i64);
    }
    else
    {
      sub_14002A5D0(v2);
    }
    if ( v2 <= 0xB && _bittest(&v16, v2) )
    {
      v3[1] = v14;
      if ( v2 == 8 )
        *(_DWORD *)(sub_14001B620(a2) + 16) = v20;
    }
  }
  return 0i64;
}
// 140023E98: using guessed type char byte_140023E98;
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);
// 1400411C8: using guessed type __int64 qword_1400411C8;
// 1400411D0: using guessed type __int64 qword_1400411D0;
// 1400411D8: using guessed type __int64 qword_1400411D8;
// 1400411E0: using guessed type __int64 qword_1400411E0;

//----- (0000000140023E9C) ----------------------------------------------------
__int64 __usercall sub_140023E9C@<rax>(signed int a1@<ecx>, __m256i *a2@<ymm0>)
{
  if ( a1 == -2 )
  {
    *(_DWORD *)sub_140015334() = 9;
  }
  else
  {
    if ( a1 >= 0 && a1 < (unsigned int)dword_140040D70 )
      return *(_BYTE *)(qword_140040970[(unsigned __int64)a1 >> 6] + 72i64 * (a1 & 0x3F) + 56) & 0x40;
    *(_DWORD *)sub_140015334() = 9;
    sub_14001ADB4(a2);
  }
  return 0i64;
}
// 140040D70: using guessed type int dword_140040D70;

//----- (0000000140023EFC) ----------------------------------------------------
__int64 __fastcall sub_140023EFC(__int64 a1)
{
  __int64 v1; // rbx
  signed int v2; // edi
  __int64 result; // rax

  v1 = a1;
  ++dword_1400406D0;
  v2 = 4096;
  *(_QWORD *)(a1 + 8) = sub_14001F068(0x1000ui64, 1ui64);
  sub_14001AE1C(0i64);
  if ( *(_QWORD *)(v1 + 8) )
  {
    _InterlockedOr((volatile signed __int32 *)(v1 + 20), 0x40u);
  }
  else
  {
    _InterlockedOr((volatile signed __int32 *)(v1 + 20), 0x400u);
    v2 = 2;
    *(_QWORD *)(v1 + 8) = v1 + 28;
  }
  *(_DWORD *)(v1 + 32) = v2;
  result = *(_QWORD *)(v1 + 8);
  *(_DWORD *)(v1 + 16) = 0;
  *(_QWORD *)v1 = result;
  return result;
}
// 1400406D0: using guessed type int dword_1400406D0;

//----- (0000000140023F68) ----------------------------------------------------
signed __int64 __fastcall sub_140023F68(unsigned __int16 a1)
{
  signed __int64 result; // rax
  unsigned __int16 Buffer; // [rsp+30h] [rbp+8h]
  DWORD NumberOfCharsWritten; // [rsp+38h] [rbp+10h]

  Buffer = a1;
  if ( (unsigned int)sub_140028454() && (unsigned int)sub_1400284CC(&Buffer, 1u, &NumberOfCharsWritten) )
    result = Buffer;
  else
    result = 0xFFFFi64;
  return result;
}

//----- (0000000140023FA4) ----------------------------------------------------
bool __fastcall sub_140023FA4(_BYTE *a1, _BYTE *a2, int a3, int a4, int a5)
{
  int v5; // edi
  int v6; // esi
  _BYTE *v7; // rbx
  _BYTE *v8; // rbp
  int v10; // eax
  char v11; // cl
  _BYTE *v12; // rax

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( !a5 )
    return *a2 >= 53;
  v10 = sub_140025944();
  if ( v10 )
  {
    if ( v10 == 512 )
    {
      v11 = 1;
      if ( !v5 )
        goto LABEL_32;
      while ( *v7 == 48 )
        ++v7;
      if ( *v7 )
      {
LABEL_32:
        if ( v6 != 45 )
          return v11;
      }
    }
    else
    {
      if ( v10 != 256 )
        return 0;
      v11 = 1;
      if ( !v5 )
        goto LABEL_33;
      while ( *v7 == 48 )
        ++v7;
      if ( *v7 )
      {
LABEL_33:
        if ( v6 == 45 )
          return v11;
      }
    }
    return 0;
  }
  v11 = 1;
  if ( *v7 > 53 )
    return v11;
  if ( *v7 < 53 )
    return 0;
  v12 = v7 + 1;
  if ( !v5 )
    return v11;
  while ( *v12 == 48 )
    ++v12;
  if ( *v12 )
    return v11;
  if ( v7 != v8 )
    return *(v7 - 1) & 1;
  return 0;
}

//----- (0000000140024074) ----------------------------------------------------
__int64 __usercall sub_140024074@<rax>(unsigned __int64 a1@<rdx>, _BYTE *a2@<rcx>, int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>, __int64 a6, int a7, __int64 a8)
{
  __int64 v8; // rdi
  _BYTE *v9; // rsi
  unsigned int v10; // ebx
  int v12; // eax
  _BYTE *v13; // rcx
  char *v14; // rbx
  char *v15; // rdx
  char v16; // al
  signed __int64 v17; // r8

  v8 = a4;
  v9 = a2;
  if ( !a2 || !a1 )
    goto LABEL_30;
  v12 = 0;
  *a2 = 0;
  if ( a3 > 0 )
    v12 = a3;
  if ( a1 <= v12 + 1 )
  {
    v10 = 34;
    goto LABEL_3;
  }
  if ( !a4 )
  {
LABEL_30:
    v10 = 22;
LABEL_3:
    *(_DWORD *)(a8 + 44) = v10;
    *(_BYTE *)(a8 + 48) = 1;
    sub_14001ACE8(0i64, a5, 0i64, (signed __int64 *)a8);
    return v10;
  }
  v13 = *(_BYTE **)(a4 + 8);
  v14 = v9 + 1;
  v15 = *(char **)(a4 + 8);
  *v9 = 48;
  while ( a3 > 0 )
  {
    v16 = *v15;
    if ( *v15 )
      ++v15;
    else
      v16 = 48;
    *v14++ = v16;
    --a3;
  }
  *v14 = 0;
  if ( a3 >= 0 && sub_140023FA4(v13, v15, *(_DWORD *)a4, a6, a7) )
  {
    while ( *--v14 == 57 )
      *v14 = 48;
    ++*v14;
  }
  if ( *v9 == 49 )
  {
    ++*(_DWORD *)(v8 + 4);
  }
  else
  {
    v17 = -1i64;
    do
      ++v17;
    while ( v9[v17 + 1] );
    sub_14000CA50((__m128i *)v9, (const __m128i *)(v9 + 1), v17 + 1);
  }
  return 0i64;
}

//----- (0000000140024190) ----------------------------------------------------
__int64 __usercall sub_140024190@<rax>(unsigned int *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  unsigned int *v3; // r15
  unsigned int *v4; // rsi
  unsigned int v5; // edi
  __int64 v6; // r10
  __int64 v7; // rbp
  unsigned __int64 v8; // r12
  unsigned int v9; // ebp
  unsigned int v10; // ebx
  __int64 result; // rax
  unsigned int v12; // edi
  __int64 v13; // r14
  unsigned __int64 i; // rdi
  __int64 v15; // r8
  unsigned __int64 v16; // r8
  signed __int64 v17; // rdx
  int v18; // er8
  int v19; // er9
  signed __int64 v20; // r11
  _DWORD *v21; // rcx
  unsigned int v22; // er9
  unsigned int v23; // er11
  bool v24; // zf
  int v25; // eax
  int v26; // ebx
  int v27; // er14
  unsigned int v28; // eax
  unsigned int v29; // er9
  unsigned int v30; // er11
  int v31; // er12
  __int64 v32; // r11
  __int64 v33; // r13
  unsigned int v34; // edx
  __int64 v35; // r11
  unsigned __int64 v36; // r8
  unsigned __int64 v37; // r9
  unsigned __int64 v38; // r8
  signed __int64 v39; // rax
  unsigned __int64 v40; // rax
  unsigned __int64 v41; // r10
  unsigned int v42; // er11
  unsigned int *v43; // r14
  __int64 v44; // rax
  unsigned __int64 v45; // r10
  unsigned int v46; // er8
  __int64 v47; // rcx
  unsigned int v48; // eax
  unsigned __int64 v49; // rdx
  unsigned int *v50; // r11
  unsigned int v51; // er10
  unsigned __int64 v52; // r8
  __int64 v53; // rax
  __int64 v54; // rcx
  signed __int64 v55; // rdx
  __int64 v56; // rax
  unsigned __int64 v57; // r8
  unsigned int v58; // er10
  unsigned int j; // ecx
  __int64 v60; // rax
  unsigned __int64 v61; // [rsp+20h] [rbp-238h]
  unsigned __int64 v62; // [rsp+28h] [rbp-230h]
  __int64 v63; // [rsp+30h] [rbp-228h]
  char v64; // [rsp+38h] [rbp-220h]
  char v65; // [rsp+44h] [rbp-214h]
  int v66; // [rsp+260h] [rbp+8h]
  unsigned int *v67; // [rsp+268h] [rbp+10h]
  unsigned int v68; // [rsp+270h] [rbp+18h]
  unsigned int v69; // [rsp+278h] [rbp+20h]

  v67 = a1;
  v3 = a1;
  v4 = (unsigned int *)a2;
  if ( !*(_DWORD *)a2 )
    return 0i64;
  v5 = *a1;
  if ( !*a1 )
    return 0i64;
  v6 = (unsigned int)(*(_DWORD *)a2 - 1);
  v7 = v5 - 1;
  if ( v5 == 1 )
  {
    v8 = a1[1];
    v9 = 0;
    if ( (_DWORD)v8 == 1 )
    {
      v10 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)a2 = 0;
      sub_1400258BC(0x1CCui64, (__m128i *)(a2 + 4), (const __m128i *)&v65, 0i64, a3);
      result = v10;
    }
    else if ( *(_DWORD *)a2 == 1 )
    {
      v12 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)a2 = 0;
      sub_1400258BC(0x1CCui64, (__m128i *)(a2 + 4), (const __m128i *)&v65, 0i64, a3);
      v4[1] = v12 % (unsigned int)v8;
      LOBYTE(v9) = v12 % (unsigned int)v8 != 0;
      result = v12 / (unsigned int)v8;
      *v4 = v9;
    }
    else
    {
      v13 = 0i64;
      for ( i = 0i64; (_DWORD)v6 != -1; i = v16 % v8 )
      {
        v15 = *(unsigned int *)(a2 + 4 * v6 + 4);
        v6 = (unsigned int)(v6 - 1);
        v16 = (i << 32) | v15;
        v13 = (unsigned int)(v16 / v8) + (v13 << 32);
      }
      *(_DWORD *)a2 = 0;
      sub_1400258BC(0x1CCui64, (__m128i *)(a2 + 4), (const __m128i *)&v65, 0i64, a3);
      v4[1] = i;
      result = v13;
      v4[2] = HIDWORD(i);
      LOBYTE(v9) = HIDWORD(i) != 0;
      *v4 = v9 + 1;
    }
    return result;
  }
  if ( (unsigned int)v7 > (unsigned int)v6 )
    return 0i64;
  v17 = (signed int)v6;
  v18 = v6 - v7;
  v19 = *(_DWORD *)a2 - 1;
  if ( (signed int)v6 < (signed __int64)((signed int)v6 - (signed int)v7) )
    goto LABEL_18;
  v20 = (signed __int64)((char *)v3 - a2 + -4 * v18);
  v21 = (_DWORD *)(a2 + 4 + 4i64 * (signed int)v6);
  while ( *(_DWORD *)((char *)v21 + v20) == *v21 )
  {
    --v19;
    --v17;
    --v21;
    if ( v17 < v18 )
      goto LABEL_18;
  }
  if ( v3[v19 - v18 + 1] < v4[v19 + 1] )
LABEL_18:
    ++v18;
  if ( !v18 )
    return 0i64;
  v22 = v3[v7 + 1];
  v23 = v3[v5 - 1];
  v24 = !_BitScanReverse((unsigned int *)&v25, v22);
  v68 = v3[v5 - 1];
  if ( v24 )
  {
    v26 = 32;
    v66 = 0;
    LOBYTE(v27) = 0;
    goto LABEL_24;
  }
  v26 = 31 - v25;
  v27 = 32 - (31 - v25);
  v66 = 32 - (31 - v25);
  if ( v25 != 31 )
  {
LABEL_24:
    v28 = v22 << v26;
    v29 = v23 >> v27;
    v30 = v23 << v26;
    v22 = v28 | v29;
    v68 = v30;
    if ( v5 > 2 )
      v68 = (v3[v5 - 2] >> v27) | v30;
  }
  v31 = v18 - 1;
  v63 = 0i64;
  v32 = 0i64;
  if ( v18 - 1 >= 0 )
  {
    v64 = v27;
    v33 = v31 + v5;
    v62 = v22;
    do
    {
      if ( (unsigned int)v33 > (unsigned int)v6 )
        v34 = 0;
      else
        v34 = v4[v33 + 1];
      v69 = v34;
      v35 = v4[(unsigned int)(v33 - 2) + 1];
      LODWORD(v61) = v4[(unsigned int)(v33 - 1) + 1];
      HIDWORD(v61) = v34;
      if ( v26 )
      {
        v36 = (v61 << v26) | ((unsigned __int64)(unsigned int)v35 >> v64);
        v35 = (unsigned int)((_DWORD)v35 << v26);
        if ( (unsigned int)v33 >= 3 )
          v35 = (v4[(unsigned int)(v33 - 3) + 1] >> v27) | (unsigned int)v35;
      }
      else
      {
        v36 = v61;
      }
      v37 = v36 / v62;
      v38 = (unsigned int)(v36 % v62);
      if ( v37 > 0xFFFFFFFF )
      {
        v39 = v37 - 0xFFFFFFFF;
        v37 = 0xFFFFFFFFi64;
        v38 += v62 * v39;
      }
      if ( v38 <= 0xFFFFFFFF )
      {
        v40 = v37 * v68;
        do
        {
          if ( v40 <= (v35 | (v38 << 32)) )
            break;
          --v37;
          v40 -= v68;
          v38 += v62;
        }
        while ( v38 <= 0xFFFFFFFF );
        LOBYTE(v27) = v66;
      }
      if ( v37 )
      {
        v41 = 0i64;
        v42 = 0;
        if ( v5 )
        {
          v43 = v67 + 1;
          do
          {
            v44 = *v43;
            ++v43;
            v45 = v37 * v44 + v41;
            v46 = v45;
            v47 = v42 + v31;
            v48 = v4[v47 + 1];
            v49 = v45 >> 32;
            v41 = (v45 >> 32) + 1;
            if ( v48 >= v46 )
              v41 = v49;
            ++v42;
            v4[v47 + 1] = v48 - v46;
          }
          while ( v42 < v5 );
          LOBYTE(v27) = v66;
        }
        v50 = v67 + 1;
        if ( v69 < v41 )
        {
          v51 = 0;
          if ( v5 )
          {
            v52 = 0i64;
            do
            {
              v53 = v51++ + v31;
              v54 = v4[v53 + 1];
              v55 = (signed __int64)&v4[v53];
              v56 = *v50;
              ++v50;
              v57 = v54 + v56 + v52;
              *(_DWORD *)(v55 + 4) = v57;
              v52 = v57 >> 32;
            }
            while ( v51 < v5 );
          }
          LODWORD(v37) = v37 - 1;
        }
        LODWORD(v6) = v33 - 1;
      }
      v33 = (unsigned int)(v33 - 1);
      v32 = (unsigned int)v37 + (v63 << 32);
      --v31;
      v63 = (unsigned int)v37 + (v63 << 32);
    }
    while ( v31 >= 0 );
  }
  v58 = v6 + 1;
  for ( j = v58; j < *v4; v4[v60 + 1] = 0 )
    v60 = j++;
  for ( *v4 = v58; v58; *v4 = v58 )
  {
    if ( v4[--v58 + 1] )
      break;
  }
  return v32;
}

//----- (000000014002462C) ----------------------------------------------------
__int64 __usercall sub_14002462C@<rax>(int a1@<edx>, unsigned __int64 a2@<rcx>, int a3@<r8d>, __int64 a4@<r9>, __m256i *a5@<ymm0>, _BYTE *a6, __int64 a7)
{
  __int64 v7; // r12
  int v8; // esi
  unsigned int v9; // er15
  unsigned __int64 v10; // rbx
  signed int v11; // eax
  const char *v12; // r8
  unsigned int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  double v17; // xmm0_8
  unsigned __int64 v18; // rbx
  unsigned int v19; // er12
  double v20; // xmm0_8
  unsigned __int64 v21; // rbx
  unsigned int v22; // edx
  __int64 v23; // r8
  unsigned int v24; // er11
  unsigned int v25; // er8
  int v26; // ebx
  bool v27; // zf
  int v28; // eax
  int v29; // eax
  unsigned int v30; // er14
  __int64 v31; // r10
  __int64 v32; // rax
  __int64 v33; // rcx
  signed int v34; // er9
  signed int v35; // edx
  __int64 v36; // rcx
  unsigned int v37; // er12
  unsigned int v38; // er11
  unsigned int v39; // er8
  int v40; // ebx
  int v41; // eax
  int v42; // eax
  __int64 v43; // r10
  __int64 v44; // rax
  __int64 v45; // rcx
  signed int v46; // er9
  signed int v47; // edx
  __int64 v48; // rcx
  __int64 v49; // r8
  int v50; // eax
  int v51; // eax
  __int64 v52; // rdi
  unsigned __int64 v53; // r8
  unsigned int v54; // eax
  __int64 v55; // r10
  __int64 v56; // r8
  signed int v57; // er9
  unsigned int v58; // ecx
  int v59; // eax
  int v60; // eax
  unsigned int v61; // eax
  __int64 v62; // r10
  __int64 v63; // r8
  signed int v64; // er9
  unsigned int v65; // ecx
  unsigned int v66; // eax
  unsigned int v67; // ecx
  signed int v68; // eax
  __int64 v69; // rax
  __int64 v70; // rdi
  __int64 v71; // rcx
  __int64 v72; // rsi
  signed __int64 v73; // rbx
  unsigned int v74; // er9
  unsigned __int64 v75; // r8
  __int64 v76; // r10
  __int64 v77; // r9
  unsigned __int64 v78; // rcx
  __int64 v79; // rbx
  unsigned __int64 v80; // r8
  __int64 v81; // r9
  unsigned __int64 v82; // rcx
  char v83; // al
  _BYTE *v84; // rsi
  _BYTE *v85; // rbx
  unsigned __int64 v86; // r8
  __int64 v87; // r9
  unsigned __int64 v88; // r8
  unsigned int v89; // ebx
  int *v90; // rcx
  int *v91; // rdx
  __int64 v92; // r10
  __int64 v93; // rsi
  unsigned __int64 v94; // r11
  unsigned int v95; // er8
  __int64 v96; // rdi
  int v97; // eax
  unsigned __int64 v98; // rdx
  int v99; // eax
  __int64 v100; // rdx
  unsigned __int64 v101; // rcx
  unsigned __int64 v102; // r8
  int v103; // eax
  unsigned int v104; // eax
  unsigned __int64 v105; // r8
  __int64 v106; // r9
  unsigned __int64 v107; // rcx
  int v108; // ecx
  unsigned int v109; // eax
  unsigned int v110; // edx
  signed int v111; // eax
  __int64 v112; // rdi
  __int64 v113; // rcx
  __int64 v114; // rsi
  signed __int64 v115; // rbx
  unsigned int v116; // er9
  unsigned __int64 v117; // r8
  __int64 v118; // r10
  __int64 v119; // r9
  unsigned __int64 v120; // rcx
  __int64 v121; // rbx
  unsigned __int64 v122; // r8
  __int64 v123; // r9
  unsigned __int64 v124; // rcx
  char v125; // al
  unsigned int v126; // er11
  int *v127; // rcx
  int *v128; // rdx
  __int64 v129; // r10
  __int64 v130; // rsi
  unsigned __int64 v131; // rbx
  unsigned int v132; // er8
  __int64 v133; // rdi
  int v134; // eax
  unsigned __int64 v135; // rdx
  int v136; // eax
  __int64 v137; // rdx
  unsigned __int64 v138; // rcx
  unsigned __int64 v139; // r8
  int v140; // ecx
  unsigned int v141; // eax
  unsigned __int64 v142; // r8
  __int64 v143; // r9
  unsigned __int64 v144; // rcx
  int v145; // eax
  signed int v146; // edi
  unsigned __int64 v147; // r8
  __int64 v148; // r9
  unsigned __int64 v149; // r8
  unsigned int v150; // eax
  signed __int64 v151; // rdi
  _BYTE *v152; // rdi
  char v153; // si
  unsigned int v154; // er9
  unsigned __int64 v155; // r8
  __int64 v156; // r10
  unsigned __int64 v157; // rcx
  unsigned int v158; // er8
  unsigned int v159; // er9
  char v160; // cl
  signed __int64 v161; // rax
  unsigned int v163; // [rsp+30h] [rbp-D0h]
  unsigned int v164; // [rsp+34h] [rbp-CCh]
  unsigned int v165; // [rsp+34h] [rbp-CCh]
  unsigned int v166; // [rsp+38h] [rbp-C8h]
  unsigned int v167; // [rsp+38h] [rbp-C8h]
  int *v168; // [rsp+40h] [rbp-C0h]
  int v169; // [rsp+48h] [rbp-B8h]
  unsigned __int64 v170; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v171; // [rsp+58h] [rbp-A8h]
  unsigned int v172; // [rsp+60h] [rbp-A0h]
  int v173; // [rsp+64h] [rbp-9Ch]
  unsigned int v174; // [rsp+68h] [rbp-98h]
  int v175; // [rsp+6Ch] [rbp-94h]
  __int64 v176; // [rsp+70h] [rbp-90h]
  char v177; // [rsp+78h] [rbp-88h]
  int v178; // [rsp+80h] [rbp-80h]
  _BYTE *v179; // [rsp+88h] [rbp-78h]
  int *v180; // [rsp+90h] [rbp-70h]
  __int64 v181; // [rsp+98h] [rbp-68h]
  unsigned int v182; // [rsp+A0h] [rbp-60h]
  unsigned int v183; // [rsp+A4h] [rbp-5Ch]
  int v184; // [rsp+A8h] [rbp-58h]
  unsigned int v185; // [rsp+270h] [rbp+170h]
  int v186[115]; // [rsp+274h] [rbp+174h]
  unsigned int v187; // [rsp+440h] [rbp+340h]
  unsigned int v188; // [rsp+444h] [rbp+344h]
  int v189; // [rsp+448h] [rbp+348h]
  int v190; // [rsp+610h] [rbp+510h]
  int v191[115]; // [rsp+614h] [rbp+514h]

  v7 = a4;
  v170 = a2;
  v8 = a1;
  v179 = a6;
  v181 = a4;
  v173 = a3;
  sub_1400285F0(&v176);
  v9 = 1;
  if ( (v176 & 0x1F) == 31 )
  {
    v177 = 0;
  }
  else
  {
    sub_140028668(&v176);
    v177 = 1;
  }
  v10 = v170;
  v11 = 32;
  *(_QWORD *)(v7 + 8) = a6;
  if ( (v10 & 0x8000000000000000ui64) != 0i64 )
    v11 = 45;
  *(_DWORD *)v7 = v11;
  sub_14002858C(0, &v178, 0, a5);
  if ( !((v10 >> 52) & 0x7FF) )
  {
    if ( !(v10 & 0xFFFFFFFFFFFFFi64) || v178 & 0x1000000 )
    {
      *(_DWORD *)(v7 + 4) = 0;
      v12 = (const char *)&unk_14003538C;
      goto LABEL_22;
    }
    goto LABEL_28;
  }
  if ( ((v10 >> 52) & 0x7FF) != 2047 )
    goto LABEL_28;
  if ( v10 & 0xFFFFFFFFFFFFFi64 )
  {
    if ( (v10 & 0x8000000000000000ui64) == 0i64 || (v10 & 0xFFFFFFFFFFFFFi64) != 0x8000000000000i64 )
      v13 = ~(v10 >> 51) & 1 | 2;
    else
      v13 = 4;
  }
  else
  {
    v13 = 1;
  }
  *(_DWORD *)(v7 + 4) = 1;
  v14 = v13 - 1;
  if ( !v14 )
  {
    if ( !(unsigned int)sub_14001A94C(a7, a6, (__int64)"1#INF", a5) )
    {
      v9 = 0;
      goto LABEL_309;
    }
    goto LABEL_312;
  }
  v15 = v14 - 1;
  if ( !v15 )
  {
    v12 = "1#QNAN";
LABEL_22:
    if ( !(unsigned int)sub_14001A94C(a7, a6, (__int64)v12, a5) )
      goto LABEL_309;
LABEL_312:
    sub_14001ADD4(a5);
    JUMPOUT(*(_QWORD *)&byte_1400258B9);
  }
  v16 = v15 - 1;
  if ( !v16 )
  {
    v12 = "1#SNAN";
    goto LABEL_22;
  }
  if ( v16 == 1 )
  {
    v12 = "1#IND";
    goto LABEL_22;
  }
LABEL_28:
  v170 = v10 & 0x7FFFFFFFFFFFFFFFi64;
  v175 = 524319;
  sub_14002858C(0, &v174, 0, a5);
  sub_14002858C(0x8001Fu, &v168, v175, a5);
  v17 = *(double *)&v170;
  v171 = v170;
  v172 = v8 + 1;
  v18 = (v170 & 0xFFFFFFFFFFFFFi64) + (-(signed __int64)(((v170 >> 52) & 0x7FF) != 0) & 0x10000000000000i64);
  v19 = ((v170 >> 52) & 0x7FF) + 2 - (((v170 >> 52) & 0x7FF) != 0);
  sub_140028780(-(signed __int64)((v170 >> 52) & 0x7FF), (__m128i *)v170);
  v20 = sub_1400286B8(v17);
  v183 = v18;
  v21 = v18 >> 32;
  v184 = v21;
  v163 = (((signed int)v20 - 0x7FFFFFFF) & 0xFFFFFFFE) != 0 ? (signed int)v20 : 0;
  v22 = ((_DWORD)v21 != 0) + 1;
  v182 = ((_DWORD)v21 != 0) + 1;
  if ( v19 < 0x434 )
  {
    if ( v19 != 54 )
    {
      v189 = 0x100000;
      v188 = 0;
      v187 = 2;
      if ( (_DWORD)v21 )
      {
        v49 = 0i64;
        while ( *(&v188 + v49) == *(&v183 + v49) )
        {
          v49 = (unsigned int)(v49 + 1);
          if ( (_DWORD)v49 == 2 )
          {
            LODWORD(v168) = 0;
            v27 = !_BitScanReverse((unsigned int *)&v50, v21);
            if ( v27 )
              v51 = 0;
            else
              v51 = v50 + 1;
            v30 = v22 + ((unsigned int)(32 - v51) < 2);
            if ( v30 <= 0x73 )
            {
              v54 = v30 - 1;
              if ( v30 != 0 )
              {
                while ( 1 )
                {
                  v55 = v54;
                  v56 = v54 - 1;
                  v57 = v54 >= v22 ? 0 : *(&v183 + v54);
                  v58 = (unsigned int)v56 >= v22 ? 0 : *(&v183 + v56);
                  --v54;
                  *(&v183 + v55) = 4 * v57 | (v58 >> 30);
                  if ( (_DWORD)v56 == -1 )
                    break;
                  v22 = v182;
                }
              }
            }
            else
            {
              v30 = 0;
            }
            v182 = v30;
            v52 = (1078 - v19) >> 5;
            sub_14000D100(0i64, (__int64)&v188, 4 * v52, a5);
            *(&v188 + v52) = 1 << ((54 - v19) & 0x1F);
            goto LABEL_82;
          }
        }
      }
    }
    LODWORD(v168) = 0;
    v27 = !_BitScanReverse((unsigned int *)&v59, *(unsigned int *)((char *)&v183 + ((_DWORD)v21 != 0 ? 4 : 0)));
    if ( v27 )
      v60 = 0;
    else
      v60 = v59 + 1;
    v30 = v22 + ((unsigned int)(32 - v60) < 1);
    if ( v30 <= 0x73 )
    {
      v61 = v30 - 1;
      if ( v30 != 0 )
      {
        while ( 1 )
        {
          v62 = v61;
          v63 = v61 - 1;
          v64 = v61 >= v22 ? 0 : *(&v183 + v61);
          v65 = (unsigned int)v63 >= v22 ? 0 : *(&v183 + v63);
          --v61;
          *(&v183 + v62) = 2 * v64 | (v65 >> 31);
          if ( (_DWORD)v63 == -1 )
            break;
          v22 = v182;
        }
      }
    }
    else
    {
      v30 = 0;
    }
    v182 = v30;
    v52 = (1077 - v19) >> 5;
    sub_14000D100(0i64, (__int64)&v188, 4 * v52, a5);
    *(&v188 + v52) = 1 << ((53 - v19) & 0x1F);
LABEL_82:
    v37 = v52 + 1;
    v53 = 4i64 * (unsigned int)(v52 + 1);
    v187 = v52 + 1;
    v185 = v52 + 1;
    if ( v53 )
    {
      if ( v53 > 0x1CC )
      {
        sub_14000D100(0i64, (__int64)v186, 0x1CCui64, a5);
        *(_DWORD *)sub_140015334() = 34;
        sub_14001ADB4(a5);
      }
      else
      {
        sub_14000CA50((__m128i *)v186, (const __m128i *)&v188, v53);
      }
      v37 = v185;
    }
  }
  else
  {
    v189 = 0x100000;
    v188 = 0;
    v187 = 2;
    if ( (_DWORD)v21 )
    {
      v23 = 0i64;
      while ( *(&v188 + v23) == *(&v183 + v23) )
      {
        v23 = (unsigned int)(v23 + 1);
        if ( (_DWORD)v23 == 2 )
        {
          LODWORD(v168) = 0;
          v24 = (v19 - 1074) & 0x1F;
          v25 = (v19 - 1074) >> 5;
          v27 = !_BitScanReverse((unsigned int *)&v28, *(&v183 + ((_DWORD)v21 != 0)));
          if ( v27 )
            v29 = 0;
          else
            v29 = v28 + 1;
          if ( v22 + v25 > 0x73 || (v30 = v25 + v22 + (v24 > 32 - v29), v30 > 0x73) )
          {
            v30 = 0;
          }
          else
          {
            v31 = v30 - 1;
            if ( (_DWORD)v31 != v25 - 1 )
            {
              while ( 1 )
              {
                v32 = (unsigned int)v31 - v25;
                v33 = (unsigned int)(v32 - 1);
                v34 = (unsigned int)v32 >= v22 ? 0 : *(&v183 + v32);
                v35 = (unsigned int)v33 >= v22 ? 0 : *(&v183 + v33);
                v26 = (unsigned __int64)(1i64 << (32 - ((v19 - 50) & 0x1F))) - 1;
                *(&v183 + v31) = ((v26 & v34) << v24) | ((~v26 & (unsigned int)v35) >> (32 - v24));
                v31 = (unsigned int)(v31 - 1);
                if ( (_DWORD)v31 == v25 - 1 )
                  break;
                v22 = v182;
              }
            }
            v36 = 0i64;
            if ( v25 )
            {
              do
              {
                *(&v183 + v36) = 0;
                v36 = (unsigned int)(v36 + 1);
              }
              while ( (_DWORD)v36 != v25 );
            }
          }
          v182 = v30;
          v37 = 1;
          v185 = 1;
          v186[0] = 4;
          goto LABEL_111;
        }
      }
    }
    LODWORD(v168) = 0;
    v38 = (v19 - 1075) & 0x1F;
    v39 = (v19 - 1075) >> 5;
    v27 = !_BitScanReverse((unsigned int *)&v41, *(&v183 + ((_DWORD)v21 != 0)));
    if ( v27 )
      v42 = 0;
    else
      v42 = v41 + 1;
    if ( v22 + v39 > 0x73 || (v30 = v39 + v22 + (v38 > 32 - v42), v30 > 0x73) )
    {
      v30 = 0;
    }
    else
    {
      v43 = v30 - 1;
      if ( (_DWORD)v43 != v39 - 1 )
      {
        while ( 1 )
        {
          v44 = (unsigned int)v43 - v39;
          v45 = (unsigned int)(v44 - 1);
          v46 = (unsigned int)v44 >= v22 ? 0 : *(&v183 + v44);
          v47 = (unsigned int)v45 >= v22 ? 0 : *(&v183 + v45);
          v40 = (unsigned __int64)(1i64 << (32 - ((v19 - 51) & 0x1F))) - 1;
          *(&v183 + v43) = ((v40 & v46) << v38) | ((~v40 & (unsigned int)v47) >> (32 - v38));
          v43 = (unsigned int)(v43 - 1);
          if ( (_DWORD)v43 == v39 - 1 )
            break;
          v22 = v182;
        }
      }
      v48 = 0i64;
      if ( v39 )
      {
        do
        {
          *(&v183 + v48) = 0;
          v48 = (unsigned int)(v48 + 1);
        }
        while ( (_DWORD)v48 != v39 );
      }
    }
    v182 = v30;
    v37 = 1;
    v185 = 1;
    v186[0] = 2;
  }
LABEL_111:
  if ( (v163 & 0x80000000) == 0 )
  {
    v66 = v163 / 0xA;
    LODWORD(v170) = v163 / 0xA;
    v67 = v163 / 0xA;
    v166 = v163 / 0xA;
    if ( !(v163 / 0xA) )
    {
LABEL_184:
      v103 = 10 * v66;
      if ( v163 != v103 )
      {
        v104 = dword_140035368[v163 - v103 - 1];
        if ( !v104 )
          goto LABEL_142;
        if ( v104 != 1 && v37 )
        {
          LODWORD(v105) = 0;
          v106 = 0i64;
          do
          {
            v107 = (unsigned int)v105 + v104 * (unsigned __int64)(unsigned int)v186[v106];
            v186[v106] = v107;
            v105 = v107 >> 32;
            v106 = (unsigned int)(v106 + 1);
          }
          while ( (_DWORD)v106 != v37 );
          if ( HIDWORD(v107) )
          {
            if ( v185 >= 0x73 )
              goto LABEL_142;
            v186[v185] = HIDWORD(v107);
            v37 = v185 + 1;
            goto LABEL_143;
          }
          v37 = v185;
        }
      }
LABEL_144:
      v84 = v179;
      v85 = v179;
      if ( v30 )
      {
        LODWORD(v86) = 0;
        v87 = 0i64;
        do
        {
          v88 = (unsigned int)v86 + 10i64 * *(&v183 + v87);
          *(&v183 + v87) = v88;
          v87 = (unsigned int)(v87 + 1);
          v86 = v88 >> 32;
        }
        while ( (_DWORD)v87 != v30 );
        if ( (_DWORD)v86 )
        {
          if ( v182 >= 0x73 )
          {
            v187 = 0;
            v182 = 0;
            sub_1400258BC(0x1CCui64, (__m128i *)&v183, (const __m128i *)&v188, 0i64, a5);
          }
          else
          {
            *(&v183 + v182++) = v86;
          }
        }
      }
      goto LABEL_270;
    }
    while ( 1 )
    {
      v68 = v67;
      if ( v67 > 0x26 )
        v68 = 38;
      v169 = v68;
      v69 = (unsigned int)(v68 - 1);
      v70 = (unsigned int)v69;
      v71 = (unsigned __int8)byte_1400352D2[4 * v69];
      v72 = (unsigned __int8)byte_1400352D3[4 * v69];
      v73 = 4 * v71;
      v187 = v72 + v71;
      sub_14000D100(0i64, (__int64)&v188, 4 * v71, a5);
      sub_14000CA50(
        (__m128i *)((char *)&v188 + v73),
        (const __m128i *)((char *)&unk_1400349C0 + 4 * (unsigned __int16)word_1400352D0[2 * v70]),
        4 * v72);
      v74 = v187;
      if ( v187 > 1 )
      {
        if ( v37 > 1 )
        {
          v89 = v37;
          v90 = (int *)&v188;
          if ( v187 >= v37 )
            v90 = v186;
          if ( v187 < v37 )
            v89 = v187;
          v171 = (unsigned __int64)v90;
          v164 = v89;
          v91 = v186;
          if ( v187 >= v37 )
            v91 = (int *)&v188;
          v168 = v91;
          if ( v187 < v37 )
            v74 = v37;
          v37 = 0;
          v92 = 0i64;
          v190 = 0;
          if ( v89 )
          {
            do
            {
              v93 = (unsigned int)v90[v92];
              if ( (_DWORD)v93 )
              {
                LODWORD(v94) = 0;
                v95 = v92;
                if ( v74 )
                {
                  while ( v95 != 115 )
                  {
                    v96 = v95;
                    if ( v95 == v37 )
                    {
                      v191[v95] = 0;
                      v190 = v95 + 1;
                    }
                    v97 = v95++;
                    v98 = (unsigned int)v191[v96]
                        + (unsigned int)v94
                        + v93 * (unsigned int)v91[(unsigned int)(v97 - v92)];
                    v191[v96] = v98;
                    v37 = v190;
                    v94 = v98 >> 32;
                    if ( v95 - (_DWORD)v92 == v74 )
                      break;
                    v91 = v168;
                  }
                  if ( (_DWORD)v94 )
                  {
                    while ( v95 != 115 )
                    {
                      v99 = v95 + 1;
                      v100 = v95;
                      v27 = v95++ == v37;
                      if ( v27 )
                      {
                        v191[v100] = 0;
                        v190 = v99;
                      }
                      v101 = (unsigned int)v191[v100] + (unsigned __int64)(unsigned int)v94;
                      v191[v100] = v101;
                      v37 = v190;
                      LODWORD(v94) = HIDWORD(v101);
                      if ( !HIDWORD(v101) )
                        goto LABEL_173;
                    }
LABEL_142:
                    v37 = 0;
LABEL_143:
                    v185 = v37;
                    goto LABEL_144;
                  }
LABEL_173:
                  v89 = v164;
                }
                if ( v95 == 115 )
                  goto LABEL_142;
                v90 = (int *)v171;
                v91 = v168;
              }
              else if ( (_DWORD)v92 == v37 )
              {
                v191[v92] = 0;
                v37 = v92 + 1;
                v190 = v92 + 1;
              }
              v92 = (unsigned int)(v92 + 1);
            }
            while ( (_DWORD)v92 != v89 );
          }
          v102 = 4i64 * v37;
          v185 = v37;
          if ( v102 )
          {
            if ( v102 > 0x1CC )
            {
              sub_14000D100(0i64, (__int64)v186, 0x1CCui64, a5);
              *(_DWORD *)sub_140015334() = 34;
              sub_14001ADB4(a5);
            }
            else
            {
              sub_14000CA50((__m128i *)v186, (const __m128i *)v191, v102);
            }
            v37 = v185;
          }
          goto LABEL_182;
        }
        v79 = (unsigned int)v186[0];
        v80 = 4i64 * v187;
        v37 = v187;
        v185 = v187;
        if ( 4i64 * v187 )
        {
          if ( v80 > 0x1CC )
          {
            sub_14000D100(0i64, (__int64)v186, 0x1CCui64, a5);
            *(_DWORD *)sub_140015334() = 34;
            sub_14001ADB4(a5);
          }
          else
          {
            sub_14000CA50((__m128i *)v186, (const __m128i *)&v188, v80);
          }
          v37 = v185;
        }
        if ( !(_DWORD)v79 )
        {
LABEL_117:
          v37 = 0;
          goto LABEL_137;
        }
        if ( (_DWORD)v79 == 1 || !v37 )
          goto LABEL_140;
        LODWORD(v75) = 0;
        v81 = 0i64;
        do
        {
          v82 = (unsigned int)v75 + v79 * (unsigned int)v186[v81];
          v186[v81] = v82;
          v75 = v82 >> 32;
          v81 = (unsigned int)(v81 + 1);
        }
        while ( (_DWORD)v81 != v37 );
      }
      else
      {
        if ( !v188 )
          goto LABEL_117;
        if ( v188 == 1 || !v37 )
          goto LABEL_140;
        LODWORD(v75) = 0;
        v76 = v188;
        v77 = 0i64;
        do
        {
          v78 = (unsigned int)v75 + v76 * (unsigned int)v186[v77];
          v186[v77] = v78;
          v75 = v78 >> 32;
          v77 = (unsigned int)(v77 + 1);
        }
        while ( (_DWORD)v77 != v37 );
      }
      if ( !(_DWORD)v75 )
      {
        v37 = v185;
        goto LABEL_140;
      }
      if ( v185 >= 0x73 )
      {
        v37 = 0;
        v83 = 0;
        v185 = 0;
        goto LABEL_141;
      }
      v186[v185] = v75;
      v37 = v185 + 1;
LABEL_137:
      v185 = v37;
LABEL_140:
      v83 = 1;
LABEL_141:
      if ( !v83 )
        goto LABEL_142;
LABEL_182:
      v27 = v166 == v169;
      v67 = v166 - v169;
      v166 -= v169;
      if ( v27 )
      {
        v66 = v170;
        goto LABEL_184;
      }
    }
  }
  v108 = -v163;
  v169 = -v163;
  v109 = -v163 / 0xA;
  LODWORD(v168) = -v163 / 0xA;
  v110 = -v163 / 0xA;
  v165 = -v163 / 0xA;
  if ( !v109 )
  {
LABEL_259:
    v140 = v108 - 10 * v109;
    if ( !v140 )
      goto LABEL_144;
    v141 = dword_140035368[v140 - 1];
    if ( v141 )
    {
      if ( v141 == 1 || !v30 )
        goto LABEL_144;
      LODWORD(v142) = 0;
      v143 = 0i64;
      do
      {
        v144 = (unsigned int)v142 + v141 * (unsigned __int64)*(&v183 + v143);
        *(&v183 + v143) = v144;
        v142 = v144 >> 32;
        v143 = (unsigned int)(v143 + 1);
      }
      while ( (_DWORD)v143 != v30 );
      if ( !HIDWORD(v144) )
      {
        v30 = v182;
        goto LABEL_144;
      }
      if ( v182 < 0x73 )
      {
        *(&v183 + v182) = HIDWORD(v144);
        v30 = v182++ + 1;
        goto LABEL_144;
      }
    }
    goto LABEL_224;
  }
  while ( 1 )
  {
    v111 = v110;
    if ( v110 > 0x26 )
      v111 = 38;
    LODWORD(v170) = v111;
    v112 = (unsigned int)(v111 - 1);
    v113 = (unsigned __int8)byte_1400352D2[4 * v112];
    v114 = (unsigned __int8)byte_1400352D3[4 * v112];
    v115 = 4 * v113;
    v187 = v114 + v113;
    sub_14000D100(0i64, (__int64)&v188, 4 * v113, a5);
    sub_14000CA50(
      (__m128i *)((char *)&v188 + v115),
      (const __m128i *)((char *)&unk_1400349C0 + 4 * (unsigned __int16)word_1400352D0[2 * v112]),
      4 * v114);
    v116 = v187;
    if ( v187 <= 1 )
    {
      if ( !v188 )
      {
LABEL_199:
        v30 = 0;
        goto LABEL_219;
      }
      if ( v188 == 1 || !v30 )
        goto LABEL_222;
      LODWORD(v117) = 0;
      v118 = v188;
      v119 = 0i64;
      do
      {
        v120 = (unsigned int)v117 + v118 * *(&v183 + v119);
        *(&v183 + v119) = v120;
        v117 = v120 >> 32;
        v119 = (unsigned int)(v119 + 1);
      }
      while ( (_DWORD)v119 != v30 );
LABEL_216:
      if ( !(_DWORD)v117 )
      {
        v30 = v182;
        goto LABEL_222;
      }
      if ( v182 >= 0x73 )
      {
        v30 = 0;
        v125 = 0;
        v182 = 0;
        goto LABEL_223;
      }
      *(&v183 + v182) = v117;
      v30 = v182 + 1;
LABEL_219:
      v182 = v30;
LABEL_222:
      v125 = 1;
LABEL_223:
      if ( !v125 )
        goto LABEL_224;
      goto LABEL_257;
    }
    if ( v30 <= 1 )
    {
      v121 = v183;
      v122 = 4i64 * v187;
      v30 = v187;
      v182 = v187;
      if ( 4i64 * v187 )
      {
        if ( v122 > 0x1CC )
        {
          sub_14000D100(0i64, (__int64)&v183, 0x1CCui64, a5);
          *(_DWORD *)sub_140015334() = 34;
          sub_14001ADB4(a5);
        }
        else
        {
          sub_14000CA50((__m128i *)&v183, (const __m128i *)&v188, v122);
        }
        v30 = v182;
      }
      if ( !(_DWORD)v121 )
        goto LABEL_199;
      if ( (_DWORD)v121 == 1 || !v30 )
        goto LABEL_222;
      LODWORD(v117) = 0;
      v123 = 0i64;
      do
      {
        v124 = (unsigned int)v117 + v121 * *(&v183 + v123);
        *(&v183 + v123) = v124;
        v117 = v124 >> 32;
        v123 = (unsigned int)(v123 + 1);
      }
      while ( (_DWORD)v123 != v30 );
      goto LABEL_216;
    }
    v126 = v30;
    v127 = (int *)&v188;
    if ( v187 >= v30 )
      v127 = (int *)&v183;
    if ( v187 < v30 )
      v126 = v187;
    v180 = v127;
    v167 = v126;
    v128 = (int *)&v183;
    if ( v187 >= v30 )
      v128 = (int *)&v188;
    v171 = (unsigned __int64)v128;
    if ( v187 < v30 )
      v116 = v30;
    v30 = 0;
    v129 = 0i64;
    v190 = 0;
    if ( v126 )
      break;
LABEL_252:
    v139 = 4i64 * v30;
    v182 = v30;
    if ( v139 )
    {
      if ( v139 > 0x1CC )
      {
        sub_14000D100(0i64, (__int64)&v183, 0x1CCui64, a5);
        *(_DWORD *)sub_140015334() = 34;
        sub_14001ADB4(a5);
      }
      else
      {
        sub_14000CA50((__m128i *)&v183, (const __m128i *)v191, v139);
      }
      v30 = v182;
    }
LABEL_257:
    v27 = v165 == (_DWORD)v170;
    v110 = v165 - v170;
    v165 -= v170;
    if ( v27 )
    {
      v108 = v169;
      v109 = (unsigned int)v168;
      goto LABEL_259;
    }
  }
  while ( 1 )
  {
    v130 = (unsigned int)v127[v129];
    if ( !(_DWORD)v130 )
    {
      if ( (_DWORD)v129 == v30 )
      {
        v191[v129] = 0;
        v30 = v129 + 1;
        v190 = v129 + 1;
      }
      goto LABEL_251;
    }
    LODWORD(v131) = 0;
    v132 = v129;
    if ( !v116 )
      goto LABEL_249;
    while ( v132 != 115 )
    {
      v133 = v132;
      if ( v132 == v30 )
      {
        v191[v132] = 0;
        v190 = v132 + 1;
      }
      v134 = v132++;
      v135 = (unsigned int)v131 + (unsigned int)v191[v133] + v130 * (unsigned int)v128[(unsigned int)(v134 - v129)];
      v191[v133] = v135;
      v30 = v190;
      v131 = v135 >> 32;
      if ( v132 - (_DWORD)v129 == v116 )
        break;
      v128 = (int *)v171;
    }
    if ( (_DWORD)v131 )
      break;
LABEL_248:
    v126 = v167;
LABEL_249:
    if ( v132 == 115 )
      goto LABEL_224;
    v127 = v180;
    v128 = (int *)v171;
LABEL_251:
    v129 = (unsigned int)(v129 + 1);
    if ( (_DWORD)v129 == v126 )
      goto LABEL_252;
  }
  while ( v132 != 115 )
  {
    v136 = v132 + 1;
    v137 = v132;
    v27 = v132++ == v30;
    if ( v27 )
    {
      v191[v137] = 0;
      v190 = v136;
    }
    v138 = (unsigned int)v131 + (unsigned __int64)(unsigned int)v191[v137];
    v191[v137] = v138;
    v30 = v190;
    LODWORD(v131) = HIDWORD(v138);
    if ( !HIDWORD(v138) )
      goto LABEL_248;
  }
LABEL_224:
  v84 = v179;
  v182 = 0;
  v85 = v179;
LABEL_270:
  v145 = sub_140024190(&v185, (__int64)&v182, a5);
  v146 = (((signed int)v20 - 0x7FFFFFFF) & 0xFFFFFFFE) != 0 ? (signed int)v20 : 0;
  if ( v145 == 10 )
  {
    v146 = v163 + 1;
    *v84 = 49;
    v85 = v84 + 1;
    if ( v37 )
    {
      LODWORD(v147) = 0;
      v148 = 0i64;
      do
      {
        v149 = (unsigned int)v147 + 10i64 * (unsigned int)v186[v148];
        v186[v148] = v149;
        v148 = (unsigned int)(v148 + 1);
        v147 = v149 >> 32;
      }
      while ( (_DWORD)v148 != v37 );
      if ( (_DWORD)v147 )
      {
        if ( v185 >= 0x73 )
        {
          v187 = 0;
          v185 = 0;
          sub_1400258BC(0x1CCui64, (__m128i *)v186, (const __m128i *)&v188, 0i64, a5);
        }
        else
        {
          v186[v185++] = v147;
        }
      }
    }
  }
  else if ( v145 )
  {
    v85 = v84 + 1;
    *v84 = v145 + 48;
  }
  else
  {
    v146 = v163 - 1;
  }
  *(_DWORD *)(v181 + 4) = v146;
  v150 = v172;
  if ( v146 >= 0 && v172 <= 0x7FFFFFFF && !v173 )
    v150 = v146 + v172;
  v151 = v150;
  if ( a7 - 1 < (unsigned __int64)v150 )
    v151 = a7 - 1;
  v152 = &v84[v151];
  v153 = 0;
  if ( v85 == v152 )
  {
LABEL_304:
    v154 = v182;
  }
  else
  {
    while ( 1 )
    {
      v154 = v182;
      if ( !v182 )
        break;
      LODWORD(v155) = 0;
      v156 = 0i64;
      do
      {
        v157 = (unsigned int)v155 + 1000000000i64 * *(&v183 + v156);
        *(&v183 + v156) = v157;
        v155 = v157 >> 32;
        v156 = (unsigned int)(v156 + 1);
      }
      while ( (_DWORD)v156 != v154 );
      if ( HIDWORD(v157) )
      {
        if ( v182 >= 0x73 )
        {
          v187 = 0;
          v182 = 0;
          sub_1400258BC(0x1CCui64, (__m128i *)&v183, (const __m128i *)&v188, 0i64, a5);
        }
        else
        {
          *(&v183 + v182++) = HIDWORD(v157);
        }
      }
      v158 = sub_140024190(&v185, (__int64)&v182, a5);
      v159 = 8;
      do
      {
        v160 = v158 % 0xA + 48;
        v158 /= 0xAu;
        if ( (signed int)v152 - (signed int)v85 > v159 )
        {
          v85[v159] = v160;
        }
        else if ( v160 != 48 )
        {
          v153 = 1;
        }
        --v159;
      }
      while ( v159 != -1 );
      v161 = v152 - v85;
      if ( v152 - v85 > 9 )
        v161 = 9i64;
      v85 += v161;
      if ( v85 == v152 )
        goto LABEL_304;
    }
  }
  *v85 = 0;
  if ( v154 || v153 )
    v9 = 0;
  sub_14002858C(v174, &v173, v175, a5);
LABEL_309:
  if ( v177 )
    sub_140028610((unsigned int *)&v176);
  return v9;
}
// 1400258B9: using guessed type char;
// 1400352D0: using guessed type __int16 word_1400352D0[];
// 14002462C: using guessed type int var_5AC[115];
// 14002462C: using guessed type int var_20C[115];

//----- (00000001400258BC) ----------------------------------------------------
signed __int64 __usercall sub_1400258BC@<rax>(unsigned __int64 a1@<rdx>, __m128i *a2@<rcx>, const __m128i *a3@<r8>, unsigned __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  unsigned __int64 v5; // rbx
  const __m128i *v6; // rsi
  unsigned __int64 v7; // rdi
  _DWORD *v9; // rax
  unsigned int v10; // ebx

  v5 = a4;
  v6 = a3;
  v7 = a1;
  if ( !a4 )
    return 0i64;
  if ( !a2 )
    goto LABEL_15;
  if ( a3 && a1 >= a4 )
  {
    sub_14000CA50(a2, a3, a4);
    return 0i64;
  }
  sub_14000D100(0i64, (__int64)a2, a1, a5);
  if ( !v6 )
  {
LABEL_15:
    v9 = sub_140015334();
    v10 = 22;
LABEL_5:
    *v9 = v10;
    sub_14001ADB4(a5);
    return v10;
  }
  if ( v7 < v5 )
  {
    v9 = sub_140015334();
    v10 = 34;
    goto LABEL_5;
  }
  return 22i64;
}

//----- (0000000140025944) ----------------------------------------------------
__int64 sub_140025944()
{
  __int16 v0; // ax

  v0 = sub_140028D38();
  return sub_140028D2C(v0);
}

//----- (0000000140025958) ----------------------------------------------------
__int64 __fastcall sub_140025958(_BYTE *a1, unsigned int a2, _QWORD *a3, __int64 a4)
{
  _BYTE *v4; // r10
  signed __int64 v6; // rcx
  char v7; // r9
  signed __int64 v8; // r11
  char v9; // al

  v4 = a1;
  if ( !a1 )
    goto LABEL_2;
  if ( !a2 )
  {
    *a1 = 0;
LABEL_2:
    *a3 = 0i64;
    return 1i64;
  }
  if ( !(a2 & 0xFFFFFF80) )
  {
    *a1 = a2;
    return 1i64;
  }
  if ( !(a2 & 0xFFFFF800) )
  {
    v6 = 1i64;
    v7 = -64;
    goto LABEL_16;
  }
  if ( !(a2 & 0xFFFF0000) )
  {
    if ( a2 - 55296 > 0x7FF )
    {
      v6 = 2i64;
      v7 = -32;
      goto LABEL_16;
    }
    return sub_140029028(a3, a4);
  }
  if ( a2 & 0xFFE00000 || a2 > 0x10FFFF )
    return sub_140029028(a3, a4);
  v6 = 3i64;
  v7 = -16;
LABEL_16:
  v8 = v6;
  do
  {
    v9 = a2;
    a2 >>= 6;
    v4[v8--] = v9 & 0x3F | 0x80;
  }
  while ( v8 );
  *v4 = v7 | a2;
  return sub_140029020(v6 + 1, a3);
}

//----- (00000001400259FC) ----------------------------------------------------
__int64 __fastcall sub_1400259FC(unsigned __int16 *a1)
{
  unsigned __int16 *v1; // rbp
  int v2; // ebx
  int v3; // edi
  int v4; // eax
  int v5; // esi
  signed __int64 v6; // r14
  int v7; // eax
  __int64 result; // rax
  unsigned __int64 v9; // rax

  v1 = a1;
  if ( !a1 )
    goto LABEL_8;
  v2 = 0;
  v3 = 227;
  while ( 1 )
  {
    v4 = (v3 + v2) / 2;
    v5 = v4;
    v6 = 2i64 * v4;
    v7 = sub_140026888(v1, (unsigned __int16 *)*(&off_140036E10 + 2 * v4), 85i64);
    if ( !v7 )
      break;
    if ( v7 >= 0 )
      v2 = v5 + 1;
    else
      v3 = v5 - 1;
    if ( v2 > v3 )
      goto LABEL_8;
  }
  v9 = dword_140036E18[2 * v6];
  if ( (v9 & 0x80000000) == 0i64 && v9 < 0xE4 )
    result = (unsigned int)dword_1400353B0[4 * v9];
  else
LABEL_8:
    result = 0i64;
  return result;
}
// 1400353B0: using guessed type int dword_1400353B0[];
// 140036E10: using guessed type void *off_140036E10;
// 140036E18: using guessed type int dword_140036E18[];

//----- (0000000140025AA0) ----------------------------------------------------
signed __int64 __usercall sub_140025AA0@<rax>(__m128i *a1@<rdx>, unsigned __int16 a2@<cx>, __int128 *a3@<xmm1>, __m256i *a4@<ymm0>, __m256i *a5@<ymm1>)
{
  signed __int64 result; // rax
  __int64 v6; // rcx
  unsigned __int16 v7; // dx
  int v8; // eax
  __int64 v9; // [rsp+30h] [rbp-28h]
  __int64 v10; // [rsp+38h] [rbp-20h]
  char v11; // [rsp+48h] [rbp-10h]
  __m128i v12; // [rsp+60h] [rbp+8h]
  unsigned __int16 v13; // [rsp+70h] [rbp+18h]

  v12.m128i_i16[0] = a2;
  result = 0xFFFFi64;
  if ( a2 == -1 )
    return result;
  sub_14001590C(a1, (__int64)&v9, a4);
  if ( *(_DWORD *)(v10 + 12) != 65001 )
  {
    v7 = v12.m128i_i16[0];
    if ( v12.m128i_i16[0] < 0x100u )
    {
      if ( !(*((_BYTE *)&unk_140034750 + 2 * v12.m128i_u8[0] + 2) & 1) )
      {
        v7 = v12.m128i_u8[0];
        goto LABEL_15;
      }
      v6 = v12.m128i_u8[0];
      goto LABEL_10;
    }
    if ( !*(_QWORD *)(v10 + 312) )
      goto LABEL_15;
LABEL_13:
    v8 = sub_14002903C(0x100u, *(unsigned __int16 **)(v10 + 312), &v12, 1, a3, a5, &v13, 1);
    v7 = v12.m128i_i16[0];
    if ( v8 )
      v7 = v13;
    goto LABEL_15;
  }
  if ( v12.m128i_i16[0] >= 0x80u )
    goto LABEL_13;
  if ( *((_BYTE *)&unk_140034750 + 2 * v12.m128i_u8[0] + 2) & 1 )
  {
    v6 = v12.m128i_u8[0];
LABEL_10:
    v7 = *(unsigned __int8 *)(*(_QWORD *)(v10 + 272) + v6);
    goto LABEL_15;
  }
  v7 = v12.m128i_u8[0];
LABEL_15:
  if ( v11 )
    *(_DWORD *)(v9 + 936) &= 0xFFFFFFFD;
  return v7;
}

//----- (0000000140025BA0) ----------------------------------------------------
__int64 sub_140025BA0()
{
  dword_1400411F0 = 28800;
  dword_1400411E8 = 1;
  dword_1400411EC = -3600;
  qword_1400411F8 = (__int64)&off_14003EBB0;
  qword_140041200 = (__int64)off_14003EBC0;
  return 0i64;
}
// 14003EBB0: using guessed type void *off_14003EBB0;
// 14003EBC0: using guessed type wchar_t *off_14003EBC0[2];
// 1400411E8: using guessed type int dword_1400411E8;
// 1400411EC: using guessed type int dword_1400411EC;
// 1400411F0: using guessed type int dword_1400411F0;
// 1400411F8: using guessed type __int64 qword_1400411F8;
// 140041200: using guessed type __int64 qword_140041200;

//----- (0000000140025BF0) ----------------------------------------------------
int *sub_140025BF0()
{
  return &dword_1400411E8;
}
// 1400411E8: using guessed type int dword_1400411E8;

//----- (0000000140025BF8) ----------------------------------------------------
int *sub_140025BF8()
{
  return &dword_1400411EC;
}
// 1400411EC: using guessed type int dword_1400411EC;

//----- (0000000140025C00) ----------------------------------------------------
int *sub_140025C00()
{
  return &dword_1400411F0;
}
// 1400411F0: using guessed type int dword_1400411F0;

//----- (0000000140025C08) ----------------------------------------------------
__int64 sub_140025C08()
{
  return qword_1400411F8;
}
// 1400411F8: using guessed type __int64 qword_1400411F8;

//----- (0000000140025C10) ----------------------------------------------------
__int64 sub_140025C10()
{
  return qword_140041200;
}
// 140041200: using guessed type __int64 qword_140041200;

//----- (0000000140025C18) ----------------------------------------------------
signed __int64 __usercall sub_140025C18@<rax>(_DWORD *a1@<rcx>, __m256i *a2@<ymm0>)
{
  signed __int64 result; // rax

  if ( a1 )
  {
    *a1 = dword_1400411E8;
    result = 0i64;
  }
  else
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a2);
    result = 22i64;
  }
  return result;
}
// 1400411E8: using guessed type int dword_1400411E8;

//----- (0000000140025C48) ----------------------------------------------------
signed __int64 __usercall sub_140025C48@<rax>(_DWORD *a1@<rcx>, __m256i *a2@<ymm0>)
{
  signed __int64 result; // rax

  if ( a1 )
  {
    *a1 = dword_1400411EC;
    result = 0i64;
  }
  else
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a2);
    result = 22i64;
  }
  return result;
}
// 1400411EC: using guessed type int dword_1400411EC;

//----- (0000000140025C78) ----------------------------------------------------
signed __int64 __usercall sub_140025C78@<rax>(_DWORD *a1@<rcx>, __m256i *a2@<ymm0>)
{
  signed __int64 result; // rax

  if ( a1 )
  {
    *a1 = dword_1400411F0;
    result = 0i64;
  }
  else
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a2);
    result = 22i64;
  }
  return result;
}
// 1400411F0: using guessed type int dword_1400411F0;

//----- (0000000140025CA8) ----------------------------------------------------
signed __int64 __usercall sub_140025CA8@<rax>(_DWORD *a1@<rcx>, __m256i *a2@<ymm0>)
{
  _DWORD *v2; // rbp
  unsigned int v3; // edi
  int v4; // esi
  int v5; // er14
  int v6; // er15
  int v7; // er12
  int v8; // er13
  __int64 v9; // rbx
  int v10; // ecx
  int v11; // eax
  int v12; // edx
  int v13; // ecx
  int v14; // er8
  int v15; // eax
  int v16; // eax
  int v18; // ecx
  int v19; // [rsp+98h] [rbp+10h]

  v2 = a1;
  v3 = 0;
  v19 = 0;
  if ( (unsigned int)sub_140025C18(&v19, a2) )
  {
    sub_14001ADD4(a2);
    JUMPOUT(*(_QWORD *)&byte_140025FA1);
  }
  if ( !v19 )
    return 0i64;
  v4 = v2[5];
  if ( v4 != dword_14003EBD0 || v4 != dword_14003EBE0 )
  {
    if ( dword_140041210 )
    {
      if ( TimeZoneInformation.DaylightDate.wYear )
      {
        v5 = TimeZoneInformation.DaylightDate.wMilliseconds;
        v6 = TimeZoneInformation.DaylightDate.wSecond;
        v7 = TimeZoneInformation.DaylightDate.wMinute;
        v8 = TimeZoneInformation.DaylightDate.wHour;
        v9 = TimeZoneInformation.DaylightDate.wMonth;
        if ( sub_14001FBA0(v4) )
          v10 = dword_1400386E4[v9];
        else
          v10 = dword_1400386AC[v9];
        dword_14003EBD0 = v4;
        dword_14003EBD4 = v10 + TimeZoneInformation.DaylightDate.wDay;
        dword_14003EBD8 = v5 + 1000 * (v6 + 60 * (v7 + 60 * v8));
      }
      else
      {
        sub_140025FA4(
          1,
          0,
          v4,
          TimeZoneInformation.DaylightDate.wMonth,
          a2,
          TimeZoneInformation.DaylightDate.wDay,
          TimeZoneInformation.DaylightDate.wDayOfWeek,
          0,
          TimeZoneInformation.DaylightDate.wHour,
          TimeZoneInformation.DaylightDate.wMinute,
          TimeZoneInformation.DaylightDate.wSecond,
          TimeZoneInformation.DaylightDate.wMilliseconds);
        v4 = v2[5];
      }
      if ( TimeZoneInformation.StandardDate.wYear )
      {
        v14 = TimeZoneInformation.StandardDate.wDay;
        v12 = 0;
        v11 = 0;
        v13 = 0;
      }
      else
      {
        v11 = TimeZoneInformation.StandardDate.wDay;
        v12 = 1;
        v13 = TimeZoneInformation.StandardDate.wDayOfWeek;
        v14 = 0;
      }
      sub_140025FA4(
        v12,
        1,
        v4,
        TimeZoneInformation.StandardDate.wMonth,
        a2,
        v11,
        v13,
        v14,
        TimeZoneInformation.StandardDate.wHour,
        TimeZoneInformation.StandardDate.wMinute,
        TimeZoneInformation.StandardDate.wSecond,
        TimeZoneInformation.StandardDate.wMilliseconds);
    }
    else
    {
      sub_140025FA4(1, 0, v4, (v4 < 107) + 3, a2, (v4 >= 107) + 1, 0, 0, 2, 0, 0, 0);
      v15 = 5;
      if ( v4 >= 107 )
        v15 = 1;
      sub_140025FA4(1, 1, v2[5], (v4 >= 107) + 10, a2, v15, 0, 0, 2, 0, 0, 0);
    }
  }
  v16 = v2[7];
  if ( dword_14003EBD4 >= dword_14003EBE4 )
  {
    if ( v16 < dword_14003EBE4 || v16 > dword_14003EBD4 )
      return 1i64;
    if ( v16 <= dword_14003EBE4 || v16 >= dword_14003EBD4 )
      goto LABEL_30;
    return 0i64;
  }
  if ( v16 < dword_14003EBD4 || v16 > dword_14003EBE4 )
    return 0i64;
  if ( v16 > dword_14003EBD4 && v16 < dword_14003EBE4 )
    return 1i64;
LABEL_30:
  v18 = 1000 * (*v2 + 60 * (v2[1] + 60 * v2[2]));
  if ( v16 == dword_14003EBD4 )
    LOBYTE(v3) = v18 >= dword_14003EBD8;
  else
    LOBYTE(v3) = v18 < dword_14003EBE8;
  return v3;
}
// 140025FA1: using guessed type char;
// 1400386AC: using guessed type int dword_1400386AC[];
// 1400386E4: using guessed type int dword_1400386E4[];
// 14003EBD0: using guessed type int dword_14003EBD0;
// 14003EBD4: using guessed type int dword_14003EBD4;
// 14003EBD8: using guessed type int dword_14003EBD8;
// 14003EBE0: using guessed type int dword_14003EBE0;
// 14003EBE4: using guessed type int dword_14003EBE4;
// 14003EBE8: using guessed type int dword_14003EBE8;
// 140041210: using guessed type int dword_140041210;

//----- (0000000140025FA4) ----------------------------------------------------
__int64 __usercall sub_140025FA4@<rax>(int a1@<edx>, int a2@<ecx>, int a3@<r8d>, int a4@<r9d>, __m256i *a5@<ymm0>, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  int v12; // er14
  __int64 v13; // rbx
  int v14; // esi
  int v15; // edi
  bool v16; // al
  bool v17; // bp
  int v18; // er10
  int v19; // er10
  int v20; // er8
  int v21; // eax
  int v22; // ecx
  int v23; // er8
  int v24; // er8
  __int64 result; // rax
  bool v26; // sf
  int v27; // [rsp+50h] [rbp+8h]

  v27 = 0;
  v12 = a2;
  v13 = a4;
  v14 = a3;
  v15 = a1;
  v16 = sub_14001FBA0(a3);
  v17 = v16;
  if ( v15 == 1 )
  {
    if ( v16 )
      v18 = dword_1400386E4[v13];
    else
      v18 = dword_1400386AC[v13];
    v19 = v18 + 1;
    v20 = (365 * v14 - 25563 + (v14 + 299) / 400 - (v14 - 1) / 100 + v19 + (v14 - 1) / 4) % 7;
    v21 = a7 + v19 + 7 * a6 - v20 - 7;
    if ( v20 > a7 )
      v21 = a7 + v19 + 7 * a6 - v20;
    if ( v17 )
      v22 = dword_1400386E8[v13];
    else
      v22 = dword_1400386B0[v13];
    v23 = v21;
    if ( a6 == 5 && v21 > v22 )
      v23 = v21 - 7;
  }
  else
  {
    if ( v16 )
      v24 = dword_1400386E4[v13];
    else
      v24 = dword_1400386AC[v13];
    v23 = a8 + v24;
  }
  result = (unsigned int)(a10 + 60 * a9);
  if ( !v12 )
  {
    dword_14003EBD4 = v23;
    dword_14003EBD8 = a12 + 1000 * (a11 + 60 * result);
    dword_14003EBD0 = v14;
    return result;
  }
  dword_14003EBE8 = a12 + 1000 * (a11 + 60 * result);
  dword_14003EBE4 = v23;
  if ( (unsigned int)sub_140025C48(&v27, a5) )
  {
    sub_14001ADD4(a5);
    JUMPOUT(*(_QWORD *)&byte_140026198);
  }
  v26 = 1000 * v27 + dword_14003EBE8 < 0;
  result = (unsigned int)(1000 * v27 + dword_14003EBE8);
  dword_14003EBE8 += 1000 * v27;
  if ( v26 )
  {
    result = (unsigned int)(result + 86400000);
    --dword_14003EBE4;
LABEL_25:
    dword_14003EBE8 = result;
    goto LABEL_26;
  }
  if ( (signed int)result >= 86400000 )
  {
    result = (unsigned int)(result - 86400000);
    ++dword_14003EBE4;
    goto LABEL_25;
  }
LABEL_26:
  dword_14003EBE0 = v14;
  return result;
}
// 140026198: using guessed type char;
// 1400386AC: using guessed type int dword_1400386AC[];
// 1400386E4: using guessed type int dword_1400386E4[];
// 14003EBD0: using guessed type int dword_14003EBD0;
// 14003EBD4: using guessed type int dword_14003EBD4;
// 14003EBD8: using guessed type int dword_14003EBD8;
// 14003EBE0: using guessed type int dword_14003EBE0;
// 14003EBE4: using guessed type int dword_14003EBE4;
// 14003EBE8: using guessed type int dword_14003EBE8;

//----- (000000014002619C) ----------------------------------------------------
int __usercall sub_14002619C@<eax>(WCHAR *a1@<rdx>, __int64 a2@<rcx>, CHAR *a3@<r8>, signed __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  const WCHAR *v5; // rdi
  CHAR *v6; // rsi
  int v7; // ebx
  UINT v8; // ecx
  __int64 v10; // [rsp+28h] [rbp-40h]
  __int64 v11; // [rsp+40h] [rbp-28h]
  __int64 v12; // [rsp+48h] [rbp-20h]
  char v13; // [rsp+58h] [rbp-10h]

  v5 = a1;
  v6 = a3;
  v7 = a4;
  if ( (unsigned int)sub_140021CE0(64i64, a1, a2, a4, a5) )
  {
    sub_14001ADD4(a5);
    JUMPOUT(*(_QWORD *)&byte_14002627C);
  }
  sub_14001590C(0i64, (__int64)&v11, a5);
  v8 = 65001;
  if ( *(_DWORD *)(v12 + 12) == 65001 )
  {
    if ( v13 )
      *(_DWORD *)(v11 + 936) &= 0xFFFFFFFD;
  }
  else if ( (unsigned int)sub_14001F2F4() )
  {
    if ( v13 )
      *(_DWORD *)(v11 + 936) &= 0xFFFFFFFD;
    v8 = 0;
  }
  else
  {
    if ( v13 )
      *(_DWORD *)(v11 + 936) &= 0xFFFFFFFD;
    v8 = 1;
  }
  LODWORD(v10) = 63;
  return sub_1400203D8(v8, 0, v5, v7, v6, v10, 0i64, 0i64);
}
// 14002627C: using guessed type char;

//----- (0000000140026280) ----------------------------------------------------
void __usercall sub_140026280(unsigned __int16 *a1@<rcx>, __m256i *a2@<ymm0>)
{
  unsigned __int16 *v2; // rdi
  __int64 *v3; // r14
  __int64 v4; // rax
  __int64 *v5; // r15
  unsigned __int16 *v6; // rax
  int v7; // er8
  int v8; // edx
  signed __int64 v9; // rsi
  signed __int64 v10; // rcx
  _WORD *v11; // rbx
  signed __int64 v12; // rax
  unsigned __int16 v13; // si
  unsigned __int16 *v14; // rbx
  int v15; // eax
  int v16; // edi
  int v17; // ecx
  unsigned __int16 v18; // ax
  unsigned __int16 v19; // cx
  int v20; // eax
  int v21; // ebx
  int v22; // [rsp+78h] [rbp+48h]
  BOOL v23; // [rsp+80h] [rbp+50h]
  char v24; // [rsp+88h] [rbp+58h]

  v2 = a1;
  v3 = (__int64 *)sub_140025C08();
  v4 = sub_140025C10();
  v22 = 0;
  v5 = (__int64 *)v4;
  v23 = 0;
  if ( (unsigned int)sub_140025C78(&v22, a2) || (unsigned int)sub_140025C18(&v23, a2) )
    goto LABEL_41;
  if ( !qword_140041208 )
    goto LABEL_45;
  v6 = v2;
  do
  {
    v7 = *(unsigned __int16 *)((char *)v6 + (_BYTE *)qword_140041208 - (_BYTE *)v2);
    v8 = *v6 - v7;
    if ( *v6 != v7 )
      break;
    ++v6;
  }
  while ( v7 );
  if ( v8 )
  {
LABEL_45:
    v9 = -1i64;
    v10 = -1i64;
    do
      ++v10;
    while ( v2[v10] );
    v11 = sub_14001DACC(2 * v10 + 2);
    if ( !v11 )
    {
LABEL_11:
      sub_14001AE1C(0i64);
      return;
    }
    sub_14001AE1C(qword_140041208);
    qword_140041208 = v11;
    do
      ++v9;
    while ( v2[v9] );
    if ( !(unsigned int)sub_140020D64(v9 + 1, v11, (__int64)v2, a2) )
    {
      sub_14000D100(0i64, *v5, 0x80ui64, a2);
      sub_14000D100(0i64, v5[1], 0x80ui64, a2);
      sub_14000D100(0i64, *v3, 0x40ui64, a2);
      sub_14000D100(0i64, v3[1], 0x40ui64, a2);
      sub_14002619C((WCHAR *)*v5, (__int64)v2, (CHAR *)*v3, 3i64, a2);
      v12 = 3i64;
      do
      {
        if ( *v2 )
          ++v2;
        --v12;
      }
      while ( v12 );
      v13 = *v2;
      v14 = v2 + 1;
      if ( *v2 != 45 )
        v14 = v2;
      v15 = sub_140016F7C((__int64 *)&v24, (__int64)v14, 0xAu, a2);
      v16 = 3600 * v15;
      v22 = 3600 * v15;
      while ( *v14 == 43 || (unsigned __int16)(*v14 - 48) <= 9u )
        ++v14;
      if ( *v14 == 58 )
      {
        ++v14;
        v17 = 60 * (unsigned __int64)sub_140016F7C((__int64 *)&v24, (__int64)v14, 0xAu, a2);
        v18 = *v14;
        v16 = v17 + v22;
        v22 += v17;
        if ( v18 >= 0x30u )
        {
          v19 = v18;
          do
          {
            v18 = v19;
            if ( v19 > 0x39u )
              break;
            ++v14;
            v18 = *v14;
            v19 = *v14;
          }
          while ( *v14 >= 0x30u );
        }
        if ( v18 == 58 )
        {
          ++v14;
          v20 = sub_140016F7C((__int64 *)&v24, (__int64)v14, 0xAu, a2);
          v16 = v20 + v22;
          v22 += v20;
          while ( *v14 >= 0x30u && *v14 <= 0x39u )
            ++v14;
        }
      }
      if ( v13 == 45 )
      {
        v16 = -v16;
        v22 = v16;
      }
      v23 = *v14 != 0;
      if ( (_WORD)v23 )
      {
        sub_14002619C((WCHAR *)v5[1], (__int64)v14, (CHAR *)v3[1], 3i64, a2);
        v16 = v22;
      }
      *sub_140025C00() = v16;
      v21 = v23;
      *sub_140025BF0() = v21;
      goto LABEL_11;
    }
LABEL_41:
    sub_14001ADD4(a2);
    JUMPOUT(*(_QWORD *)&byte_1400264F9);
  }
}
// 1400264F9: using guessed type char;

//----- (00000001400264FC) ----------------------------------------------------
int *__usercall sub_1400264FC@<rax>(__m256i *a1@<ymm0>)
{
  __int64 *v1; // rdi
  __int64 v2; // rax
  int v3; // ebx
  __int64 *v4; // rsi
  signed int v5; // ecx
  UINT v6; // ebx
  int v7; // ebx
  int v8; // ebx
  int v9; // ebx
  int *result; // rax
  int v11; // [rsp+50h] [rbp+20h]
  int v12; // [rsp+58h] [rbp+28h]
  int v13; // [rsp+60h] [rbp+30h]

  v1 = (__int64 *)sub_140025C08();
  v2 = sub_140025C10();
  v3 = 0;
  v11 = 0;
  v4 = (__int64 *)v2;
  v12 = 0;
  v13 = 0;
  if ( (unsigned int)sub_140025C78(&v11, a1)
    || (unsigned int)sub_140025C18(&v12, a1)
    || (unsigned int)sub_140025C48(&v13, a1) )
  {
    sub_14001ADD4(a1);
    __debugbreak();
    JUMPOUT(*(_QWORD *)sub_140026684);
  }
  sub_14001AE1C(qword_140041208);
  qword_140041208 = 0i64;
  if ( GetTimeZoneInformation(&TimeZoneInformation) != -1 )
  {
    v5 = 1;
    dword_140041210 = 1;
    v11 = 60 * TimeZoneInformation.Bias;
    if ( TimeZoneInformation.StandardDate.wMonth )
      v11 = 60 * TimeZoneInformation.Bias + 60 * TimeZoneInformation.StandardBias;
    if ( TimeZoneInformation.DaylightDate.wMonth && TimeZoneInformation.DaylightBias )
      v3 = 60 * (TimeZoneInformation.DaylightBias - TimeZoneInformation.StandardBias);
    else
      v5 = 0;
    v13 = v3;
    v12 = v5;
    sub_14000D100(0i64, *v4, 0x80ui64, a1);
    sub_14000D100(0i64, v4[1], 0x80ui64, a1);
    sub_14000D100(0i64, *v1, 0x40ui64, a1);
    sub_14000D100(0i64, v1[1], 0x40ui64, a1);
    v6 = sub_1400230DC(a1);
    sub_140026794((_WORD *)*v4, (__int64)TimeZoneInformation.StandardName, (CHAR *)*v1, v6, a1);
    sub_140026794((_WORD *)v4[1], (__int64)TimeZoneInformation.DaylightName, (CHAR *)v1[1], v6, a1);
  }
  v7 = v11;
  *sub_140025C00() = v7;
  v8 = v12;
  *sub_140025BF0() = v8;
  v9 = v13;
  result = sub_140025BF8();
  *result = v9;
  return result;
}
// 140041210: using guessed type int dword_140041210;

//----- (0000000140026684) ----------------------------------------------------
void __usercall sub_140026684(__m256i *a1@<ymm0>)
{
  int v1; // eax
  char *v2; // rdi
  char *v3; // rbx
  char *v4; // rax
  char *v5; // rcx
  __int64 v6; // [rsp+20h] [rbp-228h]
  char v7; // [rsp+28h] [rbp-220h]
  char v8; // [rsp+30h] [rbp-218h]

  dword_14003EBE0 = -1;
  dword_140041210 = 0;
  dword_14003EBD0 = -1;
  v1 = sub_140021AF8(&v6, &v8, 256i64, L"TZ");
  if ( !v1 )
  {
    v2 = &v8;
    v3 = 0i64;
    goto LABEL_14;
  }
  if ( v1 != 34 )
  {
LABEL_4:
    v3 = 0i64;
    goto LABEL_5;
  }
  v4 = (char *)sub_14001DACC(2 * v6);
  v2 = v4;
  if ( !v4 )
  {
    v5 = 0i64;
LABEL_9:
    sub_14001AE1C(v5);
    goto LABEL_4;
  }
  if ( (unsigned int)sub_140021AF8(&v7, v4, v6, L"TZ") )
  {
    v5 = v2;
    goto LABEL_9;
  }
  sub_14001AE1C(0i64);
  v3 = v2;
  if ( v2 == &v8 )
    v3 = 0i64;
LABEL_14:
  if ( *(_WORD *)v2 )
  {
    sub_140026280((unsigned __int16 *)v2, a1);
    goto LABEL_6;
  }
LABEL_5:
  sub_1400264FC(a1);
LABEL_6:
  sub_14001AE1C(v3);
}
// 140021AF8: using guessed type __int64 __fastcall sub_140021AF8(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400386A4: using guessed type wchar_t aTz[3];
// 14003EBD0: using guessed type int dword_14003EBD0;
// 14003EBE0: using guessed type int dword_14003EBE0;
// 140041210: using guessed type int dword_140041210;

//----- (0000000140026794) ----------------------------------------------------
int __usercall sub_140026794@<eax>(_WORD *a1@<rdx>, __int64 a2@<rcx>, CHAR *a3@<r8>, UINT a4@<r9d>, __m256i *a5@<ymm0>)
{
  UINT v5; // edi
  CHAR *v6; // rsi
  const WCHAR *v7; // rbx
  __int64 v9; // [rsp+28h] [rbp-20h]

  v5 = a4;
  v6 = a3;
  v7 = (const WCHAR *)a2;
  if ( (unsigned int)sub_140021CE0(64i64, a1, a2, 32i64, a5) )
  {
    sub_14001ADD4(a5);
    __debugbreak();
    JUMPOUT(*(_QWORD *)sub_140026814);
  }
  LODWORD(v9) = 64;
  return sub_1400203D8(v5, 0, v7, -1, v6, v9, 0i64, 0i64);
}

//----- (0000000140026814) ----------------------------------------------------
void __usercall sub_140026814(__m256i *a1@<ymm0>)
{
  if ( !dword_140041214 )
  {
    sub_140020BC8(dword_140041214 + 6);
    if ( !dword_140041214 )
    {
      sub_140026684(a1);
      _InterlockedIncrement(&dword_140041214);
    }
    sub_140020C28(6);
  }
}
// 140041214: using guessed type int dword_140041214;

//----- (0000000140026858) ----------------------------------------------------
__int64 __usercall sub_140026858@<rax>(_DWORD *a1@<rcx>, __m256i *a2@<ymm0>)
{
  _DWORD *v2; // rbx

  v2 = a1;
  sub_140020BC8(6);
  LODWORD(v2) = sub_140025CA8(v2, a2);
  sub_140020C28(6);
  return (unsigned int)v2;
}

//----- (0000000140026888) ----------------------------------------------------
__int64 __fastcall sub_140026888(unsigned __int16 *a1, unsigned __int16 *a2, __int64 a3)
{
  unsigned __int16 *v3; // r11
  unsigned __int16 *v4; // r10
  __int64 result; // rax
  int v6; // ecx
  int v7; // edx
  int v8; // er9
  int v9; // ecx

  v3 = a2;
  v4 = a1;
  if ( !a3 )
    return 0i64;
  do
  {
    v6 = *v4;
    ++v4;
    v7 = *v3;
    ++v3;
    v8 = v6 + 32;
    if ( (unsigned int)(v6 - 65) > 0x19 )
      v8 = v6;
    v9 = v7 + 32;
    if ( (unsigned int)(v7 - 65) > 0x19 )
      v9 = v7;
    result = (unsigned int)(v8 - v9);
    if ( v8 != v9 )
      break;
    if ( !v8 )
      break;
    --a3;
  }
  while ( a3 );
  return result;
}

//----- (00000001400268D4) ----------------------------------------------------
__int64 __usercall sub_1400268D4@<rax>(unsigned __int16 *a1@<rdx>, unsigned __int16 *a2@<rcx>, __int64 a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>)
{
  if ( dword_140040924 )
    return sub_14002691C(a1, a2, a3, 0i64, a4, a5, a6);
  if ( a2 && a1 )
    return sub_140026888(a2, a1, a3);
  *(_DWORD *)sub_140015334() = 22;
  sub_14001ADB4(a5);
  return 0x7FFFFFFFi64;
}
// 140040924: using guessed type int dword_140040924;

//----- (000000014002691C) ----------------------------------------------------
signed __int64 __usercall sub_14002691C@<rax>(unsigned __int16 *a1@<rdx>, unsigned __int16 *a2@<rcx>, __int64 a3@<r8>, __m128i *a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>)
{
  __int64 v7; // rbp
  unsigned __int16 *v8; // rsi
  unsigned __int16 *v9; // rbx
  signed __int64 result; // rax
  __int64 v11; // rdx
  unsigned int v12; // edi
  __int64 v13; // rcx
  unsigned __int16 v14; // ax
  __int64 v15; // rcx
  int v16; // er14
  int v17; // edi
  unsigned __int16 v18; // ax
  __int64 v19; // [rsp+20h] [rbp-38h]
  __m128i v20; // [rsp+28h] [rbp-30h]
  char v21; // [rsp+38h] [rbp-20h]

  v7 = a3;
  v8 = a1;
  v9 = a2;
  if ( a2 && a1 )
  {
    if ( a3 )
    {
      sub_14001590C(a4, (__int64)&v19, a6);
      v11 = v20.m128i_i64[0];
      if ( *(_QWORD *)(v20.m128i_i64[0] + 312) )
      {
        do
        {
          LOWORD(v13) = *v9;
          ++v9;
          if ( (unsigned __int16)v13 >= 0x100u )
          {
            v14 = sub_140025AA0(&v20, v13, a5, a6, a7);
            v11 = v20.m128i_i64[0];
          }
          else
          {
            v13 = (unsigned __int8)v13;
            if ( *((_BYTE *)&unk_140034750 + 2 * (unsigned __int8)v13 + 2) & 1 )
              LOBYTE(v13) = *(_BYTE *)(v13 + *(_QWORD *)(v11 + 272));
            v14 = (unsigned __int8)v13;
          }
          LOWORD(v15) = *v8;
          ++v8;
          v16 = v14;
          v17 = v14;
          if ( (unsigned __int16)v15 >= 0x100u )
          {
            v18 = sub_140025AA0(&v20, v15, a5, a6, a7);
            v11 = v20.m128i_i64[0];
          }
          else
          {
            v15 = (unsigned __int8)v15;
            if ( *((_BYTE *)&unk_140034750 + 2 * (unsigned __int8)v15 + 2) & 1 )
              LOBYTE(v15) = *(_BYTE *)(v15 + *(_QWORD *)(v11 + 272));
            v18 = (unsigned __int8)v15;
          }
          v12 = v17 - v18;
          if ( v12 )
            break;
          if ( !v16 )
            break;
          --v7;
        }
        while ( v7 );
      }
      else
      {
        v12 = sub_140026888(v9, v8, v7);
      }
      if ( v21 )
        *(_DWORD *)(v19 + 936) &= 0xFFFFFFFD;
      result = v12;
    }
    else
    {
      result = 0i64;
    }
  }
  else
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a6);
    result = 0x7FFFFFFFi64;
  }
  return result;
}

//----- (0000000140026A70) ----------------------------------------------------
__int64 __fastcall sub_140026A70(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v3; // r11
  unsigned __int8 *v4; // r10
  __int64 result; // rax
  int v6; // ecx
  int v7; // edx
  int v8; // er9
  int v9; // ecx

  v3 = a2;
  v4 = a1;
  if ( !a3 )
    return 0i64;
  do
  {
    v6 = *v4++;
    v7 = *v3;
    v8 = v6 + 32;
    if ( (unsigned int)(v6 - 65) > 0x19 )
      v8 = v6;
    ++v3;
    v9 = v7 + 32;
    if ( (unsigned int)(v7 - 65) > 0x19 )
      v9 = v7;
    result = (unsigned int)(v8 - v9);
    if ( v8 != v9 )
      break;
    if ( !v8 )
      break;
    --a3;
  }
  while ( a3 );
  return result;
}

//----- (0000000140026ABC) ----------------------------------------------------
__int64 __usercall sub_140026ABC@<rax>(unsigned __int8 *a1@<rdx>, unsigned __int8 *a2@<rcx>, unsigned __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  if ( dword_140040924 )
    return sub_140026B0C(a1, a2, a3, 0i64, a4);
  if ( a2 && a1 && a3 <= 0x7FFFFFFF )
    return sub_140026A70(a2, a1, a3);
  *(_DWORD *)sub_140015334() = 22;
  sub_14001ADB4(a4);
  return 0x7FFFFFFFi64;
}
// 140040924: using guessed type int dword_140040924;

//----- (0000000140026B0C) ----------------------------------------------------
signed __int64 __usercall sub_140026B0C@<rax>(unsigned __int8 *a1@<rdx>, unsigned __int8 *a2@<rcx>, unsigned __int64 a3@<r8>, __m128i *a4@<r9>, __m256i *a5@<ymm0>)
{
  unsigned __int64 v5; // rbx
  unsigned __int8 *v6; // rdi
  unsigned __int8 *v7; // rsi
  signed __int64 result; // rax
  __int64 v9; // r8
  __int64 v10; // rax
  int v11; // edx
  __int64 v12; // rax
  int v13; // ecx
  __int64 v14; // [rsp+20h] [rbp-28h]
  __int64 v15; // [rsp+28h] [rbp-20h]
  char v16; // [rsp+38h] [rbp-10h]

  v5 = a3;
  v6 = a1;
  v7 = a2;
  if ( a2 && a1 && a3 <= 0x7FFFFFFF )
  {
    if ( a3 )
    {
      sub_14001590C(a4, (__int64)&v14, a5);
      v9 = *(_QWORD *)(v15 + 272);
      do
      {
        v10 = *v7++;
        v11 = *(unsigned __int8 *)(v10 + v9);
        v12 = *v6++;
        v13 = *(unsigned __int8 *)(v12 + v9);
        result = (unsigned int)(v11 - v13);
        if ( v11 != v13 )
          break;
        if ( !v11 )
          break;
        --v5;
      }
      while ( v5 );
      if ( v16 )
        *(_DWORD *)(v14 + 936) &= 0xFFFFFFFD;
    }
    else
    {
      result = 0i64;
    }
  }
  else
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
    result = 0x7FFFFFFFi64;
  }
  return result;
}

//----- (0000000140026BBC) ----------------------------------------------------
signed __int64 __usercall sub_140026BBC@<rax>(int a1@<edx>, const WCHAR *a2@<rcx>, int a3@<r9d>, __m256i *a4@<ymm0>, int *a5, int a6)
{
  signed __int64 result; // rax
  unsigned int v7; // edi
  __int64 v8; // rax
  int v9; // [rsp+40h] [rbp-18h]
  unsigned int v10; // [rsp+44h] [rbp-14h]

  if ( !a5 || (*a5 = -1, !a2) || a6 && a3 & 0xFFFFFE7F )
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a4);
    result = 22i64;
  }
  else
  {
    v9 = 0;
    v10 = 0;
    v7 = sub_1400271CC((unsigned __int64)a5, (unsigned __int64)&v9, a2, a1, a4);
    v10 = v7;
    if ( v9 )
    {
      if ( v7 )
      {
        v8 = qword_140040970[(signed __int64)*a5 >> 6];
        *(_BYTE *)(v8 + 72i64 * (*a5 & 0x3F) + 56) &= 0xFEu;
      }
      sub_14001831C(*a5);
    }
    if ( v7 )
      *a5 = -1;
    result = v7;
  }
  return result;
}

//----- (0000000140026C80) ----------------------------------------------------
__int64 __usercall sub_140026C80@<rax>(__int64 a1@<rdx>, signed int a2@<ecx>, int a3@<r8d>, _BYTE *a4@<r9>, __m256i *a5@<ymm0>)
{
  signed int v5; // er15
  int v6; // ebx
  _BYTE *v7; // r14
  int v8; // esi
  __int64 v9; // rbp
  int v10; // ecx
  signed int v11; // edi
  unsigned int v12; // eax
  int v13; // ecx
  int v14; // ecx
  signed int v15; // eax
  int v17; // eax
  int v18; // eax
  int v19; // [rsp+50h] [rbp+8h]

  v5 = a2;
  v6 = 0;
  *a4 = 0;
  v7 = a4;
  v8 = a3;
  v9 = a1;
  if ( *(_BYTE *)(qword_140040970[(signed __int64)a2 >> 6] + 72i64 * (a2 & 0x3F) + 56) >= 0 )
    return 0i64;
  if ( !(a3 & 0x74000) )
  {
    v19 = 0;
    if ( (unsigned int)sub_14001A018(&v19, a5) )
    {
      sub_14001ADD4(a5);
      __debugbreak();
      JUMPOUT(*(_QWORD *)sub_140026F00);
    }
    if ( v19 & 0x74000 )
      v8 |= v19 & 0x74000;
    else
      v8 |= 0x4000u;
  }
  v10 = v8 & 0x74000;
  v11 = 2;
  if ( (v8 & 0x74000) == 0x4000 )
  {
    *v7 = 0;
    goto LABEL_15;
  }
  if ( !((v10 - 0x10000) & 0xFFFFBFFF) )
  {
    if ( (v8 & 0x301) != 769 )
      goto LABEL_15;
LABEL_13:
    *v7 = 2;
    goto LABEL_15;
  }
  if ( !((v10 - 0x20000) & 0xFFFFBFFF) )
    goto LABEL_13;
  if ( !((v10 - 0x40000) & 0xFFFFBFFF) )
    *v7 = 1;
LABEL_15:
  if ( !(v8 & 0x70000) || *(_BYTE *)v9 & 0x40 )
    return 0i64;
  v12 = *(_DWORD *)(v9 + 4) & 0xC0000000;
  if ( v12 != 0x40000000 )
  {
    if ( v12 == 2147483648 )
      goto LABEL_32;
    if ( v12 != -1073741824 )
      return 0i64;
  }
  if ( *(_DWORD *)(v9 + 8) != 1 && *(_DWORD *)(v9 + 8) != 2 )
  {
    if ( *(_DWORD *)(v9 + 8) != 3 && *(_DWORD *)(v9 + 8) != 4 )
    {
      if ( *(_DWORD *)(v9 + 8) != 5 )
        return 0i64;
      goto LABEL_25;
    }
    if ( sub_14001C754(0i64, v5, 2u, a5) )
    {
      if ( sub_14001C754(0i64, v5, 0, a5) == -1i64 )
        return *(unsigned int *)sub_140015334();
      if ( !(*(_DWORD *)(v9 + 4) & 0x80000000) )
        return 0i64;
LABEL_32:
      v19 = 0;
      v17 = sub_14001BF2C((WCHAR *)&v19, v5, 3u, a5);
      if ( v17 == -1 )
        return *(unsigned int *)sub_140015334();
      if ( v17 != 2 )
      {
        if ( v17 != 3 )
          goto LABEL_42;
        if ( v19 == 12565487 )
        {
          *v7 = 1;
          return 0i64;
        }
      }
      if ( (unsigned __int16)v19 == 65534 )
      {
        *(_DWORD *)sub_140015334() = 22;
        return *(unsigned int *)sub_140015334();
      }
      if ( (unsigned __int16)v19 == 65279 )
      {
        if ( sub_14001C754((LARGE_INTEGER)2i64, v5, 0, a5) != -1i64 )
        {
          *v7 = 2;
          return 0i64;
        }
        return *(unsigned int *)sub_140015334();
      }
LABEL_42:
      if ( sub_14001C754(0i64, v5, 0, a5) != -1i64 )
        return 0i64;
      return *(unsigned int *)sub_140015334();
    }
  }
LABEL_25:
  v13 = (char)*v7;
  v19 = 0;
  v14 = v13 - 1;
  if ( !v14 )
  {
    v11 = 3;
    v15 = 12565487;
LABEL_45:
    v19 = v15;
    while ( 1 )
    {
      v18 = sub_14001D278((unsigned __int16 *)((char *)&v19 + v6), v5, v11 - v6, a5);
      if ( v18 == -1 )
        break;
      v6 += v18;
      if ( v11 <= v6 )
        return 0i64;
    }
    return *(unsigned int *)sub_140015334();
  }
  if ( v14 == 1 )
  {
    v15 = 65279;
    goto LABEL_45;
  }
  return 0i64;
}

//----- (0000000140026F00) ----------------------------------------------------
_BYTE *__usercall sub_140026F00@<rax>(int a1@<edx>, _BYTE *a2@<rcx>, int a3@<r8d>, char a4@<r9b>, __m256i *a5@<ymm0>)
{
  _BYTE *v5; // rbx
  char v6; // r14
  int v7; // ebp
  int v8; // edi
  signed int v9; // esi
  signed int v10; // eax
  int v11; // eax
  signed int v12; // eax
  int v13; // ebp
  int v14; // ebp
  int v15; // ebp
  int v16; // ebp
  int v18; // [rsp+58h] [rbp+10h]

  v5 = a2;
  *a2 = 0;
  v6 = a4;
  v7 = a3;
  v8 = a1;
  v9 = -1;
  if ( a1 & 3 )
  {
    if ( (a1 & 3) == 1 )
    {
      v10 = ((a1 & 8) != 0 && (a1 & 0x70000) != 0) != 0 ? -1073741824 : 0x40000000;
    }
    else if ( (a1 & 3) == 2 )
    {
      v10 = -1073741824;
    }
    else
    {
      *(_DWORD *)sub_140015334() = 22;
      sub_14001ADB4(a5);
      v10 = -1;
    }
  }
  else
  {
    v10 = 2147483648;
  }
  *((_DWORD *)v5 + 1) = v10;
  v11 = v8 & 0x700;
  if ( v8 & 0x700 )
  {
    switch ( v11 )
    {
      case 256:
        v12 = 4;
        goto LABEL_22;
      case 512:
LABEL_19:
        v12 = 5;
        goto LABEL_22;
      case 768:
        v12 = 2;
        goto LABEL_22;
    }
    if ( v11 != 1024 )
    {
      if ( v11 == 1280 )
      {
LABEL_17:
        v12 = 1;
        goto LABEL_22;
      }
      if ( v11 != 1536 )
      {
        if ( v11 != 1792 )
        {
          *(_DWORD *)sub_140015334() = 22;
          sub_14001ADB4(a5);
          v12 = -1;
          goto LABEL_22;
        }
        goto LABEL_17;
      }
      goto LABEL_19;
    }
  }
  v12 = 3;
LABEL_22:
  *((_DWORD *)v5 + 2) = v12;
  v13 = v7 - 16;
  if ( v13 )
  {
    v14 = v13 - 16;
    if ( v14 )
    {
      v15 = v14 - 16;
      if ( v15 )
      {
        v16 = v15 - 16;
        if ( v16 )
        {
          if ( v16 == 64 )
          {
            v9 = *((_DWORD *)v5 + 1) == 2147483648;
          }
          else
          {
            *(_DWORD *)sub_140015334() = 22;
            sub_14001ADB4(a5);
          }
        }
        else
        {
          v9 = 3;
        }
      }
      else
      {
        v9 = 2;
      }
    }
    else
    {
      v9 = 1;
    }
  }
  else
  {
    v9 = 0;
  }
  *((_DWORD *)v5 + 5) = 0;
  *((_DWORD *)v5 + 3) = v9;
  *((_DWORD *)v5 + 4) = 128;
  if ( (v8 & 0x80u) != 0 )
    *v5 |= 0x10u;
  if ( !(v8 & 0x8000) )
  {
    if ( v8 & 0x74000 )
      goto LABEL_58;
    if ( (unsigned int)sub_14001A018(&v18, a5) )
    {
      sub_14001ADD4(a5);
      JUMPOUT(*(_QWORD *)&byte_140027105);
    }
    if ( v18 != 0x8000 )
LABEL_58:
      *v5 |= 0x80u;
  }
  if ( v8 & 0x100 && (v6 & ~(_BYTE)dword_140041308 & 0x80u) == 0 )
    *((_DWORD *)v5 + 4) = 1;
  if ( v8 & 0x40 )
  {
    *((_DWORD *)v5 + 5) |= 0x4000000u;
    *((_DWORD *)v5 + 1) |= 0x10000u;
    *((_DWORD *)v5 + 3) |= 4u;
  }
  if ( _bittest(&v8, 0xCu) )
    *((_DWORD *)v5 + 4) |= 0x100u;
  if ( _bittest(&v8, 0xDu) )
    *((_DWORD *)v5 + 5) |= 0x2000000u;
  if ( v8 & 0x20 )
  {
    *((_DWORD *)v5 + 5) |= 0x8000000u;
  }
  else if ( v8 & 0x10 )
  {
    *((_DWORD *)v5 + 5) |= 0x10000000u;
  }
  return v5;
}
// 140027105: using guessed type char;
// 140041308: using guessed type int dword_140041308;

//----- (0000000140027108) ----------------------------------------------------
__int64 __usercall sub_140027108@<rax>(int a1@<ecx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rbx
  char v3; // cl
  LARGE_INTEGER v4; // rdi
  __int16 v6; // [rsp+30h] [rbp+8h]

  v2 = a1;
  v3 = *(_BYTE *)(qword_140040970[v2 >> 6] + 72 * (v2 & 0x3F) + 56);
  if ( !(v3 & 0x48) && v3 < 0 )
  {
    v4 = sub_14001C754((LARGE_INTEGER)-1i64, v2, 2u, a2);
    if ( v4.QuadPart == -1 )
    {
      if ( *(_DWORD *)sub_140015314() != 131 )
        return *(unsigned int *)sub_140015334();
    }
    else
    {
      v6 = 0;
      if ( !(unsigned int)sub_14001BF2C((WCHAR *)&v6, v2, 1u, a2)
        && v6 == 26
        && (unsigned int)sub_1400290C4(v4, v2, a2) == -1
        || sub_14001C754(0i64, v2, 0, a2) == -1i64 )
      {
        return *(unsigned int *)sub_140015334();
      }
    }
  }
  return 0i64;
}

//----- (00000001400271CC) ----------------------------------------------------
__int64 __usercall sub_1400271CC@<rax>(unsigned __int64 a1@<rdx>, unsigned __int64 a2@<rcx>, const WCHAR *a3@<r8>, int a4@<r9d>, __m256i *a5@<ymm0>)
{
  unsigned int v5; // er12
  const WCHAR *v6; // rbx
  unsigned __int128 v7; // di
  _BYTE *v8; // rax
  __m128i v9; // xmm0
  void *v10; // xmm1_8
  unsigned __int64 v11; // xmm0_8
  int v13; // eax
  DWORD v14; // ecx
  DWORD v15; // dh^3
  __int64 v16; // r14
  HANDLE v17; // rax
  DWORD v18; // ebx
  HANDLE v19; // r13
  int v20; // eax
  DWORD v21; // eax
  int v22; // ebx
  char v23; // r14
  signed __int64 v24; // rax
  __int64 v25; // rcx
  unsigned int v26; // er14
  unsigned int v27; // ecx
  signed int v28; // ecx
  __int64 v29; // rcx
  HANDLE v30; // rdx
  int v31; // eax
  char v32; // [rsp+18h] [rbp-61h]
  DWORD dwCreationDisposition[4]; // [rsp+20h] [rbp-59h]
  HANDLE hTemplateFile; // [rsp+30h] [rbp-49h]
  char v35; // [rsp+38h] [rbp-41h]
  void *v36; // [rsp+40h] [rbp-39h]
  DWORD dwFlagsAndAttributes[2]; // [rsp+48h] [rbp-31h]
  DWORD dwShareMode[2]; // [rsp+50h] [rbp-29h]
  struct _SECURITY_ATTRIBUTES SecurityAttributes; // [rsp+58h] [rbp-21h]
  __int128 v40; // [rsp+78h] [rbp-1h]
  void *v41; // [rsp+88h] [rbp+Fh]
  __int64 v42; // [rsp+A0h] [rbp+27h]
  LPCWSTR lpFileName; // [rsp+D8h] [rbp+5Fh]
  void *retaddr; // [rsp+E8h] [rbp+6Fh]
  char v45; // [rsp+F0h] [rbp+77h]

  v5 = a4;
  v6 = a3;
  v7 = __PAIR__(a2, a1);
  v8 = sub_140026F00(a4, &v42, (int)retaddr, v45, a5);
  v9 = *(__m128i *)v8;
  v10 = (void *)*((_QWORD *)v8 + 2);
  *(__m128i *)dwCreationDisposition = v9;
  v11 = (unsigned __int128)_mm_srli_si128(v9, 8);
  v36 = v10;
  hTemplateFile = v10;
  *(_QWORD *)dwShareMode = v11 >> 32;
  if ( HIDWORD(v11) == -1 )
  {
    *(_DWORD *)sub_140015314() = 0;
    *(_DWORD *)v7 = -1;
    return *(unsigned int *)sub_140015334();
  }
  v13 = sub_140018344();
  *(_DWORD *)v7 = v13;
  if ( v13 == -1 )
  {
    *(_DWORD *)sub_140015314() = 0;
    *(_DWORD *)v7 = -1;
    *(_DWORD *)sub_140015334() = 24;
    return *(unsigned int *)sub_140015334();
  }
  v14 = dwCreationDisposition[2];
  v15 = dwCreationDisposition[1];
  v16 = (unsigned int)hTemplateFile | HIDWORD(hTemplateFile);
  **((_DWORD **)&v7 + 1) = 1;
  SecurityAttributes.nLength = 24;
  SecurityAttributes.lpSecurityDescriptor = 0i64;
  SecurityAttributes.bInheritHandle = ~(unsigned __int8)(v5 >> 7) & 1;
  *(_QWORD *)dwFlagsAndAttributes = v16;
  v17 = CreateFileW(v6, v15, HIDWORD(v11), &SecurityAttributes, v14, v16, 0i64);
  v18 = dwCreationDisposition[1];
  v19 = v17;
  if ( v17 == (HANDLE)-1i64 )
  {
    if ( (dwCreationDisposition[1] & 0xC0000000) != -1073741824
      || !(v5 & 1)
      || (v18 = dwCreationDisposition[1] & 0x7FFFFFFF,
          v19 = CreateFileW(
                  lpFileName,
                  dwCreationDisposition[1] & 0x7FFFFFFF,
                  HIDWORD(v11),
                  &SecurityAttributes,
                  dwCreationDisposition[2],
                  v16,
                  0i64),
          v19 == (HANDLE)-1i64) )
    {
      *(_BYTE *)(qword_140040970[(signed __int64)*(signed int *)v7 >> 6] + 72i64 * (*(_DWORD *)v7 & 0x3F) + 56) &= 0xFEu;
      v20 = GetLastError();
      sub_1400152A8(v20);
      return *(unsigned int *)sub_140015334();
    }
  }
  v21 = GetFileType(v19);
  if ( !v21 )
  {
    v22 = GetLastError();
    sub_1400152A8(v22);
    *(_BYTE *)(qword_140040970[(signed __int64)*(signed int *)v7 >> 6] + 72i64 * (*(_DWORD *)v7 & 0x3F) + 56) &= 0xFEu;
    CloseHandle(v19);
    if ( !v22 )
      *(_DWORD *)sub_140015334() = 13;
    return *(unsigned int *)sub_140015334();
  }
  v23 = dwCreationDisposition[0];
  if ( v21 == 2 )
  {
    v23 = LOBYTE(dwCreationDisposition[0]) | 0x40;
  }
  else if ( v21 == 3 )
  {
    v23 = LOBYTE(dwCreationDisposition[0]) | 8;
  }
  sub_14001825C(*(_DWORD *)v7, v19);
  v24 = (signed __int64)*(signed int *)v7 >> 6;
  v25 = *(_DWORD *)v7 & 0x3F;
  v35 = v23 | 1;
  LOBYTE(dwCreationDisposition[0]) = v23 | 1;
  *(_BYTE *)(qword_140040970[v24] + 72 * v25 + 56) = v23 | 1;
  *(_BYTE *)(qword_140040970[(signed __int64)*(signed int *)v7 >> 6] + 72i64 * (*(_DWORD *)v7 & 0x3F) + 57) = 0;
  if ( v5 & 2 )
  {
    v26 = sub_140027108(*(_DWORD *)v7, a5);
    if ( v26 )
    {
      v27 = *(_DWORD *)v7;
LABEL_21:
      sub_14001AF94(v27, a5);
      return v26;
    }
  }
  v28 = *(_DWORD *)v7;
  v40 = *(_OWORD *)dwCreationDisposition;
  v41 = v36;
  v26 = sub_140026C80((__int64)&v40, v28, v5, &v32, a5);
  if ( v26 )
  {
    v27 = *(_DWORD *)v7;
    goto LABEL_21;
  }
  *(_BYTE *)(qword_140040970[(signed __int64)*(signed int *)v7 >> 6] + 72i64 * (*(_DWORD *)v7 & 0x3F) + 57) = v32;
  v29 = *(signed int *)v7;
  *(_BYTE *)(qword_140040970[v29 >> 6] + 72 * (v29 & 0x3F) + 61) ^= (*(_BYTE *)(qword_140040970[v29 >> 6]
                                                                              + 72 * (v29 & 0x3F)
                                                                              + 61) ^ BYTE2(v5)) & 1;
  if ( !(v35 & 0x48) && v5 & 8 )
    *(_BYTE *)(qword_140040970[(signed __int64)*(signed int *)v7 >> 6] + 72i64 * (*(_DWORD *)v7 & 0x3F) + 56) |= 0x20u;
  if ( (v18 & 0xC0000000) == -1073741824 && v5 & 1 )
  {
    CloseHandle(v19);
    v30 = CreateFileW(
            lpFileName,
            v18 & 0x7FFFFFFF,
            dwShareMode[0],
            &SecurityAttributes,
            dwFlagsAndAttributes[0],
            dwFlagsAndAttributes[0],
            0i64);
    if ( v30 == (HANDLE)-1i64 )
    {
      v31 = GetLastError();
      sub_1400152A8(v31);
      *(_BYTE *)(qword_140040970[(signed __int64)*(signed int *)v7 >> 6] + 72i64 * (*(_DWORD *)v7 & 0x3F) + 56) &= 0xFEu;
      sub_140018484(*(_DWORD *)v7);
      return *(unsigned int *)sub_140015334();
    }
    *(_QWORD *)(qword_140040970[(signed __int64)*(signed int *)v7 >> 6] + 72i64 * (*(_DWORD *)v7 & 0x3F) + 40) = v30;
  }
  return 0i64;
}

//----- (00000001400275BC) ----------------------------------------------------
signed __int64 __usercall sub_1400275BC@<rax>(const WCHAR *a1@<rdx>, int *a2@<rcx>, int a3@<r8d>, __m256i *a4@<ymm0>, int a5)
{
  return sub_140026BBC(a3, a1, a5, a4, a2, 1);
}

//----- (00000001400275F0) ----------------------------------------------------
__int64 __fastcall sub_1400275F0(__int64 a1, char *a2, unsigned __int64 a3, _QWORD *a4, __int64 a5)
{
  _QWORD *v5; // r10
  __int64 v6; // r11
  char *v7; // rdi
  char *v8; // r12
  unsigned __int64 v9; // r15
  _DWORD *v10; // r14
  int v12; // er9
  unsigned __int8 v13; // r8
  unsigned __int8 v14; // bl
  unsigned int v15; // edx
  unsigned __int64 v16; // r9
  char v17; // cl
  int v18[2]; // [rsp+18h] [rbp-60h]
  int v19; // [rsp+20h] [rbp-58h]
  int v20; // [rsp+24h] [rbp-54h]
  int v21; // [rsp+28h] [rbp-50h]

  v5 = &unk_1400412D0;
  v6 = 0i64;
  v7 = (char *)&unk_14002BDF1;
  v8 = a2;
  if ( a4 )
    v5 = a4;
  if ( a2 )
    v7 = a2;
  v9 = 1i64;
  if ( a2 )
    v9 = a3;
  v10 = (_DWORD *)(a1 & -(signed __int64)(a2 != 0i64));
  if ( !v9 )
    return -2i64;
  if ( !*((_WORD *)v5 + 3) )
  {
    v12 = (unsigned __int8)*v7++;
    if ( (v12 & 0x80u) == 0 )
    {
      if ( v10 )
        *v10 = v12;
      LOBYTE(v6) = (_BYTE)v12 != 0;
      return v6;
    }
    if ( (v12 & 0xE0) == -64 )
    {
      v13 = 2;
LABEL_20:
      v14 = v13;
      v15 = v12 & ((1 << (7 - v13)) - 1);
      goto LABEL_24;
    }
    if ( (v12 & 0xF0) == -32 )
    {
      v13 = 3;
      goto LABEL_20;
    }
    if ( (v12 & 0xF8) == -16 )
    {
      v13 = 4;
      goto LABEL_20;
    }
    return sub_140029028(v5, a5);
  }
  v13 = *((_BYTE *)v5 + 4);
  v15 = *(_DWORD *)v5;
  v14 = *((_BYTE *)v5 + 6);
  if ( (unsigned __int8)(v13 - 2) > 2u || v14 < 1u || v14 >= v13 )
    return sub_140029028(v5, a5);
LABEL_24:
  v16 = v14;
  if ( v14 >= v9 )
    v16 = v9;
  while ( v7 - v8 < v16 )
  {
    v17 = *v7++;
    if ( (v17 & 0xC0) != -128 )
      return sub_140029028(v5, a5);
    v15 = (v15 << 6) | v17 & 0x3F;
  }
  if ( v16 < v14 )
  {
    *((_WORD *)v5 + 2) = v13;
    *((_WORD *)v5 + 3) = (unsigned __int8)(v14 - v16);
    *(_DWORD *)v5 = v15;
    return -2i64;
  }
  if ( v15 - 55296 <= 0x7FF )
    return sub_140029028(v5, a5);
  if ( v15 >= 0x110000 )
    return sub_140029028(v5, a5);
  v19 = 128;
  v20 = 2048;
  v21 = 0x10000;
  if ( v15 < v18[v13] )
    return sub_140029028(v5, a5);
  if ( v10 )
    *v10 = v15;
  return sub_140029020(v14 & (unsigned __int64)-(signed __int64)(v15 != 0), v5);
}
// 1400275F0: using guessed type int var_60[2];

//----- (00000001400277CC) ----------------------------------------------------
__int64 __usercall sub_1400277CC@<rax>(__m128i *a1@<rdx>, __m128i *a2@<rcx>, unsigned __int64 a3@<r8>, __int128 *a4@<xmm1>, __m256i *a5@<ymm0>, __m256i *a6@<ymm1>)
{
  if ( dword_140040924 )
    return sub_14002781C(a1, a2, a3, 0i64, a4, a5, a6);
  if ( a2 && a1 && a3 <= 0x7FFFFFFF )
    return sub_140026888((unsigned __int16 *)a2, (unsigned __int16 *)a1, a3);
  *(_DWORD *)sub_140015334() = 22;
  sub_14001ADB4(a5);
  return 0x7FFFFFFFi64;
}
// 140040924: using guessed type int dword_140040924;

//----- (000000014002781C) ----------------------------------------------------
signed __int64 __usercall sub_14002781C@<rax>(__m128i *a1@<rdx>, __m128i *a2@<rcx>, unsigned __int64 a3@<r8>, __m128i *a4@<r9>, __int128 *a5@<xmm1>, __m256i *a6@<ymm0>, __m256i *a7@<ymm1>)
{
  __int64 v7; // rdi
  __m128i *v8; // rsi
  __m128i *v9; // rbp
  signed __int64 result; // rax
  unsigned int v11; // ebx
  unsigned __int16 *v12; // rcx
  int v13; // eax
  __int64 v14; // [rsp+30h] [rbp-28h]
  __int64 v15; // [rsp+38h] [rbp-20h]
  char v16; // [rsp+48h] [rbp-10h]

  v7 = a3;
  v8 = a1;
  v9 = a2;
  if ( !a3 )
    return 0i64;
  if ( a2 && a1 )
  {
    v11 = 0x7FFFFFFF;
    if ( a3 <= 0x7FFFFFFF )
    {
      sub_14001590C(a4, (__int64)&v14, a6);
      v12 = *(unsigned __int16 **)(v15 + 304);
      if ( v12 )
      {
        v13 = sub_1400292F0(0x1001u, v12, v9, v7, a5, a7, v8, v7);
        if ( v13 )
          v11 = v13 - 2;
        else
          *(_DWORD *)sub_140015334() = 22;
      }
      else
      {
        v11 = sub_140026888((unsigned __int16 *)v9, (unsigned __int16 *)v8, v7);
      }
      if ( v16 )
        *(_DWORD *)(v14 + 936) &= 0xFFFFFFFD;
    }
    else
    {
      *(_DWORD *)sub_140015334() = 22;
      sub_14001ADB4(a6);
    }
    result = v11;
  }
  else
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a6);
    result = 0x7FFFFFFFi64;
  }
  return result;
}

//----- (000000014002790C) ----------------------------------------------------
__int64 __usercall sub_14002790C@<rax>(unsigned __int8 *a1@<rdx>, CHAR *a2@<rcx>, unsigned __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  JUMPOUT(dword_140040924, 0, sub_140026ABC);
  return sub_140027924(a1, a2, a3, 0i64, a4);
}
// 140040924: using guessed type int dword_140040924;

//----- (0000000140027924) ----------------------------------------------------
__int64 __usercall sub_140027924@<rax>(unsigned __int8 *a1@<rdx>, CHAR *a2@<rcx>, unsigned __int64 a3@<r8>, __m128i *a4@<r9>, __m256i *a5@<ymm0>)
{
  unsigned __int8 *v5; // rsi
  CHAR *v6; // rbp
  unsigned __int64 v7; // rdi
  unsigned int v8; // ebx
  unsigned __int16 *v9; // rdx
  int v10; // eax
  __int64 v12; // [rsp+40h] [rbp-28h]
  __m128i v13; // [rsp+48h] [rbp-20h]
  char v14; // [rsp+58h] [rbp-10h]

  v5 = a1;
  v6 = a2;
  v7 = a3;
  sub_14001590C(a4, (__int64)&v12, a5);
  if ( v7 )
  {
    if ( v6 && v5 )
    {
      v8 = 0x7FFFFFFF;
      if ( v7 <= 0x7FFFFFFF )
      {
        v9 = *(unsigned __int16 **)(v13.m128i_i64[0] + 304);
        if ( v9 )
        {
          v10 = sub_140029734(v9, &v13, 0x1001u, v6, a5, v7, (__int64)v5, v7, *(_DWORD *)(v13.m128i_i64[0] + 20));
          if ( v10 )
            v8 = v10 - 2;
          else
            *(_DWORD *)sub_140015334() = 22;
        }
        else
        {
          v8 = sub_140026B0C(v5, (unsigned __int8 *)v6, v7, &v13, a5);
        }
      }
      else
      {
        *(_DWORD *)sub_140015334() = 22;
        sub_14001ADB4(a5);
      }
    }
    else
    {
      *(_DWORD *)sub_140015334() = 22;
      sub_14001ADB4(a5);
      v8 = 0x7FFFFFFF;
    }
  }
  else
  {
    v8 = 0;
  }
  if ( v14 )
    *(_DWORD *)(v12 + 936) &= 0xFFFFFFFD;
  return v8;
}

//----- (0000000140027A24) ----------------------------------------------------
__int64 __usercall sub_140027A24@<rax>(const CHAR *a1@<rdx>, const CHAR *a2@<rcx>, __m256i *a3@<ymm0>)
{
  const CHAR *v3; // r14
  const CHAR *v4; // rsi
  WCHAR *v5; // rdi
  UINT v6; // ebx
  UINT v7; // er9
  int v8; // eax
  unsigned int v9; // ebx
  __int64 v11; // [rsp+8h] [rbp-39h]
  __int64 v12; // [rsp+10h] [rbp-31h]
  char v13; // [rsp+20h] [rbp-21h]
  __int64 v14; // [rsp+28h] [rbp-19h]
  __int64 v15; // [rsp+30h] [rbp-11h]
  LPCWSTR lpValue; // [rsp+38h] [rbp-9h]
  __int64 v17; // [rsp+40h] [rbp-1h]
  __int64 v18; // [rsp+48h] [rbp+7h]
  char v19; // [rsp+50h] [rbp+Fh]
  __int64 v20; // [rsp+58h] [rbp+17h]
  __int64 v21; // [rsp+60h] [rbp+1Fh]
  LPCWSTR lpName; // [rsp+68h] [rbp+27h]
  __int64 v23; // [rsp+70h] [rbp+2Fh]
  __int64 v24; // [rsp+78h] [rbp+37h]
  char v25; // [rsp+80h] [rbp+3Fh]
  void *retaddr; // [rsp+B8h] [rbp+77h]

  v3 = a1;
  v4 = a2;
  v20 = 0i64;
  v21 = 0i64;
  lpName = 0i64;
  v23 = 0i64;
  v5 = 0i64;
  v24 = 0i64;
  v25 = 0;
  v14 = 0i64;
  v15 = 0i64;
  lpValue = 0i64;
  v17 = 0i64;
  v18 = 0i64;
  v19 = 0;
  sub_14001590C(0i64, (__int64)&v13, a3);
  v6 = 65001;
  if ( *(_DWORD *)(v12 + 12) == 65001 )
  {
    if ( v13 )
      *(_DWORD *)(v11 + 936) &= 0xFFFFFFFD;
    v7 = 65001;
  }
  else if ( (unsigned int)sub_14001F2F4() )
  {
    if ( v13 )
      *(_DWORD *)(v11 + 936) &= 0xFFFFFFFD;
    v7 = 0;
  }
  else
  {
    if ( v13 )
      *(_DWORD *)(v11 + 936) &= 0xFFFFFFFD;
    v7 = 1;
  }
  if ( (unsigned int)sub_1400153F4(v4, (__int64)&v20, (__int64)&retaddr, v7) )
    goto LABEL_33;
  sub_14001590C(0i64, (__int64)&v11, a3);
  if ( *(_DWORD *)(v12 + 12) == 65001 )
  {
    if ( v13 )
      *(_DWORD *)(v11 + 936) &= 0xFFFFFFFD;
  }
  else if ( (unsigned int)sub_14001F2F4() )
  {
    if ( v13 )
      *(_DWORD *)(v11 + 936) &= 0xFFFFFFFD;
    v6 = 0;
  }
  else
  {
    if ( v13 )
      *(_DWORD *)(v11 + 936) &= 0xFFFFFFFD;
    v6 = 1;
  }
  v8 = sub_1400153F4(v3, (__int64)&v14, (__int64)&retaddr, v6);
  v5 = (WCHAR *)lpValue;
  if ( v8 )
LABEL_33:
    v9 = 0;
  else
    v9 = SetEnvironmentVariableW(lpName, lpValue);
  if ( v19 )
    sub_14001AE1C(v5);
  if ( v25 )
    sub_14001AE1C((LPVOID)lpName);
  return v9;
}

//----- (0000000140027BC4) ----------------------------------------------------
int *sub_140027BC4()
{
  LPVOID *v0; // rbx
  LPVOID *v1; // rbx
  int *result; // rax

  v0 = (LPVOID *)&unk_1400412D8;
  do
  {
    sub_14001AE1C(*v0);
    *v0 = 0i64;
    ++v0;
  }
  while ( v0 != (LPVOID *)&unk_1400412F0 );
  v1 = (LPVOID *)&unk_1400412F0;
  do
  {
    sub_14001AE1C(*v1);
    *v1 = 0i64;
    result = &dword_140041308;
    ++v1;
  }
  while ( v1 != (LPVOID *)&dword_140041308 );
  return result;
}
// 140041308: using guessed type int dword_140041308;

//----- (0000000140027C20) ----------------------------------------------------
void __usercall sub_140027C20(unsigned __int64 a1@<rdx>, unsigned __int64 a2@<rcx>, unsigned __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  unsigned __int64 v5; // r14
  unsigned __int64 v6; // r13
  unsigned __int64 v7; // r15
  signed __int64 v8; // rcx
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // rbx
  unsigned __int64 i; // rdi
  unsigned __int64 v12; // r8
  _BYTE *v13; // rdx
  unsigned __int64 v14; // rbx
  char v15; // cl
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // rsi
  unsigned __int64 v18; // r9
  _BYTE *v19; // r8
  char v20; // cl
  unsigned __int64 v21; // r8
  _BYTE *v22; // rdx
  unsigned __int64 v23; // r9
  char v24; // cl
  unsigned __int64 v25; // r8
  _BYTE *v26; // rdx
  unsigned __int64 v27; // r9
  char v28; // cl
  unsigned __int64 v29; // rbx
  _BYTE *v30; // rdi
  unsigned __int64 v31; // rbp
  unsigned __int64 v32; // r8
  _BYTE *v33; // rdx
  unsigned __int64 v34; // r9
  char v35; // cl
  unsigned __int64 v36; // rax
  signed __int64 v37; // [rsp+20h] [rbp-448h]
  __int64 v38[62]; // [rsp+30h] [rbp-438h]
  __int64 v39[62]; // [rsp+220h] [rbp-248h]

  v5 = a3;
  v6 = a2;
  if ( (a2 || !a1) && a3 && a4 )
  {
    if ( a1 >= 2 )
    {
      v7 = a2 + a3 * (a1 - 1);
      v8 = 0i64;
      v37 = 0i64;
      while ( 1 )
      {
        while ( 1 )
        {
          v9 = (v7 - v6) / v5 + 1;
          if ( v9 <= 8 )
          {
            if ( v7 > v6 )
            {
              do
              {
                v10 = v6;
                for ( i = v5 + v6; i <= v7; i += v5 )
                {
                  if ( (signed int)sub_14002A5D0(i) > 0 )
                    v10 = i;
                }
                v12 = v5;
                v13 = (_BYTE *)v7;
                if ( v10 != v7 )
                {
                  v14 = v10 - v7;
                  do
                  {
                    v15 = v13[v14];
                    v13[v14] = *v13;
                    *v13++ = v15;
                    --v12;
                  }
                  while ( v12 );
                }
                v7 -= v5;
              }
              while ( v7 > v6 );
              v8 = v37;
            }
            goto LABEL_19;
          }
          v16 = v5 * (v9 >> 1);
          v17 = v16 + v6;
          if ( (signed int)sub_14002A5D0(v6) > 0 )
          {
            v18 = v5;
            v19 = (_BYTE *)(v16 + v6);
            if ( v6 != v17 )
            {
              do
              {
                v20 = v19[-v16];
                v19[-v16] = *v19;
                *v19++ = v20;
                --v18;
              }
              while ( v18 );
            }
          }
          if ( (signed int)sub_14002A5D0(v6) > 0 )
          {
            v21 = v5;
            v22 = (_BYTE *)v7;
            if ( v6 != v7 )
            {
              v23 = v6 - v7;
              do
              {
                v24 = v22[v23];
                v22[v23] = *v22;
                *v22++ = v24;
                --v21;
              }
              while ( v21 );
            }
          }
          if ( (signed int)sub_14002A5D0(v16 + v6) > 0 )
          {
            v25 = v5;
            v26 = (_BYTE *)v7;
            if ( v17 != v7 )
            {
              v27 = v17 - v7;
              do
              {
                v28 = v26[v27];
                v26[v27] = *v26;
                *v26++ = v28;
                --v25;
              }
              while ( v25 );
            }
          }
          v29 = v6;
          v30 = (_BYTE *)v7;
          while ( 1 )
          {
            if ( v17 > v29 )
            {
              while ( 1 )
              {
                v29 += v5;
                if ( v29 >= v17 )
                  break;
                if ( (signed int)sub_14002A5D0(v29) > 0 )
                  goto LABEL_39;
              }
            }
            do
              v29 += v5;
            while ( v29 <= v7 && (signed int)sub_14002A5D0(v29) <= 0 );
            do
            {
LABEL_39:
              v31 = (unsigned __int64)v30;
              v30 -= v5;
            }
            while ( (unsigned __int64)v30 > v17 && (signed int)sub_14002A5D0(v30) > 0 );
            if ( (unsigned __int64)v30 < v29 )
              break;
            v32 = v5;
            v33 = v30;
            if ( v30 != (_BYTE *)v29 )
            {
              v34 = v29 - (_QWORD)v30;
              do
              {
                v35 = v33[v34];
                v33[v34] = *v33;
                *v33++ = v35;
                --v32;
              }
              while ( v32 );
            }
            v36 = v29;
            if ( (_BYTE *)v17 != v30 )
              v36 = v17;
            v17 = v36;
          }
          if ( v17 < v31 )
          {
            while ( 1 )
            {
              v31 -= v5;
              if ( v31 <= v17 )
                break;
              if ( (unsigned int)sub_14002A5D0(v31) )
                goto LABEL_54;
            }
          }
          do
            v31 -= v5;
          while ( v31 > v6 && !(unsigned int)sub_14002A5D0(v31) );
LABEL_54:
          v8 = v37;
          if ( (signed __int64)(v31 - v6) >= (signed __int64)(v7 - v29) )
            break;
          if ( v29 < v7 )
          {
            v38[v37] = v29;
            v39[v37] = v7;
            v8 = v37++ + 1;
          }
          if ( v6 >= v31 )
          {
LABEL_19:
            v37 = --v8;
            if ( v8 < 0 )
              return;
            v6 = v38[v8];
            v7 = v39[v8];
          }
          else
          {
            v7 = v31;
          }
        }
        if ( v6 < v31 )
        {
          v38[v37] = v6;
          v39[v37] = v31;
          v8 = v37++ + 1;
        }
        if ( v29 >= v7 )
          goto LABEL_19;
        v6 = v29;
      }
    }
  }
  else
  {
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a5);
  }
}
// 14002A5D0: using guessed type __int64 __fastcall sub_14002A5D0(_QWORD);
// 140027C20: using guessed type __int64 var_438[62];
// 140027C20: using guessed type __int64 var_248[62];

//----- (0000000140028030) ----------------------------------------------------
int __fastcall sub_140028030(__int64 a1, unsigned __int16 *a2, DWORD a3, CHAR *a4, int a5, WCHAR *a6, int a7, UINT a8, int a9)
{
  int v9; // edi
  const CHAR *v10; // rsi
  DWORD v11; // er12
  unsigned __int16 *v12; // r13
  __int64 v13; // rbx
  int v14; // eax
  UINT v15; // er14
  int result; // eax
  __int64 v17; // r15
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rax
  signed __int64 v20; // rcx
  signed __int64 v21; // rcx
  void *v22; // rsp
  void *v23; // rsp
  WCHAR *v24; // rbx
  WCHAR *v25; // rax
  int v26; // eax
  int v27; // esi
  unsigned __int64 v28; // rcx
  signed __int64 v29; // rax
  void *v30; // rsp
  WCHAR *v31; // rdi
  WCHAR *v32; // rax
  __int64 v33; // [rsp+0h] [rbp-50h]
  __int64 v34; // [rsp+28h] [rbp-28h]
  const CHAR *v35; // [rsp+30h] [rbp-20h]
  BOOL *v36; // [rsp+38h] [rbp-18h]
  __int64 v37; // [rsp+40h] [rbp-10h]
  char v38; // [rsp+50h] [rbp+0h]

  v9 = a5;
  v10 = a4;
  v11 = a3;
  v12 = a2;
  v13 = a1;
  if ( a5 > 0 )
  {
    v14 = sub_1400297C0(a4, a5);
    v9 = v14 + 1;
    if ( v14 >= a5 )
      v9 = v14;
  }
  v15 = a8;
  if ( !a8 )
    v15 = *(_DWORD *)(*(_QWORD *)v13 + 12i64);
  result = sub_14001FB10(v15, a9 != 0 ? 9 : 1, v10, v9, 0i64, 0);
  v17 = result;
  if ( result )
  {
    v18 = 2i64 * result + 16;
    v19 = v18 & -(signed __int64)(2i64 * result < v18);
    if ( !(v18 & -(signed __int64)(2 * v17 < v18)) )
    {
      v24 = 0i64;
      goto LABEL_47;
    }
    if ( v19 > 0x400 )
    {
      v25 = (WCHAR *)sub_14001DACC(v18 & -(signed __int64)(2 * v17 < v18));
      v24 = v25;
      if ( !v25 )
      {
LABEL_16:
        if ( v24 )
        {
          if ( sub_14001FB10(v15, 1, v10, v9, v24, v17) )
          {
            v37 = 0i64;
            v36 = 0i64;
            v35 = 0i64;
            v26 = sub_14001F4B4(v12, v11, v24, v17, 0i64, 0);
            v27 = v26;
            if ( v26 )
            {
              if ( v11 & 0x400 )
              {
                if ( !a7 )
                  goto LABEL_48;
                if ( v26 <= a7 )
                {
                  v37 = 0i64;
                  v36 = 0i64;
                  v35 = 0i64;
                  v27 = sub_14001F4B4(v12, v11, v24, v17, a6, a7);
                  if ( v27 )
                    goto LABEL_48;
                }
                goto LABEL_47;
              }
              v28 = (2i64 * v26 + 16) & -(signed __int64)(2i64 * v26 < (unsigned __int64)(2i64 * v26 + 16));
              if ( !v28 )
              {
                v31 = 0i64;
                goto LABEL_42;
              }
              if ( v28 > 0x400 )
              {
                v32 = (WCHAR *)sub_14001DACC(v28);
                v31 = v32;
                if ( !v32 )
                  goto LABEL_33;
                *(_DWORD *)v32 = 56797;
              }
              else
              {
                v29 = v28 + 15;
                if ( v28 + 15 <= v28 )
                  v29 = 1152921504606846960i64;
                v30 = alloca(v29);
                v31 = (WCHAR *)&v38;
                if ( &v33 == (__int64 *)-80i64 )
                  goto LABEL_45;
                *(_DWORD *)&v38 = 52428;
              }
              v31 += 8;
LABEL_33:
              if ( !v31 )
                goto LABEL_45;
              v37 = 0i64;
              v36 = 0i64;
              v35 = 0i64;
              if ( sub_14001F4B4(v12, v11, v24, v17, v31, v27) )
              {
                v36 = 0i64;
                v35 = 0i64;
                if ( a7 )
                {
                  LODWORD(v34) = a7;
                  v27 = sub_1400203D8(v15, 0, v31, v27, (CHAR *)a6, v34, v35, v36);
                  if ( !v27 )
                    goto LABEL_43;
                }
                else
                {
                  LODWORD(v34) = 0;
                  v27 = sub_1400203D8(v15, 0, v31, v27, 0i64, v34, v35, v36);
                  if ( !v27 )
                    goto LABEL_42;
                }
                if ( *((_DWORD *)v31 - 4) == 56797 )
                  sub_14001AE1C(v31 - 8);
                goto LABEL_48;
              }
LABEL_42:
              if ( v31 )
              {
LABEL_43:
                if ( *((_DWORD *)v31 - 4) == 56797 )
                  sub_14001AE1C(v31 - 8);
              }
LABEL_45:
              v27 = 0;
              goto LABEL_48;
            }
          }
        }
LABEL_47:
        v27 = 0;
        if ( !v24 )
          return v27;
LABEL_48:
        if ( *((_DWORD *)v24 - 4) == 56797 )
          sub_14001AE1C(v24 - 8);
        return v27;
      }
      *(_DWORD *)v25 = 56797;
    }
    else
    {
      v20 = v19 + 15;
      if ( v19 + 15 <= v19 )
        v20 = 1152921504606846960i64;
      v21 = v20 & 0xFFFFFFFFFFFFFFF0ui64;
      v22 = alloca(v21);
      v23 = alloca(v21);
      v24 = (WCHAR *)&v38;
      if ( &v33 == (__int64 *)-80i64 )
        goto LABEL_47;
      *(_DWORD *)&v38 = 52428;
    }
    v24 += 8;
    goto LABEL_16;
  }
  return result;
}

//----- (0000000140028364) ----------------------------------------------------
int __usercall sub_140028364@<eax>(unsigned __int16 *a1@<rdx>, __m128i *a2@<rcx>, DWORD a3@<r8d>, CHAR *a4@<r9>, __m256i *a5@<ymm0>, int a6, WCHAR *a7, int a8, UINT a9, int a10)
{
  unsigned __int16 *v10; // rsi
  CHAR *v11; // rbx
  DWORD v12; // edi
  int result; // eax
  __int64 v14; // [rsp+50h] [rbp-28h]
  char v15; // [rsp+58h] [rbp-20h]
  char v16; // [rsp+68h] [rbp-10h]

  v10 = a1;
  v11 = a4;
  v12 = a3;
  sub_14001590C(a2, (__int64)&v14, a5);
  result = sub_140028030((__int64)&v15, v10, v12, v11, a6, a7, a8, a9, a10);
  if ( v16 )
    *(_DWORD *)(v14 + 936) &= 0xFFFFFFFD;
  return result;
}

//----- (0000000140028400) ----------------------------------------------------
_BOOL8 __usercall sub_140028400@<rax>(__m256i *a1@<ymm0>)
{
  return sub_140022B70(a1) == 0;
}

//----- (0000000140028418) ----------------------------------------------------
SIZE_T __usercall sub_140028418@<rax>(const void *a1@<rcx>, __m256i *a2@<ymm0>)
{
  if ( a1 )
    return HeapSize(hHeap, 0, a1);
  *(_DWORD *)sub_140015334() = 22;
  sub_14001ADB4(a2);
  return -1i64;
}

//----- (0000000140028454) ----------------------------------------------------
__int64 sub_140028454()
{
  char *v0; // rax
  unsigned int v1; // ebx

  v0 = (char *)hObject;
  v1 = 0;
  if ( hObject == (HANDLE)-2i64 )
  {
    v0 = (char *)CreateFileW(L"CONOUT$", 0x40000000u, 3u, 0i64, 3u, 0, 0i64);
    hObject = v0;
  }
  LOBYTE(v1) = v0 + 1 != 0i64;
  return v1;
}

//----- (00000001400284B0) ----------------------------------------------------
BOOL sub_1400284B0()
{
  BOOL result; // eax

  if ( (unsigned __int64)hObject <= 0xFFFFFFFFFFFFFFFDui64 )
    result = CloseHandle(hObject);
  return result;
}

//----- (00000001400284CC) ----------------------------------------------------
__int64 __fastcall sub_1400284CC(void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)
{
  DWORD *v3; // rdi
  DWORD v4; // esi
  void *v5; // rbp
  unsigned int v6; // ebx

  v3 = lpNumberOfCharsWritten;
  v4 = nNumberOfCharsToWrite;
  v5 = lpBuffer;
  v6 = WriteConsoleW(hObject, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, 0i64);
  if ( !v6 && GetLastError() == 6 )
  {
    if ( (unsigned __int64)hObject <= 0xFFFFFFFFFFFFFFFDui64 )
      CloseHandle(hObject);
    hObject = CreateFileW(L"CONOUT$", 0x40000000u, 3u, 0i64, 3u, 0, 0i64);
    v6 = WriteConsoleW(hObject, v5, v4, v3, 0i64);
  }
  return v6;
}

//----- (000000014002858C) ----------------------------------------------------
signed __int64 __usercall sub_14002858C@<rax>(unsigned int a1@<edx>, _DWORD *a2@<rcx>, int a3@<r8d>, __m256i *a4@<ymm0>)
{
  unsigned int v4; // er8
  signed __int64 result; // rax

  v4 = a3 & 0xFFF7FFFF;
  if ( v4 & a1 & 0xFCF0FCE0 )
  {
    if ( a2 )
      *a2 = sub_140029844(0i64, 0i64);
    *(_DWORD *)sub_140015334() = 22;
    sub_14001ADB4(a4);
    result = 22i64;
  }
  else
  {
    if ( a2 )
      *a2 = sub_140029844(a1, v4);
    else
      sub_140029844(a1, v4);
    result = 0i64;
  }
  return result;
}
// 140029844: using guessed type __int64 __fastcall sub_140029844(_QWORD, _QWORD);

//----- (00000001400285F0) ----------------------------------------------------
__int64 __fastcall sub_1400285F0(_DWORD *a1)
{
  _DWORD *v1; // rbx

  v1 = a1;
  *a1 = sub_140028D38();
  v1[1] = sub_140028E1C();
  return 0i64;
}

//----- (0000000140028610) ----------------------------------------------------
signed __int64 __fastcall sub_140028610(unsigned int *a1)
{
  unsigned int *v1; // rbx
  unsigned int v2; // edi
  __int64 v4; // [rsp+30h] [rbp+8h]

  v1 = a1;
  sub_140028E74(*a1);
  sub_140028FAC(v1[1]);
  v2 = 0;
  v4 = 0i64;
  if ( (unsigned int)sub_1400285F0(&v4) || *v1 != (_DWORD)v4 )
    return 1i64;
  LOBYTE(v2) = v1[1] != HIDWORD(v4);
  return v2;
}

//----- (0000000140028668) ----------------------------------------------------
signed __int64 __fastcall sub_140028668(__int64 *a1)
{
  __int64 *v1; // rbx
  __int64 v2; // rax
  __int64 v4; // [rsp+38h] [rbp+10h]

  v4 = 0i64;
  v1 = a1;
  if ( (unsigned int)sub_1400285F0(&v4) )
    return 1i64;
  v2 = v4;
  LODWORD(v4) = v4 | 0x1F;
  *v1 = v2;
  if ( (unsigned int)sub_140028610((unsigned int *)&v4) )
    return 1i64;
  sub_1400297D8();
  return 0i64;
}

//----- (00000001400286B8) ----------------------------------------------------
double __fastcall sub_1400286B8(double result)
{
  double v1; // rdx
  unsigned __int64 v2; // rax
  _BOOL8 v3; // r8
  signed __int64 v4; // rax

  v1 = result;
  v2 = *(_QWORD *)&result & 0x7FFFFFFFFFFFFFFFi64;
  v3 = *(_QWORD *)&result != (*(_QWORD *)&result & 0x7FFFFFFFFFFFFFFFi64);
  if ( (*(_QWORD *)&result & 0x7FFFFFFFFFFFFFFFui64) < 0x4340000000000000i64 )
  {
    if ( v2 >= 0x3FF0000000000000i64 )
    {
      v4 = *(_QWORD *)&result & ~((1i64 << (51 - (unsigned __int8)(*(_QWORD *)&result >> 52))) - 1);
      *(_QWORD *)&result &= ~((1i64 << (51 - (unsigned __int8)(*(_QWORD *)&result >> 52))) - 1);
      if ( !v3 && v4 != *(_QWORD *)&v1 )
        result = result + 1.0;
    }
    else if ( v2 )
    {
      if ( *(_QWORD *)&result != (*(_QWORD *)&result & 0x7FFFFFFFFFFFFFFFi64) )
        result = -0.0;
      else
        result = 1.0;
    }
  }
  else if ( v2 > 0x7FF0000000000000i64 )
  {
    *(_QWORD *)&result |= 0x8000000000000ui64;
  }
  return result;
}

//----- (0000000140028780) ----------------------------------------------------
unsigned __int64 __usercall sub_140028780@<rax>(__int64 a1@<rcx>, __m128i _XMM0@<xmm0>)
{
  unsigned __int64 result; // rax
  __m128i v3; // xmm3
  double v4; // xmm6_8
  __m128i v5; // xmm5
  __m128i v6; // xmm2
  __m128i v7; // xmm1
  double v8; // xmm2_8
  double v9; // xmm0_8
  __m128i v10; // xmm2

  if ( !dword_140041310 )
  {
    result = _XMM0.m128i_i64[0];
    v3 = _mm_sub_epi64(_mm_srli_epi64(_XMM0, 0x34u), (__m128i)xmmword_140038780);
    if ( COERCE_DOUBLE(_XMM0.m128i_i64[0] & xmmword_140038750) == *(double *)&xmmword_140038750 )
    {
      if ( _XMM0.m128i_i64[0] == (_QWORD)xmmword_140038750 )
        return result;
      if ( _XMM0.m128i_i64[0] != -4503599627370496i64 )
        return _XMM0.m128i_i64[0] | 0x8000000000000i64;
    }
    else
    {
      *(_QWORD *)&v4 = (unsigned __int128)_mm_cvtepi32_pd(v3);
      v5 = 0i64;
      if ( *(double *)_XMM0.m128i_i64 > 0.0 )
      {
        v6 = _mm_and_si128(_XMM0, (__m128i)xmmword_1400387A0);
        if ( v4 == -1023.0 )
        {
          v10 = _mm_or_si128(v6, (__m128i)xmmword_140038830);
          *(double *)v10.m128i_i64 = *(double *)v10.m128i_i64 - *(double *)&xmmword_140038830;
          v5.m128i_i64[0] = v10.m128i_i64[0];
          v6 = _mm_and_si128(v10, (__m128i)xmmword_1400387A0);
          result = v6.m128i_i64[0];
          *(_QWORD *)&v4 = (unsigned __int128)_mm_cvtepi32_pd(_mm_sub_epi32(_mm_srli_epi64(v5, 0x34u), (__m128i)xmmword_1400388D0));
        }
        result = 2 * (xmmword_1400387C0 & result) + (xmmword_1400387B0 & result);
        v7 = (__m128i)result;
        if ( COERCE_DOUBLE(COERCE_UNSIGNED_INT64(*(double *)_XMM0.m128i_i64 - *(double *)&xmmword_140038830) & xmmword_140038920) >= 0.0625 )
        {
          result >>= 44;
          v8 = (COERCE_DOUBLE(_mm_or_si128(v7, (__m128i)xmmword_140038840))
              - COERCE_DOUBLE(_mm_or_si128(v6, (__m128i)xmmword_140038840)))
             * dbl_1400399B0[result];
          v9 = dbl_140038990[result]
             + 0.3010299950838089 * v4
             + dbl_1400391A0[result]
             + 5.801722962879576e-10 * v4
             - ((0.3333333333333333 * v8 + 0.5) * (v8 * v8)
              + v8
              + ((0.1666666666666667 * v8 + 0.2) * v8 + 0.25) * (v8 * v8 * (v8 * v8)))
             * 0.4342944819032518;
        }
        return result;
      }
      if ( *(double *)_XMM0.m128i_i64 == 0.0 )
        return sub_140029DC0(a1);
    }
    return sub_140029DC0(a1);
  }
  __asm
  {
    vpsrlq  xmm3, xmm0, 34h
    vmovq   rax, xmm0
    vpsubq  xmm3, xmm3, cs:xmmword_140038780
    vcvtdq2pd xmm6, xmm3
    vpand   xmm5, xmm0, cs:xmmword_140038750
    vcomisd xmm5, qword ptr cs:xmmword_140038750
  }
  if ( result != (_QWORD)xmmword_140038750 )
  {
    if ( result == -4503599627370496i64 )
    {
      __asm { vmovsd  xmm1, cs:qword_140038760 }
      result = sub_140029DC0(a1);
      __asm { vmovdqa xmm6, [rsp+58h+var_38] }
      return result;
    }
    result = sub_140029DC0(a1);
  }
  __asm { vmovdqa xmm6, [rsp+58h+var_38] }
  return result;
}
// 140038750: using guessed type __int128 xmmword_140038750;
// 140038780: using guessed type __int128 xmmword_140038780;
// 1400387A0: using guessed type __int128 xmmword_1400387A0;
// 1400387B0: using guessed type __int128 xmmword_1400387B0;
// 1400387C0: using guessed type __int128 xmmword_1400387C0;
// 140038830: using guessed type __int128 xmmword_140038830;
// 140038840: using guessed type __int128 xmmword_140038840;
// 1400388D0: using guessed type __int128 xmmword_1400388D0;
// 140038920: using guessed type __int128 xmmword_140038920;
// 140041310: using guessed type int dword_140041310;

//----- (0000000140028D2C) ----------------------------------------------------
__int64 __fastcall sub_140028D2C(__int16 a1)
{
  return a1 & 0x300;
}

//----- (0000000140028D38) ----------------------------------------------------
__int64 sub_140028D38()
{
  unsigned int v0; // er9
  __int16 v1; // ax
  signed int v2; // er8
  int v3; // eax
  signed int v4; // ecx
  unsigned int v5; // edx

  v0 = _mm_getcsr();
  v1 = v0 & 0x8040;
  if ( (v0 & 0x8040) == -32768 )
  {
    v2 = 3072;
  }
  else if ( v1 == 64 )
  {
    v2 = 2048;
  }
  else
  {
    v2 = 0;
    if ( v1 == -32704 )
      v2 = 1024;
  }
  v3 = v0 & 0x6000;
  if ( v0 & 0x6000 )
  {
    if ( v3 == 0x2000 )
    {
      v4 = 256;
    }
    else if ( v3 == 0x4000 )
    {
      v4 = 512;
    }
    else
    {
      v4 = 768;
      if ( v3 != 24576 )
        v4 = 0;
    }
  }
  else
  {
    v4 = 0;
  }
  v5 = v4 | v2 | ((v0 & 0x180 | ((v0 & 0x200 | ((v0 & 0x400 | ((v0 & 0x800 | (v0 >> 2) & 0x400) >> 2)) >> 2)) >> 3)) >> 3);
  return v5 | ((4 * v5 | v5 & 0xFFFFFF00) << 22);
}

//----- (0000000140028E1C) ----------------------------------------------------
__int64 sub_140028E1C()
{
  unsigned int v0; // er8
  int v2; // [rsp+8h] [rbp+8h]

  v2 = _mm_getcsr();
  v0 = 16 * (v2 & 1) | 2 * (v2 & 4 | 8 * (v2 & 2)) | ((v2 & 8 | ((v2 & 0x10 | ((v2 & 0x3Fu) >> 2) & 8) >> 2)) >> 1);
  return v0 | (v0 << 24);
}

//----- (0000000140028E74) ----------------------------------------------------
__int64 __fastcall sub_140028E74(unsigned int a1)
{
  int v1; // edx
  signed __int16 v2; // di
  signed __int16 v3; // r11
  int v4; // ecx
  signed __int16 v5; // r9
  signed __int16 v6; // bx
  signed __int16 v7; // r10
  int v8; // eax
  signed __int16 v9; // r8
  signed __int16 v10; // cx
  __int16 v11; // cx
  __int16 v12; // cx
  __int16 v13; // cx
  signed __int16 v14; // ax
  __int16 v15; // cx
  int v16; // et0
  int v17; // ecx
  __int64 result; // rax

  v1 = (a1 >> 22) & 0x300 | (a1 >> 24) & 0x3F;
  v2 = 1024;
  v3 = 2048;
  v4 = a1 & 0xC00;
  switch ( v4 )
  {
    case 1024:
      v5 = -32704;
      break;
    case 2048:
      v5 = 64;
      break;
    case 3072:
      v5 = -32768;
      break;
    default:
      v5 = 0;
      break;
  }
  v6 = 256;
  v7 = 512;
  v8 = v1 & 0x300;
  if ( v1 & 0x300 )
  {
    switch ( v8 )
    {
      case 256:
        v9 = 0x2000;
        goto LABEL_16;
      case 512:
        v9 = 0x4000;
        goto LABEL_16;
      case 768:
        v9 = 24576;
        goto LABEL_16;
    }
  }
  v9 = 0;
LABEL_16:
  if ( _bittest(&v1, 0) )
    v10 = 4096;
  else
    v10 = 0;
  if ( !_bittest(&v1, 1u) )
    v3 = 0;
  v11 = v3 | v10;
  if ( !_bittest(&v1, 2u) )
    v2 = 0;
  v12 = v2 | v11;
  if ( !_bittest(&v1, 3u) )
    v7 = 0;
  v13 = v7 | v12;
  if ( _bittest(&v1, 4u) )
    v14 = 128;
  else
    v14 = 0;
  v15 = v14 | v13;
  if ( !_bittest(&v1, 5u) )
    v6 = 0;
  v16 = _mm_getcsr();
  v17 = ((unsigned __int16)v5 | (unsigned __int16)(v6 | v15 | v9)) & 0xFFC0;
  result = v17 | v16 & 0xFFFF003F;
  _mm_setcsr(v17 | v16 & 0xFFFF003F);
  return result;
}

//----- (0000000140028FAC) ----------------------------------------------------
__int64 __fastcall sub_140028FAC(unsigned int a1)
{
  int v1; // edx
  int v2; // et0
  int v3; // ecx
  __int64 result; // rax

  v1 = (a1 >> 24) & 0x3F;
  v2 = _mm_getcsr();
  v3 = ((((a1 >> 24) & 0x20) != 0 ? 2 : 0) | (unsigned __int8)(_bittest(&v1, 4u) | ((a1 & 0x8000000) != 0 ? 4 : 0) | ((a1 & 0x4000000) != 0 ? 8 : 0) | ((a1 & 0x2000000) != 0 ? 0x10 : 0) | ((a1 & 0x1000000) != 0 ? 0x20 : 0))) & 0x3F;
  result = v3 | v2 & 0xFFFFFFC0;
  _mm_setcsr(v3 | v2 & 0xFFFFFFC0);
  return result;
}

//----- (0000000140029020) ----------------------------------------------------
__int64 __fastcall sub_140029020(__int64 a1, _QWORD *a2)
{
  *a2 = 0i64;
  return a1;
}

//----- (0000000140029028) ----------------------------------------------------
signed __int64 __fastcall sub_140029028(_QWORD *a1, __int64 a2)
{
  signed __int64 result; // rax

  *a1 = 0i64;
  result = -1i64;
  *(_BYTE *)(a2 + 48) = 1;
  *(_DWORD *)(a2 + 44) = 42;
  return result;
}

//----- (000000014002903C) ----------------------------------------------------
int __usercall sub_14002903C@<eax>(DWORD a1@<edx>, unsigned __int16 *a2@<rcx>, __m128i *a3@<r8>, int a4@<r9d>, __int128 *a5@<xmm1>, __m256i *a6@<ymm1>, WCHAR *a7, int a8)
{
  int v8; // ebx
  const WCHAR *v9; // rdi
  DWORD v10; // esi
  unsigned __int16 *v11; // rbp
  int v12; // eax
  bool v13; // sf
  unsigned __int8 v14; // of

  v8 = a4;
  v9 = (const WCHAR *)a3;
  v10 = a1;
  v11 = a2;
  if ( a4 > 0 )
  {
    v12 = sub_14001DC7C(a4, a3, a5, a6);
    v14 = __OFSUB__(v12, v8);
    v13 = v12 - v8 < 0;
    v8 = v12 + 1;
    if ( !(v13 ^ v14) )
      v8 = v12;
  }
  return sub_14001F4B4(v11, v10, v9, v8, a7, a8);
}

//----- (00000001400290C4) ----------------------------------------------------
__int64 __usercall sub_1400290C4@<rax>(LARGE_INTEGER a1@<rdx>, unsigned int a2@<ecx>, __m256i *a3@<ymm0>)
{
  unsigned int v3; // edi
  int v4; // ebx
  int v5; // ebx
  __int64 v7; // [rsp+20h] [rbp-40h]
  char v8; // [rsp+30h] [rbp-30h]
  __int128 v9; // [rsp+38h] [rbp-28h]
  char v10; // [rsp+48h] [rbp-18h]
  int v11; // [rsp+4Ch] [rbp-14h]
  char v12; // [rsp+50h] [rbp-10h]
  int v13; // [rsp+54h] [rbp-Ch]
  char v14; // [rsp+58h] [rbp-8h]

  v7 = 0i64;
  v8 = 0;
  v10 = 0;
  v12 = 0;
  v14 = 0;
  if ( !dword_140040924 )
  {
    v10 = 1;
    _mm_storeu_si128((__m128i *)&v9, off_14003E2C8);
  }
  v3 = sub_14002915C(a1, a2, (__int64)&v7, a3);
  if ( v10 == 2 )
    *(_DWORD *)(v7 + 936) &= 0xFFFFFFFD;
  if ( v12 )
  {
    v4 = v11;
    *(_DWORD *)(sub_14001009C(&v7, a3) + 32) = v4;
  }
  if ( v14 )
  {
    v5 = v13;
    *(_DWORD *)(sub_14001009C(&v7, a3) + 36) = v5;
  }
  return v3;
}
// 140040924: using guessed type int dword_140040924;

//----- (000000014002915C) ----------------------------------------------------
__int64 __usercall sub_14002915C@<rax>(LARGE_INTEGER a1@<rdx>, unsigned int a2@<ecx>, __int64 a3@<r8>, __m256i *a4@<ymm0>)
{
  LARGE_INTEGER v4; // rbx
  __int64 v5; // rsi
  unsigned int v6; // er14
  LARGE_INTEGER v7; // r12
  LARGE_INTEGER v8; // rax
  LONGLONG v9; // rbp
  unsigned int v10; // edi
  unsigned __int16 *v11; // rbx
  int v12; // er15
  unsigned int v13; // er8
  int v14; // eax
  void *v15; // rax
  DWORD v16; // eax
  signed int v17; // eax

  v4 = a1;
  v5 = a3;
  v6 = a2;
  v7 = sub_14001C754(0i64, a2, 1u, a4);
  v8 = sub_14001C754(0i64, v6, 2u, a4);
  v9 = v4.QuadPart - v8.QuadPart;
  if ( v7.QuadPart == -1 || v8.QuadPart == -1 )
  {
    if ( *(_BYTE *)(v5 + 48) )
      v17 = *(_DWORD *)(v5 + 44);
    else
      v17 = 22;
    v10 = v17;
  }
  else
  {
    v10 = 0;
    if ( v9 <= 0 )
    {
      if ( v9 < 0 )
      {
        if ( sub_14001C754(v4, v6, 0, a4) == -1i64 )
        {
          if ( *(_BYTE *)(v5 + 48) )
            v10 = *(_DWORD *)(v5 + 44);
        }
        else
        {
          v15 = (void *)sub_140018540(v6, a4);
          if ( !SetEndOfFile(v15) )
          {
            v16 = GetLastError();
            *(_BYTE *)(v5 + 56) = 1;
            v10 = 13;
            *(_DWORD *)(v5 + 52) = v16;
            *(_BYTE *)(v5 + 48) = 1;
            *(_DWORD *)(v5 + 44) = 13;
          }
        }
      }
    }
    else
    {
      v11 = (unsigned __int16 *)sub_14001F068(0x1000ui64, 1ui64);
      if ( v11 )
      {
        v12 = sub_14001A088(v6, 0x8000);
        while ( 1 )
        {
          v13 = v9;
          if ( v9 >= 4096 )
            v13 = 4096;
          v14 = sub_14001D430(v11, v6, v13, v5, a4);
          if ( v14 == -1 )
            break;
          v9 -= v14;
          if ( v9 <= 0 )
          {
            sub_14001A088(v6, v12);
            goto LABEL_17;
          }
        }
        if ( *(_BYTE *)(v5 + 56) && *(_DWORD *)(v5 + 52) == 5 )
        {
          *(_BYTE *)(v5 + 48) = 1;
          *(_DWORD *)(v5 + 44) = 13;
        }
        if ( *(_BYTE *)(v5 + 48) )
          v10 = *(_DWORD *)(v5 + 44);
      }
      else
      {
        v10 = 12;
        *(_BYTE *)(v5 + 48) = 1;
        *(_DWORD *)(v5 + 44) = 12;
      }
LABEL_17:
      sub_14001AE1C(v11);
    }
  }
  sub_14001C754(v7, v6, 0, a4);
  return v10;
}

//----- (00000001400292F0) ----------------------------------------------------
int __usercall sub_1400292F0@<eax>(DWORD a1@<edx>, unsigned __int16 *a2@<rcx>, __m128i *a3@<r8>, int a4@<r9d>, __int128 *a5@<xmm1>, __m256i *a6@<ymm1>, __m128i *a7, int a8)
{
  int v8; // ebx
  const WCHAR *v9; // rsi
  DWORD v10; // ebp
  unsigned __int16 *v11; // r14
  int v12; // eax
  int result; // eax
  int v14; // ebx

  v8 = a4;
  v9 = (const WCHAR *)a3;
  v10 = a1;
  v11 = a2;
  if ( a4 > 0 )
    v8 = sub_14001DC7C(a4, a3, a5, a6);
  v12 = a8;
  if ( a8 > 0 )
    v12 = sub_14001DC7C(a8, a7, a5, a6);
  if ( v8 && v12 )
    return sub_14001F338(v11, v10, v9, v8, (const WCHAR *)a7, v12);
  v14 = v8 - v12;
  result = ((v14 >> 31) & 0xFFFFFFFE) + 3;
  if ( !v14 )
    result = 2;
  return result;
}

//----- (00000001400293B0) ----------------------------------------------------
__int64 __fastcall sub_1400293B0(__int64 a1, unsigned __int16 *a2, DWORD a3, CHAR *a4, int a5, __int64 CodePage, signed int a7, UINT CodePagea)
{
  int v8; // edi
  const CHAR *v9; // r14
  __int64 v10; // rbx
  int v11; // esi
  UINT v12; // er15
  BYTE *v13; // rax
  BYTE *v15; // rax
  int v16; // eax
  int v17; // er13
  unsigned __int64 v18; // rdx
  signed __int64 v19; // rax
  void *v20; // rsp
  WCHAR *v21; // rbx
  WCHAR *v22; // rax
  int v23; // eax
  int v24; // er12
  unsigned __int64 v25; // rcx
  signed __int64 v26; // rax
  void *v27; // rsp
  WCHAR *v28; // rdi
  WCHAR *v29; // rax
  WCHAR *v30; // r14
  WCHAR *v31; // rcx
  bool v32; // zf
  unsigned int v33; // edi
  __int64 v34; // [rsp+0h] [rbp-50h]
  __int64 v35; // [rsp+30h] [rbp-20h]
  __int64 v36; // [rsp+38h] [rbp-18h]
  __int64 v37; // [rsp+40h] [rbp-10h]
  DWORD v38; // [rsp+50h] [rbp+0h]
  const CHAR *v39; // [rsp+58h] [rbp+8h]
  unsigned __int16 *v40; // [rsp+60h] [rbp+10h]
  struct _cpinfo CPInfo; // [rsp+68h] [rbp+18h]

  v8 = a5;
  v9 = a4;
  v38 = a3;
  v10 = a1;
  v40 = a2;
  v39 = (const CHAR *)CodePage;
  if ( a5 <= 0 )
  {
    if ( a5 < -1 )
      return 0i64;
  }
  else
  {
    v8 = sub_1400297C0(a4, a5);
  }
  v11 = a7;
  if ( a7 <= 0 )
  {
    if ( a7 < -1 )
      return 0i64;
  }
  else
  {
    v11 = sub_1400297C0((_BYTE *)CodePage, a7);
  }
  v12 = CodePagea;
  if ( !CodePagea )
    v12 = *(_DWORD *)(*(_QWORD *)v10 + 12i64);
  if ( !v8 || !v11 )
  {
    if ( v8 == v11 )
      return 2i64;
    if ( v11 > 1 )
      return 1i64;
    if ( v8 > 1 )
      return 3i64;
    if ( !GetCPInfo(v12, &CPInfo) )
      return 0i64;
    if ( v8 > 0 )
    {
      if ( CPInfo.MaxCharSize >= 2 )
      {
        v13 = CPInfo.LeadByte;
        if ( CPInfo.LeadByte[0] )
        {
          while ( v13[1] )
          {
            if ( *v9 >= *v13 && *v9 <= v13[1] )
              return 2i64;
            v13 += 2;
            if ( !*v13 )
              return 3i64;
          }
        }
      }
      return 3i64;
    }
    if ( v11 > 0 )
    {
      if ( CPInfo.MaxCharSize >= 2 )
      {
        v15 = CPInfo.LeadByte;
        if ( CPInfo.LeadByte[0] )
        {
          while ( v15[1] )
          {
            if ( *(_BYTE *)CodePage >= *v15 && *(_BYTE *)CodePage <= v15[1] )
              return 2i64;
            v15 += 2;
            if ( !*v15 )
              return 1i64;
          }
        }
      }
      return 1i64;
    }
  }
  v16 = sub_14001FB10(v12, 9, v9, v8, 0i64, 0);
  v17 = v16;
  if ( !v16 )
    return 0i64;
  v18 = (2i64 * v16 + 16) & -(signed __int64)(2i64 * v16 < (unsigned __int64)(2i64 * v16 + 16));
  if ( !v18 )
    return 0i64;
  if ( v18 > 0x400 )
  {
    v22 = (WCHAR *)sub_14001DACC(v18);
    v21 = v22;
    if ( !v22 )
      goto LABEL_41;
    *(_DWORD *)v22 = 56797;
  }
  else
  {
    v19 = v18 + 15;
    if ( v18 + 15 <= v18 )
      v19 = 1152921504606846960i64;
    v20 = alloca(v19);
    v21 = (WCHAR *)&v38;
    if ( &v34 == (__int64 *)-80i64 )
      return 0i64;
    v38 = 52428;
  }
  v21 += 8;
LABEL_41:
  if ( !v21 )
    return 0i64;
  if ( !sub_14001FB10(v12, 1, v9, v8, v21, v17) )
    goto LABEL_63;
  v23 = sub_14001FB10(v12, 9, (const CHAR *)CodePage, v11, 0i64, 0);
  v24 = v23;
  if ( !v23 )
    goto LABEL_63;
  v25 = (2i64 * v23 + 16) & -(signed __int64)(2i64 * v23 < (unsigned __int64)(2i64 * v23 + 16));
  if ( !v25 )
    goto LABEL_63;
  if ( v25 > 0x400 )
  {
    v29 = (WCHAR *)sub_14001DACC(v25);
    v28 = v29;
    if ( !v29 )
      goto LABEL_53;
    *(_DWORD *)v29 = 56797;
  }
  else
  {
    v26 = v25 + 15;
    if ( v25 + 15 <= v25 )
      v26 = 1152921504606846960i64;
    v27 = alloca(v26);
    v28 = (WCHAR *)&v38;
    if ( &v34 == (__int64 *)-80i64 )
      goto LABEL_63;
    v38 = 52428;
  }
  v28 += 8;
LABEL_53:
  if ( !v28 )
  {
LABEL_63:
    v31 = v21 - 8;
    v32 = *((_DWORD *)v21 - 4) == 56797;
LABEL_64:
    if ( v32 )
      sub_14001AE1C(v31);
    return 0i64;
  }
  v30 = v28 - 8;
  if ( !sub_14001FB10(v12, 1, v39, v11, v28, v24) )
  {
    if ( *(_DWORD *)v30 == 56797 )
      sub_14001AE1C(v30);
    v31 = v21 - 8;
    v32 = *((_DWORD *)v21 - 4) == 56797;
    goto LABEL_64;
  }
  v37 = 0i64;
  v36 = 0i64;
  v35 = 0i64;
  v33 = sub_14001F338(v40, v38, v21, v17, v28, v24);
  if ( *(_DWORD *)v30 == 56797 )
    sub_14001AE1C(v30);
  if ( *((_DWORD *)v21 - 4) == 56797 )
    sub_14001AE1C(v21 - 8);
  return v33;
}

//----- (0000000140029734) ----------------------------------------------------
__int64 __usercall sub_140029734@<rax>(unsigned __int16 *a1@<rdx>, __m128i *a2@<rcx>, DWORD a3@<r8d>, CHAR *a4@<r9>, __m256i *a5@<ymm0>, int a6, __int64 CodePage, signed int a8, UINT a9)
{
  unsigned __int16 *v9; // rsi
  CHAR *v10; // rbx
  DWORD v11; // edi
  __int64 result; // rax
  __int64 v13; // [rsp+40h] [rbp-28h]
  int v14; // [rsp+48h] [rbp-20h]
  char v15; // [rsp+58h] [rbp-10h]

  v9 = a1;
  v10 = a4;
  v11 = a3;
  sub_14001590C(a2, (__int64)&v13, a5);
  result = sub_1400293B0((__int64)&v14, v9, v11, v10, a6, CodePage, a8, a9);
  if ( v15 )
    *(_DWORD *)(v13 + 936) &= 0xFFFFFFFD;
  return result;
}

//----- (00000001400297C0) ----------------------------------------------------
__int64 __fastcall sub_1400297C0(_BYTE *a1, __int64 a2)
{
  __int64 result; // rax

  result = 0i64;
  if ( *a1 )
  {
    do
    {
      if ( result == a2 )
        break;
      ++result;
    }
    while ( a1[result] );
  }
  return result;
}

//----- (00000001400297D8) ----------------------------------------------------
__int64 sub_1400297D8()
{
  char v0; // bl
  unsigned int v1; // er9
  int v2; // er8
  int v3; // ecx
  int v4; // edx

  v0 = sub_140029E90();
  sub_140029EAA();
  v1 = 0;
  if ( v0 & 0x3F )
  {
    v2 = 16 * (v0 & 1) | 8;
    if ( !(v0 & 4) )
      v2 = 16 * (v0 & 1);
    v3 = v2 | 4;
    if ( !(v0 & 8) )
      v3 = v2;
    v4 = v3 | 2;
    if ( !(v0 & 0x10) )
      v4 = v3;
    v1 = v4 | 1;
    if ( !(v0 & 0x20) )
      v1 = v4;
    if ( v0 & 2 )
      v1 |= 0x80000u;
  }
  return v1;
}

//----- (000000014002984C) ----------------------------------------------------
__int64 __fastcall sub_14002984C(int a1, int a2)
{
  int v2; // ebx
  int v3; // er12
  unsigned int v4; // eax
  __int16 v5; // r10
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  unsigned int v10; // edx
  int v11; // eax
  int v12; // er10
  int v13; // er10
  int v14; // er8
  int v15; // edx
  int v16; // ecx
  int v17; // edx
  int v18; // ecx
  unsigned int v19; // ebx
  int v20; // eax
  int v21; // er8
  int v22; // edx
  int v23; // ecx
  int v24; // edx
  int v25; // ecx
  int v26; // eax
  int v27; // ebx
  int v28; // ebx

  v2 = a1;
  v3 = a2 & 0x308031F;
  v4 = sub_140029E90();
  v5 = v4;
  v6 = (v4 >> 3) & 0x10 | 8;
  if ( !(v4 & 0x200) )
    v6 = (v4 >> 3) & 0x10;
  v7 = v6 | 4;
  if ( !_bittest((const signed int *)&v4, 0xAu) )
    v7 = v6;
  v8 = v7 | 2;
  if ( !(v4 & 0x800) )
    v8 = v7;
  v9 = v8 | 1;
  if ( !(v4 & 0x1000) )
    v9 = v8;
  v10 = v9 | 0x80000;
  if ( !(v4 & 0x100) )
    v10 = v9;
  v11 = v4 & 0x6000;
  if ( v11 )
  {
    switch ( v11 )
    {
      case 8192:
        v10 |= 0x100u;
        break;
      case 16384:
        v10 |= 0x200u;
        break;
      case 24576:
        v10 |= 0x300u;
        break;
    }
  }
  v12 = (unsigned __int16)(v5 & 0x8040) - 64;
  if ( v12 )
  {
    v13 = v12 - 32704;
    if ( v13 )
    {
      if ( v13 == 64 )
        v10 |= 0x1000000u;
    }
    else
    {
      v10 |= 0x3000000u;
    }
  }
  else
  {
    v10 |= 0x2000000u;
  }
  v14 = v3 & v2 | v10 & ~v3;
  if ( v14 != v10 )
  {
    v15 = 8 * (v14 & 0x10) | 0x200;
    if ( !(v14 & 8) )
      v15 = 8 * (v14 & 0x10);
    v16 = v15 | 0x400;
    if ( !(v14 & 4) )
      v16 = v15;
    v17 = v16 | 0x800;
    if ( !(v14 & 2) )
      v17 = v16;
    v18 = v17 | 0x1000;
    if ( !(v14 & 1) )
      v18 = v17;
    v19 = v18 | 0x100;
    if ( !_bittest(&v14, 0x13u) )
      v19 = v18;
    v20 = v14 & 0x300;
    if ( v14 & 0x300 )
    {
      switch ( v20 )
      {
        case 256:
          v19 |= 0x2000u;
          break;
        case 512:
          v19 |= 0x4000u;
          break;
        case 768:
          v19 |= 0x6000u;
          break;
      }
    }
    v21 = v14 & 0x3000000;
    switch ( v21 )
    {
      case 16777216:
        v19 |= 0x8040u;
        break;
      case 33554432:
        v19 |= 0x40u;
        break;
      case 50331648:
        v19 |= 0x8000u;
        break;
    }
    if ( byte_14003EC00 && v19 & 0x40 )
    {
      sub_140029EA0(v19);
    }
    else
    {
      v19 &= 0xFFFFFFBF;
      sub_140029EA0(v19);
    }
    v22 = (v19 >> 3) & 0x10 | 8;
    if ( !(v19 & 0x200) )
      v22 = (v19 >> 3) & 0x10;
    v23 = v22 | 4;
    if ( !_bittest((const signed int *)&v19, 0xAu) )
      v23 = v22;
    v24 = v23 | 2;
    if ( !_bittest((const signed int *)&v19, 0xBu) )
      v24 = v23;
    v25 = v24 | 1;
    if ( !_bittest((const signed int *)&v19, 0xCu) )
      v25 = v24;
    v10 = v25 | 0x80000;
    if ( !(v19 & 0x100) )
      v10 = v25;
    v26 = v19 & 0x6000;
    if ( v19 & 0x6000 )
    {
      switch ( v26 )
      {
        case 8192:
          v10 |= 0x100u;
          break;
        case 16384:
          v10 |= 0x200u;
          break;
        case 24576:
          v10 |= 0x300u;
          break;
      }
    }
    v27 = (unsigned __int16)(v19 & 0x8040) - 64;
    if ( v27 )
    {
      v28 = v27 - 32704;
      if ( v28 )
      {
        if ( v28 == 64 )
          v10 |= 0x1000000u;
      }
      else
      {
        v10 |= 0x3000000u;
      }
    }
    else
    {
      v10 |= 0x2000000u;
    }
  }
  return v10;
}
// 14003EC00: using guessed type char byte_14003EC00;

//----- (0000000140029AE8) ----------------------------------------------------
double __fastcall sub_140029AE8(int a1, __int64 a2, __int64 a3, double a4, __int64 a5, double a6, int a7)
{
  int v7; // ebx
  int v9; // [rsp+20h] [rbp-38h]
  __int64 v10; // [rsp+28h] [rbp-30h]
  double v11; // [rsp+30h] [rbp-28h]
  __int64 v12; // [rsp+38h] [rbp-20h]
  double v13; // [rsp+40h] [rbp-18h]

  v7 = a1;
  v9 = a1;
  v12 = a5;
  v13 = a6;
  v11 = a4;
  v10 = a3;
  sub_14002A260(a7, 65472);
  if ( !(unsigned int)sub_14001924C((__int64)&v9) )
    sub_14002A210(v7);
  return v13;
}

//----- (0000000140029B50) ----------------------------------------------------
_BOOL8 __fastcall sub_140029B50(char a1, __int64 a2)
{
  __int64 v2; // rsi
  int v3; // ebx
  char v4; // di

  v2 = a2;
  v3 = a1 & 0x1F;
  v4 = a1;
  if ( a1 & 8 && (a2 & 0x80u) != 0i64 )
  {
    sub_14002A2DC(1);
    v3 &= 0xFFFFFFF7;
  }
  else if ( a1 & 4 && _bittest64(&v2, 9u) )
  {
    sub_14002A2DC(4);
    v3 &= 0xFFFFFFFB;
  }
  else if ( a1 & 1 && _bittest64(&v2, 0xAu) )
  {
    sub_14002A2DC(8);
    v3 &= 0xFFFFFFFE;
  }
  else if ( a1 & 2 && _bittest64(&v2, 0xBu) )
  {
    if ( a1 & 0x10 )
      sub_14002A2DC(16);
    v3 &= 0xFFFFFFFD;
  }
  if ( v4 & 0x10 && _bittest64(&v2, 0xCu) )
  {
    sub_14002A2DC(32);
    v3 &= 0xFFFFFFEF;
  }
  return v3 == 0;
}

//----- (0000000140029C0C) ----------------------------------------------------
double __fastcall sub_140029C0C(__int64 a1, __int16 a2, __int64 a3, int a4)
{
  __int16 v4; // si
  __int64 v5; // r14
  int v6; // edi
  __int64 v7; // rbx
  __int64 v8; // rax
  BOOL v9; // eax
  __int64 v10; // xmm6_8
  __int128 v12; // [rsp+40h] [rbp-69h]
  char v13; // [rsp+50h] [rbp-59h]
  __int64 v14; // [rsp+58h] [rbp-51h]
  unsigned int v15; // [rsp+68h] [rbp-41h]
  void *retaddr; // [rsp+108h] [rbp+5Fh]
  unsigned int v17; // [rsp+110h] [rbp+67h]
  double v18; // [rsp+118h] [rbp+6Fh]
  __int64 v19; // [rsp+120h] [rbp+77h]
  int v20; // [rsp+128h] [rbp+7Fh]

  v4 = a2;
  v5 = a1;
  v6 = a4;
  v7 = a3;
  v8 = sub_14002A260(8064, 65472);
  *((_QWORD *)&v12 + 1) = v8;
  *(_QWORD *)&v12 = v7;
  v9 = sub_140029B50((char)retaddr, v8);
  v10 = v19;
  if ( !v9 )
  {
    if ( v20 == 2 )
    {
      v14 = v19;
      v15 = v15 & 0xFFFFFFE3 | 3;
    }
    sub_140029EE0((ULONG_PTR)&v13, (_QWORD *)&v12 + 1, (char)retaddr, v4, &v18, &v12);
  }
  if ( sub_140019224() && v6 )
    return sub_140029AE8(v6, v17, v5, v18, v10, *(double *)&v12, SDWORD2(v12));
  sub_14002A210(v6);
  sub_14002A260(SDWORD2(v12), 65472);
  return *(double *)&v12;
}

//----- (0000000140029D50) ----------------------------------------------------
__int64 sub_140029D50()
{
  int v0; // er8

  v0 = 0;
  dword_14004130C = 0;
  _RAX = 1i64;
  __asm { cpuid }
  if ( (_RCX & 0x18001000) == 402657280 )
  {
    __asm { xgetbv }
    v0 = dword_14004130C;
  }
  dword_140041310 = v0;
  return 0i64;
}
// 14004130C: using guessed type int dword_14004130C;
// 140041310: using guessed type int dword_140041310;

//----- (0000000140029DC0) ----------------------------------------------------
__int64 __fastcall sub_140029DC0(__int64 a1)
{
  return sub_140029DE0(a1);
}
// 140029DE0: using guessed type __int64 __fastcall sub_140029DE0(__int64);

//----- (0000000140029DE0) ----------------------------------------------------
int sub_140029DE0(...)
{
  __int16 v5; // dx
  int v6; // er8
  int v7; // er9

  v5 = a4;
  v6 = a3 - 1;
  if ( !v6 )
  {
    v7 = 2;
    goto LABEL_5;
  }
  if ( v6 == 1 )
  {
    v7 = 1;
LABEL_5:
    sub_140029C0C(a5, v5, a2, v7);
  }
  return (__m128)a2;
}

//----- (0000000140029E90) ----------------------------------------------------
__int64 sub_140029E90()
{
  return (unsigned int)_mm_getcsr();
}

//----- (0000000140029EA0) ----------------------------------------------------
void __fastcall sub_140029EA0(unsigned int a1)
{
  _mm_setcsr(a1);
}

//----- (0000000140029EAA) ----------------------------------------------------
void sub_140029EAA()
{
  _mm_setcsr(_mm_getcsr() & 0xFFFFFFC0);
}

//----- (0000000140029EE0) ----------------------------------------------------
__int64 __fastcall sub_140029EE0(ULONG_PTR a1, _QWORD *a2, char a3, __int16 a4, _DWORD *a5, _DWORD *a6)
{
  return sub_140029F08(a1, a2, a3, a4, a5, a6, 0);
}

//----- (0000000140029F08) ----------------------------------------------------
__int64 __fastcall sub_140029F08(ULONG_PTR a1, _QWORD *a2, char a3, __int16 a4, _DWORD *a5, _DWORD *a6, int a7)
{
  _DWORD *v7; // rbx
  __int16 v8; // si
  DWORD v9; // edi
  char v10; // al
  signed __int64 v11; // rax
  _DWORD *v12; // rsi
  ULONG_PTR v13; // rcx
  __int64 result; // rax
  ULONG_PTR Arguments; // [rsp+30h] [rbp+10h]

  Arguments = a1;
  v7 = a2;
  v8 = a4;
  v9 = -1073741811;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(Arguments + 8) = 0;
  *(_DWORD *)(Arguments + 12) = 0;
  if ( a3 & 0x10 )
  {
    v9 = -1073741681;
    *(_DWORD *)(Arguments + 4) |= 1u;
  }
  if ( a3 & 2 )
  {
    v9 = -1073741677;
    *(_DWORD *)(Arguments + 4) |= 2u;
  }
  if ( a3 & 1 )
  {
    v9 = -1073741679;
    *(_DWORD *)(Arguments + 4) |= 4u;
  }
  if ( a3 & 4 )
  {
    v9 = -1073741682;
    *(_DWORD *)(Arguments + 4) |= 8u;
  }
  if ( a3 & 8 )
  {
    v9 = -1073741680;
    *(_DWORD *)(Arguments + 4) |= 0x10u;
  }
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(16 * (*a2 >> 7))) & 0x10;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(8 * (*a2 >> 9))) & 8;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(4 * (*a2 >> 10))) & 4;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(2 * (*a2 >> 11))) & 2;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(*(_DWORD *)a2 >> 12)) & 1;
  v10 = sub_14002A2FC();
  if ( v10 & 1 )
    *(_DWORD *)(Arguments + 12) |= 0x10u;
  if ( v10 & 4 )
    *(_DWORD *)(Arguments + 12) |= 8u;
  if ( v10 & 8 )
    *(_DWORD *)(Arguments + 12) |= 4u;
  if ( v10 & 0x10 )
    *(_DWORD *)(Arguments + 12) |= 2u;
  if ( v10 & 0x20 )
    *(_DWORD *)(Arguments + 12) |= 1u;
  v11 = *v7 & 0x6000i64;
  if ( v11 )
  {
    switch ( v11 )
    {
      case 8192i64:
        *(_DWORD *)Arguments &= 0xFFFFFFFD;
        *(_DWORD *)Arguments |= 1u;
        break;
      case 16384i64:
        *(_DWORD *)Arguments &= 0xFFFFFFFE;
        *(_DWORD *)Arguments |= 2u;
        break;
      case 24576i64:
        *(_DWORD *)Arguments |= 3u;
        break;
    }
  }
  else
  {
    *(_DWORD *)Arguments &= 0xFFFFFFFC;
  }
  *(_DWORD *)Arguments &= 0xFFFE001F;
  *(_DWORD *)Arguments |= 32 * (v8 & 0xFFF);
  v12 = a6;
  *(_DWORD *)(Arguments + 32) |= 1u;
  if ( a7 )
  {
    *(_DWORD *)(Arguments + 32) &= 0xFFFFFFE1;
    *(_DWORD *)(Arguments + 16) = *a5;
    *(_DWORD *)(Arguments + 96) |= 1u;
    *(_DWORD *)(Arguments + 96) &= 0xFFFFFFE1;
    *(_DWORD *)(Arguments + 80) = *v12;
  }
  else
  {
    *(_DWORD *)(Arguments + 32) = *(_DWORD *)(Arguments + 32) & 0xFFFFFFE3 | 2;
    *(_QWORD *)(Arguments + 16) = *(_QWORD *)a5;
    *(_DWORD *)(Arguments + 96) |= 1u;
    *(_DWORD *)(Arguments + 96) = *(_DWORD *)(Arguments + 96) & 0xFFFFFFE3 | 2;
    *(_QWORD *)(Arguments + 80) = *(_QWORD *)v12;
  }
  sub_14002A240();
  RaiseException(v9, 0, 1u, &Arguments);
  v13 = Arguments;
  if ( *(_BYTE *)(Arguments + 8) & 0x10 )
    *(_QWORD *)v7 &= 0xFFFFFFFFFFFFFF7Fui64;
  if ( *(_BYTE *)(v13 + 8) & 8 )
    *(_QWORD *)v7 &= 0xFFFFFFFFFFFFFDFFui64;
  if ( *(_BYTE *)(v13 + 8) & 4 )
    *(_QWORD *)v7 &= 0xFFFFFFFFFFFFFBFFui64;
  if ( *(_BYTE *)(v13 + 8) & 2 )
    *(_QWORD *)v7 &= 0xFFFFFFFFFFFFF7FFui64;
  if ( *(_BYTE *)(v13 + 8) & 1 )
    *(_QWORD *)v7 &= 0xFFFFFFFFFFFFEFFFui64;
  if ( *(_DWORD *)v13 & 3 )
  {
    switch ( *(_DWORD *)v13 & 3 )
    {
      case 1:
        *(_QWORD *)v7 &= 0xFFFFFFFFFFFFBFFFui64;
        *(_QWORD *)v7 |= 0x2000ui64;
        break;
      case 2:
        *(_QWORD *)v7 &= 0xFFFFFFFFFFFFDFFFui64;
        *(_QWORD *)v7 |= 0x4000ui64;
        break;
      case 3:
        *(_QWORD *)v7 |= 0x6000ui64;
        break;
    }
  }
  else
  {
    *(_QWORD *)v7 &= 0xFFFFFFFFFFFF9FFFui64;
  }
  if ( a7 )
  {
    result = *(unsigned int *)(v13 + 80);
    *v12 = result;
  }
  else
  {
    result = *(_QWORD *)(v13 + 80);
    *(_QWORD *)v12 = result;
  }
  return result;
}

//----- (000000014002A210) ----------------------------------------------------
void __fastcall sub_14002A210(int a1)
{
  int v1; // ecx
  int v2; // ecx

  v1 = a1 - 1;
  if ( v1 )
  {
    v2 = v1 - 1;
    if ( !v2 || v2 == 1 )
      *(_DWORD *)sub_140015334() = 34;
  }
  else
  {
    *(_DWORD *)sub_140015334() = 33;
  }
}

//----- (000000014002A240) ----------------------------------------------------
__int64 sub_14002A240()
{
  unsigned int v0; // ebx

  v0 = sub_140029E90() & 0x3F;
  sub_140029EAA();
  return v0;
}

//----- (000000014002A260) ----------------------------------------------------
__int64 __fastcall sub_14002A260(int a1, int a2)
{
  int v2; // ebx
  int v3; // edi
  unsigned int v4; // esi
  unsigned int v5; // ecx

  v2 = a2;
  v3 = a1;
  v4 = sub_140029E90();
  v5 = v2 & v3 | v4 & (~(_WORD)v2 | 0xFFFF807F);
  if ( byte_14003EC10 && v5 & 0x40 )
    sub_140029EA0(v5);
  else
    sub_140029EA0(v5 & 0xFFFFFFBF);
  return v4;
}
// 14003EC10: using guessed type char byte_14003EC10;

//----- (000000014002A2DC) ----------------------------------------------------
void __fastcall sub_14002A2DC(char a1)
{
  char v1; // bl
  int v2; // eax

  v1 = a1;
  v2 = sub_140029E90();
  sub_140029EA0(v1 & 0x3F | v2);
}

//----- (000000014002A2FC) ----------------------------------------------------
__int64 sub_14002A2FC()
{
  return sub_140029E90() & 0x3F;
}

//----- (000000014002A310) ----------------------------------------------------
signed __int64 __fastcall sub_14002A310(__int64 a1, unsigned __int64 a2)
{
  unsigned int v2; // er9
  __int64 v3; // r8
  unsigned __int64 v4; // r10
  signed __int64 result; // rax
  unsigned __int64 v6; // rdx

  v2 = 0;
  v3 = a1 + *(signed int *)(a1 + 60);
  v4 = a2;
  result = v3 + *(unsigned __int16 *)(v3 + 20) + 24i64;
  if ( !*(_WORD *)(v3 + 6) )
    return 0i64;
  while ( 1 )
  {
    v6 = *(unsigned int *)(result + 12);
    if ( v4 >= v6 && v4 < (unsigned int)(v6 + *(_DWORD *)(result + 8)) )
      break;
    ++v2;
    result += 40i64;
    if ( v2 >= *(unsigned __int16 *)(v3 + 6) )
      return 0i64;
  }
  return result;
}

//----- (000000014002A360) ----------------------------------------------------
signed __int64 __fastcall sub_14002A360(__int64 a1)
{
  __int64 v1; // rbx
  signed __int64 result; // rax

  v1 = a1;
  result = sub_14002A3B0(5368709120i64);
  if ( (_DWORD)result )
  {
    result = sub_14002A310(5368709120i64, v1 - 5368709120i64);
    if ( result )
      result = *(_DWORD *)(result + 36) >= 0;
  }
  return result;
}

//----- (000000014002A3B0) ----------------------------------------------------
_BOOL8 __fastcall sub_14002A3B0(__int64 a1)
{
  __int64 v1; // rdx
  _BOOL8 result; // rax

  if ( *(_WORD *)a1 != 23117 || (v1 = a1 + *(signed int *)(a1 + 60), *(_DWORD *)v1 != 17744) )
    result = 0i64;
  else
    result = *(_WORD *)(v1 + 24) == 523;
  return result;
}

//----- (000000014002A3E0) ----------------------------------------------------
_QWORD *__fastcall sub_14002A3E0(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = &type_info::`vftable';
  if ( a2 & 1 )
    sub_14002A40C(a1, 24i64);
  return v2;
}
// 14002A40C: using guessed type __int64 __fastcall sub_14002A40C(_QWORD, _QWORD);
// 14003A1E8: using guessed type void *type_info::`vftable';

//----- (000000014002A49C) ----------------------------------------------------
__int64 __usercall sub_14002A49C@<rax>(void *a1@<rdx>, EXCEPTION_RECORD *a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __m256i *a5@<ymm0>)
{
  __int64 v5; // rdi
  EXCEPTION_RECORD *v6; // rbx
  __int64 result; // rax

  v5 = a3;
  v6 = a2;
  result = sub_14000D798(a2, a1, a3, a4);
  if ( !(v6->ExceptionFlags & 0x66) && v6->ExceptionCode == -529697949 && (_DWORD)result == 1 )
  {
    *((_QWORD *)sub_14000DC10(a5) + 4) = v6;
    *((_QWORD *)sub_14000DC10(a5) + 5) = v5;
    sub_14001A878(a5);
  }
  return result;
}

//----- (000000014002A4E8) ----------------------------------------------------
signed __int64 __fastcall sub_14002A4E8(const __m128i *a1, unsigned __int16 a2)
{
  const __m128i *v2; // r8
  unsigned int v3; // er9
  const __m128i *v4; // rcx
  const __m128i *v5; // rdx
  __int16 v6; // ax
  signed __int64 result; // rax
  signed __int64 v8; // rdx
  __m128i v9; // xmm1
  __m128i v10; // xmm0
  int v11; // ecx
  __m128i v12; // xmm1
  __m128i v13; // xmm0
  unsigned __int8 v14; // zf
  int v15; // ecx

  v2 = a1;
  v3 = a2;
  v4 = 0i64;
  if ( dword_14003E028 >= 2 )
  {
    v8 = 0i64;
    while ( ((_BYTE)v2 + 1) & 0xE )
    {
      if ( LOWORD(v2->m128i_i64[0]) == (_WORD)v3 )
        v8 = (signed __int64)v2;
      if ( !LOWORD(v2->m128i_i64[0]) )
        return v8;
      v2 = (const __m128i *)((char *)v2 + 2);
    }
    if ( 0 != (_WORD)v3 )
    {
      v12 = _mm_cvtsi32_si128(v3);
      while ( 1 )
      {
        v13 = _mm_loadu_si128(v2);
        v15 = _mm_cmpistri(v12, v13, 65);
        v14 = _mm_cmpistrz(v12, v13, 65);
        if ( _mm_cmpistrc(v12, v13, 65) )
          v8 = (signed __int64)v2->m128i_i64 + 2 * v15;
        if ( v14 )
          break;
        ++v2;
      }
      return v8;
    }
    v9 = _mm_cvtsi32_si128(0xFFFF0001);
    while ( 1 )
    {
      v10 = _mm_loadu_si128(v2);
      v11 = _mm_cmpistri(v9, v10, 21);
      if ( _mm_cmpistrz(v9, v10, 21) )
        break;
      ++v2;
    }
    result = (signed __int64)v2->m128i_i64 + 2 * v11;
  }
  else
  {
    v5 = v2;
    do
    {
      v6 = v2->m128i_i64[0];
      v2 = (const __m128i *)((char *)v2 + 2);
    }
    while ( v6 );
    do
      v2 = (const __m128i *)((char *)v2 - 2);
    while ( v2 != v5 && LOWORD(v2->m128i_i64[0]) != (_WORD)v3 );
    if ( LOWORD(v2->m128i_i64[0]) == (_WORD)v3 )
      v4 = v2;
    result = (signed __int64)v4;
  }
  return result;
}
// 14003E028: using guessed type int dword_14003E028;

//----- (000000014002A5E0) ----------------------------------------------------
signed __int64 __fastcall sub_14002A5E0(int **a1)
{
  return sub_140019090(**a1, (__int64)a1);
}

//----- (000000014002A5FE) ----------------------------------------------------
_BOOL8 __fastcall sub_14002A5FE(_DWORD **a1)
{
  return **a1 == -1073741819;
}

//----- (000000014002A616) ----------------------------------------------------
__int64 __usercall sub_14002A616@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  __int64 v3; // rbp
  __int64 v4; // rbx

  v3 = a1;
  *(_QWORD *)(a1 + 56) = a2;
  *(_QWORD *)(a1 + 48) = a2;
  if ( *(_BYTE *)(a1 + 88) )
  {
    *(_QWORD *)(a1 + 40) = **(_QWORD **)(a1 + 48);
    if ( **(_DWORD **)(a1 + 40) == -529697949
      && *(_DWORD *)(*(_QWORD *)(a1 + 40) + 24i64) == 4
      && (*(_DWORD *)(*(_QWORD *)(a1 + 40) + 32i64) == 429065504
       || *(_DWORD *)(*(_QWORD *)(a1 + 40) + 32i64) == 429065505
       || *(_DWORD *)(*(_QWORD *)(a1 + 40) + 32i64) == 429065506) )
    {
      *((_QWORD *)sub_14000DC10(a3) + 4) = *(_QWORD *)(a1 + 40);
      v4 = *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8i64);
      *((_QWORD *)sub_14000DC10(a3) + 5) = v4;
      sub_14001A878(a3);
    }
  }
  *(_DWORD *)(a1 + 32) = 0;
  return *(unsigned int *)(a1 + 32);
}

//----- (000000014002A6AC) ----------------------------------------------------
signed __int64 __usercall sub_14002A6AC@<rax>(_QWORD *a1@<rdx>, __int64 a2@<rcx>, __m256i *a3@<ymm0>)
{
  _QWORD *v3; // rbp
  __int64 v4; // rdi
  __int64 v5; // rbx
  __int64 v6; // rbx

  v3 = a1;
  a1[10] = a2;
  a1[9] = a2;
  *((_QWORD *)sub_14000DC10(a3) + 14) = a1[16];
  v4 = v3[19];
  v5 = *(_QWORD *)(v4 + 8);
  *((_QWORD *)sub_14000DC10(a3) + 12) = v5;
  v6 = *(_QWORD *)(*(_QWORD *)v3[9] + 56i64);
  *((_QWORD *)sub_14000DC10(a3) + 13) = v6;
  sub_14000F58C(*(_QWORD *)v3[9], v3[17], v3[18], v4, v3[20]);
  *((_QWORD *)sub_14000DC10(a3) + 14) = 0i64;
  *((_DWORD *)v3 + 16) = 1;
  return 1i64;
}
// 14000F58C: using guessed type __int64 __fastcall sub_14000F58C(__int64, _DWORD, _DWORD, __int64, char);

//----- (000000014002A74F) ----------------------------------------------------
signed __int64 __usercall sub_14002A74F@<rax>(__int64 a1@<rdx>, __int64 *a2@<rcx>, __m256i *a3@<ymm0>)
{
  *(_QWORD *)(a1 + 88) = a2;
  return sub_14000F87C(*(_QWORD *)(a1 + 184), a2, (signed int *)(a1 + 32), a3);
}

//----- (000000014002A774) ----------------------------------------------------
_QWORD *__usercall sub_14002A774@<rax>(__int64 a1@<rdx>, __m256i *a2@<ymm0>)
{
  __int64 v2; // rbp
  __int64 v3; // rbx
  _QWORD *result; // rax

  v2 = a1;
  sub_14000E54C(*(_QWORD *)(a1 + 56), a2);
  if ( !*(_DWORD *)(v2 + 32) )
  {
    v3 = *(_QWORD *)(v2 + 184);
    if ( *(_DWORD *)v3 == -529697949
      && *(_DWORD *)(v3 + 24) == 4
      && (*(_DWORD *)(v3 + 32) == 429065504 || *(_DWORD *)(v3 + 32) == 429065505 || *(_DWORD *)(v3 + 32) == 429065506) )
    {
      if ( (unsigned int)sub_14000DA74(*(_QWORD *)(v3 + 40), a2) )
        sub_14000DA00(v3);
    }
  }
  *((_QWORD *)sub_14000DC10(a2) + 4) = *(_QWORD *)(v2 + 192);
  result = sub_14000DC10(a2);
  result[5] = *(_QWORD *)(v2 + 64);
  return result;
}

//----- (000000014002A7FA) ----------------------------------------------------
__int64 __usercall sub_14002A7FA@<rax>(_DWORD **a1@<rcx>, __m256i *a2@<ymm0>)
{
  return sub_14000DAC8(a1, a2);
}

//----- (000000014002A810) ----------------------------------------------------
_DWORD *__usercall sub_14002A810@<rax>(__m256i *a1@<ymm0>)
{
  _DWORD *result; // rax

  result = sub_14000DC10(a1);
  if ( result[12] > 0 )
  {
    result = sub_14000DC10(a1);
    --result[12];
  }
  return result;
}

//----- (000000014002A833) ----------------------------------------------------
void __fastcall sub_14002A833(__int64 a1, __int64 a2)
{
  sub_1400151E8(*(_QWORD *)(a2 + 64));
}

//----- (000000014002A84B) ----------------------------------------------------
void __fastcall sub_14002A84B(__int64 a1, __int64 a2)
{
  sub_1400151E8(*(_QWORD *)(a2 + 96));
}

//----- (000000014002A863) ----------------------------------------------------
void __fastcall sub_14002A863(__int64 a1, __int64 a2)
{
  sub_1400151E8(**(_QWORD **)(a2 + 72));
}

//----- (000000014002A87E) ----------------------------------------------------
void __fastcall sub_14002A87E(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp

  v2 = a2;
  if ( !*(_QWORD *)(a2 + 32) )
    sub_14001B154(*(_QWORD *)(a2 + 64));
  sub_1400151E8(*(_QWORD *)(v2 + 64));
}

//----- (000000014002A8A9) ----------------------------------------------------
void __fastcall sub_14002A8A9(__int64 a1, __int64 a2)
{
  sub_140020C28(**(_DWORD **)(a2 + 152));
}

//----- (000000014002A8C6) ----------------------------------------------------
void sub_14002A8C6()
{
  sub_140020C28(11);
}

//----- (000000014002A8DF) ----------------------------------------------------
void sub_14002A8DF()
{
  sub_140020C28(7);
}

//----- (000000014002A8F8) ----------------------------------------------------
void sub_14002A8F8()
{
  sub_140020C28(12);
}

//----- (000000014002A911) ----------------------------------------------------
void __fastcall sub_14002A911(__int64 a1, __int64 a2)
{
  sub_1400151E8(*(_QWORD *)(a2 + 48));
}

//----- (000000014002A929) ----------------------------------------------------
void __fastcall sub_14002A929(__int64 a1, __int64 a2)
{
  sub_140020C28(**(_DWORD **)(a2 + 72));
}

//----- (000000014002A943) ----------------------------------------------------
__int64 __fastcall sub_14002A943(int **a1, __int64 a2)
{
  int v2; // ecx

  *(_QWORD *)(a2 + 40) = a1;
  v2 = **a1;
  *(_DWORD *)(a2 + 36) = v2;
  *(_DWORD *)(a2 + 32) = v2 == -529697949;
  return *(unsigned int *)(a2 + 32);
}

//----- (000000014002A970) ----------------------------------------------------
void __fastcall sub_14002A970(__int64 a1, __int64 a2)
{
  sub_140020C28(**(_DWORD **)(a2 + 88));
}

//----- (000000014002A98A) ----------------------------------------------------
void __fastcall sub_14002A98A(__int64 a1, __int64 a2)
{
  sub_14001831C(**(_DWORD **)(a2 + 72));
}

//----- (000000014002A9A4) ----------------------------------------------------
void sub_14002A9A4()
{
  sub_140020C28(8);
}

//----- (000000014002A9BD) ----------------------------------------------------
void __fastcall sub_14002A9BD(__int64 a1, __int64 a2)
{
  sub_14001831C(*(_DWORD *)(a2 + 64));
}

//----- (000000014002A9D4) ----------------------------------------------------
void __fastcall sub_14002A9D4(__int64 a1, __int64 a2)
{
  sub_14001831C(*(_DWORD *)(a2 + 96));
}

//----- (000000014002A9EB) ----------------------------------------------------
void sub_14002A9EB()
{
  sub_140020C28(11);
}

//----- (000000014002AA04) ----------------------------------------------------
void __fastcall sub_14002AA04(__int64 a1, __int64 a2)
{
  sub_1400151E8(*(_QWORD *)(a2 + 72));
}

//----- (000000014002AA1E) ----------------------------------------------------
void sub_14002AA1E()
{
  sub_140020C28(8);
}

//----- (000000014002AA37) ----------------------------------------------------
void __fastcall sub_14002AA37(__int64 a1, __int64 a2)
{
  sub_140020C28(**(_DWORD **)(a2 + 104));
}

//----- (000000014002AA51) ----------------------------------------------------
void sub_14002AA51()
{
  sub_140020C28(5);
}

//----- (000000014002AA6A) ----------------------------------------------------
void sub_14002AA6A()
{
  sub_140020C28(4);
}

//----- (000000014002AA83) ----------------------------------------------------
void sub_14002AA83()
{
  sub_140020C28(0);
}

//----- (000000014002AA99) ----------------------------------------------------
void __fastcall sub_14002AA99(__int64 a1, __int64 a2)
{
  if ( *(_BYTE *)(a2 + 112) )
    sub_140020C28(3);
}

//----- (000000014002AABA) ----------------------------------------------------
void sub_14002AABA()
{
  sub_140020C28(6);
}

//----- (000000014002AAD3) ----------------------------------------------------
void __fastcall sub_14002AAD3(__int64 a1, __int64 a2)
{
  signed int *v2; // r9

  if ( *(_DWORD *)(a2 + 64) )
  {
    if ( *(_DWORD *)(a2 + 68) )
    {
      v2 = *(signed int **)(a2 + 128);
      *(_BYTE *)(qword_140040970[(signed __int64)*v2 >> 6] + 72i64 * (*v2 & 0x3F) + 56) &= 0xFEu;
    }
    sub_14001831C(**(_DWORD **)(a2 + 128));
  }
}

//----- (000000014002AB4B) ----------------------------------------------------
_BOOL8 __fastcall sub_14002AB4B(_DWORD **a1)
{
  return **a1 == -1073741819 || **a1 == -1073741795;
}

//----- (000000014002AB80) ----------------------------------------------------
_BOOL8 __fastcall sub_14002AB80(_DWORD **a1)
{
  return **a1 == -1073741819;
}

// ALL OK, 765 function(s) have been successfully decompiled
